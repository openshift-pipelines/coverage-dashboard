
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/pipeline/cmd/controller/main.go (0.0%)</option>
				
				<option value="file1">github.com/tektoncd/pipeline/cmd/entrypoint/args.go (100.0%)</option>
				
				<option value="file2">github.com/tektoncd/pipeline/cmd/entrypoint/main.go (12.5%)</option>
				
				<option value="file3">github.com/tektoncd/pipeline/cmd/entrypoint/namespaces_linux.go (90.0%)</option>
				
				<option value="file4">github.com/tektoncd/pipeline/cmd/entrypoint/post_writer.go (72.7%)</option>
				
				<option value="file5">github.com/tektoncd/pipeline/cmd/entrypoint/runner.go (86.2%)</option>
				
				<option value="file6">github.com/tektoncd/pipeline/cmd/entrypoint/spire.go (0.0%)</option>
				
				<option value="file7">github.com/tektoncd/pipeline/cmd/entrypoint/subcommands/cp.go (90.0%)</option>
				
				<option value="file8">github.com/tektoncd/pipeline/cmd/entrypoint/subcommands/decode_script.go (82.6%)</option>
				
				<option value="file9">github.com/tektoncd/pipeline/cmd/entrypoint/subcommands/init.go (66.7%)</option>
				
				<option value="file10">github.com/tektoncd/pipeline/cmd/entrypoint/subcommands/step_init.go (70.0%)</option>
				
				<option value="file11">github.com/tektoncd/pipeline/cmd/entrypoint/subcommands/subcommands.go (56.0%)</option>
				
				<option value="file12">github.com/tektoncd/pipeline/cmd/entrypoint/waiter.go (85.0%)</option>
				
				<option value="file13">github.com/tektoncd/pipeline/cmd/events/main.go (0.0%)</option>
				
				<option value="file14">github.com/tektoncd/pipeline/cmd/nop/main.go (0.0%)</option>
				
				<option value="file15">github.com/tektoncd/pipeline/cmd/resolvers/main.go (22.7%)</option>
				
				<option value="file16">github.com/tektoncd/pipeline/cmd/sidecarlogresults/main.go (0.0%)</option>
				
				<option value="file17">github.com/tektoncd/pipeline/cmd/webhook/main.go (0.0%)</option>
				
				<option value="file18">github.com/tektoncd/pipeline/cmd/workingdirinit/main.go (23.1%)</option>
				
				<option value="file19">github.com/tektoncd/pipeline/docs/resolver-template/cmd/demoresolver/main.go (75.0%)</option>
				
				<option value="file20">github.com/tektoncd/pipeline/docs/resolver-template/cmd/resolver/main.go (88.2%)</option>
				
				<option value="file21">github.com/tektoncd/pipeline/internal/sidecarlogresults/sidecarlogresults.go (87.6%)</option>
				
				<option value="file22">github.com/tektoncd/pipeline/pkg/apis/config/default.go (88.3%)</option>
				
				<option value="file23">github.com/tektoncd/pipeline/pkg/apis/config/events.go (98.1%)</option>
				
				<option value="file24">github.com/tektoncd/pipeline/pkg/apis/config/feature_flags.go (94.0%)</option>
				
				<option value="file25">github.com/tektoncd/pipeline/pkg/apis/config/featureflags_validation.go (100.0%)</option>
				
				<option value="file26">github.com/tektoncd/pipeline/pkg/apis/config/metrics.go (77.3%)</option>
				
				<option value="file27">github.com/tektoncd/pipeline/pkg/apis/config/metrics_tls.go (100.0%)</option>
				
				<option value="file28">github.com/tektoncd/pipeline/pkg/apis/config/resolver/feature_flags.go (84.0%)</option>
				
				<option value="file29">github.com/tektoncd/pipeline/pkg/apis/config/resolver/store.go (58.8%)</option>
				
				<option value="file30">github.com/tektoncd/pipeline/pkg/apis/config/spire_config.go (88.2%)</option>
				
				<option value="file31">github.com/tektoncd/pipeline/pkg/apis/config/store.go (93.9%)</option>
				
				<option value="file32">github.com/tektoncd/pipeline/pkg/apis/config/testing/defaults.go (0.0%)</option>
				
				<option value="file33">github.com/tektoncd/pipeline/pkg/apis/config/testing/featureflags.go (0.0%)</option>
				
				<option value="file34">github.com/tektoncd/pipeline/pkg/apis/config/tracing.go (85.0%)</option>
				
				<option value="file35">github.com/tektoncd/pipeline/pkg/apis/config/wait_exponential_backoff.go (87.0%)</option>
				
				<option value="file36">github.com/tektoncd/pipeline/pkg/apis/pipeline/errors/errors.go (92.3%)</option>
				
				<option value="file37">github.com/tektoncd/pipeline/pkg/apis/pipeline/images.go (100.0%)</option>
				
				<option value="file38">github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum/checksum.go (95.2%)</option>
				
				<option value="file39">github.com/tektoncd/pipeline/pkg/apis/pipeline/pod/affinity_assitant_template.go (0.0%)</option>
				
				<option value="file40">github.com/tektoncd/pipeline/pkg/apis/pipeline/pod/template.go (88.3%)</option>
				
				<option value="file41">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/artifact_types.go (95.7%)</option>
				
				<option value="file42">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/container_types.go (62.6%)</option>
				
				<option value="file43">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/container_validation.go (100.0%)</option>
				
				<option value="file44">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/matrix_types.go (100.0%)</option>
				
				<option value="file45">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/merge.go (85.0%)</option>
				
				<option value="file46">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/param_types.go (98.9%)</option>
				
				<option value="file47">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipeline_conversion.go (66.7%)</option>
				
				<option value="file48">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipeline_defaults.go (100.0%)</option>
				
				<option value="file49">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipeline_types.go (87.2%)</option>
				
				<option value="file50">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipeline_validation.go (99.3%)</option>
				
				<option value="file51">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipelineref_validation.go (100.0%)</option>
				
				<option value="file52">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipelinerun_conversion.go (66.7%)</option>
				
				<option value="file53">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipelinerun_defaults.go (100.0%)</option>
				
				<option value="file54">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipelinerun_types.go (92.5%)</option>
				
				<option value="file55">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/pipelinerun_validation.go (93.4%)</option>
				
				<option value="file56">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/register.go (0.0%)</option>
				
				<option value="file57">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/result_defaults.go (100.0%)</option>
				
				<option value="file58">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/result_types.go (100.0%)</option>
				
				<option value="file59">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/result_validation.go (100.0%)</option>
				
				<option value="file60">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/resultref.go (100.0%)</option>
				
				<option value="file61">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/task_conversion.go (66.7%)</option>
				
				<option value="file62">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/task_defaults.go (100.0%)</option>
				
				<option value="file63">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/task_types.go (71.4%)</option>
				
				<option value="file64">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/task_validation.go (99.1%)</option>
				
				<option value="file65">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskref_types.go (100.0%)</option>
				
				<option value="file66">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskref_validation.go (100.0%)</option>
				
				<option value="file67">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskrun_conversion.go (66.7%)</option>
				
				<option value="file68">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskrun_defaults.go (100.0%)</option>
				
				<option value="file69">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskrun_types.go (82.8%)</option>
				
				<option value="file70">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/taskrun_validation.go (96.9%)</option>
				
				<option value="file71">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types/artifacts_types.go (0.0%)</option>
				
				<option value="file72">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types/param_types.go (0.0%)</option>
				
				<option value="file73">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types/result_types.go (0.0%)</option>
				
				<option value="file74">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types/resultsref.go (0.0%)</option>
				
				<option value="file75">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types/when_types.go (0.0%)</option>
				
				<option value="file76">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/when_types.go (100.0%)</option>
				
				<option value="file77">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/when_validation.go (100.0%)</option>
				
				<option value="file78">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/workspace_types.go (100.0%)</option>
				
				<option value="file79">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/workspace_validation.go (100.0%)</option>
				
				<option value="file80">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/register.go (60.0%)</option>
				
				<option value="file81">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/run_defaults.go (0.0%)</option>
				
				<option value="file82">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/run_types.go (62.1%)</option>
				
				<option value="file83">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/run_validation.go (92.3%)</option>
				
				<option value="file84">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/stepaction_conversion.go (94.4%)</option>
				
				<option value="file85">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/stepaction_defaults.go (100.0%)</option>
				
				<option value="file86">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/stepaction_types.go (0.0%)</option>
				
				<option value="file87">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/stepaction_validation.go (99.2%)</option>
				
				<option value="file88">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/verificationpolicy_defaults.go (0.0%)</option>
				
				<option value="file89">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/verificationpolicy_types.go (0.0%)</option>
				
				<option value="file90">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1/verificationpolicy_validation.go (100.0%)</option>
				
				<option value="file91">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/container_conversion.go (100.0%)</option>
				
				<option value="file92">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/container_types.go (36.1%)</option>
				
				<option value="file93">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/container_validation.go (100.0%)</option>
				
				<option value="file94">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/customrun_defaults.go (0.0%)</option>
				
				<option value="file95">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/customrun_types.go (60.0%)</option>
				
				<option value="file96">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/customrun_validation.go (92.3%)</option>
				
				<option value="file97">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/matrix_types.go (100.0%)</option>
				
				<option value="file98">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/merge.go (85.0%)</option>
				
				<option value="file99">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/param_conversion.go (100.0%)</option>
				
				<option value="file100">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/param_types.go (98.8%)</option>
				
				<option value="file101">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipeline_conversion.go (95.4%)</option>
				
				<option value="file102">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipeline_defaults.go (100.0%)</option>
				
				<option value="file103">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipeline_types.go (82.4%)</option>
				
				<option value="file104">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipeline_validation.go (99.0%)</option>
				
				<option value="file105">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelineref_conversion.go (100.0%)</option>
				
				<option value="file106">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelineref_validation.go (100.0%)</option>
				
				<option value="file107">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelinerun_conversion.go (95.8%)</option>
				
				<option value="file108">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelinerun_defaults.go (100.0%)</option>
				
				<option value="file109">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelinerun_types.go (89.8%)</option>
				
				<option value="file110">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/pipelinerun_validation.go (95.3%)</option>
				
				<option value="file111">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/provenance_conversion.go (100.0%)</option>
				
				<option value="file112">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/register.go (60.0%)</option>
				
				<option value="file113">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/resolver_conversion.go (100.0%)</option>
				
				<option value="file114">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/result_conversion.go (100.0%)</option>
				
				<option value="file115">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/result_defaults.go (100.0%)</option>
				
				<option value="file116">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/result_types.go (100.0%)</option>
				
				<option value="file117">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/result_validation.go (100.0%)</option>
				
				<option value="file118">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/resultref.go (100.0%)</option>
				
				<option value="file119">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/stepaction_conversion.go (0.0%)</option>
				
				<option value="file120">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/stepaction_defaults.go (100.0%)</option>
				
				<option value="file121">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/stepaction_types.go (0.0%)</option>
				
				<option value="file122">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/stepaction_validation.go (98.9%)</option>
				
				<option value="file123">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/task_conversion.go (91.9%)</option>
				
				<option value="file124">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/task_defaults.go (100.0%)</option>
				
				<option value="file125">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/task_types.go (65.0%)</option>
				
				<option value="file126">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/task_validation.go (98.5%)</option>
				
				<option value="file127">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskref_conversion.go (100.0%)</option>
				
				<option value="file128">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskref_types.go (100.0%)</option>
				
				<option value="file129">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskref_validation.go (100.0%)</option>
				
				<option value="file130">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskrun_conversion.go (93.1%)</option>
				
				<option value="file131">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskrun_defaults.go (100.0%)</option>
				
				<option value="file132">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskrun_types.go (83.6%)</option>
				
				<option value="file133">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/taskrun_validation.go (97.5%)</option>
				
				<option value="file134">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/when_types.go (100.0%)</option>
				
				<option value="file135">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/when_validation.go (100.0%)</option>
				
				<option value="file136">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/workspace_conversion.go (100.0%)</option>
				
				<option value="file137">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/workspace_types.go (100.0%)</option>
				
				<option value="file138">github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1/workspace_validation.go (100.0%)</option>
				
				<option value="file139">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/register.go (0.0%)</option>
				
				<option value="file140">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/resolution_request_conversion.go (53.6%)</option>
				
				<option value="file141">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/resolution_request_defaults.go (0.0%)</option>
				
				<option value="file142">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/resolution_request_lifecycle.go (0.0%)</option>
				
				<option value="file143">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/resolution_request_types.go (0.0%)</option>
				
				<option value="file144">github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1/resolution_request_validation.go (0.0%)</option>
				
				<option value="file145">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/register.go (0.0%)</option>
				
				<option value="file146">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/resolution_request_conversion.go (66.7%)</option>
				
				<option value="file147">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/resolution_request_defaults.go (0.0%)</option>
				
				<option value="file148">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/resolution_request_lifecycle.go (0.0%)</option>
				
				<option value="file149">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/resolution_request_types.go (0.0%)</option>
				
				<option value="file150">github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1/resolution_request_validation.go (0.0%)</option>
				
				<option value="file151">github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1/register.go (0.0%)</option>
				
				<option value="file152">github.com/tektoncd/pipeline/pkg/apis/run/v1alpha1/runstatus_types.go (0.0%)</option>
				
				<option value="file153">github.com/tektoncd/pipeline/pkg/apis/run/v1beta1/customrunstatus_types.go (17.6%)</option>
				
				<option value="file154">github.com/tektoncd/pipeline/pkg/apis/validate/metadata.go (83.3%)</option>
				
				<option value="file155">github.com/tektoncd/pipeline/pkg/apis/version/conversion.go (81.2%)</option>
				
				<option value="file156">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file157">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/fake/clientset_generated.go (0.0%)</option>
				
				<option value="file158">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/fake/register.go (0.0%)</option>
				
				<option value="file159">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme/register.go (0.0%)</option>
				
				<option value="file160">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake/fake_pipeline.go (0.0%)</option>
				
				<option value="file161">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake/fake_pipeline_client.go (0.0%)</option>
				
				<option value="file162">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake/fake_pipelinerun.go (0.0%)</option>
				
				<option value="file163">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake/fake_task.go (0.0%)</option>
				
				<option value="file164">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake/fake_taskrun.go (0.0%)</option>
				
				<option value="file165">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/pipeline.go (0.0%)</option>
				
				<option value="file166">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/pipeline_client.go (0.0%)</option>
				
				<option value="file167">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/pipelinerun.go (0.0%)</option>
				
				<option value="file168">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/task.go (0.0%)</option>
				
				<option value="file169">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/taskrun.go (0.0%)</option>
				
				<option value="file170">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/fake/fake_pipeline_client.go (0.0%)</option>
				
				<option value="file171">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/fake/fake_run.go (0.0%)</option>
				
				<option value="file172">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/fake/fake_stepaction.go (0.0%)</option>
				
				<option value="file173">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/fake/fake_verificationpolicy.go (0.0%)</option>
				
				<option value="file174">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/pipeline_client.go (0.0%)</option>
				
				<option value="file175">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/run.go (0.0%)</option>
				
				<option value="file176">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/stepaction.go (0.0%)</option>
				
				<option value="file177">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/verificationpolicy.go (0.0%)</option>
				
				<option value="file178">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/customrun.go (0.0%)</option>
				
				<option value="file179">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_customrun.go (0.0%)</option>
				
				<option value="file180">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_pipeline.go (0.0%)</option>
				
				<option value="file181">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_pipeline_client.go (0.0%)</option>
				
				<option value="file182">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_pipelinerun.go (0.0%)</option>
				
				<option value="file183">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_stepaction.go (0.0%)</option>
				
				<option value="file184">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_task.go (0.0%)</option>
				
				<option value="file185">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake/fake_taskrun.go (0.0%)</option>
				
				<option value="file186">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/pipeline.go (0.0%)</option>
				
				<option value="file187">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/pipeline_client.go (0.0%)</option>
				
				<option value="file188">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/pipelinerun.go (0.0%)</option>
				
				<option value="file189">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/stepaction.go (0.0%)</option>
				
				<option value="file190">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/task.go (0.0%)</option>
				
				<option value="file191">github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/taskrun.go (0.0%)</option>
				
				<option value="file192">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file193">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file194">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/interface.go (0.0%)</option>
				
				<option value="file195">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1/interface.go (0.0%)</option>
				
				<option value="file196">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1/pipeline.go (0.0%)</option>
				
				<option value="file197">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1/pipelinerun.go (0.0%)</option>
				
				<option value="file198">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1/task.go (0.0%)</option>
				
				<option value="file199">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1/taskrun.go (0.0%)</option>
				
				<option value="file200">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file201">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1/run.go (0.0%)</option>
				
				<option value="file202">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1/stepaction.go (0.0%)</option>
				
				<option value="file203">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1/verificationpolicy.go (0.0%)</option>
				
				<option value="file204">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/customrun.go (0.0%)</option>
				
				<option value="file205">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/interface.go (0.0%)</option>
				
				<option value="file206">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/pipeline.go (0.0%)</option>
				
				<option value="file207">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/pipelinerun.go (0.0%)</option>
				
				<option value="file208">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/stepaction.go (0.0%)</option>
				
				<option value="file209">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/task.go (0.0%)</option>
				
				<option value="file210">github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1/taskrun.go (0.0%)</option>
				
				<option value="file211">github.com/tektoncd/pipeline/pkg/client/injection/client/client.go (0.0%)</option>
				
				<option value="file212">github.com/tektoncd/pipeline/pkg/client/injection/client/fake/fake.go (0.0%)</option>
				
				<option value="file213">github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/factory.go (0.0%)</option>
				
				<option value="file214">github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake/fake.go (0.0%)</option>
				
				<option value="file215">github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered/fake/fake_filtered_factory.go (0.0%)</option>
				
				<option value="file216">github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered/filtered_factory.go (0.0%)</option>
				
				<option value="file217">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/fake/fake.go (0.0%)</option>
				
				<option value="file218">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file219">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/filtered/pipeline.go (0.0%)</option>
				
				<option value="file220">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/pipeline.go (0.0%)</option>
				
				<option value="file221">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/fake/fake.go (0.0%)</option>
				
				<option value="file222">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file223">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/filtered/pipelinerun.go (0.0%)</option>
				
				<option value="file224">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/pipelinerun.go (0.0%)</option>
				
				<option value="file225">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/fake/fake.go (0.0%)</option>
				
				<option value="file226">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file227">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/filtered/task.go (0.0%)</option>
				
				<option value="file228">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/task.go (0.0%)</option>
				
				<option value="file229">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/fake/fake.go (0.0%)</option>
				
				<option value="file230">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file231">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/filtered/taskrun.go (0.0%)</option>
				
				<option value="file232">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/taskrun.go (0.0%)</option>
				
				<option value="file233">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run/fake/fake.go (0.0%)</option>
				
				<option value="file234">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file235">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run/filtered/run.go (0.0%)</option>
				
				<option value="file236">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run/run.go (0.0%)</option>
				
				<option value="file237">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction/fake/fake.go (0.0%)</option>
				
				<option value="file238">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file239">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction/filtered/stepaction.go (0.0%)</option>
				
				<option value="file240">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction/stepaction.go (0.0%)</option>
				
				<option value="file241">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/fake/fake.go (0.0%)</option>
				
				<option value="file242">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file243">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/filtered/verificationpolicy.go (0.0%)</option>
				
				<option value="file244">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/verificationpolicy.go (0.0%)</option>
				
				<option value="file245">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/customrun.go (0.0%)</option>
				
				<option value="file246">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/fake/fake.go (0.0%)</option>
				
				<option value="file247">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/filtered/customrun.go (0.0%)</option>
				
				<option value="file248">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file249">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline/fake/fake.go (0.0%)</option>
				
				<option value="file250">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file251">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline/filtered/pipeline.go (0.0%)</option>
				
				<option value="file252">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline/pipeline.go (0.0%)</option>
				
				<option value="file253">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun/fake/fake.go (0.0%)</option>
				
				<option value="file254">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file255">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun/filtered/pipelinerun.go (0.0%)</option>
				
				<option value="file256">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun/pipelinerun.go (0.0%)</option>
				
				<option value="file257">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/fake/fake.go (0.0%)</option>
				
				<option value="file258">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file259">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/filtered/stepaction.go (0.0%)</option>
				
				<option value="file260">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/stepaction.go (0.0%)</option>
				
				<option value="file261">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task/fake/fake.go (0.0%)</option>
				
				<option value="file262">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file263">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task/filtered/task.go (0.0%)</option>
				
				<option value="file264">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task/task.go (0.0%)</option>
				
				<option value="file265">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun/fake/fake.go (0.0%)</option>
				
				<option value="file266">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file267">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun/filtered/taskrun.go (0.0%)</option>
				
				<option value="file268">github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun/taskrun.go (0.0%)</option>
				
				<option value="file269">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipeline/controller.go (0.0%)</option>
				
				<option value="file270">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipeline/reconciler.go (0.0%)</option>
				
				<option value="file271">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipeline/state.go (0.0%)</option>
				
				<option value="file272">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun/controller.go (0.0%)</option>
				
				<option value="file273">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun/reconciler.go (0.0%)</option>
				
				<option value="file274">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun/state.go (0.0%)</option>
				
				<option value="file275">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/task/controller.go (0.0%)</option>
				
				<option value="file276">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/task/reconciler.go (0.0%)</option>
				
				<option value="file277">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/task/state.go (0.0%)</option>
				
				<option value="file278">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun/controller.go (0.0%)</option>
				
				<option value="file279">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun/reconciler.go (0.0%)</option>
				
				<option value="file280">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun/state.go (0.0%)</option>
				
				<option value="file281">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/run/controller.go (0.0%)</option>
				
				<option value="file282">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/run/reconciler.go (0.0%)</option>
				
				<option value="file283">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/run/state.go (0.0%)</option>
				
				<option value="file284">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/stepaction/controller.go (0.0%)</option>
				
				<option value="file285">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/stepaction/reconciler.go (0.0%)</option>
				
				<option value="file286">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/stepaction/state.go (0.0%)</option>
				
				<option value="file287">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/verificationpolicy/controller.go (0.0%)</option>
				
				<option value="file288">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/verificationpolicy/reconciler.go (0.0%)</option>
				
				<option value="file289">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1alpha1/verificationpolicy/state.go (0.0%)</option>
				
				<option value="file290">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun/controller.go (0.0%)</option>
				
				<option value="file291">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun/reconciler.go (0.0%)</option>
				
				<option value="file292">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun/state.go (0.0%)</option>
				
				<option value="file293">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipeline/controller.go (0.0%)</option>
				
				<option value="file294">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipeline/reconciler.go (0.0%)</option>
				
				<option value="file295">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipeline/state.go (0.0%)</option>
				
				<option value="file296">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipelinerun/controller.go (0.0%)</option>
				
				<option value="file297">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipelinerun/reconciler.go (0.0%)</option>
				
				<option value="file298">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/pipelinerun/state.go (0.0%)</option>
				
				<option value="file299">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/stepaction/controller.go (0.0%)</option>
				
				<option value="file300">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/stepaction/reconciler.go (0.0%)</option>
				
				<option value="file301">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/stepaction/state.go (0.0%)</option>
				
				<option value="file302">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/task/controller.go (0.0%)</option>
				
				<option value="file303">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/task/reconciler.go (0.0%)</option>
				
				<option value="file304">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/task/state.go (0.0%)</option>
				
				<option value="file305">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/taskrun/controller.go (0.0%)</option>
				
				<option value="file306">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/taskrun/reconciler.go (0.0%)</option>
				
				<option value="file307">github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/taskrun/state.go (0.0%)</option>
				
				<option value="file308">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1/pipeline.go (0.0%)</option>
				
				<option value="file309">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1/pipelinerun.go (0.0%)</option>
				
				<option value="file310">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1/task.go (0.0%)</option>
				
				<option value="file311">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1/taskrun.go (0.0%)</option>
				
				<option value="file312">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1/run.go (0.0%)</option>
				
				<option value="file313">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1/stepaction.go (0.0%)</option>
				
				<option value="file314">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1/verificationpolicy.go (0.0%)</option>
				
				<option value="file315">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/customrun.go (0.0%)</option>
				
				<option value="file316">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/pipeline.go (0.0%)</option>
				
				<option value="file317">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/pipelinerun.go (0.0%)</option>
				
				<option value="file318">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/stepaction.go (0.0%)</option>
				
				<option value="file319">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/task.go (0.0%)</option>
				
				<option value="file320">github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1/taskrun.go (0.0%)</option>
				
				<option value="file321">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file322">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/fake/clientset_generated.go (0.0%)</option>
				
				<option value="file323">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/fake/register.go (0.0%)</option>
				
				<option value="file324">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme/register.go (0.0%)</option>
				
				<option value="file325">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1/fake/fake_resolution_client.go (0.0%)</option>
				
				<option value="file326">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1/fake/fake_resolutionrequest.go (0.0%)</option>
				
				<option value="file327">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1/resolution_client.go (0.0%)</option>
				
				<option value="file328">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1/resolutionrequest.go (0.0%)</option>
				
				<option value="file329">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1/fake/fake_resolution_client.go (0.0%)</option>
				
				<option value="file330">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1/fake/fake_resolutionrequest.go (0.0%)</option>
				
				<option value="file331">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1/resolution_client.go (0.0%)</option>
				
				<option value="file332">github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1/resolutionrequest.go (0.0%)</option>
				
				<option value="file333">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file334">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file335">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/interface.go (0.0%)</option>
				
				<option value="file336">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file337">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1/resolutionrequest.go (0.0%)</option>
				
				<option value="file338">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1/interface.go (0.0%)</option>
				
				<option value="file339">github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1/resolutionrequest.go (0.0%)</option>
				
				<option value="file340">github.com/tektoncd/pipeline/pkg/client/resolution/injection/client/client.go (0.0%)</option>
				
				<option value="file341">github.com/tektoncd/pipeline/pkg/client/resolution/injection/client/fake/fake.go (0.0%)</option>
				
				<option value="file342">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/factory.go (0.0%)</option>
				
				<option value="file343">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/fake/fake.go (0.0%)</option>
				
				<option value="file344">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered/fake/fake_filtered_factory.go (0.0%)</option>
				
				<option value="file345">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered/filtered_factory.go (0.0%)</option>
				
				<option value="file346">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest/fake/fake.go (0.0%)</option>
				
				<option value="file347">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file348">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest/filtered/resolutionrequest.go (0.0%)</option>
				
				<option value="file349">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest/resolutionrequest.go (0.0%)</option>
				
				<option value="file350">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/fake/fake.go (0.0%)</option>
				
				<option value="file351">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file352">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/filtered/resolutionrequest.go (0.0%)</option>
				
				<option value="file353">github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/resolutionrequest.go (0.0%)</option>
				
				<option value="file354">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1alpha1/resolutionrequest/controller.go (0.0%)</option>
				
				<option value="file355">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1alpha1/resolutionrequest/reconciler.go (0.0%)</option>
				
				<option value="file356">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1alpha1/resolutionrequest/state.go (0.0%)</option>
				
				<option value="file357">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1beta1/resolutionrequest/controller.go (0.0%)</option>
				
				<option value="file358">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1beta1/resolutionrequest/reconciler.go (0.0%)</option>
				
				<option value="file359">github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1beta1/resolutionrequest/state.go (0.0%)</option>
				
				<option value="file360">github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1alpha1/resolutionrequest.go (0.0%)</option>
				
				<option value="file361">github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1/resolutionrequest.go (0.0%)</option>
				
				<option value="file362">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file363">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/fake/clientset_generated.go (0.0%)</option>
				
				<option value="file364">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/fake/register.go (0.0%)</option>
				
				<option value="file365">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/scheme/register.go (0.0%)</option>
				
				<option value="file366">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1/fake/fake_pipelineresource.go (0.0%)</option>
				
				<option value="file367">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1/fake/fake_resource_client.go (0.0%)</option>
				
				<option value="file368">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1/pipelineresource.go (0.0%)</option>
				
				<option value="file369">github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1/resource_client.go (0.0%)</option>
				
				<option value="file370">github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file371">github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file372">github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/interface.go (0.0%)</option>
				
				<option value="file373">github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file374">github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1/pipelineresource.go (0.0%)</option>
				
				<option value="file375">github.com/tektoncd/pipeline/pkg/client/resource/injection/client/client.go (0.0%)</option>
				
				<option value="file376">github.com/tektoncd/pipeline/pkg/client/resource/injection/client/fake/fake.go (0.0%)</option>
				
				<option value="file377">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/factory.go (0.0%)</option>
				
				<option value="file378">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/fake/fake.go (0.0%)</option>
				
				<option value="file379">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/filtered/fake/fake_filtered_factory.go (0.0%)</option>
				
				<option value="file380">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/filtered/filtered_factory.go (0.0%)</option>
				
				<option value="file381">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource/fake/fake.go (0.0%)</option>
				
				<option value="file382">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file383">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource/filtered/pipelineresource.go (0.0%)</option>
				
				<option value="file384">github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource/pipelineresource.go (0.0%)</option>
				
				<option value="file385">github.com/tektoncd/pipeline/pkg/client/resource/listers/resource/v1alpha1/pipelineresource.go (0.0%)</option>
				
				<option value="file386">github.com/tektoncd/pipeline/pkg/container/container_replacements.go (100.0%)</option>
				
				<option value="file387">github.com/tektoncd/pipeline/pkg/container/sidecar_replacements.go (100.0%)</option>
				
				<option value="file388">github.com/tektoncd/pipeline/pkg/container/step_replacements.go (72.7%)</option>
				
				<option value="file389">github.com/tektoncd/pipeline/pkg/controller/errors.go (100.0%)</option>
				
				<option value="file390">github.com/tektoncd/pipeline/pkg/controller/filter.go (97.1%)</option>
				
				<option value="file391">github.com/tektoncd/pipeline/pkg/credentials/dockercreds/creds.go (89.2%)</option>
				
				<option value="file392">github.com/tektoncd/pipeline/pkg/credentials/gitcreds/basic.go (89.3%)</option>
				
				<option value="file393">github.com/tektoncd/pipeline/pkg/credentials/gitcreds/creds.go (94.7%)</option>
				
				<option value="file394">github.com/tektoncd/pipeline/pkg/credentials/gitcreds/ssh.go (88.5%)</option>
				
				<option value="file395">github.com/tektoncd/pipeline/pkg/credentials/matcher/matcher.go (75.0%)</option>
				
				<option value="file396">github.com/tektoncd/pipeline/pkg/credentials/writer/writer.go (46.0%)</option>
				
				<option value="file397">github.com/tektoncd/pipeline/pkg/entrypoint/entrypointer.go (89.4%)</option>
				
				<option value="file398">github.com/tektoncd/pipeline/pkg/entrypoint/spire.go (100.0%)</option>
				
				<option value="file399">github.com/tektoncd/pipeline/pkg/internal/affinityassistant/affinityassistant_types.go (87.5%)</option>
				
				<option value="file400">github.com/tektoncd/pipeline/pkg/internal/affinityassistant/transformer.go (100.0%)</option>
				
				<option value="file401">github.com/tektoncd/pipeline/pkg/internal/computeresources/compare/compare.go (0.0%)</option>
				
				<option value="file402">github.com/tektoncd/pipeline/pkg/internal/computeresources/limitrange/limitrange.go (97.3%)</option>
				
				<option value="file403">github.com/tektoncd/pipeline/pkg/internal/computeresources/tasklevel/tasklevel.go (95.0%)</option>
				
				<option value="file404">github.com/tektoncd/pipeline/pkg/internal/computeresources/transformer.go (85.7%)</option>
				
				<option value="file405">github.com/tektoncd/pipeline/pkg/internal/defaultresourcerequirements/transformer.go (100.0%)</option>
				
				<option value="file406">github.com/tektoncd/pipeline/pkg/internal/resolution/resolutionrequest.go (0.0%)</option>
				
				<option value="file407">github.com/tektoncd/pipeline/pkg/internal/resultref/resultref.go (100.0%)</option>
				
				<option value="file408">github.com/tektoncd/pipeline/pkg/list/diff.go (100.0%)</option>
				
				<option value="file409">github.com/tektoncd/pipeline/pkg/names/generate.go (100.0%)</option>
				
				<option value="file410">github.com/tektoncd/pipeline/pkg/pipelinerunmetrics/fake/fake.go (0.0%)</option>
				
				<option value="file411">github.com/tektoncd/pipeline/pkg/pipelinerunmetrics/injection.go (11.1%)</option>
				
				<option value="file412">github.com/tektoncd/pipeline/pkg/pipelinerunmetrics/metrics.go (86.7%)</option>
				
				<option value="file413">github.com/tektoncd/pipeline/pkg/platforms/platforms.go (50.0%)</option>
				
				<option value="file414">github.com/tektoncd/pipeline/pkg/pod/creds_init.go (94.9%)</option>
				
				<option value="file415">github.com/tektoncd/pipeline/pkg/pod/entrypoint.go (93.5%)</option>
				
				<option value="file416">github.com/tektoncd/pipeline/pkg/pod/entrypoint_lookup.go (86.4%)</option>
				
				<option value="file417">github.com/tektoncd/pipeline/pkg/pod/entrypoint_lookup_impl.go (75.4%)</option>
				
				<option value="file418">github.com/tektoncd/pipeline/pkg/pod/pod.go (93.4%)</option>
				
				<option value="file419">github.com/tektoncd/pipeline/pkg/pod/script.go (99.1%)</option>
				
				<option value="file420">github.com/tektoncd/pipeline/pkg/pod/security_context_config.go (100.0%)</option>
				
				<option value="file421">github.com/tektoncd/pipeline/pkg/pod/status.go (92.4%)</option>
				
				<option value="file422">github.com/tektoncd/pipeline/pkg/pod/workingdir_init.go (94.1%)</option>
				
				<option value="file423">github.com/tektoncd/pipeline/pkg/reconciler/apiserver/apiserver.go (96.2%)</option>
				
				<option value="file424">github.com/tektoncd/pipeline/pkg/reconciler/events/cache/cache.go (83.3%)</option>
				
				<option value="file425">github.com/tektoncd/pipeline/pkg/reconciler/events/cache/cacheclient.go (7.1%)</option>
				
				<option value="file426">github.com/tektoncd/pipeline/pkg/reconciler/events/cache/cachefakeclient.go (50.0%)</option>
				
				<option value="file427">github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent/cloud_event_controller.go (84.6%)</option>
				
				<option value="file428">github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent/cloudevent.go (53.1%)</option>
				
				<option value="file429">github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent/cloudeventclient.go (28.6%)</option>
				
				<option value="file430">github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent/cloudeventsfakeclient.go (71.8%)</option>
				
				<option value="file431">github.com/tektoncd/pipeline/pkg/reconciler/events/event.go (100.0%)</option>
				
				<option value="file432">github.com/tektoncd/pipeline/pkg/reconciler/events/k8sevent/event.go (100.0%)</option>
				
				<option value="file433">github.com/tektoncd/pipeline/pkg/reconciler/events/k8sevent/events.go (78.3%)</option>
				
				<option value="file434">github.com/tektoncd/pipeline/pkg/reconciler/notifications/customrun/controller.go (90.9%)</option>
				
				<option value="file435">github.com/tektoncd/pipeline/pkg/reconciler/notifications/customrun/customrun.go (100.0%)</option>
				
				<option value="file436">github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag/dag.go (99.0%)</option>
				
				<option value="file437">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/affinity_assistant.go (96.3%)</option>
				
				<option value="file438">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/cancel.go (91.8%)</option>
				
				<option value="file439">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/controller.go (82.1%)</option>
				
				<option value="file440">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/pipelinerun.go (91.6%)</option>
				
				<option value="file441">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/pipelinespec/pipelinespec.go (100.0%)</option>
				
				<option value="file442">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/apply.go (98.3%)</option>
				
				<option value="file443">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/pipelineref.go (94.9%)</option>
				
				<option value="file444">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/pipelinerunresolution.go (96.5%)</option>
				
				<option value="file445">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/pipelinerunstate.go (98.2%)</option>
				
				<option value="file446">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/resultrefresolution.go (99.2%)</option>
				
				<option value="file447">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/validate_dependencies.go (100.0%)</option>
				
				<option value="file448">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources/validate_params.go (100.0%)</option>
				
				<option value="file449">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/timeout.go (87.8%)</option>
				
				<option value="file450">github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/tracing.go (75.8%)</option>
				
				<option value="file451">github.com/tektoncd/pipeline/pkg/reconciler/resolutionrequest/controller.go (90.9%)</option>
				
				<option value="file452">github.com/tektoncd/pipeline/pkg/reconciler/resolutionrequest/resolutionrequest.go (81.2%)</option>
				
				<option value="file453">github.com/tektoncd/pipeline/pkg/reconciler/resources.go (100.0%)</option>
				
				<option value="file454">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/controller.go (85.7%)</option>
				
				<option value="file455">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources/apply.go (99.2%)</option>
				
				<option value="file456">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources/taskref.go (93.9%)</option>
				
				<option value="file457">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources/taskspec.go (100.0%)</option>
				
				<option value="file458">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources/validate_params.go (97.2%)</option>
				
				<option value="file459">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/taskrun.go (86.5%)</option>
				
				<option value="file460">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/tracing.go (90.9%)</option>
				
				<option value="file461">github.com/tektoncd/pipeline/pkg/reconciler/taskrun/validate_taskrun.go (100.0%)</option>
				
				<option value="file462">github.com/tektoncd/pipeline/pkg/reconciler/testing/configmap.go (0.0%)</option>
				
				<option value="file463">github.com/tektoncd/pipeline/pkg/reconciler/testing/logger.go (0.0%)</option>
				
				<option value="file464">github.com/tektoncd/pipeline/pkg/reconciler/testing/status.go (0.0%)</option>
				
				<option value="file465">github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim/pvchandler.go (88.9%)</option>
				
				<option value="file466">github.com/tektoncd/pipeline/pkg/remote/oci/resolver.go (71.4%)</option>
				
				<option value="file467">github.com/tektoncd/pipeline/pkg/remote/resolution/error.go (33.3%)</option>
				
				<option value="file468">github.com/tektoncd/pipeline/pkg/remote/resolution/request.go (100.0%)</option>
				
				<option value="file469">github.com/tektoncd/pipeline/pkg/remote/resolution/resolver.go (88.5%)</option>
				
				<option value="file470">github.com/tektoncd/pipeline/pkg/remoteresolution/remote/resolution/request.go (100.0%)</option>
				
				<option value="file471">github.com/tektoncd/pipeline/pkg/remoteresolution/remote/resolution/resolver.go (88.5%)</option>
				
				<option value="file472">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/bundle/resolver.go (81.8%)</option>
				
				<option value="file473">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/cluster/resolver.go (81.8%)</option>
				
				<option value="file474">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework/controller.go (65.6%)</option>
				
				<option value="file475">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework/fakeresolver.go (100.0%)</option>
				
				<option value="file476">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework/reconciler.go (75.3%)</option>
				
				<option value="file477">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework/testing/fakecontroller.go (0.0%)</option>
				
				<option value="file478">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/git/resolver.go (82.4%)</option>
				
				<option value="file479">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/http/resolver.go (88.9%)</option>
				
				<option value="file480">github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/hub/resolver.go (50.0%)</option>
				
				<option value="file481">github.com/tektoncd/pipeline/pkg/remoteresolution/resource/crd_resource.go (95.0%)</option>
				
				<option value="file482">github.com/tektoncd/pipeline/pkg/remoteresolution/resource/request.go (100.0%)</option>
				
				<option value="file483">github.com/tektoncd/pipeline/pkg/resolution/common/context.go (92.9%)</option>
				
				<option value="file484">github.com/tektoncd/pipeline/pkg/resolution/common/errors.go (14.3%)</option>
				
				<option value="file485">github.com/tektoncd/pipeline/pkg/resolution/resolver/bundle/bundle.go (71.1%)</option>
				
				<option value="file486">github.com/tektoncd/pipeline/pkg/resolution/resolver/bundle/config.go (84.8%)</option>
				
				<option value="file487">github.com/tektoncd/pipeline/pkg/resolution/resolver/bundle/params.go (87.9%)</option>
				
				<option value="file488">github.com/tektoncd/pipeline/pkg/resolution/resolver/bundle/resolver.go (94.3%)</option>
				
				<option value="file489">github.com/tektoncd/pipeline/pkg/resolution/resolver/cluster/resolver.go (80.4%)</option>
				
				<option value="file490">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/configstore.go (47.8%)</option>
				
				<option value="file491">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/controller.go (54.4%)</option>
				
				<option value="file492">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/fakeresolver.go (92.5%)</option>
				
				<option value="file493">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/reconciler.go (74.0%)</option>
				
				<option value="file494">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/testing/fakecontroller.go (0.0%)</option>
				
				<option value="file495">github.com/tektoncd/pipeline/pkg/resolution/resolver/framework/testing/featureflag.go (0.0%)</option>
				
				<option value="file496">github.com/tektoncd/pipeline/pkg/resolution/resolver/git/config.go (100.0%)</option>
				
				<option value="file497">github.com/tektoncd/pipeline/pkg/resolution/resolver/git/repository.go (84.6%)</option>
				
				<option value="file498">github.com/tektoncd/pipeline/pkg/resolution/resolver/git/resolver.go (84.9%)</option>
				
				<option value="file499">github.com/tektoncd/pipeline/pkg/resolution/resolver/http/resolver.go (92.5%)</option>
				
				<option value="file500">github.com/tektoncd/pipeline/pkg/resolution/resolver/hub/resolver.go (77.6%)</option>
				
				<option value="file501">github.com/tektoncd/pipeline/pkg/resolution/resource/crd_resource.go (84.4%)</option>
				
				<option value="file502">github.com/tektoncd/pipeline/pkg/resolution/resource/name.go (67.3%)</option>
				
				<option value="file503">github.com/tektoncd/pipeline/pkg/resolution/resource/request.go (100.0%)</option>
				
				<option value="file504">github.com/tektoncd/pipeline/pkg/result/result.go (88.2%)</option>
				
				<option value="file505">github.com/tektoncd/pipeline/pkg/spire/config/config.go (0.0%)</option>
				
				<option value="file506">github.com/tektoncd/pipeline/pkg/spire/controller.go (40.2%)</option>
				
				<option value="file507">github.com/tektoncd/pipeline/pkg/spire/entrypointer.go (88.0%)</option>
				
				<option value="file508">github.com/tektoncd/pipeline/pkg/spire/sign.go (81.4%)</option>
				
				<option value="file509">github.com/tektoncd/pipeline/pkg/spire/spire_mock.go (80.6%)</option>
				
				<option value="file510">github.com/tektoncd/pipeline/pkg/spire/test/ca.go (0.0%)</option>
				
				<option value="file511">github.com/tektoncd/pipeline/pkg/spire/test/keys.go (0.0%)</option>
				
				<option value="file512">github.com/tektoncd/pipeline/pkg/spire/verify.go (82.1%)</option>
				
				<option value="file513">github.com/tektoncd/pipeline/pkg/status/status.go (82.1%)</option>
				
				<option value="file514">github.com/tektoncd/pipeline/pkg/substitution/replacements.go (100.0%)</option>
				
				<option value="file515">github.com/tektoncd/pipeline/pkg/substitution/substitution.go (86.2%)</option>
				
				<option value="file516">github.com/tektoncd/pipeline/pkg/taskrunmetrics/fake/fake.go (0.0%)</option>
				
				<option value="file517">github.com/tektoncd/pipeline/pkg/taskrunmetrics/injection.go (11.1%)</option>
				
				<option value="file518">github.com/tektoncd/pipeline/pkg/taskrunmetrics/metrics.go (87.3%)</option>
				
				<option value="file519">github.com/tektoncd/pipeline/pkg/termination/parse.go (100.0%)</option>
				
				<option value="file520">github.com/tektoncd/pipeline/pkg/termination/write.go (70.0%)</option>
				
				<option value="file521">github.com/tektoncd/pipeline/pkg/tracing/tracing.go (78.3%)</option>
				
				<option value="file522">github.com/tektoncd/pipeline/pkg/trustedresources/verifier/verifier.go (100.0%)</option>
				
				<option value="file523">github.com/tektoncd/pipeline/pkg/trustedresources/verify.go (91.6%)</option>
				
				<option value="file524">github.com/tektoncd/pipeline/pkg/workspace/apply.go (97.8%)</option>
				
				<option value="file525">github.com/tektoncd/pipeline/pkg/workspace/validate.go (100.0%)</option>
				
				<option value="file526">github.com/tektoncd/pipeline/tekton/release_names.go (0.0%)</option>
				
				<option value="file527">github.com/tektoncd/pipeline/test/build_logs.go (0.0%)</option>
				
				<option value="file528">github.com/tektoncd/pipeline/test/clients.go (0.0%)</option>
				
				<option value="file529">github.com/tektoncd/pipeline/test/controller.go (30.1%)</option>
				
				<option value="file530">github.com/tektoncd/pipeline/test/featureflags.go (0.0%)</option>
				
				<option value="file531">github.com/tektoncd/pipeline/test/kubectl.go (0.0%)</option>
				
				<option value="file532">github.com/tektoncd/pipeline/test/multiarch_utils.go (43.8%)</option>
				
				<option value="file533">github.com/tektoncd/pipeline/test/remote.go (71.9%)</option>
				
				<option value="file534">github.com/tektoncd/pipeline/test/trustedresources.go (8.2%)</option>
				
				<option value="file535">github.com/tektoncd/pipeline/test/wait.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"
        "log"
        "net/http"
        "os"
        "strconv"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun"
        "github.com/tektoncd/pipeline/pkg/reconciler/resolutionrequest"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/utils/clock"
        filteredinformerfactory "knative.dev/pkg/client/injection/kube/informers/factory/filtered"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        "knative.dev/pkg/signals"
)

const (
        // ControllerLogKey is the name of the logger for the controller cmd
        ControllerLogKey = "tekton-pipelines-controller"
)

func main() <span class="cov0" title="0">{
        if val, ok := os.LookupEnv("THREADS_PER_CONTROLLER"); ok </span><span class="cov0" title="0">{
                threadsPerController, err := strconv.Atoi(val)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to parse value %q of THREADS_PER_CONTROLLER: %v\n", val, err)
                }</span>
                <span class="cov0" title="0">controller.DefaultThreadsPerController = threadsPerController</span>
        }
        <span class="cov0" title="0">flag.IntVar(&amp;controller.DefaultThreadsPerController, "threads-per-controller", controller.DefaultThreadsPerController, "Threads (goroutines) to create per controller")
        namespace := flag.String("namespace", corev1.NamespaceAll, "Namespace to restrict informer to. Optional, defaults to all namespaces.")
        disableHighAvailability := flag.Bool("disable-ha", false, "Whether to disable high-availability functionality for this component.  This flag will be deprecated "+
                "and removed when we have promoted this feature to stable, so do not pass it without filing an "+
                "issue upstream!")

        opts := &amp;pipeline.Options{}
        flag.StringVar(&amp;opts.Images.EntrypointImage, "entrypoint-image", "", "The container image containing our entrypoint binary.")
        flag.StringVar(&amp;opts.Images.SidecarLogResultsImage, "sidecarlogresults-image", "", "The container image containing the binary for accessing results.")
        flag.StringVar(&amp;opts.Images.NopImage, "nop-image", "", "The container image used to stop sidecars")
        flag.StringVar(&amp;opts.Images.ShellImage, "shell-image", "", "The container image containing a shell")
        flag.StringVar(&amp;opts.Images.ShellImageWin, "shell-image-win", "", "The container image containing a windows shell")
        flag.StringVar(&amp;opts.Images.WorkingDirInitImage, "workingdirinit-image", "", "The container image containing our working dir init binary.")
        flag.DurationVar(&amp;opts.ResyncPeriod, "resync-period", controller.DefaultResyncPeriod, "The period between two resync run (going through all objects)")

        // This parses flags.
        cfg := injection.ParseAndGetRESTConfigOrDie()

        if err := opts.Images.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">if cfg.QPS == 0 </span><span class="cov0" title="0">{
                cfg.QPS = 2 * rest.DefaultQPS
        }</span>
        <span class="cov0" title="0">if cfg.Burst == 0 </span><span class="cov0" title="0">{
                cfg.Burst = rest.DefaultBurst
        }</span>
        // FIXME(vdemeester): this is here to not break current behavior
        // multiply by 2, no of controllers being created
        <span class="cov0" title="0">cfg.QPS = 2 * cfg.QPS
        cfg.Burst = 2 * cfg.Burst

        ctx := injection.WithNamespaceScope(signals.NewContext(), *namespace)
        if *disableHighAvailability </span><span class="cov0" title="0">{
                ctx = sharedmain.WithHADisabled(ctx)
        }</span>

        // sets up liveness and readiness probes.
        <span class="cov0" title="0">mux := http.NewServeMux()

        mux.HandleFunc("/", handler)
        mux.HandleFunc("/health", handler)
        mux.HandleFunc("/readiness", handler)

        port := os.Getenv("PROBES_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // start the web server on port and accept requests
                log.Printf("Readiness and health check server listening on port %s", port)
                log.Fatal(http.ListenAndServe(":"+port, mux)) // #nosec G114 -- see https://github.com/securego/gosec#available-rules
        }</span>()

        <span class="cov0" title="0">ctx = filteredinformerfactory.WithSelectors(ctx, v1beta1.ManagedByLabelKey)
        ctx = controller.WithResyncPeriod(ctx, opts.ResyncPeriod)

        sharedmain.MainWithConfig(ctx, ControllerLogKey, cfg,
                taskrun.NewController(opts, clock.RealClock{}),
                pipelinerun.NewController(opts, clock.RealClock{}),
                resolutionrequest.NewController(clock.RealClock{}),
        )</span>
}

func handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

func extractArgs(initialArgs []string) ([]string, []string) <span class="cov8" title="1">{
        commandArgs := []string{}
        args := initialArgs
        if len(initialArgs) == 0 </span><span class="cov8" title="1">{
                return args, commandArgs
        }</span>
        // Detect if `--` is present, if it is, parse only the one before.
        <span class="cov8" title="1">terminatorIndex := -1
        for i, a := range initialArgs </span><span class="cov8" title="1">{
                if a == "--" </span><span class="cov8" title="1">{
                        terminatorIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if terminatorIndex &gt; 0 </span><span class="cov8" title="1">{
                commandArgs = initialArgs[terminatorIndex+1:]
                args = initialArgs[:terminatorIndex]
        }</span>
        <span class="cov8" title="1">return args, commandArgs</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"
        "syscall"
        "time"

        "github.com/tektoncd/pipeline/cmd/entrypoint/subcommands"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types"
        "github.com/tektoncd/pipeline/pkg/credentials/dockercreds"
        "github.com/tektoncd/pipeline/pkg/credentials/gitcreds"
        credwriter "github.com/tektoncd/pipeline/pkg/credentials/writer"
        "github.com/tektoncd/pipeline/pkg/entrypoint"
        "github.com/tektoncd/pipeline/pkg/platforms"
        "github.com/tektoncd/pipeline/pkg/termination"
)

var (
        ep                  = flag.String("entrypoint", "", "Original specified entrypoint to execute")
        waitFiles           = flag.String("wait_file", "", "Comma-separated list of paths to wait for")
        waitFileContent     = flag.Bool("wait_file_content", false, "If specified, expect wait_file to have content")
        postFile            = flag.String("post_file", "", "If specified, file to write upon completion")
        terminationPath     = flag.String("termination_path", "/tekton/termination", "If specified, file to write upon termination")
        results             = flag.String("results", "", "If specified, list of file names that might contain task results")
        stepResults         = flag.String("step_results", "", "step results if specified")
        whenExpressions     = flag.String("when_expressions", "", "when expressions if specified")
        timeout             = flag.Duration("timeout", time.Duration(0), "If specified, sets timeout for step")
        stdoutPath          = flag.String("stdout_path", "", "If specified, file to copy stdout to")
        stderrPath          = flag.String("stderr_path", "", "If specified, file to copy stderr to")
        breakpointOnFailure = flag.Bool("breakpoint_on_failure", false, "If specified, expect steps to not skip on failure")
        debugBeforeStep     = flag.Bool("debug_before_step", false, "If specified, wait for a debugger to attach before executing the step")
        onError             = flag.String("on_error", "", "Set to \"continue\" to ignore an error and continue when a container terminates with a non-zero exit code."+
                " Set to \"stopAndFail\" to declare a failure with a step error and stop executing the rest of the steps.")
        stepMetadataDir        = flag.String("step_metadata_dir", "", "If specified, create directory to store the step metadata e.g. /tekton/steps/&lt;step-name&gt;/")
        resultExtractionMethod = flag.String("result_from", entrypoint.ResultExtractionMethodTerminationMessage, "The method using which to extract results from tasks. Default is using the termination message.")
)

const (
        defaultWaitPollingInterval = time.Second
        TektonPlatformCommandsEnv  = "TEKTON_PLATFORM_COMMANDS"
)

func main() <span class="cov0" title="0">{
        // Add credential flags originally introduced with our legacy credentials helper
        // image (creds-init).
        gitcreds.AddFlags(flag.CommandLine)
        dockercreds.AddFlags(flag.CommandLine)

        // Split args with `--` for the entrypoint and what it should execute
        args, commandArgs := extractArgs(os.Args[1:])

        // We are using the global variable flag.CommandLine here to be able
        // to define what args it should parse.
        // flag.Parse() does flag.CommandLine.Parse(os.Args[1:])
        if err := flag.CommandLine.Parse(args); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := subcommands.Process(flag.CommandLine.Args()); err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                var ok subcommands.OK
                if errors.As(err, &amp;ok) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        // Copy credentials we're expecting from the legacy credentials helper (creds-init)
        // from secret volume mounts to /tekton/creds. This is done to support the expansion
        // of a variable, $(credentials.path), that resolves to a single place with all the
        // stored credentials.
        <span class="cov0" title="0">builders := []credwriter.Writer{dockercreds.NewBuilder(), gitcreds.NewBuilder()}
        for _, c := range builders </span><span class="cov0" title="0">{
                if err := c.Write(entrypoint.CredsDir); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error initializing credentials: %s", err)
                }</span>
        }

        <span class="cov0" title="0">var cmd []string
        if *ep != "" </span><span class="cov0" title="0">{
                cmd = []string{*ep}
        }</span> else<span class="cov0" title="0"> {
                env := os.Getenv(TektonPlatformCommandsEnv)
                var cmds map[string][]string
                if err := json.Unmarshal([]byte(env), &amp;cmds); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                // NB: This value contains OS/architecture and maybe variant.
                // It doesn't include osversion, which is necessary to
                // disambiguate two images both for e.g., Windows, that only
                // differ by osversion.
                <span class="cov0" title="0">plat := platforms.NewPlatform().Format()
                var err error
                cmd, err = selectCommandForPlatform(cmds, plat)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">var when v1.StepWhenExpressions
        if len(*whenExpressions) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*whenExpressions), &amp;when); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }

        <span class="cov0" title="0">spireWorkloadAPI := initializeSpireAPI()

        e := entrypoint.Entrypointer{
                Command:         append(cmd, commandArgs...),
                WaitFiles:       strings.Split(*waitFiles, ","),
                WaitFileContent: *waitFileContent,
                PostFile:        *postFile,
                TerminationPath: *terminationPath,
                Waiter:          &amp;realWaiter{waitPollingInterval: defaultWaitPollingInterval, breakpointOnFailure: *breakpointOnFailure},
                Runner: &amp;realRunner{
                        stdoutPath: *stdoutPath,
                        stderrPath: *stderrPath,
                },
                PostWriter:             &amp;realPostWriter{},
                Results:                strings.Split(*results, ","),
                StepResults:            strings.Split(*stepResults, ","),
                Timeout:                timeout,
                StepWhenExpressions:    when,
                BreakpointOnFailure:    *breakpointOnFailure,
                DebugBeforeStep:        *debugBeforeStep,
                OnError:                *onError,
                StepMetadataDir:        *stepMetadataDir,
                SpireWorkloadAPI:       spireWorkloadAPI,
                ResultExtractionMethod: *resultExtractionMethod,
        }

        // Copy any creds injected by the controller into the $HOME directory of the current
        // user so that they're discoverable by git / ssh.
        if err := credwriter.CopyCredsToHome(credwriter.CredsInitCredentials); err != nil </span><span class="cov0" title="0">{
                log.Printf("non-fatal error copying credentials: %q", err)
        }</span>

        <span class="cov0" title="0">if err := e.Go(); err != nil </span><span class="cov0" title="0">{
                switch t := err.(type) </span>{ //nolint:errorlint // checking for multiple types with errors.As is ugly.
                case entrypoint.DebugBeforeStepError:<span class="cov0" title="0">
                        log.Println("Skipping execute step script because before step breakpoint fail-continue")
                        os.Exit(1)</span>
                case entrypoint.SkipError:<span class="cov0" title="0">
                        log.Print("Skipping step because a previous step failed")
                        os.Exit(1)</span>
                case termination.MessageLengthError:<span class="cov0" title="0">
                        log.Print(err.Error())
                        os.Exit(1)</span>
                case entrypoint.ContextError:<span class="cov0" title="0">
                        if entrypoint.IsContextCanceledError(err) </span><span class="cov0" title="0">{
                                log.Print("Step was cancelled")
                                // use the SIGKILL signal to distinguish normal exit programs, just like kill -9 PID
                                os.Exit(int(syscall.SIGKILL))
                        }</span> else<span class="cov0" title="0"> {
                                log.Print(err.Error())
                                os.Exit(1)
                        }</span>
                case *exec.ExitError:<span class="cov0" title="0">
                        // Copied from https://stackoverflow.com/questions/10385551/get-exit-code-go
                        // This works on both Unix and Windows. Although
                        // package syscall is generally platform dependent,
                        // WaitStatus is defined for both Unix and Windows and
                        // in both cases has an ExitStatus() method with the
                        // same signature.
                        if status, ok := t.Sys().(syscall.WaitStatus); ok </span><span class="cov0" title="0">{
                                e.CheckForBreakpointOnFailure()
                                // ignore a step error i.e. do not exit if a container terminates with a non-zero exit code when onError is set to "continue"
                                if e.OnError != entrypoint.ContinueOnError </span><span class="cov0" title="0">{
                                        os.Exit(status.ExitStatus())
                                }</span>
                        }
                        // log and exit only if a step error must cause run failure
                        <span class="cov0" title="0">if e.OnError != entrypoint.ContinueOnError </span><span class="cov0" title="0">{
                                log.Fatalf("Error executing command (ExitError): %v", err)
                        }</span>
                default:<span class="cov0" title="0">
                        e.CheckForBreakpointOnFailure()
                        log.Fatalf("Error executing command: %v", err)</span>
                }
        }
}

func selectCommandForPlatform(cmds map[string][]string, plat string) ([]string, error) <span class="cov8" title="1">{
        cmd, found := cmds[plat]
        if found </span><span class="cov8" title="1">{
                return cmd, nil
        }</span>

        // If the command wasn't found, check if there's a
        // command defined for the same platform without a CPU
        // variant specified.
        <span class="cov8" title="1">platWithoutVariant := plat[:strings.LastIndex(plat, "/")]
        cmd, found = cmds[platWithoutVariant]
        if found </span><span class="cov8" title="1">{
                return cmd, nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("could not find command for platform %q", plat)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "math"
        "os/exec"
        "syscall"
)

// We need the max value of an unsigned 32 bit integer (4294967295), but we also need this number
// to fit into an "int". One some systems this is 32 bits, so the max uint32 can't fit into here.
// maxIntForArch is the higher of those two values.
func maxIntForArch() int <span class="cov8" title="1">{
        // We have to do over two lines as a variable. The go compiler optimizes
        // away types for constants, so int(uint32(math.MaxUint32)) is the same as int(math.MaxUint32),
        // which overflows.
        maxUint := uint32(math.MaxUint32)
        if int(maxUint) &gt; math.MaxInt32 </span><span class="cov8" title="1">{
                return int(maxUint)
        }</span>
        <span class="cov0" title="0">return math.MaxInt32</span>
}

// dropNetworking modifies the supplied exec.Cmd to execute in a net set of namespaces that do not
// have network access
func dropNetworking(cmd *exec.Cmd) <span class="cov8" title="1">{
        // These flags control the behavior of the new process.
        // Documentation for these is available here: https://man7.org/linux/man-pages/man2/clone.2.html
        // We mostly want to just create a new network namespace, unattached to any networking devices.
        // The other flags are necessary for that to work.

        if cmd.SysProcAttr == nil </span><span class="cov8" title="1">{
                // We build this up piecemeal in case it was already set, to avoid overwriting anything.
                cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        }</span>
        <span class="cov8" title="1">cmd.SysProcAttr.Cloneflags = syscall.CLONE_NEWNS |
                syscall.CLONE_NEWPID | // NEWPID creates a new process namespace
                syscall.CLONE_NEWNET | // NEWNET creates a new network namespace (this is the one we really care about)
                syscall.CLONE_NEWUSER // NEWUSER creates a new user namespace

        // We need to map the existing user IDs into the new namespace.
        // Just map everything.
        cmd.SysProcAttr.UidMappings = []syscall.SysProcIDMap{
                {
                        ContainerID: 0,
                        HostID:      0,
                        // Map all users
                        Size: maxIntForArch(),
                },
        }

        // This is needed to allow programs to call setgroups when in a new Gid namespace.
        // Things like apt-get install require this to work.
        cmd.SysProcAttr.GidMappingsEnableSetgroups = true
        // We need to map the existing group IDs into the new namespace.
        // Just map everything.
        cmd.SysProcAttr.GidMappings = []syscall.SysProcIDMap{
                {
                        ContainerID: 0,
                        HostID:      0,

                        //  Map all groups
                        Size: maxIntForArch(),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "log"
        "os"
        "path/filepath"

        "github.com/tektoncd/pipeline/pkg/entrypoint"
)

// realPostWriter actually writes files.
type realPostWriter struct{}

var _ entrypoint.PostWriter = (*realPostWriter)(nil)

// Write creates a file and writes content to that file if content is specified
func (*realPostWriter) Write(file string, content string) <span class="cov8" title="1">{
        if file == "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Create directory if it doesn't already exist
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(file), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating parent directory of %q: %v", file, err)
        }</span>

        <span class="cov8" title="1">f, err := os.Create(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Creating %q: %v", file, err)
        }</span>

        // make sure that the file is closed at the end
        <span class="cov8" title="1">defer f.Close()

        if content != "" </span><span class="cov8" title="1">{
                if _, err := f.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Writing %q: %v", file, err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//go:build !windows
// +build !windows

/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "sync"
        "syscall"

        "github.com/tektoncd/pipeline/pkg/entrypoint"
)

const (
        TektonHermeticEnvVar = "TEKTON_HERMETIC"
)

// TODO(jasonhall): Test that original exit code is propagated and that
// stdout/stderr are collected -- needs e2e tests.

// realRunner actually runs commands.
type realRunner struct {
        sync.Mutex
        signals       chan os.Signal
        signalsClosed bool
        stdoutPath    string
        stderrPath    string
}

var _ entrypoint.Runner = (*realRunner)(nil)

// close closes the signals channel which is used to receive system signals.
func (rr *realRunner) close() <span class="cov8" title="1">{
        rr.Lock()
        defer rr.Unlock()
        if rr.signals != nil &amp;&amp; !rr.signalsClosed </span><span class="cov8" title="1">{
                close(rr.signals)
                rr.signalsClosed = true
        }</span>
}

// signal allows the caller to simulate the sending of a system signal.
func (rr *realRunner) signal(signal os.Signal) <span class="cov8" title="1">{
        rr.Lock()
        defer rr.Unlock()
        if rr.signals != nil &amp;&amp; !rr.signalsClosed </span><span class="cov8" title="1">{
                rr.signals &lt;- signal
        }</span>
}

// Run executes the entrypoint.
func (rr *realRunner) Run(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">name, args := args[0], args[1:]

        // Receive system signals on "rr.signals"
        if rr.signals == nil </span><span class="cov8" title="1">{
                rr.signals = make(chan os.Signal, 1)
        }</span>
        <span class="cov8" title="1">defer rr.close()
        signal.Notify(rr.signals)
        defer signal.Reset()

        cmd := exec.CommandContext(ctx, name, args...)

        // if a standard output file is specified
        // create the log file and add to the std multi writer
        if rr.stdoutPath != "" </span><span class="cov8" title="1">{
                stdout, err := newStdLogWriter(rr.stdoutPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stdout.Close()
                cmd.Stdout = io.MultiWriter(os.Stdout, stdout)</span>
        } else<span class="cov8" title="1"> {
                cmd.Stdout = os.Stdout
        }</span>
        <span class="cov8" title="1">if rr.stderrPath != "" </span><span class="cov8" title="1">{
                stderr, err := newStdLogWriter(rr.stderrPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer stderr.Close()
                cmd.Stderr = io.MultiWriter(os.Stderr, stderr)</span>
        } else<span class="cov8" title="1"> {
                cmd.Stderr = os.Stderr
        }</span>

        // dedicated PID group used to forward signals to
        // main process and all children
        <span class="cov8" title="1">cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setpgid: true}

        if os.Getenv("TEKTON_RESOURCE_NAME") == "" &amp;&amp; os.Getenv(TektonHermeticEnvVar) == "1" </span><span class="cov0" title="0">{
                dropNetworking(cmd)
        }</span>

        // Start defined command
        <span class="cov8" title="1">if err := cmd.Start(); err != nil </span><span class="cov8" title="1">{
                if errors.Is(ctx.Err(), context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        return entrypoint.ErrContextDeadlineExceeded
                }</span>
                <span class="cov8" title="1">if errors.Is(ctx.Err(), context.Canceled) </span><span class="cov8" title="1">{
                        return entrypoint.ErrContextCanceled
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Goroutine for signals forwarding
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for s := range rr.signals </span><span class="cov8" title="1">{
                        // Forward signal to main process and all children
                        if s != syscall.SIGCHLD </span><span class="cov8" title="1">{
                                _ = syscall.Kill(-cmd.Process.Pid, s.(syscall.Signal))
                        }</span>
                }
        }()

        // Wait for command to exit
        // as os.exec [note](https://github.com/golang/go/blob/ee522e2cdad04a43bc9374776483b6249eb97ec9/src/os/exec/exec.go#L897-L906)
        // cmd.Wait prefer Process error over context error
        // but we want to return context error instead
        <span class="cov8" title="1">if err := cmd.Wait(); err != nil </span><span class="cov8" title="1">{
                if errors.Is(ctx.Err(), context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        return entrypoint.ErrContextDeadlineExceeded
                }</span>
                <span class="cov8" title="1">if errors.Is(ctx.Err(), context.Canceled) </span><span class="cov8" title="1">{
                        return entrypoint.ErrContextCanceled
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// newStdLogWriter create a new file writer that used for collecting std log
// the file is opened with os.O_WRONLY|os.O_CREATE|os.O_APPEND, and will not
// override any existing content in the path. This means that the same file can
// be used for multiple streams if desired. note that close after use
func newStdLogWriter(path string) (*os.File, error) <span class="cov8" title="1">{
        if err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating parent directory: %w", err)
        }</span>
        <span class="cov8" title="1">f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//go:build !disable_spire

/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"
        "log"

        "github.com/tektoncd/pipeline/pkg/spire"
        "github.com/tektoncd/pipeline/pkg/spire/config"
)

var (
        enableSpire = flag.Bool("enable_spire", false, "If specified by configmap, this enables spire signing and verification")
        socketPath  = flag.String("spire_socket_path", "unix:///spiffe-workload-api/spire-agent.sock", "Experimental: The SPIRE agent socket for SPIFFE workload API.")
)

func initializeSpireAPI() spire.EntrypointerAPIClient <span class="cov0" title="0">{
        if enableSpire != nil &amp;&amp; *enableSpire &amp;&amp; socketPath != nil &amp;&amp; *socketPath != "" </span><span class="cov0" title="0">{
                log.Println("SPIRE is enabled in this build, enableSpire is supported")
                spireConfig := config.SpireConfig{
                        SocketPath: *socketPath,
                }
                return spire.NewEntrypointerAPIClient(&amp;spireConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subcommands

import (
        "io"
        "os"
)

// CopyCommand is the name of the copy command.
const CopyCommand = "cp"

// Owner has permission to write and execute, and anybody has
// permission to execute.
const dstPermissions = 0311

// cp copies a files from src to dst.
func cp(src, dst string) error <span class="cov8" title="1">{
        s, err := os.Open(src)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer s.Close()

        d, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE, dstPermissions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer d.Close()

        _, err = io.Copy(d, s)
        return err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subcommands

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "io"
        "os"
)

// DecodeScriptCommand is the command name for decoding scripts.
const DecodeScriptCommand = "decode-script"

// decodeScript rewrites a script file from base64 back into its original content from
// the Step definition.
func decodeScript(scriptPath string) error <span class="cov8" title="1">{
        decodedBytes, permissions, err := decodeScriptFromFile(scriptPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding script file %q: %w", scriptPath, err)
        }</span>
        <span class="cov8" title="1">err = os.WriteFile(scriptPath, decodedBytes, permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing decoded script file %q: %w", scriptPath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// decodeScriptFromFile reads the script at scriptPath, decodes it from
// base64, and returns the decoded bytes w/ the permissions to use when re-writing
// or an error.
func decodeScriptFromFile(scriptPath string) ([]byte, os.FileMode, error) <span class="cov8" title="1">{
        scriptFile, err := os.Open(scriptPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("error reading from script file %q: %w", scriptPath, err)
        }</span>
        <span class="cov8" title="1">defer scriptFile.Close()

        encoded := bytes.NewBuffer(nil)
        if _, err = io.Copy(encoded, scriptFile); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error reading from script file %q: %w", scriptPath, err)
        }</span>

        <span class="cov8" title="1">fileInfo, err := scriptFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error statting script file %q: %w", scriptPath, err)
        }</span>
        <span class="cov8" title="1">perms := fileInfo.Mode().Perm()

        decoded := make([]byte, base64.StdEncoding.DecodedLen(encoded.Len()))
        n, err := base64.StdEncoding.Decode(decoded, encoded.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("error decoding script file %q: %w", scriptPath, err)
        }</span>
        <span class="cov8" title="1">return decoded[0:n], perms, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subcommands

// InitCommand is the name of main initialization command
const InitCommand = "init"

// init copies the entrypoint to the right place and sets up /tekton/steps directory for the pod.
// This expects  the list of steps (in order matching the Task spec).
func entrypointInit(src, dst string, steps []string) error <span class="cov8" title="1">{
        if err := cp(src, dst); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return stepInit(steps)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subcommands

import (
        "log"
        "os"
        "path/filepath"
        "strconv"
)

// StepInitCommand is the name of the /tekton/steps initialization command.
const StepInitCommand = "step-init"

var (
        // root is the location of the Tekton root directory.
        // Included as a global variable to allow overriding for tests.
        tektonRoot = "/tekton"
)

// stepInit sets up the /tekton/steps directory for the pod.
// This expects the list of steps (in order matching the Task spec).
func stepInit(steps []string) error <span class="cov8" title="1">{
        // Setup step directory symlinks - step data is written to a /tekton/run/&lt;step&gt;/status
        // folder corresponding to each step - this is only mounted RW for the matching user step
        // (and RO for all other steps).
        // /tekton/steps provides a convenience symlink so that Tekton utilities to reference steps
        // by name or index.
        // NOTE: /tekton/steps may be removed in the future. Prefer using /tekton/run directly if
        // possible.

        // Create directory if it doesn't already exist
        stepDir := filepath.Join(tektonRoot, "steps")
        if err := os.MkdirAll(stepDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating steps directory %q: %v", stepDir, err)
        }</span>

        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                run := filepath.Join(tektonRoot, "run", strconv.Itoa(i), "status")
                if err := os.Symlink(run, filepath.Join(stepDir, s)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := os.Symlink(run, filepath.Join(stepDir, strconv.Itoa(i))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subcommands

import (
        "fmt"
)

// OK is returned for successful subcommand executions.
type OK struct {
        message string
}

func (err OK) Error() string <span class="cov0" title="0">{
        return err.message
}</span>

// Compile-time check that OK is an error type.
var _ error = OK{}

// SubcommandError is returned for failed subcommand executions.
type SubcommandError struct {
        subcommand string
        message    string
}

func (err SubcommandError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s error: %s", err.subcommand, err.message)
}</span>

// Process takes the set of arguments passed to entrypoint and executes any
// subcommand that the args call for. An error is returned to the caller to
// indicate that a subcommand was matched and to pass back its success/fail
// state. The returned error will be nil if no subcommand was matched to the
// passed args, OK if args matched and the subcommand
// succeeded, or any other error if the args matched but the subcommand failed.
func Process(args []string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch args[0] </span>{
        case InitCommand:<span class="cov0" title="0">
                // If invoked in "init mode" (`entrypoint init &lt;src&gt; &lt;dst&gt; [&lt;step-name&gt;]`),
                // it will copy the src path to the dst path (like CopyCommand), and initialize
                // the /tekton/steps folder (like StepInitCommand)
                if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                        src, dst := args[1], args[2]
                        steps := args[3:]
                        if err := entrypointInit(src, dst, steps); err != nil </span><span class="cov0" title="0">{
                                return SubcommandError{subcommand: InitCommand, message: err.Error()}
                        }</span>
                        <span class="cov0" title="0">return OK{message: "Entrypoint initialization"}</span>
                }
        case CopyCommand:<span class="cov8" title="1">
                // If invoked in "cp mode" (`entrypoint cp &lt;src&gt; &lt;dst&gt;`), simply copy
                // the src path to the dst path. This is used to place the entrypoint
                // binary in the tools directory, without requiring the cp command to
                // exist in the base image.
                if len(args) == 3 </span><span class="cov8" title="1">{
                        src, dst := args[1], args[2]
                        if err := cp(src, dst); err != nil </span><span class="cov0" title="0">{
                                return SubcommandError{subcommand: CopyCommand, message: err.Error()}
                        }</span>
                        <span class="cov8" title="1">return OK{message: fmt.Sprintf("Copied %s to %s", src, dst)}</span>
                }
        case DecodeScriptCommand:<span class="cov8" title="1">
                // If invoked in "decode-script" mode (`entrypoint decode-script &lt;src&gt;`),
                // read the script at &lt;src&gt; and overwrite it with its decoded content.
                if len(args) == 2 </span><span class="cov8" title="1">{
                        src := args[1]
                        if err := decodeScript(src); err != nil </span><span class="cov0" title="0">{
                                return SubcommandError{subcommand: DecodeScriptCommand, message: err.Error()}
                        }</span>
                        <span class="cov8" title="1">return OK{message: "Decoded script " + src}</span>
                }
        case StepInitCommand:<span class="cov8" title="1">
                if err := stepInit(args[1:]); err != nil </span><span class="cov0" title="0">{
                        return SubcommandError{subcommand: StepInitCommand, message: err.Error()}
                }</span>
                <span class="cov8" title="1">return OK{message: "Setup /step directories"}</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/tektoncd/pipeline/pkg/entrypoint"
)

// realWaiter actually waits for files, by polling.
type realWaiter struct {
        waitPollingInterval time.Duration
        breakpointOnFailure bool
}

var _ entrypoint.Waiter = (*realWaiter)(nil)

// setWaitPollingInterval sets the pollingInterval that will be used by the wait function
func (rw *realWaiter) setWaitPollingInterval(pollingInterval time.Duration) *realWaiter <span class="cov8" title="1">{
        rw.waitPollingInterval = pollingInterval
        return rw
}</span>

// Wait watches a file and returns when either a) the file exists and, if
// the expectContent argument is true, the file has non-zero size or b) there
// is an error polling the file.
//
// If the passed-in file is an empty string then this function returns
// immediately.
//
// If a file of the same name with a ".err" extension exists then this Wait
// will end with a skipError.
func (rw *realWaiter) Wait(ctx context.Context, file string, expectContent bool, breakpointOnFailure bool) error <span class="cov8" title="1">{
        if file == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if info, err := os.Stat(file); err == nil </span><span class="cov8" title="1">{
                        if !expectContent || info.Size() &gt; 0 </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                } else<span class="cov8" title="1"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("waiting for %q: %w", file, err)
                }</span>
                // When a .err file is read by this step, it means that a previous step has failed
                // We wouldn't want this step to stop executing because the previous step failed during debug
                // That is counterproductive to debugging
                // Hence we disable skipError here so that the other steps in the failed taskRun can continue
                // executing if breakpointOnFailure is enabled for the taskRun
                // TLDR: Do not return skipError when breakpointOnFailure is enabled as it breaks execution of the TaskRun
                <span class="cov8" title="1">if _, err := os.Stat(file + ".err"); err == nil </span><span class="cov8" title="1">{
                        if breakpointOnFailure </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return entrypoint.ErrSkipPreviousStepFailed</span>
                }
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        if errors.Is(ctx.Err(), context.Canceled) </span><span class="cov8" title="1">{
                                return entrypoint.ErrContextCanceled
                        }</span>
                        <span class="cov8" title="1">if errors.Is(ctx.Err(), context.DeadlineExceeded) </span><span class="cov8" title="1">{
                                return entrypoint.ErrContextDeadlineExceeded
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case &lt;-time.After(rw.waitPollingInterval):<span class="cov8" title="1"></span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "log"
        "net/http"
        "os"

        "github.com/tektoncd/pipeline/pkg/reconciler/notifications/customrun"
        "knative.dev/pkg/injection/sharedmain"
)

const eventsControllerName = "events-controller"

func main() <span class="cov0" title="0">{
        // sets up liveness and readiness probes.
        mux := http.NewServeMux()

        mux.HandleFunc("/", handler)
        mux.HandleFunc("/health", handler)
        mux.HandleFunc("/readiness", handler)

        port := os.Getenv("PROBES_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // start the web server on port and accept requests
                log.Printf("Readiness and health check server listening on port %s", port)
                log.Fatal(http.ListenAndServe(":"+port, mux)) // #nosec G114 -- see https://github.com/securego/gosec#available-rules
        }</span>()

        // start the events controller
        <span class="cov0" title="0">sharedmain.Main(eventsControllerName, customrun.NewController())</span>
}

func handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "log"
        "os"
        "os/signal"
        "syscall"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt;= 2 &amp;&amp; os.Args[1] == "tekton_run_indefinitely" </span><span class="cov0" title="0">{
                log.Println("Waiting indefinitely...")
                ch := make(chan os.Signal, 1)
                signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
                log.Println("received signal:", &lt;-ch)
        }</span>

        <span class="cov0" title="0">log.Println("Exiting...")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"
        "log"
        "os"
        "strconv"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/bundle"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/cluster"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/git"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/http"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/hub"
        hubresolution "github.com/tektoncd/pipeline/pkg/resolution/resolver/hub"
        "k8s.io/client-go/rest"
        filteredinformerfactory "knative.dev/pkg/client/injection/kube/informers/factory/filtered"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        "knative.dev/pkg/signals"
)

func main() <span class="cov0" title="0">{
        if val, ok := os.LookupEnv("THREADS_PER_CONTROLLER"); ok </span><span class="cov0" title="0">{
                threadsPerController, err := strconv.Atoi(val)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to parse value %q of THREADS_PER_CONTROLLER: %v\n", val, err)
                }</span>
                <span class="cov0" title="0">controller.DefaultThreadsPerController = threadsPerController</span>
        }
        <span class="cov0" title="0">flag.IntVar(&amp;controller.DefaultThreadsPerController, "threads-per-controller", controller.DefaultThreadsPerController, "Threads (goroutines) to create per controller")

        ctx := filteredinformerfactory.WithSelectors(signals.NewContext(), v1alpha1.ManagedByLabelKey)
        tektonHubURL := buildHubURL(os.Getenv("TEKTON_HUB_API"), "")
        artifactHubURL := buildHubURL(os.Getenv("ARTIFACT_HUB_API"), hubresolution.DefaultArtifactHubURL)

        // This parses flags.
        cfg := injection.ParseAndGetRESTConfigOrDie()

        if cfg.QPS == 0 </span><span class="cov0" title="0">{
                cfg.QPS = 2 * rest.DefaultQPS
        }</span>
        <span class="cov0" title="0">if cfg.Burst == 0 </span><span class="cov0" title="0">{
                cfg.Burst = rest.DefaultBurst
        }</span>
        // multiply by no of controllers being created
        <span class="cov0" title="0">cfg.QPS = 5 * cfg.QPS
        cfg.Burst = 5 * cfg.Burst

        sharedmain.MainWithConfig(ctx, "controller", cfg,
                framework.NewController(ctx, &amp;git.Resolver{}),
                framework.NewController(ctx, &amp;hub.Resolver{TektonHubURL: tektonHubURL, ArtifactHubURL: artifactHubURL}),
                framework.NewController(ctx, &amp;bundle.Resolver{}),
                framework.NewController(ctx, &amp;cluster.Resolver{}),
                framework.NewController(ctx, &amp;http.Resolver{}))</span>
}

func buildHubURL(configAPI, defaultURL string) string <span class="cov8" title="1">{
        var hubURL string
        if configAPI == "" </span><span class="cov8" title="1">{
                hubURL = defaultURL
        }</span> else<span class="cov8" title="1"> {
                hubURL = configAPI
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(hubURL, "/")</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "encoding/json"
        "flag"
        "log"
        "os"
        "strings"

        "github.com/tektoncd/pipeline/internal/sidecarlogresults"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/pod"
)

func main() <span class="cov0" title="0">{
        var resultsDir string
        var resultNames string
        var stepResultsStr string
        var stepNames string

        flag.StringVar(&amp;resultsDir, "results-dir", pipeline.DefaultResultPath, "Path to the results directory. Default is /tekton/results")
        flag.StringVar(&amp;resultNames, "result-names", "", "comma separated result names to expect from the steps running in the pod. eg. foo,bar,baz")
        flag.StringVar(&amp;stepResultsStr, "step-results", "", "json containing a map of step Name as key and list of result Names. eg. {\"stepName\":[\"foo\",\"bar\",\"baz\"]}")
        flag.StringVar(&amp;stepNames, "step-names", "", "comma separated step names. eg. foo,bar,baz")
        flag.Parse()

        var expectedResults []string
        // strings.Split returns [""] instead of [] for empty string, we don't want pass [""] to other methods.
        if len(resultNames) &gt; 0 </span><span class="cov0" title="0">{
                expectedResults = strings.Split(resultNames, ",")
        }</span>
        <span class="cov0" title="0">expectedStepResults := map[string][]string{}
        if err := json.Unmarshal([]byte(stepResultsStr), &amp;expectedStepResults); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err := sidecarlogresults.LookForResults(os.Stdout, pod.RunDir, resultsDir, expectedResults, pipeline.StepsDir, expectedStepResults)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">var names []string
        if len(stepNames) &gt; 0 </span><span class="cov0" title="0">{
                names = strings.Split(stepNames, ",")
        }</span>
        <span class="cov0" title="0">err = sidecarlogresults.LookForArtifacts(os.Stdout, names, pod.RunDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "strings"

        defaultconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        pkgleaderelection "knative.dev/pkg/leaderelection"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/signals"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        "knative.dev/pkg/webhook/certificates"
        "knative.dev/pkg/webhook/configmaps"
        "knative.dev/pkg/webhook/resourcesemantics"
        "knative.dev/pkg/webhook/resourcesemantics/conversion"
        "knative.dev/pkg/webhook/resourcesemantics/defaulting"
        "knative.dev/pkg/webhook/resourcesemantics/validation"
)

var types = map[schema.GroupVersionKind]resourcesemantics.GenericCRD{
        // v1alpha1
        v1alpha1.SchemeGroupVersion.WithKind("VerificationPolicy"): &amp;v1alpha1.VerificationPolicy{},
        v1alpha1.SchemeGroupVersion.WithKind("StepAction"):         &amp;v1alpha1.StepAction{},
        // v1beta1
        v1beta1.SchemeGroupVersion.WithKind("Pipeline"):    &amp;v1beta1.Pipeline{},
        v1beta1.SchemeGroupVersion.WithKind("Task"):        &amp;v1beta1.Task{},
        v1beta1.SchemeGroupVersion.WithKind("TaskRun"):     &amp;v1beta1.TaskRun{},
        v1beta1.SchemeGroupVersion.WithKind("PipelineRun"): &amp;v1beta1.PipelineRun{},
        v1beta1.SchemeGroupVersion.WithKind("CustomRun"):   &amp;v1beta1.CustomRun{},
        v1beta1.SchemeGroupVersion.WithKind("StepAction"):  &amp;v1beta1.StepAction{},
        // v1
        v1.SchemeGroupVersion.WithKind("Task"):        &amp;v1.Task{},
        v1.SchemeGroupVersion.WithKind("Pipeline"):    &amp;v1.Pipeline{},
        v1.SchemeGroupVersion.WithKind("TaskRun"):     &amp;v1.TaskRun{},
        v1.SchemeGroupVersion.WithKind("PipelineRun"): &amp;v1.PipelineRun{},

        // resolution
        // v1alpha1
        resolutionv1alpha1.SchemeGroupVersion.WithKind("ResolutionRequest"): &amp;resolutionv1alpha1.ResolutionRequest{},
        // v1beta1
        resolutionv1beta1.SchemeGroupVersion.WithKind("ResolutionRequest"): &amp;resolutionv1beta1.ResolutionRequest{},
}

func newDefaultingAdmissionController(name string) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                // Decorate contexts with the current state of the config.
                store := defaultconfig.NewStore(logging.FromContext(ctx).Named("config-store"))
                store.WatchConfigs(cmw)
                return defaulting.NewAdmissionController(ctx,

                        // Name of the resource webhook, it is the value of the environment variable WEBHOOK_ADMISSION_CONTROLLER_NAME
                        // default is "webhook.pipeline.tekton.dev"
                        name,

                        // The path on which to serve the webhook.
                        "/defaulting",

                        // The resources to validate and default.
                        types,

                        // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                        func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                                return store.ToContext(ctx)
                        }</span>,

                        // Whether to disallow unknown fields.
                        true,
                )
        }
}

func newValidationAdmissionController(name string) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                // Decorate contexts with the current state of the config.
                store := defaultconfig.NewStore(logging.FromContext(ctx).Named("config-store"))
                store.WatchConfigs(cmw)
                return validation.NewAdmissionController(ctx,

                        // Name of the validation webhook, it is based on the value of the environment variable WEBHOOK_ADMISSION_CONTROLLER_NAME
                        // default is "validation.webhook.pipeline.tekton.dev"
                        strings.Join([]string{"validation", name}, "."),

                        // The path on which to serve the webhook.
                        "/resource-validation",

                        // The resources to validate and default.
                        types,

                        // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                        func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                                return store.ToContext(ctx)
                        }</span>,

                        // Whether to disallow unknown fields.
                        true,
                )
        }
}

func newConfigValidationController(name string) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                return configmaps.NewAdmissionController(ctx,

                        // Name of the configmap webhook, it is based on the value of the environment variable WEBHOOK_ADMISSION_CONTROLLER_NAME
                        // default is "config.webhook.pipeline.tekton.dev"
                        strings.Join([]string{"config", name}, "."),

                        // The path on which to serve the webhook.
                        "/config-validation",

                        // The configmaps to validate.
                        configmap.Constructors{
                                logging.ConfigMapName():                   logging.NewConfigFromConfigMap,
                                defaultconfig.GetDefaultsConfigName():     defaultconfig.NewDefaultsFromConfigMap,
                                pkgleaderelection.ConfigMapName():         pkgleaderelection.NewConfigFromConfigMap,
                                defaultconfig.GetFeatureFlagsConfigName(): defaultconfig.NewFeatureFlagsFromConfigMap,
                        },
                )
        }</span>
}

func newConversionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        var (
                v1alpha1GroupVersion           = v1alpha1.SchemeGroupVersion.Version
                v1beta1GroupVersion            = v1beta1.SchemeGroupVersion.Version
                v1GroupVersion                 = v1.SchemeGroupVersion.Version
                resolutionv1alpha1GroupVersion = resolutionv1alpha1.SchemeGroupVersion.Version
                resolutionv1beta1GroupVersion  = resolutionv1beta1.SchemeGroupVersion.Version
        )
        // Decorate contexts with the current state of the config.
        store := defaultconfig.NewStore(logging.FromContext(ctx).Named("config-store"))
        store.WatchConfigs(cmw)
        return conversion.NewConversionController(ctx,
                // The path on which to serve the webhook
                "/resource-conversion",

                // Specify the types of custom resource definitions that should be converted
                // "HubVersion" specifies which version of the CustomResource supports
                // conversions to and from all types.
                // "Zygotes" are the supported versions.
                map[schema.GroupKind]conversion.GroupKindConversion{
                        v1beta1.Kind("StepAction"): {
                                DefinitionName: pipeline.StepActionResource.String(),
                                HubVersion:     v1alpha1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        v1alpha1GroupVersion: &amp;v1alpha1.StepAction{},
                                        v1beta1GroupVersion:  &amp;v1beta1.StepAction{},
                                },
                        },
                        v1.Kind("Task"): {
                                DefinitionName: pipeline.TaskResource.String(),
                                HubVersion:     v1beta1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        v1beta1GroupVersion: &amp;v1beta1.Task{},
                                        v1GroupVersion:      &amp;v1.Task{},
                                },
                        },
                        v1.Kind("Pipeline"): {
                                DefinitionName: pipeline.PipelineResource.String(),
                                HubVersion:     v1beta1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        v1beta1GroupVersion: &amp;v1beta1.Pipeline{},
                                        v1GroupVersion:      &amp;v1.Pipeline{},
                                },
                        },
                        v1.Kind("TaskRun"): {
                                DefinitionName: pipeline.TaskRunResource.String(),
                                HubVersion:     v1beta1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        v1beta1GroupVersion: &amp;v1beta1.TaskRun{},
                                        v1GroupVersion:      &amp;v1.TaskRun{},
                                },
                        },
                        v1.Kind("PipelineRun"): {
                                DefinitionName: pipeline.PipelineRunResource.String(),
                                HubVersion:     v1beta1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        v1beta1GroupVersion: &amp;v1beta1.PipelineRun{},
                                        v1GroupVersion:      &amp;v1.PipelineRun{},
                                },
                        },
                        resolutionv1beta1.Kind("ResolutionRequest"): {
                                DefinitionName: resolution.ResolutionRequestResource.String(),
                                HubVersion:     resolutionv1alpha1GroupVersion,
                                Zygotes: map[string]conversion.ConvertibleObject{
                                        resolutionv1alpha1GroupVersion: &amp;resolutionv1alpha1.ResolutionRequest{},
                                        resolutionv1beta1GroupVersion:  &amp;resolutionv1beta1.ResolutionRequest{},
                                },
                        },
                },

                // A function that infuses the context passed to ConvertTo/ConvertFrom/SetDefaults with custom metadata
                func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                        return store.ToContext(ctx)
                }</span>,
        )
}

func main() <span class="cov0" title="0">{
        serviceName := os.Getenv("WEBHOOK_SERVICE_NAME")
        if serviceName == "" </span><span class="cov0" title="0">{
                serviceName = "tekton-pipelines-webhook"
        }</span>

        <span class="cov0" title="0">secretName := os.Getenv("WEBHOOK_SECRET_NAME")
        if secretName == "" </span><span class="cov0" title="0">{
                secretName = "webhook-certs" // #nosec
        }</span>

        <span class="cov0" title="0">webhookName := os.Getenv("WEBHOOK_ADMISSION_CONTROLLER_NAME")
        if webhookName == "" </span><span class="cov0" title="0">{
                webhookName = "webhook.pipeline.tekton.dev"
        }</span>

        <span class="cov0" title="0">var statsReporterOptions []webhook.StatsReporterOption
        enableNamespace := os.Getenv("WEBHOOK_METRICS_ENABLE_NAMESPACE")
        if enableNamespace != "true" </span><span class="cov0" title="0">{
                statsReporterOptions = append(statsReporterOptions, webhook.WithoutTags("resource_namespace"))
        }</span>

        // Scope informers to the webhook's namespace instead of cluster-wide
        <span class="cov0" title="0">ctx := injection.WithNamespaceScope(signals.NewContext(), system.Namespace())

        // Set up a signal context with our webhook options
        ctx = webhook.WithOptions(ctx, webhook.Options{
                ServiceName: serviceName,
                Port:        webhook.PortFromEnv(8443),
                SecretName:  secretName,

                StatsReporterOptions: statsReporterOptions,
        })

        mux := http.NewServeMux()

        mux.HandleFunc("/", handler)
        mux.HandleFunc("/health", handler)
        mux.HandleFunc("/readiness", handler)

        port := os.Getenv("PROBES_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // start the web server on port and accept requests
                log.Printf("Readiness and health check server listening on port %s", port)
                log.Fatal(http.ListenAndServe(":"+port, mux)) // #nosec G114 -- see https://github.com/securego/gosec#available-rules
        }</span>()

        <span class="cov0" title="0">sharedmain.MainWithContext(ctx, serviceName,
                certificates.NewController,
                newDefaultingAdmissionController(webhookName),
                newValidationAdmissionController(webhookName),
                newConfigValidationController(webhookName),
                newConversionController,
        )</span>
}

func handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strings"
)

func main() <span class="cov0" title="0">{
        for i, d := range os.Args </span><span class="cov0" title="0">{
                // os.Args[0] is the path to this executable, so we should skip it
                if i == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ws := cleanPath("/workspace/")
                p := cleanPath(d)

                if !filepath.IsAbs(p) || strings.HasPrefix(p, ws+string(filepath.Separator)) </span><span class="cov0" title="0">{
                        if err := os.MkdirAll(p, 0755); err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to mkdir %q: %v", p, err)
                        }</span>
                }
        }
}

func cleanPath(path string) string <span class="cov8" title="1">{
        p := filepath.Clean(path)

        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Append 'C:' if the path is absolute (i.e. it begins with a single '\')
                if strings.HasPrefix(p, "\\") &amp;&amp; !strings.HasPrefix(p, "\\\\") </span><span class="cov0" title="0">{
                        p = "C:" + p
                }</span>
        }

        <span class="cov8" title="1">return p</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "errors"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        filteredinformerfactory "knative.dev/pkg/client/injection/kube/informers/factory/filtered"
        "knative.dev/pkg/injection/sharedmain"
)

func main() <span class="cov0" title="0">{
        ctx := filteredinformerfactory.WithSelectors(context.Background(), v1beta1.ManagedByLabelKey)
        sharedmain.MainWithContext(ctx, "controller",
                framework.NewController(ctx, &amp;resolver{}),
        )
}</span>

// Deprecated
type resolver struct{}

// Initialize sets up any dependencies needed by the resolver. None atm.
func (r *resolver) Initialize(context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return "Demo"
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: "demo",
        }
}</span>

// ValidateParams ensures parameters from a request are as expected.
func (r *resolver) ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        if len(params) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("no params allowed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Resolve uses the given params to resolve the requested file or resource.
func (r *resolver) Resolve(ctx context.Context, params []pipelinev1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        return &amp;myResolvedResource{}, nil
}</span>

// our hard-coded resolved file to return
const pipeline = `
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: my-pipeline
spec:
  tasks:
  - name: hello-world
    taskSpec:
      steps:
      - image: alpine:3.15.1
        script: |
          echo "hello world"
`

// myResolvedResource wraps the data we want to return to Pipelines
type myResolvedResource struct{}

// Data returns the bytes of our hard-coded Pipeline
func (*myResolvedResource) Data() []byte <span class="cov8" title="1">{
        return []byte(pipeline)
}</span>

// Annotations returns any metadata needed alongside the data. None atm.
func (*myResolvedResource) Annotations() map[string]string <span class="cov8" title="1">{
        return nil
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint. None atm.
func (*myResolvedResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "errors"
        "fmt"
        neturl "net/url"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        frameworkV1 "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        filteredinformerfactory "knative.dev/pkg/client/injection/kube/informers/factory/filtered"
        "knative.dev/pkg/injection/sharedmain"
)

func main() <span class="cov0" title="0">{
        ctx := filteredinformerfactory.WithSelectors(context.Background(), v1beta1.ManagedByLabelKey)
        sharedmain.MainWithContext(ctx, "controller",
                framework.NewController(ctx, &amp;resolver{}),
        )
}</span>

type resolver struct{}

// Initialize sets up any dependencies needed by the resolver. None atm.
func (r *resolver) Initialize(context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return "Demo"
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: "demo",
        }
}</span>

// Validate ensures resolution spec from a request is as expected.
func (r *resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return errors.New("no params allowed")
        }</span>
        <span class="cov8" title="1">u, err := neturl.ParseRequestURI(req.URL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if u.Scheme != "demoscheme" </span><span class="cov8" title="1">{
                return fmt.Errorf("Invalid Scheme. Want %s, Got %s", "demoscheme", u.Scheme)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Resolve uses the given resolution spec to resolve the requested file or resource.
func (r *resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (frameworkV1.ResolvedResource, error) <span class="cov8" title="1">{
        return &amp;myResolvedResource{}, nil
}</span>

// our hard-coded resolved file to return
const pipeline = `
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: my-pipeline
spec:
  tasks:
  - name: hello-world
    taskSpec:
      steps:
      - image: alpine:3.15.1
        script: |
          echo "hello world"
`

// myResolvedResource wraps the data we want to return to Pipelines
type myResolvedResource struct{}

// Data returns the bytes of our hard-coded Pipeline
func (*myResolvedResource) Data() []byte <span class="cov8" title="1">{
        return []byte(pipeline)
}</span>

// Annotations returns any metadata needed alongside the data. None atm.
func (*myResolvedResource) Annotations() map[string]string <span class="cov8" title="1">{
        return nil
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint. None atm.
func (*myResolvedResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sidecarlogresults

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/result"
        "golang.org/x/sync/errgroup"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/kubernetes"
)

// ErrSizeExceeded indicates that the result exceeded its maximum allowed size
var (
        ErrSizeExceeded = errors.New("results size exceeds configured limit")
        stepDir         = pipeline.StepsDir
)

type SidecarLogResultType string

const (
        taskResultType SidecarLogResultType = "task"
        stepResultType SidecarLogResultType = "step"

        stepArtifactType           SidecarLogResultType = "stepArtifact"
        taskArtifactType           SidecarLogResultType = "taskArtifact"
        sidecarResultNameSeparator string               = "."
)

// SidecarLogResult holds fields for storing extracted results
type SidecarLogResult struct {
        Name  string               `json:"name"`
        Value string               `json:"value"`
        Type  SidecarLogResultType `json:"type"`
}

func fileExists(filename string) (bool, error) <span class="cov8" title="1">{
        info, err := os.Stat(filename)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error checking for file existence %w", err)
        }</span>
        <span class="cov8" title="1">return !info.IsDir(), nil</span>
}

func encode(w io.Writer, v any) error <span class="cov8" title="1">{
        return json.NewEncoder(w).Encode(v)
}</span>

func waitForStepsToFinish(runDir string, sleepInterval time.Duration) error <span class="cov8" title="1">{
        steps := make(map[string]bool)
        files, err := os.ReadDir(runDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing the run dir  %w", err)
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                steps[filepath.Join(runDir, file.Name(), "out")] = true
        }</span>
        <span class="cov8" title="1">for len(steps) &gt; 0 </span><span class="cov8" title="1">{
                for stepFile := range steps </span><span class="cov8" title="1">{
                        // check if there is a post file without error
                        exists, err := fileExists(stepFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error checking for out file's existence %w", err)
                        }</span>
                        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                                delete(steps, stepFile)
                                continue</span>
                        }
                        // check if there is a post file with error
                        // if err is nil then either the out.err file does not exist or it does and there was no issue
                        // in either case, existence of out.err marks that the step errored and the following steps will
                        // not run. We want the function to break out with nil error in that case so that
                        // the existing results can be logged.
                        <span class="cov8" title="1">if exists, err = fileExists(stepFile + ".err"); exists || err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if sleepInterval &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(sleepInterval)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func createSidecarResultName(stepName, resultName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s%s", stepName, sidecarResultNameSeparator, resultName)
}</span>

// ExtractStepAndResultFromSidecarResultName splits the result name to extract the step
// and result name from it. It only works if the format is &lt;stepName&gt;.&lt;resultName&gt;
func ExtractStepAndResultFromSidecarResultName(sidecarResultName string) (string, string, error) <span class="cov8" title="1">{
        splitString := strings.SplitN(sidecarResultName, sidecarResultNameSeparator, 2)
        if len(splitString) != 2 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid string %s : expected somtthing that looks like &lt;stepName&gt;.&lt;resultName&gt;", sidecarResultName)
        }</span>
        <span class="cov8" title="1">return splitString[0], splitString[1], nil</span>
}

func readResults(resultsDir, resultFile, stepName string, resultType SidecarLogResultType) (SidecarLogResult, error) <span class="cov8" title="1">{
        value, err := os.ReadFile(filepath.Join(resultsDir, resultFile))
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return SidecarLogResult{}, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return SidecarLogResult{}, fmt.Errorf("error reading the results file %w", err)
        }</span>
        <span class="cov8" title="1">resultName := resultFile
        if resultType == stepResultType </span><span class="cov8" title="1">{
                resultName = createSidecarResultName(stepName, resultFile)
        }</span>
        <span class="cov8" title="1">return SidecarLogResult{
                Name:  resultName,
                Value: string(value),
                Type:  resultType,
        }, nil</span>
}

// LookForResults waits for results to be written out by the steps
// in their results path and prints them in a structured way to its
// stdout so that the reconciler can parse those logs.
func LookForResults(w io.Writer, runDir string, resultsDir string, resultNames []string, stepResultsDir string, stepResults map[string][]string) error <span class="cov8" title="1">{
        interval, err := getSidecarLogPollingInterval()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting polling interval: %w", err)
        }</span>
        <span class="cov8" title="1">if err := waitForStepsToFinish(runDir, interval); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while waiting for the steps to finish  %w", err)
        }</span>
        <span class="cov8" title="1">results := make(chan SidecarLogResult)
        g := new(errgroup.Group)
        for _, resultFile := range resultNames </span><span class="cov8" title="1">{
                g.Go(func() error </span><span class="cov8" title="1">{
                        newResult, err := readResults(resultsDir, resultFile, "", taskResultType)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if newResult.Name == "" </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">results &lt;- newResult
                        return nil</span>
                })
        }

        <span class="cov8" title="1">for sName, sresults := range stepResults </span><span class="cov8" title="1">{
                for _, resultName := range sresults </span><span class="cov8" title="1">{
                        stepResultsDir := filepath.Join(stepResultsDir, sName, "results")

                        g.Go(func() error </span><span class="cov8" title="1">{
                                newResult, err := readResults(stepResultsDir, resultName, sName, stepResultType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if newResult.Name == "" </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">results &lt;- newResult
                                return nil</span>
                        })
                }
        }

        <span class="cov8" title="1">channelGroup := new(errgroup.Group)
        channelGroup.Go(func() error </span><span class="cov8" title="1">{
                if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing results: %w", err)
                }</span>
                <span class="cov8" title="1">close(results)
                return nil</span>
        })

        <span class="cov8" title="1">for result := range results </span><span class="cov8" title="1">{
                if err := encode(w, result); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error writing results: %w", err)
                }</span>
        }
        <span class="cov8" title="1">if err := channelGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LookForArtifacts searches for and processes artifacts within a specified run directory.
// It looks for "provenance.json" files within the "artifacts" subdirectory of each named step.
// If the provenance file exists, the function extracts artifact information, formats it into a
// JSON string, and encodes it for output alongside relevant metadata (step name, artifact type).
func LookForArtifacts(w io.Writer, names []string, runDir string) error <span class="cov8" title="1">{
        interval, err := getSidecarLogPollingInterval()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting polling interval: %w", err)
        }</span>
        <span class="cov8" title="1">if err := waitForStepsToFinish(runDir, interval); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, name := range names </span><span class="cov8" title="1">{
                p := filepath.Join(stepDir, name, "artifacts", "provenance.json")
                if exist, err := fileExists(p); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if !exist </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">subRes, err := extractArtifactsFromFile(p)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">values, err := json.Marshal(&amp;subRes)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := encode(w, SidecarLogResult{Name: name, Value: string(values), Type: stepArtifactType}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetResultsFromSidecarLogs extracts results from the logs of the results sidecar
func GetResultsFromSidecarLogs(ctx context.Context, clientset kubernetes.Interface, namespace string, name string, container string, podPhase corev1.PodPhase) ([]result.RunResult, error) <span class="cov8" title="1">{
        sidecarLogResults := []result.RunResult{}
        if podPhase == corev1.PodPending </span><span class="cov8" title="1">{
                return sidecarLogResults, nil
        }</span>
        <span class="cov8" title="1">podLogOpts := corev1.PodLogOptions{Container: container}
        req := clientset.CoreV1().Pods(namespace).GetLogs(name, &amp;podLogOpts)
        sidecarLogs, err := req.Stream(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return sidecarLogResults, err
        }</span>
        <span class="cov8" title="1">defer sidecarLogs.Close()
        maxResultLimit := config.FromContextOrDefaults(ctx).FeatureFlags.MaxResultSize
        return extractResultsFromLogs(sidecarLogs, sidecarLogResults, maxResultLimit)</span>
}

func extractResultsFromLogs(logs io.Reader, sidecarLogResults []result.RunResult, maxResultLimit int) ([]result.RunResult, error) <span class="cov8" title="1">{
        scanner := bufio.NewScanner(logs)
        buf := make([]byte, maxResultLimit)
        scanner.Buffer(buf, maxResultLimit)
        for scanner.Scan() </span><span class="cov8" title="1">{
                result, err := parseResults(scanner.Bytes(), maxResultLimit)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">sidecarLogResults = append(sidecarLogResults, result)</span>
        }

        <span class="cov8" title="1">if scanner.Err() != nil </span><span class="cov8" title="1">{
                if errors.Is(scanner.Err(), bufio.ErrTooLong) </span><span class="cov8" title="1">{
                        return sidecarLogResults, ErrSizeExceeded
                }</span>
                <span class="cov0" title="0">return nil, scanner.Err()</span>
        }
        <span class="cov8" title="1">return sidecarLogResults, nil</span>
}

func parseResults(resultBytes []byte, maxResultLimit int) (result.RunResult, error) <span class="cov8" title="1">{
        runResult := result.RunResult{}
        var res SidecarLogResult
        if err := json.Unmarshal(resultBytes, &amp;res); err != nil </span><span class="cov8" title="1">{
                return runResult, fmt.Errorf("invalid result \"%s\": %w", res.Name, err)
        }</span>
        <span class="cov8" title="1">if len(resultBytes) &gt; maxResultLimit </span><span class="cov8" title="1">{
                return runResult, fmt.Errorf("invalid result \"%s\": %w of %d", res.Name, ErrSizeExceeded, maxResultLimit)
        }</span>
        <span class="cov8" title="1">var resultType result.ResultType
        switch res.Type </span>{
        case taskResultType:<span class="cov8" title="1">
                resultType = result.TaskRunResultType</span>
        case stepResultType:<span class="cov8" title="1">
                resultType = result.StepResultType</span>
        case stepArtifactType:<span class="cov8" title="1">
                resultType = result.StepArtifactsResultType</span>
        case taskArtifactType:<span class="cov8" title="1">
                resultType = result.TaskRunArtifactsResultType</span>
        default:<span class="cov8" title="1">
                return result.RunResult{}, fmt.Errorf("invalid sidecar result type %v. Must be %v or %v or %v", res.Type, taskResultType, stepResultType, stepArtifactType)</span>
        }
        <span class="cov8" title="1">runResult = result.RunResult{
                Key:        res.Name,
                Value:      res.Value,
                ResultType: resultType,
        }
        return runResult, nil</span>
}

func parseArtifacts(fileContent []byte) (v1.Artifacts, error) <span class="cov8" title="1">{
        var as v1.Artifacts
        if err := json.Unmarshal(fileContent, &amp;as); err != nil </span><span class="cov8" title="1">{
                return as, fmt.Errorf("invalid artifacts : %w", err)
        }</span>
        <span class="cov8" title="1">return as, nil</span>
}

func extractArtifactsFromFile(filename string) (v1.Artifacts, error) <span class="cov8" title="1">{
        b, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return v1.Artifacts{}, fmt.Errorf("error reading the results file %w", err)
        }</span>
        <span class="cov8" title="1">return parseArtifacts(b)</span>
}

// getSidecarLogPollingInterval reads the SIDECAR_LOG_POLLING_INTERVAL environment variable,
// parses it as a time.Duration, and returns the result. If the variable is not set or is invalid,
// it defaults to 100ms.
func getSidecarLogPollingInterval() (time.Duration, error) <span class="cov8" title="1">{
        intervalStr := os.Getenv("SIDECAR_LOG_POLLING_INTERVAL")
        if intervalStr == "" </span><span class="cov8" title="1">{
                intervalStr = "100ms"
        }</span>
        <span class="cov8" title="1">interval, err := time.ParseDuration(intervalStr)
        if err != nil </span><span class="cov8" title="1">{
                return 100 * time.Millisecond, err
        }</span>
        <span class="cov8" title="1">return interval, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "log"
        "os"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "sigs.k8s.io/yaml"
)

const (
        // DefaultTimeoutMinutes is used when no timeout is specified.
        DefaultTimeoutMinutes = 60
        // NoTimeoutDuration is used when a pipeline or task should never time out.
        NoTimeoutDuration = 0 * time.Minute
        // DefaultServiceAccountValue is the SA used when one is not specified.
        DefaultServiceAccountValue = "default"
        // DefaultManagedByLabelValue is the value for the managed-by label that is used by default.
        DefaultManagedByLabelValue = "tekton-pipelines"
        // DefaultCloudEventSinkValue is the default value for cloud event sinks.
        DefaultCloudEventSinkValue = ""
        // DefaultMaxMatrixCombinationsCount is used when no max matrix combinations count is specified.
        DefaultMaxMatrixCombinationsCount = 256
        // DefaultResolverTypeValue is used when no default resolver type is specified
        DefaultResolverTypeValue = ""
        // default resource requirements, will be applied to all the containers, which has empty resource requirements
        ResourceRequirementDefaultContainerKey = "default"

        DefaultImagePullBackOffTimeout = 0 * time.Minute

        // Default maximum resolution timeout used by the resolution controller before timing out when exceeded
        DefaultMaximumResolutionTimeout = 1 * time.Minute

        DefaultSidecarLogPollingInterval = 100 * time.Millisecond

        // DefaultStepRefConcurrencyLimit is the default concurrency limit for resolving step references.
        DefaultStepRefConcurrencyLimit = 5

        defaultTimeoutMinutesKey                = "default-timeout-minutes"
        defaultServiceAccountKey                = "default-service-account"
        defaultManagedByLabelValueKey           = "default-managed-by-label-value"
        defaultPodTemplateKey                   = "default-pod-template"
        defaultAAPodTemplateKey                 = "default-affinity-assistant-pod-template"
        defaultCloudEventsSinkKey               = "default-cloud-events-sink"
        defaultTaskRunWorkspaceBinding          = "default-task-run-workspace-binding"
        defaultMaxMatrixCombinationsCountKey    = "default-max-matrix-combinations-count"
        defaultForbiddenEnv                     = "default-forbidden-env"
        defaultResolverTypeKey                  = "default-resolver-type"
        defaultContainerResourceRequirementsKey = "default-container-resource-requirements"
        defaultImagePullBackOffTimeout          = "default-imagepullbackoff-timeout"
        defaultMaximumResolutionTimeout         = "default-maximum-resolution-timeout"
        defaultSidecarLogPollingIntervalKey     = "default-sidecar-log-polling-interval"
        DefaultStepRefConcurrencyLimitKey       = "default-step-ref-concurrency-limit"
)

// DefaultConfig holds all the default configurations for the config.
var DefaultConfig, _ = NewDefaultsFromMap(map[string]string{})

// Defaults holds the default configurations
// +k8s:deepcopy-gen=true
type Defaults struct {
        DefaultTimeoutMinutes                int
        DefaultServiceAccount                string
        DefaultManagedByLabelValue           string
        DefaultPodTemplate                   *pod.Template
        DefaultAAPodTemplate                 *pod.AffinityAssistantTemplate
        DefaultCloudEventsSink               string // Deprecated. Use the events package instead
        DefaultTaskRunWorkspaceBinding       string
        DefaultMaxMatrixCombinationsCount    int
        DefaultForbiddenEnv                  []string
        DefaultResolverType                  string
        DefaultContainerResourceRequirements map[string]corev1.ResourceRequirements
        DefaultImagePullBackOffTimeout       time.Duration
        DefaultMaximumResolutionTimeout      time.Duration
        // DefaultSidecarLogPollingInterval specifies how frequently (as a time.Duration) the Tekton sidecar log results container polls for step completion files.
        // This value is loaded from the 'sidecar-log-polling-interval' key in the config-defaults ConfigMap.
        // It is used to control the responsiveness and resource usage of the sidecar in both production and test environments.
        DefaultSidecarLogPollingInterval time.Duration
        DefaultStepRefConcurrencyLimit   int
}

// GetDefaultsConfigName returns the name of the configmap containing all
// defined defaults.
func GetDefaultsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_DEFAULTS_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-defaults"</span>
}

// Equals returns true if two Configs are identical
func (cfg *Defaults) Equals(other *Defaults) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return other.DefaultTimeoutMinutes == cfg.DefaultTimeoutMinutes &amp;&amp;
                other.DefaultServiceAccount == cfg.DefaultServiceAccount &amp;&amp;
                other.DefaultManagedByLabelValue == cfg.DefaultManagedByLabelValue &amp;&amp;
                other.DefaultPodTemplate.Equals(cfg.DefaultPodTemplate) &amp;&amp;
                other.DefaultAAPodTemplate.Equals(cfg.DefaultAAPodTemplate) &amp;&amp;
                other.DefaultCloudEventsSink == cfg.DefaultCloudEventsSink &amp;&amp;
                other.DefaultTaskRunWorkspaceBinding == cfg.DefaultTaskRunWorkspaceBinding &amp;&amp;
                other.DefaultMaxMatrixCombinationsCount == cfg.DefaultMaxMatrixCombinationsCount &amp;&amp;
                other.DefaultResolverType == cfg.DefaultResolverType &amp;&amp;
                other.DefaultImagePullBackOffTimeout == cfg.DefaultImagePullBackOffTimeout &amp;&amp;
                other.DefaultMaximumResolutionTimeout == cfg.DefaultMaximumResolutionTimeout &amp;&amp;
                other.DefaultSidecarLogPollingInterval == cfg.DefaultSidecarLogPollingInterval &amp;&amp;
                other.DefaultStepRefConcurrencyLimit == cfg.DefaultStepRefConcurrencyLimit &amp;&amp;
                reflect.DeepEqual(other.DefaultForbiddenEnv, cfg.DefaultForbiddenEnv)</span>
}

// NewDefaultsFromMap returns a Config given a map corresponding to a ConfigMap
func NewDefaultsFromMap(cfgMap map[string]string) (*Defaults, error) <span class="cov8" title="1">{
        tc := Defaults{
                DefaultTimeoutMinutes:             DefaultTimeoutMinutes,
                DefaultServiceAccount:             DefaultServiceAccountValue,
                DefaultManagedByLabelValue:        DefaultManagedByLabelValue,
                DefaultCloudEventsSink:            DefaultCloudEventSinkValue,
                DefaultMaxMatrixCombinationsCount: DefaultMaxMatrixCombinationsCount,
                DefaultResolverType:               DefaultResolverTypeValue,
                DefaultImagePullBackOffTimeout:    DefaultImagePullBackOffTimeout,
                DefaultMaximumResolutionTimeout:   DefaultMaximumResolutionTimeout,
                DefaultSidecarLogPollingInterval:  DefaultSidecarLogPollingInterval,
                DefaultStepRefConcurrencyLimit:    DefaultStepRefConcurrencyLimit,
        }

        if defaultTimeoutMin, ok := cfgMap[defaultTimeoutMinutesKey]; ok </span><span class="cov8" title="1">{
                timeout, err := strconv.ParseInt(defaultTimeoutMin, 10, 0)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed parsing default config %q", defaultTimeoutMinutesKey)
                }</span>
                <span class="cov8" title="1">tc.DefaultTimeoutMinutes = int(timeout)</span>
        }

        <span class="cov8" title="1">if defaultServiceAccount, ok := cfgMap[defaultServiceAccountKey]; ok </span><span class="cov8" title="1">{
                tc.DefaultServiceAccount = defaultServiceAccount
        }</span>

        <span class="cov8" title="1">if defaultManagedByLabelValue, ok := cfgMap[defaultManagedByLabelValueKey]; ok </span><span class="cov8" title="1">{
                tc.DefaultManagedByLabelValue = defaultManagedByLabelValue
        }</span>

        <span class="cov8" title="1">if defaultPodTemplate, ok := cfgMap[defaultPodTemplateKey]; ok </span><span class="cov8" title="1">{
                var podTemplate pod.Template
                if err := yamlUnmarshal(defaultPodTemplate, defaultPodTemplateKey, &amp;podTemplate); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal %v", defaultPodTemplate)
                }</span>
                <span class="cov8" title="1">tc.DefaultPodTemplate = &amp;podTemplate</span>
        }

        <span class="cov8" title="1">if defaultAAPodTemplate, ok := cfgMap[defaultAAPodTemplateKey]; ok </span><span class="cov8" title="1">{
                var podTemplate pod.AffinityAssistantTemplate
                if err := yamlUnmarshal(defaultAAPodTemplate, defaultAAPodTemplateKey, &amp;podTemplate); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal %v", defaultAAPodTemplate)
                }</span>
                <span class="cov8" title="1">tc.DefaultAAPodTemplate = &amp;podTemplate</span>
        }

        <span class="cov8" title="1">if defaultCloudEventsSink, ok := cfgMap[defaultCloudEventsSinkKey]; ok </span><span class="cov0" title="0">{
                tc.DefaultCloudEventsSink = defaultCloudEventsSink
        }</span>

        <span class="cov8" title="1">if bindingYAML, ok := cfgMap[defaultTaskRunWorkspaceBinding]; ok </span><span class="cov0" title="0">{
                tc.DefaultTaskRunWorkspaceBinding = bindingYAML
        }</span>

        <span class="cov8" title="1">if defaultMaxMatrixCombinationsCount, ok := cfgMap[defaultMaxMatrixCombinationsCountKey]; ok </span><span class="cov8" title="1">{
                matrixCombinationsCount, err := strconv.ParseInt(defaultMaxMatrixCombinationsCount, 10, 0)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed parsing default config %q", defaultMaxMatrixCombinationsCountKey)
                }</span>
                <span class="cov8" title="1">tc.DefaultMaxMatrixCombinationsCount = int(matrixCombinationsCount)</span>
        }
        <span class="cov8" title="1">if defaultForbiddenEnvString, ok := cfgMap[defaultForbiddenEnv]; ok </span><span class="cov8" title="1">{
                tmpString := sets.NewString()
                fEnvs := strings.Split(defaultForbiddenEnvString, ",")
                for _, fEnv := range fEnvs </span><span class="cov8" title="1">{
                        tmpString.Insert(strings.TrimSpace(fEnv))
                }</span>
                <span class="cov8" title="1">tc.DefaultForbiddenEnv = tmpString.List()</span>
        }

        <span class="cov8" title="1">if defaultResolverType, ok := cfgMap[defaultResolverTypeKey]; ok </span><span class="cov8" title="1">{
                tc.DefaultResolverType = defaultResolverType
        }</span>

        <span class="cov8" title="1">if resourceRequirementsStringValue, ok := cfgMap[defaultContainerResourceRequirementsKey]; ok </span><span class="cov8" title="1">{
                resourceRequirementsValue := make(map[string]corev1.ResourceRequirements)
                if err := yamlUnmarshal(resourceRequirementsStringValue, defaultContainerResourceRequirementsKey, &amp;resourceRequirementsValue); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal %v", resourceRequirementsStringValue)
                }</span>
                <span class="cov8" title="1">tc.DefaultContainerResourceRequirements = resourceRequirementsValue</span>
        }

        <span class="cov8" title="1">if defaultImagePullBackOff, ok := cfgMap[defaultImagePullBackOffTimeout]; ok </span><span class="cov8" title="1">{
                timeout, err := time.ParseDuration(defaultImagePullBackOff)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed parsing default config %q", defaultImagePullBackOffTimeout)
                }</span>
                <span class="cov8" title="1">tc.DefaultImagePullBackOffTimeout = timeout</span>
        }

        <span class="cov8" title="1">if defaultMaximumResolutionTimeout, ok := cfgMap[defaultMaximumResolutionTimeout]; ok </span><span class="cov0" title="0">{
                timeout, err := time.ParseDuration(defaultMaximumResolutionTimeout)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed parsing default config %q", defaultMaximumResolutionTimeout)
                }</span>
                <span class="cov0" title="0">tc.DefaultMaximumResolutionTimeout = timeout</span>
        }

        <span class="cov8" title="1">if defaultSidecarPollingInterval, ok := cfgMap[defaultSidecarLogPollingIntervalKey]; ok </span><span class="cov8" title="1">{
                interval, err := time.ParseDuration(defaultSidecarPollingInterval)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed parsing default config %q", defaultSidecarPollingInterval)
                }</span>
                <span class="cov8" title="1">tc.DefaultSidecarLogPollingInterval = interval</span>
        }

        <span class="cov8" title="1">if DefaultStepRefConcurrencyLimit, ok := cfgMap[DefaultStepRefConcurrencyLimitKey]; ok </span><span class="cov8" title="1">{
                stepRefConcurrencyLimit, err := strconv.ParseInt(DefaultStepRefConcurrencyLimit, 10, 0)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed parsing default config %q", DefaultStepRefConcurrencyLimitKey)
                }</span>
                <span class="cov8" title="1">tc.DefaultStepRefConcurrencyLimit = int(stepRefConcurrencyLimit)</span>
        }

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

func yamlUnmarshal(s string, key string, o interface{}) error <span class="cov8" title="1">{
        b := []byte(s)
        if err := yaml.UnmarshalStrict(b, o); err != nil </span><span class="cov8" title="1">{
                log.Printf("warning: failed to decode %q: %q. Trying decode with non-strict mode", key, err)
                return yaml.Unmarshal(b, o)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewDefaultsFromConfigMap returns a Config for the given configmap
func NewDefaultsFromConfigMap(config *corev1.ConfigMap) (*Defaults, error) <span class="cov8" title="1">{
        return NewDefaultsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "errors"
        "os"
        "sort"
        "strings"

        corev1 "k8s.io/api/core/v1"
)

const (
        // FormatTektonV1 represents the "v1" events in Tekton custom format
        FormatTektonV1 EventFormat = "tektonv1"

        // DefaultSink is the default value for "sink"
        DefaultSink = ""

        formatsKey = "formats"
        sinkKey    = "sink"
)

var (
        // TODO(afrittoli): only one valid format for now, more to come
        // See TEP-0137 https://github.com/tektoncd/community/pull/1028
        validFormats = EventFormats{FormatTektonV1: struct{}{}}

        // DefaultFormat is the default value for "formats"
        DefaultFormats = EventFormats{FormatTektonV1: struct{}{}}

        // DefaultConfig holds all the default configurations for the config.
        DefaultEvents, _ = NewEventsFromMap(map[string]string{})
)

// Events holds the events configurations
// +k8s:deepcopy-gen=true
type Events struct {
        Sink    string
        Formats EventFormats
}

// EventFormat is a single event format
type EventFormat string

// EventFormats is a set of event formats
type EventFormats map[EventFormat]struct{}

// String is a string representation of an EventFormat
func (ef EventFormat) String() string <span class="cov8" title="1">{
        return string(ef)
}</span>

// IsValid returns true is the EventFormat one of the valid ones
func (ef EventFormat) IsValid() bool <span class="cov8" title="1">{
        _, ok := validFormats[ef]
        return ok
}</span>

// String is a string representation of an EventFormats
func (efs EventFormats) String() string <span class="cov8" title="1">{
        // Make an array of map keys
        keys := make([]string, len(efs))

        i := 0
        for k := range efs </span><span class="cov8" title="1">{
                keys[i] = k.String()
                i++
        }</span>
        // Sorting helps with testing
        <span class="cov8" title="1">sort.Strings(keys)

        // Build a comma separated list
        return strings.Join(keys, ",")</span>
}

// Equals defines identity between EventFormats
func (efs EventFormats) Equals(other EventFormats) bool <span class="cov8" title="1">{
        if len(efs) != len(other) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for key := range efs </span><span class="cov8" title="1">{
                if _, ok := other[key]; !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ParseEventFormats converts a comma separated list into a EventFormats set
func ParseEventFormats(formats string) (EventFormats, error) <span class="cov8" title="1">{
        // An empty string is not a valid configuration
        if formats == "" </span><span class="cov8" title="1">{
                return EventFormats{}, errors.New("formats cannot be empty")
        }</span>
        <span class="cov8" title="1">stringFormats := strings.Split(formats, ",")
        var eventFormats EventFormats = make(map[EventFormat]struct{}, len(stringFormats))
        for _, format := range stringFormats </span><span class="cov8" title="1">{
                if !EventFormat(format).IsValid() </span><span class="cov8" title="1">{
                        return EventFormats{}, errors.New("invalid format: " + format)
                }</span>
                // If already in the map (duplicate), fail
                <span class="cov8" title="1">if _, ok := eventFormats[EventFormat(format)]; ok </span><span class="cov8" title="1">{
                        return EventFormats{}, errors.New("duplicate format: " + format)
                }</span>
                <span class="cov8" title="1">eventFormats[EventFormat(format)] = struct{}{}</span>
        }
        <span class="cov8" title="1">return eventFormats, nil</span>
}

// GetEventsConfigName returns the name of the configmap containing all
// feature flags.
func GetEventsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_EVENTS_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-events"</span>
}

// NewEventsFromMap returns a Config given a map corresponding to a ConfigMap
func NewEventsFromMap(cfgMap map[string]string) (*Events, error) <span class="cov8" title="1">{
        // for any string field with no extra validation
        setField := func(key string, defaultValue string, field *string) </span><span class="cov8" title="1">{
                if cfg, ok := cfgMap[key]; ok </span><span class="cov8" title="1">{
                        *field = cfg
                }</span> else<span class="cov8" title="1"> {
                        *field = defaultValue
                }</span>
        }

        <span class="cov8" title="1">events := Events{}
        err := setFormats(cfgMap, DefaultFormats, &amp;events.Formats)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">setField(sinkKey, DefaultSink, &amp;events.Sink)
        return &amp;events, nil</span>
}

func setFormats(cfgMap map[string]string, defaultValue EventFormats, field *EventFormats) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[formatsKey]; ok </span><span class="cov8" title="1">{
                v, err := ParseEventFormats(cfg)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">value = v</span>
        }
        <span class="cov8" title="1">*field = value
        return nil</span>
}

// NewEventsFromConfigMap returns a Config for the given configmap
func NewEventsFromConfigMap(config *corev1.ConfigMap) (*Events, error) <span class="cov8" title="1">{
        return NewEventsFromMap(config.Data)
}</span>

// Equals returns true if two Configs are identical
func (cfg *Events) Equals(other *Events) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return other.Sink == cfg.Sink &amp;&amp;
                other.Formats.Equals(cfg.Formats)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
)

const (
        // StableAPIFields is the value used for API-driven features of stable stability level.
        StableAPIFields = "stable"
        // AlphaAPIFields is the value used for API-driven features of alpha stability level.
        AlphaAPIFields = "alpha"
        // BetaAPIFields is the value used for API-driven features of beta stability level.
        BetaAPIFields = "beta"
        // Features of "alpha" stability level are disabled by default
        DefaultAlphaFeatureEnabled = false
        // Features of "beta" stability level are disabled by default
        DefaultBetaFeatureEnabled = false
        // Features of "stable" stability level are enabled by default
        DefaultStableFeatureEnabled = true
        // FailNoMatchPolicy is the value used for "trusted-resources-verification-no-match-policy" to fail TaskRun or PipelineRun
        // when no matching policies are found
        FailNoMatchPolicy = "fail"
        // WarnNoMatchPolicy is the value used for "trusted-resources-verification-no-match-policy" to log warning and skip verification
        // when no matching policies are found
        WarnNoMatchPolicy = "warn"
        // IgnoreNoMatchPolicy is the value used for "trusted-resources-verification-no-match-policy" to skip verification
        // when no matching policies are found
        IgnoreNoMatchPolicy = "ignore"
        // CoscheduleWorkspaces is the value used for "coschedule" to coschedule PipelineRun Pods sharing the same PVC workspaces to the same node
        CoscheduleWorkspaces = "workspaces"
        // CoschedulePipelineRuns is the value used for "coschedule" to coschedule all PipelineRun Pods to the same node
        CoschedulePipelineRuns = "pipelineruns"
        // CoscheduleIsolatePipelineRun is the value used for "coschedule" to coschedule all PipelineRun Pods to the same node, and only allows one PipelineRun to run on a node at a time
        CoscheduleIsolatePipelineRun = "isolate-pipelinerun"
        // CoscheduleDisabled is the value used for "coschedule" to disabled PipelineRun Pods coschedule
        CoscheduleDisabled = "disabled"
        // ResultExtractionMethodTerminationMessage is the value used for "results-from" as a way to extract results from tasks using kubernetes termination message.
        ResultExtractionMethodTerminationMessage = "termination-message"
        // ResultExtractionMethodSidecarLogs is the value used for "results-from" as a way to extract results from tasks using sidecar logs.
        ResultExtractionMethodSidecarLogs = "sidecar-logs"
        // DefaultDisableCredsInit is the default value for "disable-creds-init".
        DefaultDisableCredsInit = false
        // DefaultRunningInEnvWithInjectedSidecars is the default value for "running-in-environment-with-injected-sidecars".
        DefaultRunningInEnvWithInjectedSidecars = true
        // DefaultAwaitSidecarReadiness is the default value for "await-sidecar-readiness".
        DefaultAwaitSidecarReadiness = true
        // DefaultDisableInlineSpec is the default value of "disable-inline-spec"
        DefaultDisableInlineSpec = ""
        // DefaultRequireGitSSHSecretKnownHosts is the default value for "require-git-ssh-secret-known-hosts".
        DefaultRequireGitSSHSecretKnownHosts = false
        // DefaultEnableTektonOciBundles is the default value for "enable-tekton-oci-bundles".
        DefaultEnableTektonOciBundles = false
        // DefaultEnableAPIFields is the default value for "enable-api-fields".
        DefaultEnableAPIFields = BetaAPIFields
        // DefaultSendCloudEventsForRuns is the default value for "send-cloudevents-for-runs".
        DefaultSendCloudEventsForRuns = false
        // EnforceNonfalsifiabilityWithSpire is the value used for  "enable-nonfalsifiability" when SPIRE is used to enable non-falsifiability.
        EnforceNonfalsifiabilityWithSpire = "spire"
        // EnforceNonfalsifiabilityNone is the value used for  "enable-nonfalsifiability" when non-falsifiability is not enabled.
        EnforceNonfalsifiabilityNone = "none"
        // DefaultEnforceNonfalsifiability is the default value for "enforce-nonfalsifiability".
        DefaultEnforceNonfalsifiability = EnforceNonfalsifiabilityNone
        // DefaultNoMatchPolicyConfig is the default value for "trusted-resources-verification-no-match-policy".
        DefaultNoMatchPolicyConfig = IgnoreNoMatchPolicy
        // DefaultEnableProvenanceInStatus is the default value for "enable-provenance-status".
        DefaultEnableProvenanceInStatus = true
        // DefaultResultExtractionMethod is the default value for ResultExtractionMethod
        DefaultResultExtractionMethod = ResultExtractionMethodTerminationMessage
        // DefaultMaxResultSize is the default value in bytes for the size of a result
        DefaultMaxResultSize = 4096
        // DefaultSetSecurityContext is the default value for "set-security-context"
        DefaultSetSecurityContext = false
        // DefaultSetSecurityContextReadOnlyRootFilesystem is the default value for "set-security-context-read-only-root-filesystem"
        DefaultSetSecurityContextReadOnlyRootFilesystem = false
        // DefaultCoschedule is the default value for coschedule
        DefaultCoschedule = CoscheduleWorkspaces
        // KeepPodOnCancel is the flag used to enable cancelling a pod using the entrypoint, and keep pod on cancel
        KeepPodOnCancel = "keep-pod-on-cancel"
        // EnableCELInWhenExpression is the flag to enabled CEL in WhenExpression
        EnableCELInWhenExpression = "enable-cel-in-whenexpression"
        // EnableArtifacts is the flag to enable the use of Artifacts in Steps
        EnableArtifacts = "enable-artifacts"
        // EnableParamEnum is the flag to enabled enum in params
        EnableParamEnum = "enable-param-enum"
        // EnableConciseResolverSyntax is the flag to enable concise resolver syntax
        EnableConciseResolverSyntax = "enable-concise-resolver-syntax"
        // EnableKubernetesSidecar is the flag to enable kubernetes sidecar support
        EnableKubernetesSidecar = "enable-kubernetes-sidecar"
        // DefaultEnableKubernetesSidecar is the default value for EnableKubernetesSidecar
        DefaultEnableKubernetesSidecar = false
        // EnableWaitExponentialBackoff is the flag to enable exponential backoff strategy
        EnableWaitExponentialBackoff = "enable-wait-exponential-backoff"
        // DefaultEnableWaitExponentialBackoff is the default value for EnableWaitExponentialBackoff
        DefaultEnableWaitExponentialBackoff = false

        // EnableStepActions is the flag to enable step actions (no-op since it's stable)
        EnableStepActions = "enable-step-actions"

        // DisableInlineSpec is the flag to disable embedded spec
        // in Taskrun or Pipelinerun
        DisableInlineSpec = "disable-inline-spec"

        disableCredsInitKey                 = "disable-creds-init"
        runningInEnvWithInjectedSidecarsKey = "running-in-environment-with-injected-sidecars"
        awaitSidecarReadinessKey            = "await-sidecar-readiness"
        requireGitSSHSecretKnownHostsKey    = "require-git-ssh-secret-known-hosts" //nolint:gosec
        // enableTektonOCIBundles              = "enable-tekton-oci-bundles"

        enableAPIFields                             = "enable-api-fields"
        sendCloudEventsForRuns                      = "send-cloudevents-for-runs"
        enforceNonfalsifiability                    = "enforce-nonfalsifiability"
        verificationNoMatchPolicy                   = "trusted-resources-verification-no-match-policy"
        enableProvenanceInStatus                    = "enable-provenance-in-status"
        resultExtractionMethod                      = "results-from"
        maxResultSize                               = "max-result-size"
        setSecurityContextKey                       = "set-security-context"
        setSecurityContextReadOnlyRootFilesystemKey = "set-security-context-read-only-root-filesystem"
        coscheduleKey                               = "coschedule"
)

// DefaultFeatureFlags holds all the default configurations for the feature flags configmap.
var (
        DefaultFeatureFlags, _ = NewFeatureFlagsFromMap(map[string]string{})

        // DefaultEnableKeepPodOnCancel is the default PerFeatureFlag value for "keep-pod-on-cancel"
        DefaultEnableKeepPodOnCancel = PerFeatureFlag{
                Name:      KeepPodOnCancel,
                Stability: BetaAPIFields,
                Enabled:   DefaultBetaFeatureEnabled,
        }

        // DefaultEnableCELInWhenExpression is the default PerFeatureFlag value for EnableCELInWhenExpression
        DefaultEnableCELInWhenExpression = PerFeatureFlag{
                Name:      EnableCELInWhenExpression,
                Stability: AlphaAPIFields,
                Enabled:   DefaultAlphaFeatureEnabled,
        }

        // DefaultEnableArtifacts is the default PerFeatureFlag value for EnableArtifacts
        DefaultEnableArtifacts = PerFeatureFlag{
                Name:      EnableArtifacts,
                Stability: AlphaAPIFields,
                Enabled:   DefaultAlphaFeatureEnabled,
        }

        // DefaultEnableParamEnum is the default PerFeatureFlag value for EnableParamEnum
        DefaultEnableParamEnum = PerFeatureFlag{
                Name:      EnableParamEnum,
                Stability: AlphaAPIFields,
                Enabled:   DefaultAlphaFeatureEnabled,
        }

        // DefaultEnableConciseResolverSyntax is the default PerFeatureFlag value for EnableConciseResolverSyntax
        DefaultEnableConciseResolverSyntax = PerFeatureFlag{
                Name:      EnableConciseResolverSyntax,
                Stability: AlphaAPIFields,
                Enabled:   DefaultAlphaFeatureEnabled,
        }
)

// FeatureFlags holds the features configurations
// +k8s:deepcopy-gen=true
type FeatureFlags struct {
        DisableCredsInit                 bool `json:"disableCredsInit,omitempty"`
        RunningInEnvWithInjectedSidecars bool `json:"runningInEnvWithInjectedSidecars,omitempty"`
        RequireGitSSHSecretKnownHosts    bool `json:"requireGitSSHSecretKnownHosts,omitempty"`

        EnableAPIFields          string `json:"enableAPIFields,omitempty"`
        SendCloudEventsForRuns   bool   `json:"sendCloudEventsForRuns,omitempty"`
        AwaitSidecarReadiness    bool   `json:"awaitSidecarReadiness,omitempty"`
        EnforceNonfalsifiability string `json:"enforceNonfalsifiability,omitempty"`
        EnableKeepPodOnCancel    bool   `json:"enableKeepPodOnCancel,omitempty"`
        // VerificationNoMatchPolicy is the feature flag for "trusted-resources-verification-no-match-policy"
        // VerificationNoMatchPolicy can be set to "ignore", "warn" and "fail" values.
        // ignore: skip trusted resources verification when no matching verification policies found
        // warn: skip trusted resources verification when no matching verification policies found and log a warning
        // fail: fail the taskrun or pipelines run if no matching verification policies found
        VerificationNoMatchPolicy                string `json:"verificationNoMatchPolicy,omitempty"`
        EnableProvenanceInStatus                 bool   `json:"enableProvenanceInStatus,omitempty"`
        ResultExtractionMethod                   string `json:"resultExtractionMethod,omitempty"`
        MaxResultSize                            int    `json:"maxResultSize,omitempty"`
        SetSecurityContext                       bool   `json:"setSecurityContext,omitempty"`
        SetSecurityContextReadOnlyRootFilesystem bool   `json:"setSecurityContextReadOnlyRootFilesystem,omitempty"`
        Coschedule                               string `json:"coschedule,omitempty"`
        EnableCELInWhenExpression                bool   `json:"enableCELInWhenExpression,omitempty"`
        // EnableStepActions is a no-op flag since StepActions are stable
        EnableStepActions            bool   `json:"enableStepActions,omitempty"`
        EnableParamEnum              bool   `json:"enableParamEnum,omitempty"`
        EnableArtifacts              bool   `json:"enableArtifacts,omitempty"`
        DisableInlineSpec            string `json:"disableInlineSpec,omitempty"`
        EnableConciseResolverSyntax  bool   `json:"enableConciseResolverSyntax,omitempty"`
        EnableKubernetesSidecar      bool   `json:"enableKubernetesSidecar,omitempty"`
        EnableWaitExponentialBackoff bool   `json:"enableWaitExponentialBackoff,omitempty"`
}

// GetFeatureFlagsConfigName returns the name of the configmap containing all
// feature flags.
func GetFeatureFlagsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_FEATURE_FLAGS_NAME"); e != "" </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">return "feature-flags"</span>
}

// NewFeatureFlagsFromMap returns a Config given a map corresponding to a ConfigMap
func NewFeatureFlagsFromMap(cfgMap map[string]string) (*FeatureFlags, error) <span class="cov8" title="1">{
        setPerFeatureFlag := func(key string, defaultValue PerFeatureFlag, feature *bool) error </span><span class="cov8" title="1">{
                if cfg, ok := cfgMap[key]; ok </span><span class="cov8" title="1">{
                        value, err := strconv.ParseBool(cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed parsing feature flags config %q: %w for feature %s", cfg, err, key)
                        }</span>
                        <span class="cov8" title="1">*feature = value
                        return nil</span>
                }
                <span class="cov8" title="1">*feature = defaultValue.Enabled
                return nil</span>
        }

        <span class="cov8" title="1">setFeature := func(key string, defaultValue bool, feature *bool) error </span><span class="cov8" title="1">{
                if cfg, ok := cfgMap[key]; ok </span><span class="cov8" title="1">{
                        value, err := strconv.ParseBool(cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed parsing feature flags config %q: %w", cfg, err)
                        }</span>
                        <span class="cov8" title="1">*feature = value
                        return nil</span>
                }
                <span class="cov8" title="1">*feature = defaultValue
                return nil</span>
        }

        <span class="cov8" title="1">tc := FeatureFlags{}
        if err := setFeature(disableCredsInitKey, DefaultDisableCredsInit, &amp;tc.DisableCredsInit); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(runningInEnvWithInjectedSidecarsKey, DefaultRunningInEnvWithInjectedSidecars, &amp;tc.RunningInEnvWithInjectedSidecars); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(awaitSidecarReadinessKey, DefaultAwaitSidecarReadiness, &amp;tc.AwaitSidecarReadiness); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(requireGitSSHSecretKnownHostsKey, DefaultRequireGitSSHSecretKnownHosts, &amp;tc.RequireGitSSHSecretKnownHosts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setEnabledAPIFields(cfgMap, DefaultEnableAPIFields, &amp;tc.EnableAPIFields); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(sendCloudEventsForRuns, DefaultSendCloudEventsForRuns, &amp;tc.SendCloudEventsForRuns); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setVerificationNoMatchPolicy(cfgMap, DefaultNoMatchPolicyConfig, &amp;tc.VerificationNoMatchPolicy); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(enableProvenanceInStatus, DefaultEnableProvenanceInStatus, &amp;tc.EnableProvenanceInStatus); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setResultExtractionMethod(cfgMap, DefaultResultExtractionMethod, &amp;tc.ResultExtractionMethod); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setMaxResultSize(cfgMap, DefaultMaxResultSize, &amp;tc.MaxResultSize); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setPerFeatureFlag(KeepPodOnCancel, DefaultEnableKeepPodOnCancel, &amp;tc.EnableKeepPodOnCancel); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setEnforceNonFalsifiability(cfgMap, &amp;tc.EnforceNonfalsifiability); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(setSecurityContextKey, DefaultSetSecurityContext, &amp;tc.SetSecurityContext); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(setSecurityContextReadOnlyRootFilesystemKey, DefaultSetSecurityContextReadOnlyRootFilesystem, &amp;tc.SetSecurityContextReadOnlyRootFilesystem); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setCoschedule(cfgMap, DefaultCoschedule, &amp;tc.Coschedule); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setPerFeatureFlag(EnableCELInWhenExpression, DefaultEnableCELInWhenExpression, &amp;tc.EnableCELInWhenExpression); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setPerFeatureFlag(EnableParamEnum, DefaultEnableParamEnum, &amp;tc.EnableParamEnum); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setPerFeatureFlag(EnableArtifacts, DefaultEnableArtifacts, &amp;tc.EnableArtifacts); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := setFeatureInlineSpec(cfgMap, DisableInlineSpec, DefaultDisableInlineSpec, &amp;tc.DisableInlineSpec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setPerFeatureFlag(EnableConciseResolverSyntax, DefaultEnableConciseResolverSyntax, &amp;tc.EnableConciseResolverSyntax); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableKubernetesSidecar, DefaultEnableKubernetesSidecar, &amp;tc.EnableKubernetesSidecar); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableWaitExponentialBackoff, DefaultEnableWaitExponentialBackoff, &amp;tc.EnableWaitExponentialBackoff); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// setEnabledAPIFields sets the "enable-api-fields" flag based on the content of a given map.
// If the feature gate is invalid or missing then an error is returned.
func setEnabledAPIFields(cfgMap map[string]string, defaultValue string, feature *string) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[enableAPIFields]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>
        <span class="cov8" title="1">switch value </span>{
        case AlphaAPIFields, BetaAPIFields, StableAPIFields:<span class="cov8" title="1">
                *feature = value</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid value for feature flag %q: %q", enableAPIFields, value)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// setCoschedule sets the "coschedule" flag based on the content of a given map.
func setCoschedule(cfgMap map[string]string, defaultValue string, feature *string) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[coscheduleKey]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>

        <span class="cov8" title="1">switch value </span>{
        case CoscheduleDisabled, CoscheduleWorkspaces, CoschedulePipelineRuns, CoscheduleIsolatePipelineRun:<span class="cov8" title="1">
                *feature = value</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid value for feature flag %q: %q", coscheduleKey, value)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// setEnforceNonFalsifiability sets the "enforce-nonfalsifiability" flag based on the content of a given map.
// If the feature gate is invalid, then an error is returned.
func setEnforceNonFalsifiability(cfgMap map[string]string, feature *string) error <span class="cov8" title="1">{
        value := DefaultEnforceNonfalsifiability
        if cfg, ok := cfgMap[enforceNonfalsifiability]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>

        // validate that "enforce-nonfalsifiability" is set to a valid value
        <span class="cov8" title="1">switch value </span>{
        case EnforceNonfalsifiabilityNone, EnforceNonfalsifiabilityWithSpire:<span class="cov8" title="1">
                *feature = value
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid value for feature flag %q: %q", enforceNonfalsifiability, value)</span>
        }
}

func setFeatureInlineSpec(cfgMap map[string]string, key string, defaultValue string, feature *string) error <span class="cov8" title="1">{
        if cfg, ok := cfgMap[key]; ok </span><span class="cov8" title="1">{
                *feature = cfg
                return nil
        }</span>
        <span class="cov8" title="1">*feature = strings.ReplaceAll(defaultValue, " ", "")
        return nil</span>
}

// setResultExtractionMethod sets the "results-from" flag based on the content of a given map.
// If the feature gate is invalid or missing then an error is returned.
func setResultExtractionMethod(cfgMap map[string]string, defaultValue string, feature *string) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[resultExtractionMethod]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>
        <span class="cov8" title="1">switch value </span>{
        case ResultExtractionMethodTerminationMessage, ResultExtractionMethodSidecarLogs:<span class="cov8" title="1">
                *feature = value</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid value for feature flag %q: %q", resultExtractionMethod, value)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// setMaxResultSize sets the "max-result-size" flag based on the content of a given map.
// If the feature gate is invalid or missing then an error is returned.
func setMaxResultSize(cfgMap map[string]string, defaultValue int, feature *int) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[maxResultSize]; ok </span><span class="cov8" title="1">{
                v, err := strconv.Atoi(cfg)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">value = v</span>
        }
        // if max limit is &gt; 1.5 MB (CRD limit).
        <span class="cov8" title="1">if value &gt;= 1572864 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid value for feature flag %q: %q. This is exceeding the CRD limit", resultExtractionMethod, strconv.Itoa(value))
        }</span>
        <span class="cov8" title="1">*feature = value
        return nil</span>
}

// setVerificationNoMatchPolicy sets the "trusted-resources-verification-no-match-policy" flag based on the content of a given map.
// If the value is invalid or missing then an error is returned.
func setVerificationNoMatchPolicy(cfgMap map[string]string, defaultValue string, feature *string) error <span class="cov8" title="1">{
        value := defaultValue
        if cfg, ok := cfgMap[verificationNoMatchPolicy]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>
        <span class="cov8" title="1">switch value </span>{
        case FailNoMatchPolicy, WarnNoMatchPolicy, IgnoreNoMatchPolicy:<span class="cov8" title="1">
                *feature = value</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid value for feature flag %q: %q", verificationNoMatchPolicy, value)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type PerFeatureFlag struct {
        // Name of the feature flag
        Name string
        // Stability level of the feature, one of StableAPIFields, BetaAPIFields or AlphaAPIFields
        Stability string
        // Enabled is whether the feature is turned on
        Enabled bool
        // Deprecated indicates whether the feature is deprecated
        // +optional
        //nolint:gocritic
        Deprecated bool
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//go:build !disable_tls

/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

// ValidateEnabledAPIFields checks that the enable-api-fields feature gate is set
// to a version at most as stable as wantVersion, if not, returns an error stating which feature
// is dependent on the version and what the current version actually is.
func ValidateEnabledAPIFields(ctx context.Context, featureName string, wantVersion string) *apis.FieldError <span class="cov8" title="1">{
        currentVersion := FromContextOrDefaults(ctx).FeatureFlags.EnableAPIFields
        var errs *apis.FieldError
        message := `%s requires "enable-api-fields" feature gate to be %s but it is %q`
        switch wantVersion </span>{
        case StableAPIFields:<span class="cov8" title="1"></span>
                // If the feature is stable, it doesn't matter what the current version is
        case BetaAPIFields:<span class="cov8" title="1">
                // If the feature requires "beta" fields to be enabled, the current version may be "beta" or "alpha"
                if currentVersion != BetaAPIFields &amp;&amp; currentVersion != AlphaAPIFields </span><span class="cov8" title="1">{
                        message = fmt.Sprintf(message, featureName, fmt.Sprintf("%q or %q", AlphaAPIFields, BetaAPIFields), currentVersion)
                        errs = apis.ErrGeneric(message)
                }</span>
        case AlphaAPIFields:<span class="cov8" title="1">
                // If the feature requires "alpha" fields to be enabled, the current version must be "alpha"
                if currentVersion != wantVersion </span><span class="cov8" title="1">{
                        message = fmt.Sprintf(message, featureName, fmt.Sprintf("%q", AlphaAPIFields), currentVersion)
                        errs = apis.ErrGeneric(message)
                }</span>
        default:<span class="cov8" title="1">
                errs = apis.ErrGeneric("invalid wantVersion %s, must be one of (%s, %s, %s)", wantVersion, AlphaAPIFields, BetaAPIFields, StableAPIFields)</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        corev1 "k8s.io/api/core/v1"
)

const (
        // metricsTaskrunLevel determines to what level to aggregate metrics
        // for taskrun
        metricsTaskrunLevelKey = "metrics.taskrun.level"

        // metricsPipelinerunLevel determines to what level to aggregate metrics
        // for pipelinerun
        metricsPipelinerunLevelKey = "metrics.pipelinerun.level"
        // metricsRunningPipelinerunLevelKey determines to what level to aggregate metrics
        // for running pipelineruns
        metricsRunningPipelinerunLevelKey = "metrics.running-pipelinerun.level"
        // metricsDurationTaskrunType determines what type of
        // metrics to use for aggregating duration for taskrun
        metricsDurationTaskrunType = "metrics.taskrun.duration-type"
        // metricsDurationPipelinerunType determines what type of
        // metrics to use for aggregating duration for pipelinerun
        metricsDurationPipelinerunType = "metrics.pipelinerun.duration-type"

        // countWithReasonKey sets if the reason label should be included on count metrics
        countWithReasonKey = "metrics.count.enable-reason"

        // throttledWithNamespaceKey sets if the namespace label should be included on the taskrun throttled metrics
        throttledWithNamespaceKey = "metrics.taskrun.throttle.enable-namespace"

        // DefaultTaskrunLevel determines to what level to aggregate metrics
        // when it isn't specified in configmap
        DefaultTaskrunLevel = TaskrunLevelAtTask
        // TaskrunLevelAtTaskrun specify that aggregation will be done at
        // taskrun level
        TaskrunLevelAtTaskrun = "taskrun"
        // TaskrunLevelAtTask specify that aggregation will be done at task level
        TaskrunLevelAtTask = "task"
        // TaskrunLevelAtNS specify that aggregation will be done at namespace level
        TaskrunLevelAtNS = "namespace"
        // DefaultPipelinerunLevel determines to what level to aggregate metrics
        // when it isn't specified in configmap
        DefaultPipelinerunLevel = PipelinerunLevelAtPipeline
        // DefaultRunningPipelinerunLevel determines to what level to aggregate metrics
        // when it isn't specified in configmap
        DefaultRunningPipelinerunLevel = ""
        // PipelinerunLevelAtPipelinerun specify that aggregation will be done at
        // pipelinerun level
        PipelinerunLevelAtPipelinerun = "pipelinerun"
        // PipelinerunLevelAtPipeline specify that aggregation will be done at
        // pipeline level
        PipelinerunLevelAtPipeline = "pipeline"
        // PipelinerunLevelAtNS specify that aggregation will be done at
        // namespace level
        PipelinerunLevelAtNS = "namespace"

        // DefaultDurationTaskrunType determines what type
        // of metrics to use when we don't specify one in
        // configmap
        DefaultDurationTaskrunType = "histogram"
        // DurationTaskrunTypeHistogram specify that histogram
        // type metrics need to be use for Duration of Taskrun
        DurationTaskrunTypeHistogram = "histogram"
        // DurationTaskrunTypeLastValue specify that lastValue or
        // gauge type metrics need to be use for Duration of Taskrun
        DurationTaskrunTypeLastValue = "lastvalue"

        // DefaultDurationPipelinerunType determines what type
        // of metrics to use when we don't specify one in
        // configmap
        DefaultDurationPipelinerunType = "histogram"
        // DurationPipelinerunTypeHistogram specify that histogram
        // type metrics need to be use for Duration of Pipelinerun
        DurationPipelinerunTypeHistogram = "histogram"
        // DurationPipelinerunTypeLastValue specify that lastValue or
        // gauge type metrics need to be use for Duration of Pipelinerun
        DurationPipelinerunTypeLastValue = "lastvalue"
)

// DefaultMetrics holds all the default configurations for the metrics.
var DefaultMetrics, _ = newMetricsFromMap(map[string]string{})

// Metrics holds the configurations for the metrics
// +k8s:deepcopy-gen=true
type Metrics struct {
        TaskrunLevel            string
        PipelinerunLevel        string
        RunningPipelinerunLevel string
        DurationTaskrunType     string
        DurationPipelinerunType string
        CountWithReason         bool
        ThrottleWithNamespace   bool
}

// Equals returns true if two Configs are identical
func (cfg *Metrics) Equals(other *Metrics) bool <span class="cov0" title="0">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return other.TaskrunLevel == cfg.TaskrunLevel &amp;&amp;
                other.PipelinerunLevel == cfg.PipelinerunLevel &amp;&amp;
                other.DurationTaskrunType == cfg.DurationTaskrunType &amp;&amp;
                other.DurationPipelinerunType == cfg.DurationPipelinerunType &amp;&amp;
                other.CountWithReason == cfg.CountWithReason</span>
}

// newMetricsFromMap returns a Config given a map corresponding to a ConfigMap
func newMetricsFromMap(cfgMap map[string]string) (*Metrics, error) <span class="cov8" title="1">{
        tc := Metrics{
                TaskrunLevel:            DefaultTaskrunLevel,
                PipelinerunLevel:        DefaultPipelinerunLevel,
                RunningPipelinerunLevel: DefaultRunningPipelinerunLevel,
                DurationTaskrunType:     DefaultDurationTaskrunType,
                DurationPipelinerunType: DefaultDurationPipelinerunType,
                CountWithReason:         false,
                ThrottleWithNamespace:   false,
        }

        if taskrunLevel, ok := cfgMap[metricsTaskrunLevelKey]; ok </span><span class="cov8" title="1">{
                tc.TaskrunLevel = taskrunLevel
        }</span>

        <span class="cov8" title="1">if pipelinerunLevel, ok := cfgMap[metricsPipelinerunLevelKey]; ok </span><span class="cov8" title="1">{
                tc.PipelinerunLevel = pipelinerunLevel
        }</span>
        <span class="cov8" title="1">if runningPipelinerunLevel, ok := cfgMap[metricsRunningPipelinerunLevelKey]; ok </span><span class="cov8" title="1">{
                tc.RunningPipelinerunLevel = runningPipelinerunLevel
        }</span>
        <span class="cov8" title="1">if durationTaskrun, ok := cfgMap[metricsDurationTaskrunType]; ok </span><span class="cov8" title="1">{
                tc.DurationTaskrunType = durationTaskrun
        }</span>
        <span class="cov8" title="1">if durationPipelinerun, ok := cfgMap[metricsDurationPipelinerunType]; ok </span><span class="cov8" title="1">{
                tc.DurationPipelinerunType = durationPipelinerun
        }</span>

        <span class="cov8" title="1">if countWithReason, ok := cfgMap[countWithReasonKey]; ok &amp;&amp; countWithReason != "false" </span><span class="cov8" title="1">{
                tc.CountWithReason = true
        }</span>

        <span class="cov8" title="1">if throttleWithNamespace, ok := cfgMap[throttledWithNamespaceKey]; ok &amp;&amp; throttleWithNamespace != "false" </span><span class="cov8" title="1">{
                tc.ThrottleWithNamespace = true
        }</span>

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// NewMetricsFromConfigMap returns a Config for the given configmap
func NewMetricsFromConfigMap(config *corev1.ConfigMap) (*Metrics, error) <span class="cov8" title="1">{
        return newMetricsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">//go:build !disable_tls

package config

import (
        "context"

        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/metrics"
)

// GetMetricsConfigName returns the name of the configmap containing all
// customizations for the storage bucket.
func GetMetricsConfigName() string <span class="cov8" title="1">{
        return metrics.ConfigMapName()
}</span>

// NewFeatureFlagsFromConfigMap returns a Config for the given configmap
func NewFeatureFlagsFromConfigMap(config *corev1.ConfigMap) (*FeatureFlags, error) <span class="cov8" title="1">{
        return NewFeatureFlagsFromMap(config.Data)
}</span>

// GetVerificationNoMatchPolicy returns the "trusted-resources-verification-no-match-policy" value
func GetVerificationNoMatchPolicy(ctx context.Context) string <span class="cov8" title="1">{
        return FromContextOrDefaults(ctx).FeatureFlags.VerificationNoMatchPolicy
}</span>

// IsSpireEnabled checks if non-falsifiable provenance is enforced through SPIRE
func IsSpireEnabled(ctx context.Context) bool <span class="cov8" title="1">{
        return FromContextOrDefaults(ctx).FeatureFlags.EnforceNonfalsifiability == EnforceNonfalsifiabilityWithSpire
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolver

import (
        "fmt"
        "os"
        "strconv"

        corev1 "k8s.io/api/core/v1"
)

const (
        // DefaultEnableGitResolver is the default value for "enable-git-resolver".
        DefaultEnableGitResolver = true
        // DefaultEnableHubResolver is the default value for "enable-hub-resolver".
        DefaultEnableHubResolver = true
        // DefaultEnableBundlesResolver is the default value for "enable-bundles-resolver".
        DefaultEnableBundlesResolver = true
        // DefaultEnableClusterResolver is the default value for "enable-cluster-resolver".
        DefaultEnableClusterResolver = true
        // DefaultEnableHttpResolver is the default value for "enable-http-resolver".
        DefaultEnableHttpResolver = true

        // EnableGitResolver is the flag used to enable the git remote resolver
        EnableGitResolver = "enable-git-resolver"
        // EnableHubResolver is the flag used to enable the hub remote resolver
        EnableHubResolver = "enable-hub-resolver"
        // EnableBundlesResolver is the flag used to enable the bundle remote resolver
        EnableBundlesResolver = "enable-bundles-resolver"
        // EnableClusterResolver is the flag used to enable the cluster remote resolver
        EnableClusterResolver = "enable-cluster-resolver"
        // EnableHttpResolver is the flag used to enable the http remote resolver
        EnableHttpResolver = "enable-http-resolver"
)

// FeatureFlags holds the features configurations
// +k8s:deepcopy-gen=true
type FeatureFlags struct {
        EnableGitResolver     bool
        EnableHubResolver     bool
        EnableBundleResolver  bool
        EnableClusterResolver bool
        EnableHttpResolver    bool
}

// GetFeatureFlagsConfigName returns the name of the configmap containing all
// feature flags.
func GetFeatureFlagsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_RESOLVERS_FEATURE_FLAGS_NAME"); e != "" </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">return "resolvers-feature-flags"</span>
}

// NewFeatureFlagsFromMap returns a Config given a map corresponding to a ConfigMap
func NewFeatureFlagsFromMap(cfgMap map[string]string) (*FeatureFlags, error) <span class="cov8" title="1">{
        setFeature := func(key string, defaultValue bool, feature *bool) error </span><span class="cov8" title="1">{
                if cfg, ok := cfgMap[key]; ok </span><span class="cov8" title="1">{
                        value, err := strconv.ParseBool(cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed parsing feature flags config %q: %w", cfg, err)
                        }</span>
                        <span class="cov8" title="1">*feature = value
                        return nil</span>
                }
                <span class="cov8" title="1">*feature = defaultValue
                return nil</span>
        }

        <span class="cov8" title="1">tc := FeatureFlags{}
        if err := setFeature(EnableGitResolver, DefaultEnableGitResolver, &amp;tc.EnableGitResolver); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableHubResolver, DefaultEnableHubResolver, &amp;tc.EnableHubResolver); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableBundlesResolver, DefaultEnableBundlesResolver, &amp;tc.EnableBundleResolver); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableClusterResolver, DefaultEnableClusterResolver, &amp;tc.EnableClusterResolver); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := setFeature(EnableHttpResolver, DefaultEnableHttpResolver, &amp;tc.EnableHttpResolver); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// NewFeatureFlagsFromConfigMap returns a Config for the given configmap
func NewFeatureFlagsFromConfigMap(config *corev1.ConfigMap) (*FeatureFlags, error) <span class="cov8" title="1">{
        return NewFeatureFlagsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:build !disable_tls

/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolver

import (
        "context"

        "knative.dev/pkg/configmap"
)

type cfgKey struct{}

// Config holds the collection of configurations that we attach to contexts.
// +k8s:deepcopy-gen=false
type Config struct {
        FeatureFlags *FeatureFlags
}

// ResolversNamespace takes the pipelines namespace and appends "-resolvers" to it.
func ResolversNamespace(baseNS string) string <span class="cov0" title="0">{
        return baseNS + "-resolvers"
}</span>

// FromContext extracts a Config from the provided context.
func FromContext(ctx context.Context) *Config <span class="cov8" title="1">{
        x, ok := ctx.Value(cfgKey{}).(*Config)
        if ok </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FromContextOrDefaults is like FromContext, but when no Config is attached it
// returns a Config populated with the defaults for each of the Config fields.
func FromContextOrDefaults(ctx context.Context) *Config <span class="cov0" title="0">{
        if cfg := FromContext(ctx); cfg != nil </span><span class="cov0" title="0">{
                return cfg
        }</span>
        <span class="cov0" title="0">featureFlags, _ := NewFeatureFlagsFromMap(map[string]string{})
        return &amp;Config{
                FeatureFlags: featureFlags,
        }</span>
}

// ToContext attaches the provided Config to the provided context, returning the
// new context with the Config attached.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.
// +k8s:deepcopy-gen=false
type Store struct {
        *configmap.UntypedStore
}

// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.
func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                UntypedStore: configmap.NewUntypedStore(
                        "features",
                        logger,
                        configmap.Constructors{
                                GetFeatureFlagsConfigName(): NewFeatureFlagsFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }

        return store
}</span>

// ToContext attaches the current Config state to the provided context.
func (s *Store) ToContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return ToContext(ctx, s.Load())
}</span>

// Load creates a Config from the current config state of the Store.
func (s *Store) Load() *Config <span class="cov8" title="1">{
        featureFlags := s.UntypedLoad(GetFeatureFlagsConfigName())
        if featureFlags == nil </span><span class="cov0" title="0">{
                featureFlags, _ = NewFeatureFlagsFromMap(map[string]string{})
        }</span>
        <span class="cov8" title="1">return &amp;Config{
                FeatureFlags: featureFlags.(*FeatureFlags).DeepCopy(),
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//go:build !disable_tls

/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"

        sc "github.com/tektoncd/pipeline/pkg/spire/config"
        corev1 "k8s.io/api/core/v1"
)

const (
        // SpireConfigMapName is the name of the trusted resources configmap
        SpireConfigMapName = "config-spire"

        // SpireTrustDomain is the key to extract out the SPIRE trust domain to use
        SpireTrustDomain = "spire-trust-domain"
        // SpireSocketPath is the key to extract out the SPIRE agent socket for SPIFFE workload API
        SpireSocketPath = "spire-socket-path"
        // SpireServerAddr is the key to extract out the SPIRE server address for workload/node registration
        SpireServerAddr = "spire-server-addr"
        // SpireNodeAliasPrefix is the key to extract out the SPIRE node alias prefix to use
        SpireNodeAliasPrefix = "spire-node-alias-prefix"

        // SpireTrustDomainDefault is the default value for the SpireTrustDomain
        SpireTrustDomainDefault = "example.org"
        // SpireSocketPathDefault is the default value for the SpireSocketPath
        SpireSocketPathDefault = "unix:///spiffe-workload-api/spire-agent.sock"
        // SpireServerAddrDefault is the default value for the SpireServerAddr
        SpireServerAddrDefault = "spire-server.spire.svc.cluster.local:8081"
        // SpireNodeAliasPrefixDefault is the default value for the SpireNodeAliasPrefix
        SpireNodeAliasPrefixDefault = "/tekton-node/"
)

// DefaultSpire hols all the default configurations for the spire.
var DefaultSpire, _ = NewSpireConfigFromMap(map[string]string{})

// NewSpireConfigFromMap creates a Config from the supplied map
func NewSpireConfigFromMap(data map[string]string) (*sc.SpireConfig, error) <span class="cov8" title="1">{
        cfg := &amp;sc.SpireConfig{}
        var ok bool
        if cfg.TrustDomain, ok = data[SpireTrustDomain]; !ok </span><span class="cov8" title="1">{
                cfg.TrustDomain = SpireTrustDomainDefault
        }</span>
        <span class="cov8" title="1">if cfg.SocketPath, ok = data[SpireSocketPath]; !ok </span><span class="cov8" title="1">{
                cfg.SocketPath = SpireSocketPathDefault
        }</span>
        <span class="cov8" title="1">if cfg.ServerAddr, ok = data[SpireServerAddr]; !ok </span><span class="cov8" title="1">{
                cfg.ServerAddr = SpireServerAddrDefault
        }</span>
        <span class="cov8" title="1">if cfg.NodeAliasPrefix, ok = data[SpireNodeAliasPrefix]; !ok </span><span class="cov8" title="1">{
                cfg.NodeAliasPrefix = SpireNodeAliasPrefixDefault
        }</span>
        <span class="cov8" title="1">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse SPIRE configmap: %w", err)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// NewSpireConfigFromConfigMap creates a Config from the supplied ConfigMap
func NewSpireConfigFromConfigMap(configMap *corev1.ConfigMap) (*sc.SpireConfig, error) <span class="cov8" title="1">{
        return NewSpireConfigFromMap(configMap.Data)
}</span>

// GetSpireConfigName returns the name of Spire ConfigMap
func GetSpireConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_SPIRE"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return SpireConfigMapName</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">//go:build !disable_tls

/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"

        sc "github.com/tektoncd/pipeline/pkg/spire/config"
        "knative.dev/pkg/configmap"
)

type cfgKey struct{}

// Config holds the collection of configurations that we attach to contexts.
// +k8s:deepcopy-gen=false
type Config struct {
        Defaults               *Defaults
        FeatureFlags           *FeatureFlags
        Metrics                *Metrics
        SpireConfig            *sc.SpireConfig
        Events                 *Events
        Tracing                *Tracing
        WaitExponentialBackoff *WaitExponentialBackoff
}

// FromContext extracts a Config from the provided context.
func FromContext(ctx context.Context) *Config <span class="cov8" title="1">{
        x, ok := ctx.Value(cfgKey{}).(*Config)
        if ok </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FromContextOrDefaults is like FromContext, but when no Config is attached it
// returns a Config populated with the defaults for each of the Config fields.
func FromContextOrDefaults(ctx context.Context) *Config <span class="cov8" title="1">{
        if cfg := FromContext(ctx); cfg != nil </span><span class="cov8" title="1">{
                return cfg
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Defaults:               DefaultConfig.DeepCopy(),
                FeatureFlags:           DefaultFeatureFlags.DeepCopy(),
                Metrics:                DefaultMetrics.DeepCopy(),
                SpireConfig:            DefaultSpire.DeepCopy(),
                Events:                 DefaultEvents.DeepCopy(),
                Tracing:                DefaultTracing.DeepCopy(),
                WaitExponentialBackoff: DefaultWaitExponentialBackoff.DeepCopy(),
        }</span>
}

// ToContext attaches the provided Config to the provided context, returning the
// new context with the Config attached.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.
// +k8s:deepcopy-gen=false
type Store struct {
        *configmap.UntypedStore
}

// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.
func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                UntypedStore: configmap.NewUntypedStore(
                        "defaults/features/artifacts",
                        logger,
                        configmap.Constructors{
                                GetDefaultsConfigName():               NewDefaultsFromConfigMap,
                                GetFeatureFlagsConfigName():           NewFeatureFlagsFromConfigMap,
                                GetMetricsConfigName():                NewMetricsFromConfigMap,
                                GetSpireConfigName():                  NewSpireConfigFromConfigMap,
                                GetEventsConfigName():                 NewEventsFromConfigMap,
                                GetTracingConfigName():                NewTracingFromConfigMap,
                                GetWaitExponentialBackoffConfigName(): NewWaitExponentialBackoffFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }

        return store
}</span>

// ToContext attaches the current Config state to the provided context.
func (s *Store) ToContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return ToContext(ctx, s.Load())
}</span>

// Load creates a Config from the current config state of the Store.
func (s *Store) Load() *Config <span class="cov8" title="1">{
        defaults := s.UntypedLoad(GetDefaultsConfigName())
        if defaults == nil </span><span class="cov8" title="1">{
                defaults = DefaultConfig.DeepCopy()
        }</span>
        <span class="cov8" title="1">featureFlags := s.UntypedLoad(GetFeatureFlagsConfigName())
        if featureFlags == nil </span><span class="cov8" title="1">{
                featureFlags = DefaultFeatureFlags.DeepCopy()
        }</span>
        <span class="cov8" title="1">metrics := s.UntypedLoad(GetMetricsConfigName())
        if metrics == nil </span><span class="cov8" title="1">{
                metrics = DefaultMetrics.DeepCopy()
        }</span>
        <span class="cov8" title="1">tracing := s.UntypedLoad(GetTracingConfigName())
        if tracing == nil </span><span class="cov8" title="1">{
                tracing = DefaultTracing.DeepCopy()
        }</span>

        <span class="cov8" title="1">spireconfig := s.UntypedLoad(GetSpireConfigName())
        if spireconfig == nil </span><span class="cov8" title="1">{
                spireconfig = DefaultSpire.DeepCopy()
        }</span>
        <span class="cov8" title="1">events := s.UntypedLoad(GetEventsConfigName())
        if events == nil </span><span class="cov8" title="1">{
                events = DefaultEvents.DeepCopy()
        }</span>
        <span class="cov8" title="1">waitExponentialBackoff := s.UntypedLoad(GetWaitExponentialBackoffConfigName())
        if waitExponentialBackoff == nil </span><span class="cov8" title="1">{
                waitExponentialBackoff = DefaultWaitExponentialBackoff.DeepCopy()
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                Defaults:               defaults.(*Defaults).DeepCopy(),
                FeatureFlags:           featureFlags.(*FeatureFlags).DeepCopy(),
                Metrics:                metrics.(*Metrics).DeepCopy(),
                Tracing:                tracing.(*Tracing).DeepCopy(),
                SpireConfig:            spireconfig.(*sc.SpireConfig).DeepCopy(),
                Events:                 events.(*Events).DeepCopy(),
                WaitExponentialBackoff: waitExponentialBackoff.(*WaitExponentialBackoff).DeepCopy(),
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testing

import (
        "context"
        "testing"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        logtesting "knative.dev/pkg/logging/testing"
)

// SetDefaults sets the default ConfigMap values in an existing context (for use in testing)
func SetDefaults(ctx context.Context, t *testing.T, data map[string]string) context.Context <span class="cov0" title="0">{
        t.Helper()
        s := config.NewStore(logtesting.TestLogger(t))
        s.OnConfigChanged(&amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name: config.GetDefaultsConfigName(),
                },
                Data: data,
        })
        return s.ToContext(ctx)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testing

import (
        "context"
        "testing"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

// SetFeatureFlags sets the feature-flags ConfigMap values in an existing context (for use in testing)
func SetFeatureFlags(ctx context.Context, t *testing.T, data map[string]string) context.Context <span class="cov0" title="0">{
        t.Helper()
        s := config.NewStore(logging.FromContext(ctx).Named("config-store"))
        s.OnConfigChanged(&amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name: config.GetFeatureFlagsConfigName(),
                },
                Data: data,
        })
        return s.ToContext(ctx)
}</span>

// EnableAlphaAPIFields enables alpha features in an existing context (for use in testing)
func EnableAlphaAPIFields(ctx context.Context) context.Context <span class="cov0" title="0">{
        return setEnableAPIFields(ctx, config.AlphaAPIFields)
}</span>

// EnableBetaAPIFields enables beta features in an existing context (for use in testing)
func EnableBetaAPIFields(ctx context.Context) context.Context <span class="cov0" title="0">{
        return setEnableAPIFields(ctx, config.BetaAPIFields)
}</span>

// EnableStableAPIFields enables stable features in an existing context (for use in testing)
func EnableStableAPIFields(ctx context.Context) context.Context <span class="cov0" title="0">{
        return setEnableAPIFields(ctx, config.StableAPIFields)
}</span>

func setEnableAPIFields(ctx context.Context, want string) context.Context <span class="cov0" title="0">{
        featureFlags, _ := config.NewFeatureFlagsFromMap(map[string]string{
                "enable-api-fields": want,
        })
        cfg := &amp;config.Config{
                Defaults: &amp;config.Defaults{
                        DefaultTimeoutMinutes: 60,
                },
                FeatureFlags: featureFlags,
        }
        return config.ToContext(ctx, cfg)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"

        corev1 "k8s.io/api/core/v1"
)

const (
        // tracingEnabledKey is the configmap key which determines if tracing is enabled
        tracingEnabledKey = "enabled"
        // tracingEndpintKey is the configmap key for tracing api endpoint
        tracingEndpointKey = "endpoint"

        // tracingCredentialsSecretKey is the name of the secret which contains credentials for tracing endpoint
        tracingCredentialsSecretKey = "credentialsSecret"

        // DefaultEndpoint is the default destination for sending traces
        DefaultEndpoint = "http://jaeger-collector.jaeger.svc.cluster.local:14268/api/traces"
)

// DefaultTracing holds all the default configurations for tracing
var DefaultTracing, _ = newTracingFromMap(map[string]string{})

// Tracing holds the configurations for tracing
// +k8s:deepcopy-gen=true
type Tracing struct {
        Enabled           bool
        Endpoint          string
        CredentialsSecret string
}

// Equals returns true if two Configs are identical
func (cfg *Tracing) Equals(other *Tracing) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return other.Enabled == cfg.Enabled &amp;&amp;
                other.Endpoint == cfg.Endpoint &amp;&amp;
                other.CredentialsSecret == cfg.CredentialsSecret</span>
}

// GetTracingConfigName returns the name of the configmap containing all
// customizations for tracing
func GetTracingConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_TRACING_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-tracing"</span>
}

// newTracingFromMap returns a Config given a map from ConfigMap
func newTracingFromMap(config map[string]string) (*Tracing, error) <span class="cov8" title="1">{
        t := Tracing{
                Enabled:  false,
                Endpoint: DefaultEndpoint,
        }

        if endpoint, ok := config[tracingEndpointKey]; ok </span><span class="cov8" title="1">{
                t.Endpoint = endpoint
        }</span>

        <span class="cov8" title="1">if secret, ok := config[tracingCredentialsSecretKey]; ok </span><span class="cov0" title="0">{
                t.CredentialsSecret = secret
        }</span>

        <span class="cov8" title="1">if enabled, ok := config[tracingEnabledKey]; ok </span><span class="cov8" title="1">{
                e, err := strconv.ParseBool(enabled)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed parsing tracing config %q: %w", enabled, err)
                }</span>
                <span class="cov8" title="1">t.Enabled = e</span>
        }
        <span class="cov8" title="1">return &amp;t, nil</span>
}

// NewTracingFromConfigMap returns a Config given a ConfigMap
func NewTracingFromConfigMap(config *corev1.ConfigMap) (*Tracing, error) <span class="cov8" title="1">{
        return newTracingFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        corev1 "k8s.io/api/core/v1"
)

const (
        waitExponentialBackoffDurationKey = "duration"
        waitExponentialBackoffFactorKey   = "factor"
        waitExponentialBackoffJitterKey   = "jitter"
        waitExponentialBackoffStepsKey    = "steps"
        waitExponentialBackoffCapKey      = "cap"

        DefaultWaitExponentialBackoffDuration = "1s"
        DefaultWaitExponentialBackoffFactor   = 2.0
        DefaultWaitExponentialBackoffJitter   = 0.0
        DefaultWaitExponentialBackoffSteps    = 10
        DefaultWaitExponentialBackoffCap      = "60s"
)

// DefaultWaitExponentialBackoff holds all the default configurations for wait-exponential-backoff
var DefaultWaitExponentialBackoff, _ = newWaitExponentialBackoffFromMap(map[string]string{})

// WaitExponentialBackoff holds the configurations for exponential backoff
// +k8s:deepcopy-gen=true
type WaitExponentialBackoff struct {
        Duration time.Duration
        Factor   float64
        Jitter   float64
        Steps    int
        Cap      time.Duration
}

// Equals returns true if two Configs are identical
func (cfg *WaitExponentialBackoff) Equals(other *WaitExponentialBackoff) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return other.Duration == cfg.Duration &amp;&amp;
                other.Factor == cfg.Factor &amp;&amp;
                other.Jitter == cfg.Jitter &amp;&amp;
                other.Steps == cfg.Steps &amp;&amp;
                other.Cap == cfg.Cap</span>
}

// GetWaitExponentialBackoffConfigName returns the name of the configmap containing all customizations for wait-exponential-backoff
func GetWaitExponentialBackoffConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_WAIT_EXPONENTIAL_BACKOFF_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-wait-exponential-backoff"</span>
}

// newWaitExponentialBackoffFromMap returns a Config given a map from ConfigMap
func newWaitExponentialBackoffFromMap(config map[string]string) (*WaitExponentialBackoff, error) <span class="cov8" title="1">{
        w := WaitExponentialBackoff{}

        durationStr := DefaultWaitExponentialBackoffDuration
        if v, ok := config[waitExponentialBackoffDurationKey]; ok </span><span class="cov8" title="1">{
                durationStr = v
        }</span>
        <span class="cov8" title="1">dur, err := time.ParseDuration(durationStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed parsing duration %q: %w", durationStr, err)
        }</span>
        <span class="cov8" title="1">w.Duration = dur

        factor := DefaultWaitExponentialBackoffFactor
        if v, ok := config[waitExponentialBackoffFactorKey]; ok </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed parsing factor %q: %w", v, err)
                }</span>
                <span class="cov8" title="1">factor = f</span>
        }
        <span class="cov8" title="1">w.Factor = factor

        jitter := DefaultWaitExponentialBackoffJitter
        if v, ok := config[waitExponentialBackoffJitterKey]; ok </span><span class="cov8" title="1">{
                j, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed parsing jitter %q: %w", v, err)
                }</span>
                <span class="cov8" title="1">jitter = j</span>
        }
        <span class="cov8" title="1">w.Jitter = jitter

        steps := DefaultWaitExponentialBackoffSteps
        if v, ok := config[waitExponentialBackoffStepsKey]; ok </span><span class="cov8" title="1">{
                s, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed parsing steps %q: %w", v, err)
                }</span>
                <span class="cov8" title="1">steps = s</span>
        }
        <span class="cov8" title="1">w.Steps = steps

        capStr := DefaultWaitExponentialBackoffCap
        if v, ok := config[waitExponentialBackoffCapKey]; ok </span><span class="cov8" title="1">{
                capStr = v
        }</span>
        <span class="cov8" title="1">capDur, err := time.ParseDuration(capStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed parsing cap %q: %w", capStr, err)
        }</span>
        <span class="cov8" title="1">w.Cap = capDur

        return &amp;w, nil</span>
}

// NewWaitExponentialBackoffFromConfigMap returns a Config given a ConfigMap
func NewWaitExponentialBackoffFromConfigMap(config *corev1.ConfigMap) (*WaitExponentialBackoff, error) <span class="cov8" title="1">{
        return newWaitExponentialBackoffFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package errors

import (
        "errors"
        "strings"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
)

const UserErrorLabel = "[User error] "

type UserError struct {
        Reason   string
        Original error
}

var _ error = &amp;UserError{}

// Error returns the original error message. This implements the error.Error interface.
func (e *UserError) Error() string <span class="cov8" title="1">{
        return e.Original.Error()
}</span>

// Unwrap returns the original error without the Reason annotation. This is
// intended to support usage of errors.Is and errors.As with Errors.
func (e *UserError) Unwrap() error <span class="cov8" title="1">{
        return e.Original
}</span>

// newUserError returns a UserError with the given reason and underlying
// original error.
func newUserError(reason string, err error) *UserError <span class="cov8" title="1">{
        return &amp;UserError{
                Reason:   reason,
                Original: err,
        }
}</span>

// WrapUserError wraps the original error with the user error label
func WrapUserError(err error) error <span class="cov8" title="1">{
        return newUserError(UserErrorLabel, err)
}</span>

// LabelUserError labels the failure RunStatus message if any of its error messages has been
// wrapped as an UserError. It indicates that the user is responsible for an error.
// See github.com/tektoncd/pipeline/blob/main/docs/pipelineruns.md#marking-off-user-errors
// for more details.
func LabelUserError(messageFormat string, messageA []interface{}) string <span class="cov8" title="1">{
        for _, message := range messageA </span><span class="cov8" title="1">{
                if ue, ok := message.(*UserError); ok </span><span class="cov8" title="1">{
                        return ue.Reason + messageFormat
                }</span>
        }
        <span class="cov8" title="1">return messageFormat</span>
}

// GetErrorMessage returns the error message with the user error label if it is of type user
// error
func GetErrorMessage(err error) string <span class="cov8" title="1">{
        var ue *UserError
        if errors.As(err, &amp;ue) </span><span class="cov8" title="1">{
                return ue.Reason + err.Error()
        }</span>
        <span class="cov8" title="1">return err.Error()</span>
}

// IsImmutableTaskRunSpecError returns true if the error is the taskrun spec is immutable
func IsImmutableTaskRunSpecError(err error) bool <span class="cov0" title="0">{
        // The TaskRun may have completed and the spec field is immutable.
        // validation code: https://github.com/tektoncd/pipeline/blob/v0.62.0/pkg/apis/pipeline/v1/taskrun_validation.go#L136-L138
        return apierrors.IsBadRequest(err) &amp;&amp; strings.Contains(err.Error(), "no updates are allowed")
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipeline

import (
        "fmt"
        "sort"
)

// Images holds the images reference for a number of container images used
// across tektoncd pipelines.
type Images struct {
        // EntrypointImage is container image containing our entrypoint binary.
        EntrypointImage string
        // SidecarLogResultsImage is container image containing the binary that fetches results from the steps and logs it to stdout.
        SidecarLogResultsImage string
        // NopImage is the container image used to kill sidecars.
        NopImage string
        // ShellImage is the container image containing bash shell.
        ShellImage string
        // ShellImageWin is the container image containing powershell.
        ShellImageWin string
        // WorkingDirInitImage is the container image containing our working dir init binary.
        WorkingDirInitImage string

        // NOTE: Make sure to add any new images to Validate below!
}

// Validate returns an error if any image is not set.
func (i Images) Validate() error <span class="cov8" title="1">{
        var unset []string
        for _, f := range []struct {
                v, name string
        }{
                {i.EntrypointImage, "entrypoint-image"},
                {i.SidecarLogResultsImage, "sidecarlogresults-image"},
                {i.NopImage, "nop-image"},
                {i.ShellImage, "shell-image"},
                {i.ShellImageWin, "shell-image-win"},
                {i.WorkingDirInitImage, "workingdirinit-image"},
        } </span><span class="cov8" title="1">{
                if f.v == "" </span><span class="cov8" title="1">{
                        unset = append(unset, f.name)
                }</span>
        }
        <span class="cov8" title="1">if len(unset) &gt; 0 </span><span class="cov8" title="1">{
                sort.Strings(unset)
                return fmt.Errorf("found unset image flags: %s", unset)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package checksum

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        // SignatureAnnotation is the key of signature in annotation map
        SignatureAnnotation = "tekton.dev/signature"
)

// PrepareObjectMeta will remove annotations not configured from user side -- "kubectl-client-side-apply" and "kubectl.kubernetes.io/last-applied-configuration"
// (added when an object is created with `kubectl apply`) to avoid verification failure and extract the signature.
// Returns a copy of the input object metadata with the annotations removed and the object's signature,
// if it is present in the metadata.
func PrepareObjectMeta(in metav1.Object) metav1.ObjectMeta <span class="cov8" title="1">{
        outMeta := metav1.ObjectMeta{}

        // exclude the fields populated by system.
        outMeta.Name = in.GetName()
        outMeta.GenerateName = in.GetGenerateName()
        outMeta.Namespace = in.GetNamespace()

        if in.GetLabels() != nil </span><span class="cov8" title="1">{
                outMeta.Labels = make(map[string]string)
                for k, v := range in.GetLabels() </span><span class="cov8" title="1">{
                        outMeta.Labels[k] = v
                }</span>
        }

        <span class="cov8" title="1">outMeta.Annotations = make(map[string]string)
        for k, v := range in.GetAnnotations() </span><span class="cov8" title="1">{
                outMeta.Annotations[k] = v
        }</span>

        // exclude the annotations added by other components
        <span class="cov8" title="1">delete(outMeta.Annotations, "kubectl-client-side-apply")
        delete(outMeta.Annotations, "kubectl.kubernetes.io/last-applied-configuration")
        delete(outMeta.Annotations, SignatureAnnotation)

        return outMeta</span>
}

// ComputeSha256Checksum computes the sha256 checksum of the tekton object.
func ComputeSha256Checksum(obj interface{}) ([]byte, error) <span class="cov8" title="1">{
        ts, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal the object: %w", err)
        }</span>
        <span class="cov8" title="1">h := sha256.New()
        h.Write(ts)
        return h.Sum(nil), nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "reflect"

        corev1 "k8s.io/api/core/v1"
)

// AffinityAssistantTemplate holds pod specific configuration and is a subset
// of the generic pod Template
// +k8s:deepcopy-gen=true
// +k8s:openapi-gen=true
type AffinityAssistantTemplate struct {
        // NodeSelector is a selector which must be true for the pod to fit on a node.
        // Selector which must match a node's labels for the pod to be scheduled on that node.
        // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        // +optional
        NodeSelector map[string]string `json:"nodeSelector,omitempty"`

        // If specified, the pod's tolerations.
        // +optional
        // +listType=atomic
        Tolerations []corev1.Toleration `json:"tolerations,omitempty"`

        // ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified
        // +optional
        // +listType=atomic
        ImagePullSecrets []corev1.LocalObjectReference `json:"imagePullSecrets,omitempty"`

        // SecurityContext sets the security context for the pod
        // +optional
        SecurityContext *corev1.PodSecurityContext `json:"securityContext,omitempty"`

        // If specified, indicates the pod's priority. "system-node-critical" and
        // "system-cluster-critical" are two special keywords which indicate the
        // highest priorities with the former being the highest priority. Any other
        // name must be defined by creating a PriorityClass object with that name.
        // If not specified, the pod priority will be default or zero if there is no
        // default.
        // +optional
        PriorityClassName *string `json:"priorityClassName,omitempty"`
}

// Equals checks if this Template is identical to the given Template.
func (tpl *AffinityAssistantTemplate) Equals(other *AffinityAssistantTemplate) bool <span class="cov0" title="0">{
        if tpl == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if tpl == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return reflect.DeepEqual(tpl, other)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "reflect"

        corev1 "k8s.io/api/core/v1"
)

// +listType=atomic
type Volumes []corev1.Volume

// Template holds pod specific configuration
// +k8s:deepcopy-gen=true
// +k8s:openapi-gen=true
type Template struct {
        // NodeSelector is a selector which must be true for the pod to fit on a node.
        // Selector which must match a node's labels for the pod to be scheduled on that node.
        // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        // +optional
        NodeSelector map[string]string `json:"nodeSelector,omitempty"`

        // List of environment variables that can be provided to the containers belonging to the pod.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`

        // If specified, the pod's tolerations.
        // +optional
        // +listType=atomic
        Tolerations []corev1.Toleration `json:"tolerations,omitempty"`

        // If specified, the pod's scheduling constraints.
        // See Pod.spec.affinity (API version: v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Affinity *corev1.Affinity `json:"affinity,omitempty"`

        // SecurityContext holds pod-level security attributes and common container settings.
        // Optional: Defaults to empty.  See type description for default values of each field.
        // See Pod.spec.securityContext (API version: v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        SecurityContext *corev1.PodSecurityContext `json:"securityContext,omitempty"`

        // List of volumes that can be mounted by containers belonging to the pod.
        // More info: https://kubernetes.io/docs/concepts/storage/volumes
        // See Pod.spec.volumes (API version: v1)
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge,retainKeys
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Volumes Volumes `json:"volumes,omitempty" patchMergeKey:"name" patchStrategy:"merge,retainKeys" protobuf:"bytes,1,rep,name=volumes"`

        // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io
        // group, which should be used to run this pod. If no RuntimeClass resource
        // matches the named class, the pod will not be run. If unset or empty, the
        // "legacy" RuntimeClass will be used, which is an implicit class with an
        // empty definition that uses the default runtime handler.
        // More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
        // This is a beta feature as of Kubernetes v1.14.
        // +optional
        RuntimeClassName *string `json:"runtimeClassName,omitempty" protobuf:"bytes,2,opt,name=runtimeClassName"`

        // AutomountServiceAccountToken indicates whether pods running as this
        // service account should have an API token automatically mounted.
        // +optional
        AutomountServiceAccountToken *bool `json:"automountServiceAccountToken,omitempty" protobuf:"varint,3,opt,name=automountServiceAccountToken"`

        // Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
        // 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig
        // will be merged with the policy selected with DNSPolicy.
        // +optional
        DNSPolicy *corev1.DNSPolicy `json:"dnsPolicy,omitempty" protobuf:"bytes,4,opt,name=dnsPolicy,casttype=k8s.io/api/core/v1.DNSPolicy"`

        // Specifies the DNS parameters of a pod.
        // Parameters specified here will be merged to the generated DNS
        // configuration based on DNSPolicy.
        // +optional
        DNSConfig *corev1.PodDNSConfig `json:"dnsConfig,omitempty" protobuf:"bytes,5,opt,name=dnsConfig"`

        // EnableServiceLinks indicates whether information about services should be injected into pod's
        // environment variables, matching the syntax of Docker links.
        // Optional: Defaults to true.
        // +optional
        EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" protobuf:"varint,6,opt,name=enableServiceLinks"`

        // If specified, indicates the pod's priority. "system-node-critical" and
        // "system-cluster-critical" are two special keywords which indicate the
        // highest priorities with the former being the highest priority. Any other
        // name must be defined by creating a PriorityClass object with that name.
        // If not specified, the pod priority will be default or zero if there is no
        // default.
        // +optional
        PriorityClassName *string `json:"priorityClassName,omitempty" protobuf:"bytes,7,opt,name=priorityClassName"`
        // SchedulerName specifies the scheduler to be used to dispatch the Pod
        // +optional
        SchedulerName string `json:"schedulerName,omitempty"`

        // ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified
        // +optional
        // +listType=atomic
        ImagePullSecrets []corev1.LocalObjectReference `json:"imagePullSecrets,omitempty"`

        // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
        // file if specified. This is only valid for non-hostNetwork pods.
        // +optional
        // +listType=atomic
        HostAliases []corev1.HostAlias `json:"hostAliases,omitempty"`

        // HostNetwork specifies whether the pod may use the node network namespace
        // +optional
        HostNetwork bool `json:"hostNetwork,omitempty"`

        // TopologySpreadConstraints controls how Pods are spread across your cluster among
        // failure-domains such as regions, zones, nodes, and other user-defined topology domains.
        // +optional
        // +listType=atomic
        TopologySpreadConstraints []corev1.TopologySpreadConstraint `json:"topologySpreadConstraints,omitempty"`
}

// Equals checks if this Template is identical to the given Template.
func (tpl *Template) Equals(other *Template) bool <span class="cov0" title="0">{
        if tpl == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if tpl == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return reflect.DeepEqual(tpl, other)</span>
}

// ToAffinityAssistantTemplate converts to a affinity assistant pod Template
func (tpl *Template) ToAffinityAssistantTemplate() *AffinityAssistantTemplate <span class="cov0" title="0">{
        if tpl == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;AffinityAssistantTemplate{
                NodeSelector:      tpl.NodeSelector,
                Tolerations:       tpl.Tolerations,
                ImagePullSecrets:  tpl.ImagePullSecrets,
                SecurityContext:   tpl.SecurityContext,
                PriorityClassName: tpl.PriorityClassName,
        }</span>
}

// PodTemplate holds pod specific configuration
//
//nolint:revive
type PodTemplate = Template

// MergePodTemplateWithDefault merges 2 PodTemplates together. If the same
// field is set on both templates, the value from tpl will overwrite the value
// from defaultTpl.
func MergePodTemplateWithDefault(tpl, defaultTpl *PodTemplate) *PodTemplate <span class="cov8" title="1">{
        switch </span>{
        case defaultTpl == nil:<span class="cov8" title="1">
                // No configured default, just return the template
                return tpl</span>
        case tpl == nil:<span class="cov8" title="1">
                // No template, just return the default template
                return defaultTpl</span>
        default:<span class="cov8" title="1">
                // Otherwise, merge fields
                if tpl.NodeSelector == nil </span><span class="cov8" title="1">{
                        tpl.NodeSelector = defaultTpl.NodeSelector
                }</span>
                <span class="cov8" title="1">tpl.Env = mergeByName(defaultTpl.Env, tpl.Env)
                if tpl.Tolerations == nil </span><span class="cov8" title="1">{
                        tpl.Tolerations = defaultTpl.Tolerations
                }</span>
                <span class="cov8" title="1">if tpl.Affinity == nil </span><span class="cov8" title="1">{
                        tpl.Affinity = defaultTpl.Affinity
                }</span>
                <span class="cov8" title="1">if tpl.SecurityContext == nil </span><span class="cov8" title="1">{
                        tpl.SecurityContext = defaultTpl.SecurityContext
                }</span>
                <span class="cov8" title="1">tpl.Volumes = mergeByName(defaultTpl.Volumes, tpl.Volumes)
                if tpl.RuntimeClassName == nil </span><span class="cov8" title="1">{
                        tpl.RuntimeClassName = defaultTpl.RuntimeClassName
                }</span>
                <span class="cov8" title="1">if tpl.AutomountServiceAccountToken == nil </span><span class="cov8" title="1">{
                        tpl.AutomountServiceAccountToken = defaultTpl.AutomountServiceAccountToken
                }</span>
                <span class="cov8" title="1">if tpl.DNSPolicy == nil </span><span class="cov8" title="1">{
                        tpl.DNSPolicy = defaultTpl.DNSPolicy
                }</span>
                <span class="cov8" title="1">if tpl.DNSConfig == nil </span><span class="cov8" title="1">{
                        tpl.DNSConfig = defaultTpl.DNSConfig
                }</span>
                <span class="cov8" title="1">if tpl.EnableServiceLinks == nil </span><span class="cov8" title="1">{
                        tpl.EnableServiceLinks = defaultTpl.EnableServiceLinks
                }</span>
                <span class="cov8" title="1">if tpl.PriorityClassName == nil </span><span class="cov8" title="1">{
                        tpl.PriorityClassName = defaultTpl.PriorityClassName
                }</span>
                <span class="cov8" title="1">if tpl.SchedulerName == "" </span><span class="cov8" title="1">{
                        tpl.SchedulerName = defaultTpl.SchedulerName
                }</span>
                <span class="cov8" title="1">if tpl.ImagePullSecrets == nil </span><span class="cov8" title="1">{
                        tpl.ImagePullSecrets = defaultTpl.ImagePullSecrets
                }</span>
                <span class="cov8" title="1">if tpl.HostAliases == nil </span><span class="cov8" title="1">{
                        tpl.HostAliases = defaultTpl.HostAliases
                }</span>
                <span class="cov8" title="1">if !tpl.HostNetwork &amp;&amp; defaultTpl.HostNetwork </span><span class="cov8" title="1">{
                        tpl.HostNetwork = true
                }</span>
                <span class="cov8" title="1">if tpl.TopologySpreadConstraints == nil </span><span class="cov8" title="1">{
                        tpl.TopologySpreadConstraints = defaultTpl.TopologySpreadConstraints
                }</span>
                <span class="cov8" title="1">return tpl</span>
        }
}

// AAPodTemplate holds pod specific configuration for the affinity-assistant
type AAPodTemplate = AffinityAssistantTemplate

// MergeAAPodTemplateWithDefault is the same as MergePodTemplateWithDefault but
// for AffinityAssistantPodTemplates.
func MergeAAPodTemplateWithDefault(tpl, defaultTpl *AAPodTemplate) *AAPodTemplate <span class="cov8" title="1">{
        switch </span>{
        case defaultTpl == nil:<span class="cov8" title="1">
                // No configured default, just return the template
                return tpl</span>
        case tpl == nil:<span class="cov8" title="1">
                // No template, just return the default template
                return defaultTpl</span>
        default:<span class="cov8" title="1">
                // Otherwise, merge fields
                if tpl.NodeSelector == nil </span><span class="cov8" title="1">{
                        tpl.NodeSelector = defaultTpl.NodeSelector
                }</span>
                <span class="cov8" title="1">if tpl.Tolerations == nil </span><span class="cov8" title="1">{
                        tpl.Tolerations = defaultTpl.Tolerations
                }</span>
                <span class="cov8" title="1">if tpl.ImagePullSecrets == nil </span><span class="cov8" title="1">{
                        tpl.ImagePullSecrets = defaultTpl.ImagePullSecrets
                }</span>
                <span class="cov8" title="1">if tpl.SecurityContext == nil </span><span class="cov8" title="1">{
                        tpl.SecurityContext = defaultTpl.SecurityContext
                }</span>
                <span class="cov8" title="1">if tpl.PriorityClassName == nil </span><span class="cov0" title="0">{
                        tpl.PriorityClassName = defaultTpl.PriorityClassName
                }</span>

                <span class="cov8" title="1">return tpl</span>
        }
}

// mergeByName merges two slices of items with names based on the getName
// function, giving priority to the items in the override slice.
func mergeByName[T any](base, overrides []T) []T <span class="cov8" title="1">{
        if len(overrides) == 0 </span><span class="cov8" title="1">{
                return base
        }</span>

        // create a map to store the exist names in the override slice
        <span class="cov8" title="1">exists := make(map[string]struct{})
        merged := make([]T, 0, len(base)+len(overrides))

        // append the items in the override slice
        for _, item := range overrides </span><span class="cov8" title="1">{
                name := getName(item)
                if name != "" </span><span class="cov8" title="1">{ // name should not be empty, if empty, ignore
                        merged = append(merged, item)
                        exists[name] = struct{}{}
                }</span>
        }

        // append the items in the base slice if they have a different name
        <span class="cov8" title="1">for _, item := range base </span><span class="cov8" title="1">{
                name := getName(item)
                if name != "" </span><span class="cov8" title="1">{ // name should not be empty, if empty, ignore
                        if _, found := exists[name]; !found </span><span class="cov8" title="1">{
                                merged = append(merged, item)
                        }</span>
                }
        }

        <span class="cov8" title="1">return merged</span>
}

// getName returns the name of the given item, or an empty string if the item
// is not a supported type.
func getName(item interface{}) string <span class="cov8" title="1">{
        switch item := item.(type) </span>{
        case corev1.EnvVar:<span class="cov8" title="1">
                return item.Name</span>
        case corev1.Volume:<span class="cov8" title="1">
                return item.Name</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "github.com/google/go-cmp/cmp"
)

// Algorithm Standard cryptographic hash algorithm
type Algorithm string

// Artifact represents an artifact within a system, potentially containing multiple values
// associated with it.
type Artifact struct {
        // The artifact's identifying category name
        Name string `json:"name,omitempty"`
        // A collection of values related to the artifact
        Values []ArtifactValue `json:"values,omitempty"`
        // Indicate if the artifact is a build output or a by-product
        BuildOutput bool `json:"buildOutput,omitempty"`
}

// ArtifactValue represents a specific value or data element within an Artifact.
type ArtifactValue struct {
        Digest map[Algorithm]string `json:"digest,omitempty"` // Algorithm-specific digests for verifying the content (e.g., SHA256)
        Uri    string               `json:"uri,omitempty"`    // Location where the artifact value can be retrieved
}

// TaskRunStepArtifact represents an artifact produced or used by a step within a task run.
// It directly uses the Artifact type for its structure.
type TaskRunStepArtifact = Artifact

// Artifacts represents the collection of input and output artifacts associated with
// a task run or a similar process. Artifacts in this context are units of data or resources
// that the process either consumes as input or produces as output.
type Artifacts struct {
        // +listType=atomic
        Inputs []Artifact `json:"inputs,omitempty"`
        // +listType=atomic
        Outputs []Artifact `json:"outputs,omitempty"`
}

func (a *Artifacts) Merge(another *Artifacts) <span class="cov8" title="1">{
        inputMap := make(map[string][]ArtifactValue)
        var newInputs []Artifact

        for _, v := range a.Inputs </span><span class="cov8" title="1">{
                inputMap[v.Name] = v.Values
        }</span>
        <span class="cov8" title="1">if another != nil </span><span class="cov8" title="1">{
                for _, v := range another.Inputs </span><span class="cov8" title="1">{
                        _, ok := inputMap[v.Name]
                        if !ok </span><span class="cov8" title="1">{
                                inputMap[v.Name] = []ArtifactValue{}
                        }</span>
                        <span class="cov8" title="1">for _, vv := range v.Values </span><span class="cov8" title="1">{
                                exists := false
                                for _, av := range inputMap[v.Name] </span><span class="cov8" title="1">{
                                        if cmp.Equal(vv, av) </span><span class="cov8" title="1">{
                                                exists = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                                        inputMap[v.Name] = append(inputMap[v.Name], vv)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for k, v := range inputMap </span><span class="cov8" title="1">{
                newInputs = append(newInputs, Artifact{
                        Name:   k,
                        Values: v,
                })
        }</span>

        <span class="cov8" title="1">outputMap := make(map[string]Artifact)
        var newOutputs []Artifact
        for _, v := range a.Outputs </span><span class="cov8" title="1">{
                outputMap[v.Name] = v
        }</span>

        <span class="cov8" title="1">if another != nil </span><span class="cov8" title="1">{
                for _, v := range another.Outputs </span><span class="cov8" title="1">{
                        _, ok := outputMap[v.Name]
                        if !ok </span><span class="cov8" title="1">{
                                outputMap[v.Name] = Artifact{Name: v.Name, Values: []ArtifactValue{}, BuildOutput: v.BuildOutput}
                        }</span>
                        // only update buildOutput to true.
                        // Do not convert to false if it was true before.
                        <span class="cov8" title="1">if v.BuildOutput </span><span class="cov8" title="1">{
                                art := outputMap[v.Name]
                                art.BuildOutput = v.BuildOutput
                                outputMap[v.Name] = art
                        }</span>
                        <span class="cov8" title="1">for _, vv := range v.Values </span><span class="cov8" title="1">{
                                exists := false
                                for _, av := range outputMap[v.Name].Values </span><span class="cov8" title="1">{
                                        if cmp.Equal(vv, av) </span><span class="cov0" title="0">{
                                                exists = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                                        art := outputMap[v.Name]
                                        art.Values = append(art.Values, vv)
                                        outputMap[v.Name] = art
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for _, v := range outputMap </span><span class="cov8" title="1">{
                newOutputs = append(newOutputs, Artifact{
                        Name:        v.Name,
                        Values:      v.Values,
                        BuildOutput: v.BuildOutput,
                })
        }</span>
        <span class="cov8" title="1">a.Inputs = newInputs
        a.Outputs = newOutputs</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package v1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Step runs a subcomponent of a Task
type Step struct {
        // Name of the Step specified as a DNS_LABEL.
        // Each Step in a Task must have a unique name.
        Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
        // Docker image name.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of sources to populate environment variables in the Step.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the Step is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the Step.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // ComputeResources required by this Step.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        ComputeResources corev1.ResourceRequirements `json:"computeResources,omitempty" protobuf:"bytes,8,opt,name=computeResources"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Step.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
        // +optional
        Script string `json:"script,omitempty"`

        // Timeout is the time after which the step times out. Defaults to never.
        // Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
        // for this field to be supported.
        //
        // Workspaces is a list of workspaces from the Task that this Step wants
        // exclusive access to. Adding a workspace to this list means that any
        // other Step or Sidecar that does not also request this Workspace will
        // not have access to it.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceUsage `json:"workspaces,omitempty"`

        // OnError defines the exiting behavior of a container on error
        // can be set to [ continue | stopAndFail ]
        OnError OnErrorType `json:"onError,omitempty"`
        // Stores configuration for the stdout stream of the step.
        // +optional
        StdoutConfig *StepOutputConfig `json:"stdoutConfig,omitempty"`
        // Stores configuration for the stderr stream of the step.
        // +optional
        StderrConfig *StepOutputConfig `json:"stderrConfig,omitempty"`
        // Contains the reference to an existing StepAction.
        //+optional
        Ref *Ref `json:"ref,omitempty"`
        // Params declares parameters passed to this step action.
        // +optional
        Params Params `json:"params,omitempty"`
        // Results declares StepResults produced by the Step.
        //
        // It can be used in an inlined Step when used to store Results to $(step.results.resultName.path).
        // It cannot be used when referencing StepActions using [v1.Step.Ref].
        // The Results declared by the StepActions will be stored here instead.
        // +optional
        // +listType=atomic
        Results []StepResult `json:"results,omitempty"`

        // When is a list of when expressions that need to be true for the task to run
        // +optional
        When StepWhenExpressions `json:"when,omitempty"`
}

// Ref can be used to refer to a specific instance of a StepAction.
type Ref struct {
        // Name of the referenced step
        Name string `json:"name,omitempty"`
        // ResolverRef allows referencing a StepAction in a remote location
        // like a git repo.
        // +optional
        ResolverRef `json:",omitempty"`
}

// OnErrorType defines a list of supported exiting behavior of a container on error
type OnErrorType string

const (
        // StopAndFail indicates exit the taskRun if the container exits with non-zero exit code
        StopAndFail OnErrorType = "stopAndFail"
        // Continue indicates continue executing the rest of the steps irrespective of the container exit code
        Continue OnErrorType = "continue"
)

// StepOutputConfig stores configuration for a step output stream.
type StepOutputConfig struct {
        // Path to duplicate stdout stream to on container's local filesystem.
        // +optional
        Path string `json:"path,omitempty"`
}

// ToK8sContainer converts the Step to a Kubernetes Container struct
func (s *Step) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        return &amp;corev1.Container{
                Name:            s.Name,
                Image:           s.Image,
                Command:         s.Command,
                Args:            s.Args,
                WorkingDir:      s.WorkingDir,
                EnvFrom:         s.EnvFrom,
                Env:             s.Env,
                Resources:       s.ComputeResources,
                VolumeMounts:    s.VolumeMounts,
                VolumeDevices:   s.VolumeDevices,
                ImagePullPolicy: s.ImagePullPolicy,
                SecurityContext: s.SecurityContext,
        }
}</span>

// SetContainerFields sets the fields of the Step to the values of the corresponding fields in the Container
func (s *Step) SetContainerFields(c corev1.Container) <span class="cov8" title="1">{
        s.Name = c.Name
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.ComputeResources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
}</span>

// GetVarSubstitutionExpressions walks all the places a substitution reference can be used
func (s *Step) GetVarSubstitutionExpressions() []string <span class="cov8" title="1">{
        var allExpressions []string
        allExpressions = append(allExpressions, validateString(s.Name)...)
        allExpressions = append(allExpressions, validateString(s.Image)...)
        allExpressions = append(allExpressions, validateString(string(s.ImagePullPolicy))...)
        allExpressions = append(allExpressions, validateString(s.Script)...)
        allExpressions = append(allExpressions, validateString(s.WorkingDir)...)
        for _, cmd := range s.Command </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(cmd)...)
        }</span>
        <span class="cov8" title="1">for _, arg := range s.Args </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(arg)...)
        }</span>
        <span class="cov8" title="1">for _, env := range s.Env </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(env.Value)...)
                if env.ValueFrom != nil </span><span class="cov8" title="1">{
                        if env.ValueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.SecretKeyRef.Key)...)
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.SecretKeyRef.LocalObjectReference.Name)...)
                        }</span>
                        <span class="cov8" title="1">if env.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.ConfigMapKeyRef.Key)...)
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name)...)
                        }</span>
                }
        }
        <span class="cov8" title="1">return allExpressions</span>
}

// StepTemplate is a template for a Step
type StepTemplate struct {
        // Image reference name.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of sources to populate environment variables in the Step.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the Step is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the Step.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // ComputeResources required by this Step.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        ComputeResources corev1.ResourceRequirements `json:"computeResources,omitempty" protobuf:"bytes,8,opt,name=computeResources"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Step.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`
}

// SetContainerFields sets the fields of the Step to the values of the corresponding fields in the Container
func (s *StepTemplate) SetContainerFields(c corev1.Container) <span class="cov0" title="0">{
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.ComputeResources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
}</span>

// ToK8sContainer converts the StepTemplate to a Kubernetes Container struct
func (s *StepTemplate) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        return &amp;corev1.Container{
                Image:           s.Image,
                Command:         s.Command,
                Args:            s.Args,
                WorkingDir:      s.WorkingDir,
                EnvFrom:         s.EnvFrom,
                Env:             s.Env,
                Resources:       s.ComputeResources,
                VolumeMounts:    s.VolumeMounts,
                VolumeDevices:   s.VolumeDevices,
                ImagePullPolicy: s.ImagePullPolicy,
                SecurityContext: s.SecurityContext,
        }
}</span>

// Sidecar has nearly the same data structure as Step but does not have the ability to timeout.
type Sidecar struct {
        // Name of the Sidecar specified as a DNS_LABEL.
        // Each Sidecar in a Task must have a unique name (DNS_LABEL).
        // Cannot be updated.
        Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
        // Image reference name.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Sidecar's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Sidecar's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Sidecar's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of ports to expose from the Sidecar. Exposing a port here gives
        // the system additional information about the network connections a
        // container uses, but is primarily informational. Not specifying a port here
        // DOES NOT prevent that port from being exposed. Any port which is
        // listening on the default "0.0.0.0" address inside a container will be
        // accessible from the network.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=containerPort
        // +patchStrategy=merge
        // +listType=map
        // +listMapKey=containerPort
        // +listMapKey=protocol
        Ports []corev1.ContainerPort `json:"ports,omitempty" patchMergeKey:"containerPort" patchStrategy:"merge" protobuf:"bytes,6,rep,name=ports"`
        // List of sources to populate environment variables in the Sidecar.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the container is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the Sidecar.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // ComputeResources required by this Sidecar.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        ComputeResources corev1.ResourceRequirements `json:"computeResources,omitempty" protobuf:"bytes,8,opt,name=computeResources"`
        // Volumes to mount into the Sidecar's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Sidecar.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Periodic probe of Sidecar liveness.
        // Container will be restarted if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        LivenessProbe *corev1.Probe `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
        // Periodic probe of Sidecar service readiness.
        // Container will be removed from service endpoints if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        ReadinessProbe *corev1.Probe `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`
        // StartupProbe indicates that the Pod the Sidecar is running in has successfully initialized.
        // If specified, no other probes are executed until this completes successfully.
        // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
        // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
        // when it might take a long time to load data or warm a cache, than during steady-state operation.
        // This cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        StartupProbe *corev1.Probe `json:"startupProbe,omitempty" protobuf:"bytes,22,opt,name=startupProbe"`
        // Actions that the management system should take in response to Sidecar lifecycle events.
        // Cannot be updated.
        // +optional
        Lifecycle *corev1.Lifecycle `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
        // Optional: Path at which the file to which the Sidecar's termination message
        // will be written is mounted into the Sidecar's filesystem.
        // Message written is intended to be brief final status, such as an assertion failure message.
        // Will be truncated by the node if greater than 4096 bytes. The total message length across
        // all containers will be limited to 12kb.
        // Defaults to /dev/termination-log.
        // Cannot be updated.
        // +optional
        TerminationMessagePath string `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
        // Indicate how the termination message should be populated. File will use the contents of
        // terminationMessagePath to populate the Sidecar status message on both success and failure.
        // FallbackToLogsOnError will use the last chunk of Sidecar log output if the termination
        // message file is empty and the Sidecar exited with an error.
        // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
        // Defaults to File.
        // Cannot be updated.
        // +optional
        TerminationMessagePolicy corev1.TerminationMessagePolicy `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Sidecar should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

        // Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
        // and shouldn't be used for general purpose containers.

        // Whether this Sidecar should allocate a buffer for stdin in the container runtime. If this
        // is not set, reads from stdin in the Sidecar will always result in EOF.
        // Default is false.
        // +optional
        Stdin bool `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
        // Whether the container runtime should close the stdin channel after it has been opened by
        // a single attach. When stdin is true the stdin stream will remain open across multiple attach
        // sessions. If stdinOnce is set to true, stdin is opened on Sidecar start, is empty until the
        // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        // at which time stdin is closed and remains closed until the Sidecar is restarted. If this
        // flag is false, a container processes that reads from stdin will never receive an EOF.
        // Default is false
        // +optional
        StdinOnce bool `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
        // Whether this Sidecar should allocate a TTY for itself, also requires 'stdin' to be true.
        // Default is false.
        // +optional
        TTY bool `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`

        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command or Args.
        // +optional
        Script string `json:"script,omitempty"`

        // This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
        // for this field to be supported.
        //
        // Workspaces is a list of workspaces from the Task that this Sidecar wants
        // exclusive access to. Adding a workspace to this list means that any
        // other Step or Sidecar that does not also request this Workspace will
        // not have access to it.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceUsage `json:"workspaces,omitempty"`

        // RestartPolicy refers to kubernetes RestartPolicy. It can only be set for an
        // initContainer and must have it's policy set to "Always". It is currently
        // left optional to help support Kubernetes versions prior to 1.29 when this feature
        // was introduced.
        // +optional
        RestartPolicy *corev1.ContainerRestartPolicy `json:"restartPolicy,omitempty"`
}

// ToK8sContainer converts the Sidecar to a Kubernetes Container struct
func (s *Sidecar) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        if s.RestartPolicy == nil </span><span class="cov8" title="1">{
                return &amp;corev1.Container{
                        Name:                     s.Name,
                        Image:                    s.Image,
                        Command:                  s.Command,
                        Args:                     s.Args,
                        WorkingDir:               s.WorkingDir,
                        Ports:                    s.Ports,
                        EnvFrom:                  s.EnvFrom,
                        Env:                      s.Env,
                        Resources:                s.ComputeResources,
                        VolumeMounts:             s.VolumeMounts,
                        VolumeDevices:            s.VolumeDevices,
                        LivenessProbe:            s.LivenessProbe,
                        ReadinessProbe:           s.ReadinessProbe,
                        StartupProbe:             s.StartupProbe,
                        Lifecycle:                s.Lifecycle,
                        TerminationMessagePath:   s.TerminationMessagePath,
                        TerminationMessagePolicy: s.TerminationMessagePolicy,
                        ImagePullPolicy:          s.ImagePullPolicy,
                        SecurityContext:          s.SecurityContext,
                        Stdin:                    s.Stdin,
                        StdinOnce:                s.StdinOnce,
                        TTY:                      s.TTY,
                }
        }</span>
        <span class="cov8" title="1">return &amp;corev1.Container{
                Name:                     s.Name,
                Image:                    s.Image,
                Command:                  s.Command,
                Args:                     s.Args,
                WorkingDir:               s.WorkingDir,
                Ports:                    s.Ports,
                EnvFrom:                  s.EnvFrom,
                Env:                      s.Env,
                Resources:                s.ComputeResources,
                VolumeMounts:             s.VolumeMounts,
                VolumeDevices:            s.VolumeDevices,
                LivenessProbe:            s.LivenessProbe,
                ReadinessProbe:           s.ReadinessProbe,
                RestartPolicy:            s.RestartPolicy,
                StartupProbe:             s.StartupProbe,
                Lifecycle:                s.Lifecycle,
                TerminationMessagePath:   s.TerminationMessagePath,
                TerminationMessagePolicy: s.TerminationMessagePolicy,
                ImagePullPolicy:          s.ImagePullPolicy,
                SecurityContext:          s.SecurityContext,
                Stdin:                    s.Stdin,
                StdinOnce:                s.StdinOnce,
                TTY:                      s.TTY,
        }</span>
}

// SetContainerFields sets the fields of the Sidecar to the values of the corresponding fields in the Container
func (s *Sidecar) SetContainerFields(c corev1.Container) <span class="cov0" title="0">{
        s.Name = c.Name
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.Ports = c.Ports
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.ComputeResources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.LivenessProbe = c.LivenessProbe
        s.ReadinessProbe = c.ReadinessProbe
        s.StartupProbe = c.StartupProbe
        s.Lifecycle = c.Lifecycle
        s.TerminationMessagePath = c.TerminationMessagePath
        s.TerminationMessagePolicy = c.TerminationMessagePolicy
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
        s.Stdin = c.Stdin
        s.StdinOnce = c.StdinOnce
        s.TTY = c.TTY
        s.RestartPolicy = c.RestartPolicy
}</span>

// GetVarSubstitutionExpressions walks all the places a substitution reference can be used
func (s *Sidecar) GetVarSubstitutionExpressions() []string <span class="cov8" title="1">{
        var allExpressions []string
        allExpressions = append(allExpressions, validateString(s.Name)...)
        allExpressions = append(allExpressions, validateString(s.Image)...)
        allExpressions = append(allExpressions, validateString(string(s.ImagePullPolicy))...)
        allExpressions = append(allExpressions, validateString(s.Script)...)
        allExpressions = append(allExpressions, validateString(s.WorkingDir)...)
        for _, cmd := range s.Command </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(cmd)...)
        }</span>
        <span class="cov8" title="1">for _, arg := range s.Args </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(arg)...)
        }</span>
        <span class="cov8" title="1">for _, env := range s.Env </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(env.Value)...)
                if env.ValueFrom != nil </span><span class="cov8" title="1">{
                        if env.ValueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.SecretKeyRef.Key)...)
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.SecretKeyRef.LocalObjectReference.Name)...)
                        }</span>
                        <span class="cov8" title="1">if env.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.ConfigMapKeyRef.Key)...)
                                allExpressions = append(allExpressions, validateString(env.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name)...)
                        }</span>
                }
        }
        <span class="cov8" title="1">return allExpressions</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "slices"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// Validate ensures that a supplied Ref field is populated
// correctly. No errors are returned for a nil Ref.
func (ref *Ref) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return validateRef(ctx, ref.Name, ref.Resolver, ref.Params)</span>
}

func validateRef(ctx context.Context, refName string, refResolver ResolverName, refParams Params) (errs *apis.FieldError) <span class="cov8" title="1">{
        switch </span>{
        case refResolver != "" || refParams != nil:<span class="cov8" title="1">
                if refParams != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver params", config.BetaAPIFields).ViaField("params"))
                        if refName != "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name", "params"))
                        }</span>
                        <span class="cov8" title="1">if refResolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, refParams))</span>
                }
                <span class="cov8" title="1">if refResolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver", config.BetaAPIFields).ViaField("resolver"))
                        if refName != "" </span><span class="cov8" title="1">{
                                // make sure that the name is url-like.
                                err := RefNameLikeUrl(refName)
                                if err == nil &amp;&amp; !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                        // If name is url-like then concise resolver syntax must be enabled
                                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(err, "name"))
                                }</span>
                        }
                }
        case refName != "":<span class="cov8" title="1">
                // ref name can be a Url-like format.
                if err := RefNameLikeUrl(refName); err == nil </span><span class="cov8" title="1">{
                        // If name is url-like then concise resolver syntax must be enabled
                        if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                        }</span>
                        // In stage1 of concise remote resolvers syntax, this is a required field.
                        // TODO: remove this check when implementing stage 2 where this is optional.
                        <span class="cov8" title="1">if refResolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        // Or, it must be a valid k8s name
                } else<span class="cov8" title="1"> {
                        // ref name must be a valid k8s name
                        if errSlice := validation.IsQualifiedName(refName); len(errSlice) != 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(strings.Join(errSlice, ","), "name"))
                        }</span>
                }
        default:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("name"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// RefNameLikeUrl checks if the name is url parsable and returns an error if it isn't.
func RefNameLikeUrl(name string) error <span class="cov8" title="1">{
        schemeRegex := regexp.MustCompile(`[\w-]+:\/\/*`)
        if !schemeRegex.MatchString(name) </span><span class="cov8" title="1">{
                return errors.New("invalid URI for request")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate implements apis.Validatable
func (s *Step) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if err := validateArtifactsReferencesInStep(ctx, s); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if s.Ref != nil </span><span class="cov8" title="1">{
                errs = errs.Also(s.Ref.Validate(ctx))
                if s.Image != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "image cannot be used with Ref",
                                Paths:   []string{"image"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "command cannot be used with Ref",
                                Paths:   []string{"command"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Args) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "args cannot be used with Ref",
                                Paths:   []string{"args"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "script cannot be used with Ref",
                                Paths:   []string{"script"},
                        })
                }</span>
                <span class="cov8" title="1">if s.WorkingDir != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "working dir cannot be used with Ref",
                                Paths:   []string{"workingDir"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Env != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "env cannot be used with Ref",
                                Paths:   []string{"env"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.VolumeMounts) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "volumeMounts cannot be used with Ref",
                                Paths:   []string{"volumeMounts"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Results) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "results cannot be used with Ref",
                                Paths:   []string{"results"},
                        })
                }</span>
        } else<span class="cov8" title="1"> {
                if len(s.Params) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "params cannot be used without Ref",
                                Paths:   []string{"params"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Image == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("Image"))
                }</span>

                <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                        if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(&amp;apis.FieldError{
                                        Message: "script cannot be used with command",
                                        Paths:   []string{"script"},
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">if s.Name != "" </span><span class="cov8" title="1">{
                if e := validation.IsDNS1123Label(s.Name); len(e) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid value %q", s.Name),
                                Paths:   []string{"name"},
                                Details: "Task step name must be a valid DNS Label, For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        })
                }</span>
        }

        <span class="cov8" title="1">if s.Timeout != nil </span><span class="cov8" title="1">{
                if s.Timeout.Duration &lt; time.Duration(0) </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(s.Timeout.Duration, "negative timeout")
                }</span>
        }

        <span class="cov8" title="1">for j, vm := range s.VolumeMounts </span><span class="cov8" title="1">{
                if strings.HasPrefix(vm.MountPath, "/tekton/") &amp;&amp;
                        !strings.HasPrefix(vm.MountPath, "/tekton/home") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("volumeMount cannot be mounted under /tekton/ (volumeMount %q mounted at %q)", vm.Name, vm.MountPath), "mountPath").ViaFieldIndex("volumeMounts", j))
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(vm.Name, "tekton-internal-") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf(`volumeMount name %q cannot start with "tekton-internal-"`, vm.Name), "name").ViaFieldIndex("volumeMounts", j))
                }</span>
        }

        <span class="cov8" title="1">if s.OnError != "" </span><span class="cov8" title="1">{
                if !isParamRefs(string(s.OnError)) &amp;&amp; s.OnError != Continue &amp;&amp; s.OnError != StopAndFail </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid value: \"%v\"", s.OnError),
                                Paths:   []string{"onError"},
                                Details: "Task step onError must be either \"continue\" or \"stopAndFail\"",
                        })
                }</span>
        }

        <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                cleaned := strings.TrimSpace(s.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "windows script support", config.AlphaAPIFields).ViaField("script"))
                }</span>
        }

        // StdoutConfig is an alpha feature and will fail validation if it's used in a task spec
        // when the enable-api-fields feature gate is not "alpha".
        <span class="cov8" title="1">if s.StdoutConfig != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step stdout stream support", config.AlphaAPIFields).ViaField("stdoutconfig"))
        }</span>
        // StderrConfig is an alpha feature and will fail validation if it's used in a task spec
        // when the enable-api-fields feature gate is not "alpha".
        <span class="cov8" title="1">if s.StderrConfig != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step stderr stream support", config.AlphaAPIFields).ViaField("stderrconfig"))
        }</span>

        // Validate usage of step result reference.
        // Referencing previous step's results are only allowed in `env`, `command` and `args`.
        <span class="cov8" title="1">errs = errs.Also(validateStepResultReference(s))

        // Validate usage of step artifacts output reference
        // Referencing previous step's results are only allowed in `env`, `command` and `args`, `script`.
        errs = errs.Also(validateStepArtifactsReference(s))
        return errs</span>
}

// isParamRefs attempts to check if a specified string looks like it contains any parameter reference
// This is useful to make sure the specified value looks like a Parameter Reference before performing any strict validation
func isParamRefs(s string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(s, "$("+ParamsPrefix)
}</span>

func validateArtifactsReferencesInStep(ctx context.Context, s *Step) *apis.FieldError <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if cfg == nil || cfg.FeatureFlags == nil </span><span class="cov8" title="1">{
                cfg = &amp;config.Config{
                        FeatureFlags: &amp;config.FeatureFlags{},
                }
        }</span>

        <span class="cov8" title="1">if !cfg.FeatureFlags.EnableArtifacts </span><span class="cov8" title="1">{
                var t []string
                if s.Script != "" </span><span class="cov8" title="1">{
                        t = append(t, s.Script)
                }</span>
                <span class="cov8" title="1">if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                        t = append(t, s.Command...)
                }</span>
                <span class="cov8" title="1">if len(s.Args) &gt; 0 </span><span class="cov8" title="1">{
                        t = append(t, s.Args...)
                }</span>
                <span class="cov8" title="1">if s.Env != nil </span><span class="cov8" title="1">{
                        for _, e := range s.Env </span><span class="cov8" title="1">{
                                if e.Value != "" </span><span class="cov8" title="1">{
                                        t = append(t, e.Value)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if slices.ContainsFunc(t, stepArtifactReferenceExists) || slices.ContainsFunc(t, taskArtifactReferenceExists) </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func stepArtifactReferenceExists(src string) bool <span class="cov8" title="1">{
        return len(artifactref.StepArtifactRegex.FindAllStringSubmatch(src, -1)) &gt; 0 || strings.Contains(src, "$("+artifactref.StepArtifactPathPattern+")")
}</span>

func taskArtifactReferenceExists(src string) bool <span class="cov8" title="1">{
        return len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(src, -1)) &gt; 0 || strings.Contains(src, "$("+artifactref.TaskArtifactPathPattern+")")
}</span>

func validateStepResultReference(s *Step) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(errorIfStepResultReferencedInField(s.Name, "name"))
        errs = errs.Also(errorIfStepResultReferencedInField(s.Image, "image"))
        errs = errs.Also(errorIfStepResultReferencedInField(s.Script, "script"))
        errs = errs.Also(errorIfStepResultReferencedInField(string(s.ImagePullPolicy), "imagePullPolicy"))
        errs = errs.Also(errorIfStepResultReferencedInField(s.WorkingDir, "workingDir"))
        for _, e := range s.EnvFrom </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferencedInField(e.Prefix, "envFrom.prefix"))
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepResultReferencedInField(e.ConfigMapRef.LocalObjectReference.Name, "envFrom.configMapRef"))
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepResultReferencedInField(e.SecretRef.LocalObjectReference.Name, "envFrom.secretRef"))
                }</span>
        }
        <span class="cov8" title="1">for _, v := range s.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferencedInField(v.Name, "volumeMounts.name"))
                errs = errs.Also(errorIfStepResultReferencedInField(v.MountPath, "volumeMounts.mountPath"))
                errs = errs.Also(errorIfStepResultReferencedInField(v.SubPath, "volumeMounts.subPath"))
        }</span>
        <span class="cov8" title="1">for _, v := range s.VolumeDevices </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferencedInField(v.Name, "volumeDevices.name"))
                errs = errs.Also(errorIfStepResultReferencedInField(v.DevicePath, "volumeDevices.devicePath"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func errorIfStepResultReferencedInField(value, fieldName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        matches := resultref.StepResultRegex.FindAllStringSubmatch(value, -1)
        if len(matches) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "stepResult substitutions are only allowed in env, command and args. Found usage in",
                        Paths:   []string{fieldName},
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateStepArtifactsReference(s *Step) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.Name, "name"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.Image, "image"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(string(s.ImagePullPolicy), "imagePullPolicy"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.WorkingDir, "workingDir"))
        for _, e := range s.EnvFrom </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(e.Prefix, "envFrom.prefix"))
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepArtifactReferencedInField(e.ConfigMapRef.LocalObjectReference.Name, "envFrom.configMapRef"))
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepArtifactReferencedInField(e.SecretRef.LocalObjectReference.Name, "envFrom.secretRef"))
                }</span>
        }
        <span class="cov8" title="1">for _, v := range s.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.Name, "volumeMounts.name"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.MountPath, "volumeMounts.mountPath"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.SubPath, "volumeMounts.subPath"))
        }</span>
        <span class="cov8" title="1">for _, v := range s.VolumeDevices </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.Name, "volumeDevices.name"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.DevicePath, "volumeDevices.devicePath"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func errorIfStepArtifactReferencedInField(value, fieldName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if stepArtifactReferenceExists(value) </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "stepArtifact substitutions are only allowed in env, command, args and script. Found usage in",
                        Paths:   []string{fieldName},
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (sc *Sidecar) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if sc.Name == pipeline.ReservedResultsSidecarName </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("Invalid: cannot use reserved sidecar name %v ", sc.Name),
                        Paths:   []string{"name"},
                })
        }</span>

        <span class="cov8" title="1">if sc.Image == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("image"))
        }</span>

        <span class="cov8" title="1">if sc.Script != "" </span><span class="cov8" title="1">{
                if len(sc.Command) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "script cannot be used with command",
                                Paths:   []string{"script"},
                        })
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "maps"
        "sort"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
)

// Matrix is used to fan out Tasks in a Pipeline
type Matrix struct {
        // Params is a list of parameters used to fan out the pipelineTask
        // Params takes only `Parameters` of type `"array"`
        // Each array element is supplied to the `PipelineTask` by substituting `params` of type `"string"` in the underlying `Task`.
        // The names of the `params` in the `Matrix` must match the names of the `params` in the underlying `Task` that they will be substituting.
        Params Params `json:"params,omitempty"`

        // Include is a list of IncludeParams which allows passing in specific combinations of Parameters into the Matrix.
        // +optional
        Include IncludeParamsList `json:"include,omitempty"`
}

// IncludeParamsList is a list of IncludeParams which allows passing in specific combinations of Parameters into the Matrix.
// +listType=atomic
type IncludeParamsList []IncludeParams

// IncludeParams allows passing in a specific combinations of Parameters into the Matrix.
type IncludeParams struct {
        // Name the specified combination
        Name string `json:"name,omitempty"`

        // Params takes only `Parameters` of type `"string"`
        // The names of the `params` must match the names of the `params` in the underlying `Task`
        Params Params `json:"params,omitempty"`
}

// Combination is a map, mainly defined to hold a single combination from a Matrix with key as param.Name and value as param.Value
type Combination map[string]string

// Combinations is a Combination list
type Combinations []Combination

// FanOut returns an list of params that represent combinations
func (m *Matrix) FanOut() []Params <span class="cov8" title="1">{
        var combinations, includeCombinations Combinations
        includeCombinations = m.getIncludeCombinations()
        if m.HasInclude() &amp;&amp; !m.HasParams() </span><span class="cov8" title="1">{
                // If there are only Matrix Include Parameters return explicit combinations
                return includeCombinations.toParams()
        }</span>
        // Generate combinations from Matrix Parameters
        <span class="cov8" title="1">for _, parameter := range m.Params </span><span class="cov8" title="1">{
                combinations = combinations.fanOutMatrixParams(parameter)
        }</span>
        <span class="cov8" title="1">combinations.overwriteCombinations(includeCombinations)
        combinations = combinations.addNewCombinations(includeCombinations)
        return combinations.toParams()</span>
}

// overwriteCombinations replaces any missing include params in the initial
// matrix params combinations by overwriting the initial combinations with the
// include combinations
func (cs Combinations) overwriteCombinations(ics Combinations) <span class="cov8" title="1">{
        for _, paramCombination := range cs </span><span class="cov8" title="1">{
                for _, includeCombination := range ics </span><span class="cov8" title="1">{
                        if paramCombination.contains(includeCombination) </span><span class="cov8" title="1">{
                                // overwrite the parameter name and value in existing combination
                                // with the include combination
                                for name, val := range includeCombination </span><span class="cov8" title="1">{
                                        paramCombination[name] = val
                                }</span>
                        }
                }
        }
}

// addNewCombinations creates a new combination for any include parameter
// values that are missing entirely from the initial combinations and
// returns all combinations
func (cs Combinations) addNewCombinations(ics Combinations) Combinations <span class="cov8" title="1">{
        for _, includeCombination := range ics </span><span class="cov8" title="1">{
                if cs.shouldAddNewCombination(includeCombination) </span><span class="cov8" title="1">{
                        cs = append(cs, includeCombination)
                }</span>
        }
        <span class="cov8" title="1">return cs</span>
}

// contains returns true if the include parameter name and value exists in combinations
func (c Combination) contains(includeCombination Combination) bool <span class="cov8" title="1">{
        for name, val := range includeCombination </span><span class="cov8" title="1">{
                if _, exist := c[name]; exist </span><span class="cov8" title="1">{
                        if c[name] != val </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// shouldAddNewCombination returns true if the include parameter name exists but the value is
// missing from combinations
func (cs Combinations) shouldAddNewCombination(includeCombination map[string]string) bool <span class="cov8" title="1">{
        if len(includeCombination) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, paramCombination := range cs </span><span class="cov8" title="1">{
                for name, val := range includeCombination </span><span class="cov8" title="1">{
                        if _, exist := paramCombination[name]; exist </span><span class="cov8" title="1">{
                                if paramCombination[name] == val </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return true</span>
}

// toParams transforms Combinations from a slice of map[string]string to a slice of Params
// such that, these combinations can be directly consumed in creating taskRun/run object
func (cs Combinations) toParams() []Params <span class="cov8" title="1">{
        listOfParams := make([]Params, len(cs))
        for i := range cs </span><span class="cov8" title="1">{
                var params Params
                combination := cs[i]
                order, _ := combination.sortCombination()
                for _, key := range order </span><span class="cov8" title="1">{
                        params = append(params, Param{
                                Name:  key,
                                Value: ParamValue{Type: ParamTypeString, StringVal: combination[key]},
                        })
                }</span>
                <span class="cov8" title="1">listOfParams[i] = params</span>
        }
        <span class="cov8" title="1">return listOfParams</span>
}

// fanOutMatrixParams generates new combinations based on Matrix Parameters.
func (cs Combinations) fanOutMatrixParams(param Param) Combinations <span class="cov8" title="1">{
        if len(cs) == 0 </span><span class="cov8" title="1">{
                return initializeCombinations(param)
        }</span>
        <span class="cov8" title="1">return cs.distribute(param)</span>
}

// getIncludeCombinations generates combinations based on Matrix Include Parameters
func (m *Matrix) getIncludeCombinations() Combinations <span class="cov8" title="1">{
        var combinations Combinations
        for i := range m.Include </span><span class="cov8" title="1">{
                includeParams := m.Include[i].Params
                newCombination := make(Combination)
                for _, param := range includeParams </span><span class="cov8" title="1">{
                        newCombination[param.Name] = param.Value.StringVal
                }</span>
                <span class="cov8" title="1">combinations = append(combinations, newCombination)</span>
        }
        <span class="cov8" title="1">return combinations</span>
}

// distribute generates a new Combination of Parameters by adding a new Parameter to an existing list of Combinations.
func (cs Combinations) distribute(param Param) Combinations <span class="cov8" title="1">{
        var expandedCombinations Combinations
        for _, value := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                for _, combination := range cs </span><span class="cov8" title="1">{
                        newCombination := make(Combination)
                        maps.Copy(newCombination, combination)
                        newCombination[param.Name] = value
                        _, orderedCombination := newCombination.sortCombination()
                        expandedCombinations = append(expandedCombinations, orderedCombination)
                }</span>
        }
        <span class="cov8" title="1">return expandedCombinations</span>
}

// initializeCombinations generates a new Combination based on the first Parameter in the Matrix.
func initializeCombinations(param Param) Combinations <span class="cov8" title="1">{
        var combinations Combinations
        for _, value := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                combinations = append(combinations, Combination{param.Name: value})
        }</span>
        <span class="cov8" title="1">return combinations</span>
}

// sortCombination sorts the given Combination based on the Parameter names to produce a deterministic ordering
func (c Combination) sortCombination() ([]string, Combination) <span class="cov8" title="1">{
        sortedCombination := make(Combination, len(c))
        order := make([]string, 0, len(c))
        for key := range c </span><span class="cov8" title="1">{
                order = append(order, key)
        }</span>
        <span class="cov8" title="1">sort.Slice(order, func(i, j int) bool </span><span class="cov8" title="1">{
                return order[i] &lt;= order[j]
        }</span>)
        <span class="cov8" title="1">for _, key := range order </span><span class="cov8" title="1">{
                sortedCombination[key] = c[key]
        }</span>
        <span class="cov8" title="1">return order, sortedCombination</span>
}

// CountCombinations returns the count of Combinations of Parameters generated from the Matrix in PipelineTask.
func (m *Matrix) CountCombinations() int <span class="cov8" title="1">{
        // Iterate over Matrix Parameters and compute count of all generated Combinations
        count := m.countGeneratedCombinationsFromParams()

        // Add any additional Combinations generated from Matrix Include Parameters
        count += m.countNewCombinationsFromInclude()

        return count
}</span>

// countGeneratedCombinationsFromParams returns the count of Combinations of Parameters generated from the Matrix
// Parameters
func (m *Matrix) countGeneratedCombinationsFromParams() int <span class="cov8" title="1">{
        if !m.HasParams() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">count := 1
        for _, param := range m.Params </span><span class="cov8" title="1">{
                if len(param.Value.ArrayVal) &gt; 0 </span><span class="cov8" title="1">{
                        count *= len(param.Value.ArrayVal)
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// countNewCombinationsFromInclude returns the count of Combinations of Parameters generated from the Matrix
// Include Parameters
func (m *Matrix) countNewCombinationsFromInclude() int <span class="cov8" title="1">{
        if !m.HasInclude() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if !m.HasParams() </span><span class="cov8" title="1">{
                return len(m.Include)
        }</span>
        <span class="cov8" title="1">count := 0
        matrixParamMap := m.Params.extractParamMapArrVals()
        for _, include := range m.Include </span><span class="cov8" title="1">{
                for _, param := range include.Params </span><span class="cov8" title="1">{
                        if val, exist := matrixParamMap[param.Name]; exist </span><span class="cov8" title="1">{
                                // If the Matrix Include param values does not exist, a new Combination will be generated
                                if !slices.Contains(val, param.Value.StringVal) </span><span class="cov8" title="1">{
                                        count++
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return count</span>
}

// HasInclude returns true if the Matrix has Include Parameters
func (m *Matrix) HasInclude() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.Include != nil &amp;&amp; len(m.Include) &gt; 0
}</span>

// HasParams returns true if the Matrix has Parameters
func (m *Matrix) HasParams() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.Params != nil &amp;&amp; len(m.Params) &gt; 0
}</span>

// GetAllParams returns a list of all Matrix Parameters
func (m *Matrix) GetAllParams() Params <span class="cov8" title="1">{
        var params Params
        if m.HasParams() </span><span class="cov8" title="1">{
                params = append(params, m.Params...)
        }</span>
        <span class="cov8" title="1">if m.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range m.Include </span><span class="cov8" title="1">{
                        params = append(params, include.Params...)
                }</span>
        }
        <span class="cov8" title="1">return params</span>
}

func (m *Matrix) validateCombinationsCount(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        matrixCombinationsCount := m.CountCombinations()
        maxMatrixCombinationsCount := config.FromContextOrDefaults(ctx).Defaults.DefaultMaxMatrixCombinationsCount
        if matrixCombinationsCount &gt; maxMatrixCombinationsCount </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrOutOfBoundsValue(matrixCombinationsCount, 0, maxMatrixCombinationsCount, "matrix"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateUniqueParams validates Matrix.Params for a unique list of params
// and a unique list of params in each Matrix.Include.Params specification
func (m *Matrix) validateUniqueParams() (errs *apis.FieldError) <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                if m.HasInclude() </span><span class="cov8" title="1">{
                        for i, include := range m.Include </span><span class="cov8" title="1">{
                                errs = errs.Also(include.Params.validateDuplicateParameters().ViaField(fmt.Sprintf("matrix.include[%d].params", i)))
                        }</span>
                }
                <span class="cov8" title="1">if m.HasParams() </span><span class="cov8" title="1">{
                        errs = errs.Also(m.Params.validateDuplicateParameters().ViaField("matrix.params"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineParametersVariablesInMatrixParameters validates all pipeline parameter variables including Matrix.Params and Matrix.Include.Params
// that may contain the reference(s) to other params to make sure those references are used appropriately.
func (m *Matrix) validatePipelineParametersVariablesInMatrixParameters(prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if m.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range m.Include </span><span class="cov8" title="1">{
                        for idx, param := range include.Params </span><span class="cov8" title="1">{
                                stringElement := param.Value.StringVal
                                // Matrix Include Params must be of type string
                                errs = errs.Also(validateStringVariable(stringElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("", idx).ViaField("matrix.include.params", ""))
                        }</span>
                }
        }
        <span class="cov8" title="1">if m.HasParams() </span><span class="cov8" title="1">{
                for _, param := range m.Params </span><span class="cov8" title="1">{
                        for idx, arrayElement := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                // Matrix Params must be of type array
                                errs = errs.Also(validateArrayVariable(arrayElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("value", idx).ViaFieldKey("matrix.params", param.Name))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (m *Matrix) validateParameterInOneOfMatrixOrParams(params []Param) (errs *apis.FieldError) <span class="cov8" title="1">{
        matrixParamNames := m.GetAllParams().ExtractNames()
        for _, param := range params </span><span class="cov8" title="1">{
                if matrixParamNames.Has(param.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("matrix["+param.Name+"]", "params["+param.Name+"]"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "encoding/json"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/strategicpatch"
)

// mergeData is used to store the intermediate data needed to merge an object
// with a template. It's provided to avoid repeatedly re-serializing the template.
// +k8s:openapi-gen=false
type mergeData struct {
        emptyJSON    []byte
        templateJSON []byte
        patchSchema  strategicpatch.PatchMetaFromStruct
}

// MergeStepsWithStepTemplate takes a possibly nil container template and a
// list of steps, merging each of the steps with the container template, if
// it's not nil, and returning the resulting list.
func MergeStepsWithStepTemplate(template *StepTemplate, steps []Step) ([]Step, error) <span class="cov8" title="1">{
        if template == nil </span><span class="cov8" title="1">{
                return steps, nil
        }</span>

        <span class="cov8" title="1">md, err := getMergeData(template.ToK8sContainer(), &amp;corev1.Container{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                // If the stepaction has not been fetched yet then do not merge.
                // Skip over to the next one
                if s.Ref != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := corev1.Container{}
                err := mergeObjWithTemplateBytes(md, s.ToK8sContainer(), &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // If the container's args is nil, reset it to empty instead
                <span class="cov8" title="1">if merged.Args == nil &amp;&amp; s.Args != nil </span><span class="cov0" title="0">{
                        merged.Args = []string{}
                }</span>

                <span class="cov8" title="1">amendConflictingContainerFields(&amp;merged, s)

                // Pass through original step Script, for later conversion.
                newStep := Step{
                        Script:       s.Script,
                        OnError:      s.OnError,
                        Timeout:      s.Timeout,
                        StdoutConfig: s.StdoutConfig,
                        StderrConfig: s.StderrConfig,
                        Results:      s.Results,
                        Params:       s.Params,
                        Ref:          s.Ref,
                        When:         s.When,
                        Workspaces:   s.Workspaces,
                }
                newStep.SetContainerFields(merged)
                steps[i] = newStep</span>
        }
        <span class="cov8" title="1">return steps, nil</span>
}

// MergeStepsWithSpecs takes a possibly nil list of overrides and a
// list of steps, merging each of the steps with the overrides' resource requirements, if
// it's not nil, and returning the resulting list.
func MergeStepsWithSpecs(steps []Step, overrides []TaskRunStepSpec) ([]Step, error) <span class="cov8" title="1">{
        stepNameToOverride := make(map[string]TaskRunStepSpec, len(overrides))
        for _, o := range overrides </span><span class="cov8" title="1">{
                stepNameToOverride[o.Name] = o
        }</span>
        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                o, found := stepNameToOverride[s.Name]
                if !found </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := corev1.ResourceRequirements{}
                err := mergeObjWithTemplate(&amp;s.ComputeResources, &amp;o.ComputeResources, &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">steps[i].ComputeResources = merged</span>
        }
        <span class="cov8" title="1">return steps, nil</span>
}

// MergeSidecarsWithSpecs takes a possibly nil list of overrides and a
// list of sidecars, merging each of the sidecars with the overrides' resource requirements, if
// it's not nil, and returning the resulting list.
func MergeSidecarsWithSpecs(sidecars []Sidecar, overrides []TaskRunSidecarSpec) ([]Sidecar, error) <span class="cov8" title="1">{
        if len(overrides) == 0 </span><span class="cov8" title="1">{
                return sidecars, nil
        }</span>
        <span class="cov8" title="1">sidecarNameToOverride := make(map[string]TaskRunSidecarSpec, len(overrides))
        for _, o := range overrides </span><span class="cov8" title="1">{
                sidecarNameToOverride[o.Name] = o
        }</span>
        <span class="cov8" title="1">for i, s := range sidecars </span><span class="cov8" title="1">{
                o, found := sidecarNameToOverride[s.Name]
                if !found </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := corev1.ResourceRequirements{}
                err := mergeObjWithTemplate(&amp;s.ComputeResources, &amp;o.ComputeResources, &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">sidecars[i].ComputeResources = merged</span>
        }
        <span class="cov8" title="1">return sidecars, nil</span>
}

// mergeObjWithTemplate merges obj with template and updates out to reflect the merged result.
// template, obj, and out should point to the same type. out points to the zero value of that type.
func mergeObjWithTemplate(template, obj, out interface{}) error <span class="cov8" title="1">{
        md, err := getMergeData(template, out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return mergeObjWithTemplateBytes(md, obj, out)</span>
}

// getMergeData serializes the template and empty object to get the intermediate results necessary for
// merging an object of the same type with this template.
// This function is provided to avoid repeatedly serializing an identical template.
func getMergeData(template, empty interface{}) (*mergeData, error) <span class="cov8" title="1">{
        // We need JSON bytes to generate a patch to merge the object
        // onto the template, so marshal the template.
        templateJSON, err := json.Marshal(template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // We need to do a three-way merge to actually merge the template and
        // object, so we need an empty object as the "original"
        <span class="cov8" title="1">emptyJSON, err := json.Marshal(empty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Get the patch meta, which is needed for generating and applying the merge patch.
        <span class="cov8" title="1">patchSchema, err := strategicpatch.NewPatchMetaFromStruct(template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;mergeData{templateJSON: templateJSON, emptyJSON: emptyJSON, patchSchema: patchSchema}, nil</span>
}

// mergeObjWithTemplateBytes merges obj with md's template JSON and updates out to reflect the merged result.
// out is a pointer to the zero value of obj's type.
// This function is provided to avoid repeatedly serializing an identical template.
func mergeObjWithTemplateBytes(md *mergeData, obj, out interface{}) error <span class="cov8" title="1">{
        // Marshal the object to JSON
        objAsJSON, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Create a merge patch, with the empty JSON as the original, the object JSON as the modified, and the template
        // JSON as the current - this lets us do a deep merge of the template and object, with awareness of
        // the "patchMerge" tags.
        <span class="cov8" title="1">patch, err := strategicpatch.CreateThreeWayMergePatch(md.emptyJSON, objAsJSON, md.templateJSON, md.patchSchema, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Actually apply the merge patch to the template JSON.
        <span class="cov8" title="1">mergedAsJSON, err := strategicpatch.StrategicMergePatchUsingLookupPatchMeta(md.templateJSON, patch, md.patchSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Unmarshal the merged JSON to a pointer, and return it.
        <span class="cov8" title="1">return json.Unmarshal(mergedAsJSON, out)</span>
}

// amendConflictingContainerFields amends conflicting container fields after merge, and overrides conflicting fields
// by fields in step.
func amendConflictingContainerFields(container *corev1.Container, step Step) <span class="cov8" title="1">{
        if container == nil || len(step.Env) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">envNameToStepEnv := make(map[string]corev1.EnvVar, len(step.Env))
        for _, e := range step.Env </span><span class="cov8" title="1">{
                envNameToStepEnv[e.Name] = e
        }</span>

        <span class="cov8" title="1">for index, env := range container.Env </span><span class="cov8" title="1">{
                if env.ValueFrom != nil &amp;&amp; len(env.Value) &gt; 0 </span><span class="cov8" title="1">{
                        if e, ok := envNameToStepEnv[env.Name]; ok </span><span class="cov8" title="1">{
                                container.Env[index] = e
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/substitution"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
)

// ParamsPrefix is the prefix used in $(...) expressions referring to parameters
const ParamsPrefix = "params"

// ParamSpec defines arbitrary parameters needed beyond typed inputs (such as
// resources). Parameter values are provided by users as inputs on a TaskRun
// or PipelineRun.
type ParamSpec struct {
        // Name declares the name by which a parameter is referenced.
        Name string `json:"name"`
        // Type is the user-specified type of the parameter. The possible types
        // are currently "string", "array" and "object", and "string" is the default.
        // +optional
        Type ParamType `json:"type,omitempty"`
        // Description is a user-facing description of the parameter that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Properties is the JSON Schema properties to support key-value pairs parameter.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`
        // Default is the value a parameter takes if no input value is supplied. If
        // default is set, a Task may be executed without a supplied value for the
        // parameter.
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Default *ParamValue `json:"default,omitempty"`
        // Enum declares a set of allowed param input values for tasks/pipelines that can be validated.
        // If Enum is not set, no input validation is performed for the param.
        // +optional
        Enum []string `json:"enum,omitempty"`
}

// ParamSpecs is a list of ParamSpec
// +listType=atomic
type ParamSpecs []ParamSpec

// PropertySpec defines the struct for object keys
type PropertySpec struct {
        Type ParamType `json:"type,omitempty"`
}

// SetDefaults set the default type
func (pp *ParamSpec) SetDefaults(context.Context) <span class="cov8" title="1">{
        if pp == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Propagate inferred type to the parent ParamSpec's type, and default type to the PropertySpec's type
        // The sequence to look at is type in ParamSpec -&gt; properties -&gt; type in default -&gt; array/string/object value in default
        // If neither `properties` or `default` section is provided, ParamTypeString will be the default type.
        <span class="cov8" title="1">switch </span>{
        case pp.Type != "":<span class="cov8" title="1">
                // If param type is provided by the author, do nothing but just set default type for PropertySpec in case `properties` section is provided.
                pp.setDefaultsForProperties()</span>
        case pp.Properties != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeObject
                // Also set default type for PropertySpec
                pp.setDefaultsForProperties()</span>
        case pp.Default == nil:<span class="cov8" title="1">
                // ParamTypeString is the default value (when no type can be inferred from the default value)
                pp.Type = ParamTypeString</span>
        case pp.Default.Type != "":<span class="cov8" title="1">
                pp.Type = pp.Default.Type</span>
        case pp.Default.ArrayVal != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeArray</span>
        case pp.Default.ObjectVal != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeObject</span>
        default:<span class="cov8" title="1">
                pp.Type = ParamTypeString</span>
        }
}

// setDefaultsForProperties sets default type for PropertySpec (string) if it's not specified
func (pp *ParamSpec) setDefaultsForProperties() <span class="cov8" title="1">{
        for key, propertySpec := range pp.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type == "" </span><span class="cov8" title="1">{
                        pp.Properties[key] = PropertySpec{Type: ParamTypeString}
                }</span>
        }
}

// GetNames returns all the names of the declared parameters
func (ps ParamSpecs) GetNames() []string <span class="cov8" title="1">{
        var names []string
        for _, p := range ps </span><span class="cov8" title="1">{
                names = append(names, p.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// SortByType splits the input params into string params, array params, and object params, in that order
func (ps ParamSpecs) SortByType() (ParamSpecs, ParamSpecs, ParamSpecs) <span class="cov8" title="1">{
        var stringParams, arrayParams, objectParams ParamSpecs
        for _, p := range ps </span><span class="cov8" title="1">{
                switch p.Type </span>{
                case ParamTypeArray:<span class="cov8" title="1">
                        arrayParams = append(arrayParams, p)</span>
                case ParamTypeObject:<span class="cov8" title="1">
                        objectParams = append(objectParams, p)</span>
                case ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        stringParams = append(stringParams, p)</span>
                }
        }
        <span class="cov8" title="1">return stringParams, arrayParams, objectParams</span>
}

// ValidateNoDuplicateNames returns an error if any of the params have the same name
func (ps ParamSpecs) ValidateNoDuplicateNames() *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        names := ps.GetNames()
        for dup := range findDups(names) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("parameter appears more than once", "").ViaFieldKey("params", dup))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateParamEnums validates feature flag, duplication and allowed types for Param Enum
func (ps ParamSpecs) validateParamEnums(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for _, p := range ps </span><span class="cov8" title="1">{
                if len(p.Enum) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                        errs = errs.Also(errs, apis.ErrGeneric(fmt.Sprintf("feature flag `%s` should be set to true to use Enum", config.EnableParamEnum), "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">if p.Type != ParamTypeString </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("enum can only be set with string type param", "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">for dup := range findDups(p.Enum) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("parameter enum value %v appears more than once", dup), "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">if p.Default != nil &amp;&amp; p.Default.StringVal != "" </span><span class="cov8" title="1">{
                        if !slices.Contains(p.Enum, p.Default.StringVal) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("param default value %v not in the enum list", p.Default.StringVal), "").ViaKey(p.Name))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// findDups returns the duplicate element in the given slice
func findDups(vals []string) sets.String <span class="cov8" title="1">{
        seen := sets.String{}
        dups := sets.String{}
        for _, val := range vals </span><span class="cov8" title="1">{
                if seen.Has(val) </span><span class="cov8" title="1">{
                        dups.Insert(val)
                }</span>
                <span class="cov8" title="1">seen.Insert(val)</span>
        }
        <span class="cov8" title="1">return dups</span>
}

// Param declares an ParamValues to use for the parameter called name.
type Param struct {
        Name string `json:"name"`
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ParamValue `json:"value"`
}

// GetVarSubstitutionExpressions extracts all the value between "$(" and ")"" for a Parameter
func (p Param) GetVarSubstitutionExpressions() ([]string, bool) <span class="cov8" title="1">{
        var allExpressions []string
        switch p.Value.Type </span>{
        case ParamTypeArray:<span class="cov8" title="1">
                // array type
                for _, value := range p.Value.ArrayVal </span><span class="cov8" title="1">{
                        allExpressions = append(allExpressions, validateString(value)...)
                }</span>
        case ParamTypeString:<span class="cov8" title="1">
                // string type
                allExpressions = append(allExpressions, validateString(p.Value.StringVal)...)</span>
        case ParamTypeObject:<span class="cov8" title="1">
                // object type
                for _, value := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                        allExpressions = append(allExpressions, validateString(value)...)
                }</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}

// ExtractNames returns a set of unique names
func (ps Params) ExtractNames() sets.String <span class="cov8" title="1">{
        names := sets.String{}
        for _, p := range ps </span><span class="cov8" title="1">{
                names.Insert(p.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

func (ps Params) extractValues() []string <span class="cov8" title="1">{
        pvs := []string{}
        for i := range ps </span><span class="cov8" title="1">{
                pvs = append(pvs, ps[i].Value.StringVal)
                pvs = append(pvs, ps[i].Value.ArrayVal...)
                for _, v := range ps[i].Value.ObjectVal </span><span class="cov8" title="1">{
                        pvs = append(pvs, v)
                }</span>
        }
        <span class="cov8" title="1">return pvs</span>
}

// extractParamMapArrVals creates a param map with the key: param.Name and
// val: param.Value.ArrayVal
func (ps Params) extractParamMapArrVals() map[string][]string <span class="cov8" title="1">{
        paramsMap := make(map[string][]string)
        for _, p := range ps </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.ArrayVal
        }</span>
        <span class="cov8" title="1">return paramsMap</span>
}

// ParseTaskandResultName parses "task name", "result name" from a Matrix Context Variable
// Valid Example 1:
// - Input: tasks.myTask.matrix.length
// - Output: "myTask", ""
// Valid Example 2:
// - Input: tasks.myTask.matrix.ResultName.length
// - Output: "myTask", "ResultName"
func (p Param) ParseTaskandResultName() (string, string) <span class="cov8" title="1">{
        if expressions, ok := p.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                for _, expression := range expressions </span><span class="cov8" title="1">{
                        subExpressions := strings.Split(expression, ".")
                        pipelineTaskName := subExpressions[1]
                        if len(subExpressions) == 4 </span><span class="cov8" title="1">{
                                return pipelineTaskName, ""
                        }</span> else<span class="cov8" title="1"> if len(subExpressions) == 5 </span><span class="cov8" title="1">{
                                resultName := subExpressions[3]
                                return pipelineTaskName, resultName
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", ""</span>
}

// Params is a list of Param
// +listType=atomic
type Params []Param

// ExtractParamArrayLengths extract and return the lengths of all array params
// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
func (ps Params) ExtractParamArrayLengths() map[string]int <span class="cov8" title="1">{
        // Collect all array params
        arrayParamsLengths := make(map[string]int)

        // Collect array params lengths from params
        for _, p := range ps </span><span class="cov8" title="1">{
                if p.Value.Type == ParamTypeArray </span><span class="cov8" title="1">{
                        arrayParamsLengths[p.Name] = len(p.Value.ArrayVal)
                }</span>
        }
        <span class="cov8" title="1">return arrayParamsLengths</span>
}

// validateDuplicateParameters checks if a parameter with the same name is defined more than once
func (ps Params) validateDuplicateParameters() (errs *apis.FieldError) <span class="cov8" title="1">{
        taskParamNames := sets.NewString()
        for i, param := range ps </span><span class="cov8" title="1">{
                if taskParamNames.Has(param.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("parameter names must be unique,"+
                                " the parameter \"%s\" is also defined at", param.Name), fmt.Sprintf("[%d].name", i)))
                }</span>
                <span class="cov8" title="1">taskParamNames.Insert(param.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ReplaceVariables applies string, array and object replacements to variables in Params
func (ps Params) ReplaceVariables(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) Params <span class="cov8" title="1">{
        params := ps.DeepCopy()
        for i := range params </span><span class="cov8" title="1">{
                params[i].Value.ApplyReplacements(stringReplacements, arrayReplacements, objectReplacements)
        }</span>
        <span class="cov8" title="1">return params</span>
}

// ExtractDefaultParamArrayLengths extract and return the lengths of all array params
// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
func (ps ParamSpecs) ExtractDefaultParamArrayLengths() map[string]int <span class="cov8" title="1">{
        // Collect all array params
        arrayParamsLengths := make(map[string]int)

        // Collect array params lengths from defaults
        for _, p := range ps </span><span class="cov8" title="1">{
                if p.Default != nil </span><span class="cov8" title="1">{
                        if p.Default.Type == ParamTypeArray </span><span class="cov8" title="1">{
                                arrayParamsLengths[p.Name] = len(p.Default.ArrayVal)
                        }</span>
                }
        }
        <span class="cov8" title="1">return arrayParamsLengths</span>
}

// extractArrayIndexingParamRefs takes a string of the form `foo-$(params.array-param[1])-bar` and extracts the portions of the string that reference an element in an array param.
// For example, for the string foo-$(params.array-param[1])-bar-$(params.other-array-param[2])-$(params.string-param)`,
// it would return ["$(params.array-param[1])", "$(params.other-array-param[2])"].
func extractArrayIndexingParamRefs(paramReference string) []string <span class="cov8" title="1">{
        l := []string{}
        list := substitution.ExtractArrayIndexingParamsExpressions(paramReference)
        for _, val := range list </span><span class="cov8" title="1">{
                indexString := substitution.ExtractIndexString(val)
                if indexString != "" </span><span class="cov8" title="1">{
                        l = append(l, val)
                }</span>
        }
        <span class="cov8" title="1">return l</span>
}

// extractParamRefsFromSteps get all array indexing references from steps
func extractParamRefsFromSteps(steps []Step) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for _, step := range steps </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, step.Script)
                container := step.ToK8sContainer()
                paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromStepTemplate get all array indexing references from StepsTemplate
func extractParamRefsFromStepTemplate(stepTemplate *StepTemplate) []string <span class="cov8" title="1">{
        if stepTemplate == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">container := stepTemplate.ToK8sContainer()
        return extractParamRefsFromContainer(container)</span>
}

// extractParamRefsFromSidecars get all array indexing references from sidecars
func extractParamRefsFromSidecars(sidecars []Sidecar) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for _, s := range sidecars </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, s.Script)
                container := s.ToK8sContainer()
                paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromVolumes get all array indexing references from volumes
func extractParamRefsFromVolumes(volumes []corev1.Volume) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for i, v := range volumes </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.Name)
                if v.VolumeSource.ConfigMap != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.ConfigMap.Name)
                        for _, item := range v.ConfigMap.Items </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, item.Key)
                                paramsRefs = append(paramsRefs, item.Path)
                        }</span>
                }
                <span class="cov8" title="1">if v.VolumeSource.Secret != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.Secret.SecretName)
                        for _, item := range v.Secret.Items </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, item.Key)
                                paramsRefs = append(paramsRefs, item.Path)
                        }</span>
                }
                <span class="cov8" title="1">if v.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.PersistentVolumeClaim.ClaimName)
                }</span>
                <span class="cov8" title="1">if v.Projected != nil </span><span class="cov8" title="1">{
                        for _, s := range volumes[i].Projected.Sources </span><span class="cov8" title="1">{
                                if s.ConfigMap != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.ConfigMap.Name)
                                }</span>
                                <span class="cov8" title="1">if s.Secret != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.Secret.Name)
                                }</span>
                                <span class="cov8" title="1">if s.ServiceAccountToken != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.ServiceAccountToken.Audience)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if v.CSI != nil </span><span class="cov8" title="1">{
                        if v.CSI.NodePublishSecretRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, v.CSI.NodePublishSecretRef.Name)
                        }</span>
                        <span class="cov8" title="1">if v.CSI.VolumeAttributes != nil </span><span class="cov8" title="1">{
                                for _, value := range v.CSI.VolumeAttributes </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, value)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromContainer get all array indexing references from container
func extractParamRefsFromContainer(c *corev1.Container) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        paramsRefs = append(paramsRefs, c.Name)
        paramsRefs = append(paramsRefs, c.Image)
        paramsRefs = append(paramsRefs, string(c.ImagePullPolicy))
        paramsRefs = append(paramsRefs, c.Args...)

        for ie, e := range c.Env </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, e.Value)
                if c.Env[ie].ValueFrom != nil </span><span class="cov8" title="1">{
                        if e.ValueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.LocalObjectReference.Name)
                                paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.Key)
                        }</span>
                        <span class="cov8" title="1">if e.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name)
                                paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.Key)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, e := range c.EnvFrom </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, e.Prefix)
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, e.ConfigMapRef.LocalObjectReference.Name)
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, e.SecretRef.LocalObjectReference.Name)
                }</span>
        }

        <span class="cov8" title="1">paramsRefs = append(paramsRefs, c.WorkingDir)
        paramsRefs = append(paramsRefs, c.Command...)

        for _, v := range c.VolumeMounts </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.Name)
                paramsRefs = append(paramsRefs, v.MountPath)
                paramsRefs = append(paramsRefs, v.SubPath)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// ParamType indicates the type of an input parameter;
// Used to distinguish between a single string and an array of strings.
type ParamType string

// Valid ParamTypes:
const (
        ParamTypeString ParamType = "string"
        ParamTypeArray  ParamType = "array"
        ParamTypeObject ParamType = "object"
)

// AllParamTypes can be used for ParamType validation.
var AllParamTypes = []ParamType{ParamTypeString, ParamTypeArray, ParamTypeObject}

// ParamValues is modeled after IntOrString in kubernetes/apimachinery:

// ParamValue is a type that can hold a single string, string array, or string map.
// Used in JSON unmarshalling so that a single JSON field can accept
// either an individual string or an array of strings.
type ParamValue struct {
        Type      ParamType // Represents the stored type of ParamValues.
        StringVal string
        // +listType=atomic
        ArrayVal  []string
        ObjectVal map[string]string
}

// UnmarshalJSON implements the json.Unmarshaller interface.
func (paramValues *ParamValue) UnmarshalJSON(value []byte) error <span class="cov8" title="1">{
        // ParamValues is used for Results Value as well, the results can be any kind of
        // data so we need to check if it is empty.
        if len(value) == 0 </span><span class="cov8" title="1">{
                paramValues.Type = ParamTypeString
                return nil
        }</span>
        <span class="cov8" title="1">if value[0] == '[' </span><span class="cov8" title="1">{
                // We're trying to Unmarshal to []string, but for cases like []int or other types
                // of nested array which we don't support yet, we should continue and Unmarshal
                // it to String. If the Type being set doesn't match what it actually should be,
                // it will be captured by validation in reconciler.
                // if failed to unmarshal to array, we will convert the value to string and marshal it to string
                var a []string
                if err := json.Unmarshal(value, &amp;a); err == nil </span><span class="cov8" title="1">{
                        paramValues.Type = ParamTypeArray
                        paramValues.ArrayVal = a
                        return nil
                }</span>
        }
        <span class="cov8" title="1">if value[0] == '{' </span><span class="cov8" title="1">{
                // if failed to unmarshal to map, we will convert the value to string and marshal it to string
                var m map[string]string
                if err := json.Unmarshal(value, &amp;m); err == nil </span><span class="cov8" title="1">{
                        paramValues.Type = ParamTypeObject
                        paramValues.ObjectVal = m
                        return nil
                }</span>
        }

        // By default we unmarshal to string
        <span class="cov8" title="1">paramValues.Type = ParamTypeString
        if err := json.Unmarshal(value, &amp;paramValues.StringVal); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">paramValues.StringVal = string(value)

        return nil</span>
}

// MarshalJSON implements the json.Marshaller interface.
func (paramValues ParamValue) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        switch paramValues.Type </span>{
        case ParamTypeString:<span class="cov8" title="1">
                return json.Marshal(paramValues.StringVal)</span>
        case ParamTypeArray:<span class="cov8" title="1">
                return json.Marshal(paramValues.ArrayVal)</span>
        case ParamTypeObject:<span class="cov8" title="1">
                return json.Marshal(paramValues.ObjectVal)</span>
        default:<span class="cov0" title="0">
                return []byte{}, fmt.Errorf("impossible ParamValues.Type: %q", paramValues.Type)</span>
        }
}

// ApplyReplacements applyes replacements for ParamValues type
func (paramValues *ParamValue) ApplyReplacements(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) <span class="cov8" title="1">{
        switch paramValues.Type </span>{
        case ParamTypeArray:<span class="cov8" title="1">
                newArrayVal := []string{}
                for _, v := range paramValues.ArrayVal </span><span class="cov8" title="1">{
                        newArrayVal = append(newArrayVal, substitution.ApplyArrayReplacements(v, stringReplacements, arrayReplacements)...)
                }</span>
                <span class="cov8" title="1">paramValues.ArrayVal = newArrayVal</span>
        case ParamTypeObject:<span class="cov8" title="1">
                newObjectVal := map[string]string{}
                for k, v := range paramValues.ObjectVal </span><span class="cov8" title="1">{
                        newObjectVal[k] = substitution.ApplyReplacements(v, stringReplacements)
                }</span>
                <span class="cov8" title="1">paramValues.ObjectVal = newObjectVal</span>
        case ParamTypeString:<span class="cov8" title="1">
                fallthrough</span>
        default:<span class="cov8" title="1">
                paramValues.applyOrCorrect(stringReplacements, arrayReplacements, objectReplacements)</span>
        }
}

// applyOrCorrect deals with string param whose value can be string literal or a reference to a string/array/object param/result.
// If the value of paramValues is a reference to array or object, the type will be corrected from string to array/object.
func (paramValues *ParamValue) applyOrCorrect(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) <span class="cov8" title="1">{
        stringVal := paramValues.StringVal

        // if the stringVal is a string literal or a string that mixed with var references
        // just do the normal string replacement
        if !exactVariableSubstitutionRegex.MatchString(stringVal) </span><span class="cov8" title="1">{
                paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
                return
        }</span>

        // trim the head "$(" and the tail ")" or "[*])"
        // i.e. get "params.name" from "$(params.name)" or "$(params.name[*])"
        <span class="cov8" title="1">trimedStringVal := substitution.StripStarVarSubExpression(stringVal)

        // if the stringVal is a reference to a string param
        if _, ok := stringReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
        }</span>

        // if the stringVal is a reference to an array param, we need to change the type other than apply replacement
        <span class="cov8" title="1">if _, ok := arrayReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = ""
                paramValues.ArrayVal = substitution.ApplyArrayReplacements(stringVal, stringReplacements, arrayReplacements)
                paramValues.Type = ParamTypeArray
        }</span>

        // if the stringVal is a reference an object param, we need to change the type other than apply replacement
        <span class="cov8" title="1">if _, ok := objectReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = ""
                paramValues.ObjectVal = objectReplacements[trimedStringVal]
                paramValues.Type = ParamTypeObject
        }</span>
}

// NewStructuredValues creates an ParamValues of type ParamTypeString or ParamTypeArray, based on
// how many inputs are given (&gt;1 input will create an array, not string).
func NewStructuredValues(value string, values ...string) *ParamValue <span class="cov8" title="1">{
        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;ParamValue{
                        Type:     ParamTypeArray,
                        ArrayVal: append([]string{value}, values...),
                }
        }</span>
        <span class="cov8" title="1">return &amp;ParamValue{
                Type:      ParamTypeString,
                StringVal: value,
        }</span>
}

// NewObject creates an ParamValues of type ParamTypeObject using the provided key-value pairs
func NewObject(pairs map[string]string) *ParamValue <span class="cov8" title="1">{
        return &amp;ParamValue{
                Type:      ParamTypeObject,
                ObjectVal: pairs,
        }
}</span>

// ArrayReference returns the name of the parameter from array parameter reference
// returns arrayParam from $(params.arrayParam[*])
func ArrayReference(a string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimPrefix(a, "$("+ParamsPrefix+"."), "[*])")
}</span>

// validatePipelineParametersVariablesInTaskParameters validates param value that
// may contain the reference(s) to other params to make sure those references are used appropriately.
func validatePipelineParametersVariablesInTaskParameters(params Params, prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(params.validateDuplicateParameters()).ViaField("params")
        for _, param := range params </span><span class="cov8" title="1">{
                switch param.Value.Type </span>{
                case ParamTypeArray:<span class="cov8" title="1">
                        for idx, arrayElement := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                errs = errs.Also(validateArrayVariable(arrayElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("value", idx).ViaFieldKey("params", param.Name))
                        }</span>
                case ParamTypeObject:<span class="cov8" title="1">
                        for key, val := range param.Value.ObjectVal </span><span class="cov8" title="1">{
                                errs = errs.Also(validateStringVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldKey("properties", key).ViaFieldKey("params", param.Name))
                        }</span>
                case ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(validateParamStringValue(param, prefix, paramNames, arrayParamNames, objectParamNameKeys))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// validateParamStringValue validates the param value field of string type
// that may contain references to other isolated array/object params other than string param.
func validateParamStringValue(param Param, prefix string, paramNames sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        stringValue := param.Value.StringVal

        // if the provided param value is an isolated reference to the whole array/object, we just check if the param name exists.
        isIsolated, errs := substitution.ValidateWholeArrayOrObjectRefInStringVariable(param.Name, stringValue, prefix, paramNames)
        if isIsolated </span><span class="cov0" title="0">{
                return errs
        }</span>

        // if the provided param value is string literal and/or contains multiple variables
        // valid example: "$(params.myString) and another $(params.myObject.key1)"
        // invalid example: "$(params.myString) and another $(params.myObject[*])"
        <span class="cov8" title="1">return validateStringVariable(stringValue, prefix, paramNames, arrayVars, objectParamNameKeys).ViaFieldKey("params", param.Name)</span>
}

// validateStringVariable validates the normal string fields that can only accept references to string param or individual keys of object param
func validateStringVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
        errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
        return errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(value, prefix, arrayVars))
}</span>

func validateArrayVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
        errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
        return errs.Also(substitution.ValidateVariableReferenceIsIsolated(value, prefix, arrayVars))
}</span>

func validateObjectVariable(value, prefix string, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectNames := sets.NewString()
        for objectParamName, keys := range objectParamNameKeys </span><span class="cov8" title="1">{
                objectNames.Insert(objectParamName)
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(value, fmt.Sprintf("%s\\.%s", prefix, objectParamName), sets.NewString(keys...)))
        }</span>

        <span class="cov8" title="1">return errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(value, prefix, objectNames))</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*Pipeline)(nil)

// ConvertTo implements apis.Convertible
func (p *Pipeline) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", sink)</span>
}

// ConvertFrom implements apis.Convertible
func (p *Pipeline) ConvertFrom(ctx context.Context, source apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", source)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*Pipeline)(nil)

// SetDefaults sets default values on the Pipeline's Spec
func (p *Pipeline) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        p.Spec.SetDefaults(ctx)
}</span>

// SetDefaults sets default values for the PipelineSpec's Params, Tasks, and Finally
func (ps *PipelineSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        for i := range ps.Params </span><span class="cov8" title="1">{
                ps.Params[i].SetDefaults(ctx)
        }</span>

        <span class="cov8" title="1">for _, pt := range ps.Tasks </span><span class="cov8" title="1">{
                pt.SetDefaults(ctx)
        }</span>

        <span class="cov8" title="1">for _, ft := range ps.Finally </span><span class="cov8" title="1">{
                ctx := ctx // Ensure local scoping per Task
                ft.SetDefaults(ctx)
        }</span>
}

// SetDefaults sets default values for a PipelineTask
func (pt *PipelineTask) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                if pt.TaskRef.Name == "" &amp;&amp; pt.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        pt.TaskRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
                }</span>
                <span class="cov8" title="1">if pt.TaskRef.Kind == "" &amp;&amp; pt.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        pt.TaskRef.Kind = NamespacedTaskKind
                }</span>
        }
        <span class="cov8" title="1">if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                pt.TaskSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/kmeta"
)

// PipelineTaskOnErrorType defines a list of supported failure handling behaviors of a PipelineTask on error
type PipelineTaskOnErrorType string

const (
        // PipelineTasksAggregateStatus is a param representing aggregate status of all dag pipelineTasks
        PipelineTasksAggregateStatus = "tasks.status"
        // PipelineTasks is a value representing a task is a member of "tasks" section of the pipeline
        PipelineTasks = "tasks"
        // PipelineFinallyTasks is a value representing a task is a member of "finally" section of the pipeline
        PipelineFinallyTasks = "finally"
        // PipelineTaskStopAndFail indicates to stop and fail the PipelineRun if the PipelineTask fails
        PipelineTaskStopAndFail PipelineTaskOnErrorType = "stopAndFail"
        // PipelineTaskContinue indicates to continue executing the rest of the DAG when the PipelineTask fails
        PipelineTaskContinue PipelineTaskOnErrorType = "continue"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Pipeline describes a list of Tasks to execute. It expresses how outputs
// of tasks feed into inputs of subsequent tasks.
// +k8s:openapi-gen=true
// +kubebuilder:storageversion
type Pipeline struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the Pipeline from the client
        // +optional
        Spec PipelineSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*Pipeline)(nil)

// PipelineMetadata returns the Pipeline's ObjectMeta, implementing PipelineObject
func (p *Pipeline) PipelineMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return p.ObjectMeta
}</span>

// PipelineSpec returns the Pipeline's Spec, implementing PipelineObject
func (p *Pipeline) PipelineSpec() PipelineSpec <span class="cov0" title="0">{
        return p.Spec
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*Pipeline) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.PipelineControllerName)
}</span>

// Checksum computes the sha256 checksum of the pipeline object.
// Prior to computing the checksum, it performs some preprocessing on the
// metadata of the object where it removes system provided annotations.
// Only the name, namespace, generateName, user-provided labels and annotations
// and the pipelineSpec are included for the checksum computation.
func (p *Pipeline) Checksum() ([]byte, error) <span class="cov8" title="1">{
        objectMeta := checksum.PrepareObjectMeta(p)
        preprocessedPipeline := Pipeline{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1",
                        Kind:       "Pipeline"},
                ObjectMeta: objectMeta,
                Spec:       p.Spec,
        }
        sha256Checksum, err := checksum.ComputeSha256Checksum(preprocessedPipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sha256Checksum, nil</span>
}

// PipelineSpec defines the desired state of Pipeline.
type PipelineSpec struct {
        // DisplayName is a user-facing name of the pipeline that may be
        // used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`
        // Description is a user-facing description of the pipeline that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Tasks declares the graph of Tasks that execute when this Pipeline is run.
        // +listType=atomic
        Tasks []PipelineTask `json:"tasks,omitempty"`
        // Params declares a list of input parameters that must be supplied when
        // this Pipeline is run.
        Params ParamSpecs `json:"params,omitempty"`
        // Workspaces declares a set of named workspaces that are expected to be
        // provided by a PipelineRun.
        // +optional
        // +listType=atomic
        Workspaces []PipelineWorkspaceDeclaration `json:"workspaces,omitempty"`
        // Results are values that this pipeline can output once run
        // +optional
        // +listType=atomic
        Results []PipelineResult `json:"results,omitempty"`
        // Finally declares the list of Tasks that execute just before leaving the Pipeline
        // i.e. either after all Tasks are finished executing successfully
        // or after a failure which would result in ending the Pipeline
        // +listType=atomic
        Finally []PipelineTask `json:"finally,omitempty"`
}

// PipelineResult used to describe the results of a pipeline
type PipelineResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result.
        // The possible types are 'string', 'array', and 'object', with 'string' as the default.
        // 'array' and 'object' types are alpha features.
        Type ResultsType `json:"type,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description"`

        // Value the expression used to retrieve the value
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// PipelineTaskMetadata contains the labels or annotations for an EmbeddedTask
type PipelineTaskMetadata struct {
        // +optional
        Labels map[string]string `json:"labels,omitempty"`

        // +optional
        Annotations map[string]string `json:"annotations,omitempty"`
}

// EmbeddedTask is used to define a Task inline within a Pipeline's PipelineTasks.
type EmbeddedTask struct {
        // +optional
        runtime.TypeMeta `json:",inline,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        Spec runtime.RawExtension `json:"spec,omitempty"`

        // +optional
        Metadata PipelineTaskMetadata `json:"metadata,omitempty"`

        // TaskSpec is a specification of a task
        // +optional
        TaskSpec `json:",inline,omitempty"`
}

// PipelineTask defines a task in a Pipeline, passing inputs from both
// Params and from the output of previous tasks.
type PipelineTask struct {
        // Name is the name of this task within the context of a Pipeline. Name is
        // used as a coordinate with the `from` and `runAfter` fields to establish
        // the execution order of tasks relative to one another.
        Name string `json:"name,omitempty"`

        // DisplayName is the display name of this task within the context of a Pipeline.
        // This display name may be used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`

        // Description is the description of this task within the context of a Pipeline.
        // This description may be used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`

        // TaskRef is a reference to a task definition.
        // +optional
        TaskRef *TaskRef `json:"taskRef,omitempty"`

        // TaskSpec is a specification of a task
        // Specifying TaskSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Task.spec (API version: tekton.dev/v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        TaskSpec *EmbeddedTask `json:"taskSpec,omitempty"`

        // When is a list of when expressions that need to be true for the task to run
        // +optional
        When WhenExpressions `json:"when,omitempty"`

        // Retries represents how many times this task should be retried in case of task failure: ConditionSucceeded set to False
        // +optional
        Retries int `json:"retries,omitempty"`

        // RunAfter is the list of PipelineTask names that should be executed before
        // this Task executes. (Used to force a specific ordering in graph execution.)
        // +optional
        // +listType=atomic
        RunAfter []string `json:"runAfter,omitempty"`

        // Parameters declares parameters passed to this task.
        // +optional
        Params Params `json:"params,omitempty"`

        // Matrix declares parameters used to fan out this task.
        // +optional
        Matrix *Matrix `json:"matrix,omitempty"`

        // Workspaces maps workspaces from the pipeline spec to the workspaces
        // declared in the Task.
        // +optional
        // +listType=atomic
        Workspaces []WorkspacePipelineTaskBinding `json:"workspaces,omitempty"`

        // Duration after which the TaskRun times out. Defaults to 1 hour.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // PipelineRef is a reference to a pipeline definition
        // Note: PipelineRef is in preview mode and not yet supported
        // +optional
        PipelineRef *PipelineRef `json:"pipelineRef,omitempty"`

        // PipelineSpec is a specification of a pipeline
        // Note: PipelineSpec is in preview mode and not yet supported
        // Specifying PipelineSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Pipeline.spec (API version: tekton.dev/v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`

        // OnError defines the exiting behavior of a PipelineRun on error
        // can be set to [ continue | stopAndFail ]
        // +optional
        OnError PipelineTaskOnErrorType `json:"onError,omitempty"`
}

// IsCustomTask checks whether an embedded TaskSpec is a Custom Task
func (et *EmbeddedTask) IsCustomTask() bool <span class="cov8" title="1">{
        // Note that if `apiVersion` is set to `"tekton.dev/v1beta1"` and `kind` is set to `"Task"`,
        // the reference will be considered a Custom Task - https://github.com/tektoncd/pipeline/issues/6457
        return et != nil &amp;&amp; et.APIVersion != "" &amp;&amp; et.Kind != ""
}</span>

// IsMatrixed return whether pipeline task is matrixed
func (pt *PipelineTask) IsMatrixed() bool <span class="cov8" title="1">{
        return pt.Matrix.HasParams() || pt.Matrix.HasInclude()
}</span>

// TaskSpecMetadata returns the metadata of the PipelineTask's EmbeddedTask spec.
func (pt *PipelineTask) TaskSpecMetadata() PipelineTaskMetadata <span class="cov0" title="0">{
        return pt.TaskSpec.Metadata
}</span>

// HashKey is the name of the PipelineTask, and is used as the key for this PipelineTask in the DAG
func (pt PipelineTask) HashKey() string <span class="cov8" title="1">{
        return pt.Name
}</span>

// Deps returns all other PipelineTask dependencies of this PipelineTask, based on resource usage or ordering
func (pt PipelineTask) Deps() []string <span class="cov8" title="1">{
        // hold the list of dependencies in a set to avoid duplicates
        deps := sets.NewString()

        // add any new dependents from result references - resource dependency
        for _, ref := range PipelineTaskResultRefs(&amp;pt) </span><span class="cov8" title="1">{
                deps.Insert(ref.PipelineTask)
        }</span>

        // add any new dependents from runAfter - order dependency
        <span class="cov8" title="1">for _, runAfter := range pt.RunAfter </span><span class="cov8" title="1">{
                deps.Insert(runAfter)
        }</span>

        <span class="cov8" title="1">return deps.List()</span>
}

// PipelineTaskList is a list of PipelineTasks
type PipelineTaskList []PipelineTask

// Deps returns a map with key as name of a pipelineTask and value as a list of its dependencies
func (l PipelineTaskList) Deps() map[string][]string <span class="cov8" title="1">{
        deps := map[string][]string{}
        for _, pt := range l </span><span class="cov8" title="1">{
                // get the list of deps for this pipelineTask
                d := pt.Deps()
                // add the pipelineTask into the map if it has any deps
                if len(d) &gt; 0 </span><span class="cov8" title="1">{
                        deps[pt.HashKey()] = d
                }</span>
        }
        <span class="cov8" title="1">return deps</span>
}

// Items returns a slice of all tasks in the PipelineTaskList, converted to dag.Tasks
func (l PipelineTaskList) Items() []dag.Task <span class="cov8" title="1">{
        tasks := []dag.Task{}
        for _, t := range l </span><span class="cov8" title="1">{
                tasks = append(tasks, dag.Task(t))
        }</span>
        <span class="cov8" title="1">return tasks</span>
}

// Names returns a set of pipeline task names from the given list of pipeline tasks
func (l PipelineTaskList) Names() sets.String <span class="cov8" title="1">{
        names := sets.String{}
        for _, pt := range l </span><span class="cov8" title="1">{
                names.Insert(pt.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// PipelineTaskParam is used to provide arbitrary string parameters to a Task.
type PipelineTaskParam struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// PipelineList contains a list of Pipeline
type PipelineList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Pipeline `json:"items"`
}

// GetVarSubstitutionExpressions extracts all the value between "$(" and ")"" for a PipelineResult
func (result PipelineResult) GetVarSubstitutionExpressions() ([]string, bool) <span class="cov8" title="1">{
        allExpressions := validateString(result.Value.StringVal)
        for _, v := range result.Value.ArrayVal </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(v)...)
        }</span>
        <span class="cov8" title="1">for _, v := range result.Value.ObjectVal </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(v)...)
        }</span>
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "slices"
        "strings"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        "github.com/tektoncd/pipeline/pkg/substitution"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*Pipeline)(nil)
        _ resourcesemantics.VerbLimited = (*Pipeline)(nil)
)

const (
        taskRef      = "taskRef"
        taskSpec     = "taskSpec"
        pipelineRef  = "pipelineRef"
        pipelineSpec = "pipelineSpec"
)

// SupportedVerbs returns the operations that validation should be called for
func (p *Pipeline) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate checks that the Pipeline structure is valid but does not validate
// that any references resources exist, that is done at run time.
func (p *Pipeline) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(p.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(p.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        // When a Pipeline is created directly, instead of declared inline in a PipelineRun,
        // we do not support propagated parameters and workspaces.
        // Validate that all params and workspaces it uses are declared.
        errs = errs.Also(p.Spec.validatePipelineParameterUsage(ctx).ViaField("spec"))
        errs = errs.Also(p.Spec.validatePipelineWorkspacesUsage().ViaField("spec"))
        return errs
}</span>

// Validate checks that taskNames in the Pipeline are valid and that the graph
// of Tasks expressed in the Pipeline makes sense.
func (ps *PipelineSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(ps.ValidateBetaFields(ctx))
        if equality.Semantic.DeepEqual(ps, &amp;PipelineSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("expected at least one, got none", "description", "params", "resources", "tasks", "workspaces"))
        }</span>
        // PipelineTask must have a valid unique label and at least one of taskRef or taskSpec should be specified
        <span class="cov8" title="1">errs = errs.Also(ValidatePipelineTasks(ctx, ps.Tasks, ps.Finally))
        // Validate the pipeline task graph
        errs = errs.Also(validateGraph(ps.Tasks))
        // The parameter variables should be valid
        errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.Tasks, ps.Params).ViaField("tasks"))
        errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.Finally, ps.Params).ViaField("finally"))
        errs = errs.Also(validatePipelineContextVariables(ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validatePipelineContextVariables(ps.Finally).ViaField("finally"))
        errs = errs.Also(validateExecutionStatusVariables(ps.Tasks, ps.Finally))
        // Validate the pipeline's workspaces.
        errs = errs.Also(validatePipelineWorkspacesDeclarations(ps.Workspaces))
        // Validate the pipeline's results
        errs = errs.Also(validatePipelineResults(ps.Results, ps.Tasks, ps.Finally))
        errs = errs.Also(validateTasksAndFinallySection(ps))
        errs = errs.Also(validateFinalTasks(ps.Tasks, ps.Finally))
        errs = errs.Also(validateWhenExpressions(ctx, ps.Tasks, ps.Finally))
        errs = errs.Also(validateArtifactReference(ctx, ps.Tasks, ps.Finally))
        errs = errs.Also(validateMatrix(ctx, ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validateMatrix(ctx, ps.Finally).ViaField("finally"))
        return errs</span>
}

// ValidateBetaFields returns an error if the Pipeline spec uses beta features but does not
// have "enable-api-fields" set to "alpha" or "beta".
func (ps *PipelineSpec) ValidateBetaFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for i, pt := range ps.Tasks </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateBetaFields(ctx).ViaFieldIndex("tasks", i))
        }</span>
        <span class="cov8" title="1">for i, pt := range ps.Finally </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateBetaFields(ctx).ViaFieldIndex("tasks", i))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// validateBetaFields returns an error if the PipelineTask uses beta features but does not
// have "enable-api-fields" set to "alpha" or "beta".
func (pt *PipelineTask) validateBetaFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                // Resolvers
                if pt.TaskRef.Resolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "taskref.resolver", config.BetaAPIFields))
                }</span>
                <span class="cov8" title="1">if len(pt.TaskRef.Params) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "taskref.params", config.BetaAPIFields))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidatePipelineTasks ensures that pipeline tasks has unique label, pipeline tasks has specified one of
// taskRef or taskSpec, and in case of a pipeline task with taskRef, it has a reference to a valid task (task name)
func ValidatePipelineTasks(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) *apis.FieldError <span class="cov8" title="1">{
        taskNames := sets.NewString()
        var errs *apis.FieldError
        errs = errs.Also(PipelineTaskList(tasks).Validate(ctx, taskNames, "tasks"))
        errs = errs.Also(PipelineTaskList(finalTasks).Validate(ctx, taskNames, "finally"))
        return errs
}</span>

// Validate a list of pipeline tasks including custom task
func (l PipelineTaskList) Validate(ctx context.Context, taskNames sets.String, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range l </span><span class="cov8" title="1">{
                // validate pipeline task name
                errs = errs.Also(t.ValidateName().ViaFieldIndex(path, i))
                // names cannot be duplicated - checking that pipelineTask names are unique
                if _, ok := taskNames[t.Name]; ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("name").ViaFieldIndex(path, i))
                }</span>
                <span class="cov8" title="1">taskNames.Insert(t.Name)
                // validate custom task, dag, or final task
                errs = errs.Also(t.Validate(ctx).ViaFieldIndex(path, i))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateUsageOfDeclaredPipelineTaskParameters validates that all parameters referenced in the pipeline Task are declared by the pipeline Task.
func (l PipelineTaskList) validateUsageOfDeclaredPipelineTaskParameters(ctx context.Context, additionalParams []ParamSpec, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range l </span><span class="cov8" title="1">{
                if t.TaskSpec != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, t.TaskSpec.Steps, append(t.TaskSpec.Params, additionalParams...)).ViaFieldIndex(path, i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateName checks whether the PipelineTask's name is a valid DNS label
func (pt PipelineTask) ValidateName() *apis.FieldError <span class="cov8" title="1">{
        if err := validation.IsDNS1123Label(pt.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid value %q", pt.Name),
                        Paths:   []string{"name"},
                        Details: "Pipeline Task name must be a valid DNS Label." +
                                "For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate classifies whether a task is a custom task or a regular task(dag/final)
// calls the validation routine based on the type of the task
func (pt PipelineTask) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(pt.validateRefOrSpec(ctx))

        errs = errs.Also(pt.validateEnabledInlineSpec(ctx))

        errs = errs.Also(pt.validateEmbeddedOrType())
        // taskKinds contains the kinds when the apiVersion is not set, they are not custom tasks,
        // if apiVersion is set they are custom tasks.
        taskKinds := map[TaskKind]bool{
                "":                 true,
                NamespacedTaskKind: true,
        }

        errs = errs.Also(pt.ValidateOnError(ctx))

        // Pipeline task having taskRef/taskSpec with APIVersion is classified as custom task
        switch </span>{
        case pt.TaskRef != nil &amp;&amp; !taskKinds[pt.TaskRef.Kind]:<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskRef != nil &amp;&amp; pt.TaskRef.APIVersion != "":<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskSpec != nil &amp;&amp; !taskKinds[TaskKind(pt.TaskSpec.Kind)]:<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.APIVersion != "":<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        default:<span class="cov8" title="1">
                errs = errs.Also(pt.validateTask(ctx))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateOnError validates the OnError field of a PipelineTask
func (pt PipelineTask) ValidateOnError(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.OnError != "" &amp;&amp; !isParamRefs(string(pt.OnError)) </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "OnError", config.BetaAPIFields))
                if pt.OnError != PipelineTaskContinue &amp;&amp; pt.OnError != PipelineTaskStopAndFail </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(pt.OnError, "OnError", "PipelineTask OnError must be either \"continue\" or \"stopAndFail\""))
                }</span>
                <span class="cov8" title="1">if pt.OnError == PipelineTaskContinue &amp;&amp; pt.Retries &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("PipelineTask OnError cannot be set to \"continue\" when Retries is greater than 0"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (pt *PipelineTask) validateMatrix(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.IsMatrixed() </span><span class="cov8" title="1">{
                // This is a beta feature and will fail validation if it's used in a pipeline spec
                // when the enable-api-fields feature gate is set to "stable".
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "matrix", config.BetaAPIFields))
                errs = errs.Also(pt.Matrix.validateCombinationsCount(ctx))
                errs = errs.Also(pt.Matrix.validateUniqueParams())
        }</span>
        <span class="cov8" title="1">errs = errs.Also(pt.Matrix.validateParameterInOneOfMatrixOrParams(pt.Params))
        return errs</span>
}

func (pt PipelineTask) validateEmbeddedOrType() (errs *apis.FieldError) <span class="cov8" title="1">{
        // Reject cases where APIVersion and/or Kind are specified alongside an embedded Task.
        // We determine if this is an embedded Task by checking of TaskSpec.TaskSpec.Steps has items.
        if pt.TaskSpec != nil &amp;&amp; len(pt.TaskSpec.TaskSpec.Steps) &gt; 0 </span><span class="cov8" title="1">{
                if pt.TaskSpec.APIVersion != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "taskSpec.apiVersion cannot be specified when using taskSpec.steps",
                                Paths:   []string{"taskSpec.apiVersion"},
                        })
                }</span>
                <span class="cov8" title="1">if pt.TaskSpec.Kind != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "taskSpec.kind cannot be specified when using taskSpec.steps",
                                Paths:   []string{"taskSpec.kind"},
                        })
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (pt *PipelineTask) validateWorkspaces(workspaceNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaceBindingNames := sets.NewString()
        for i, ws := range pt.Workspaces </span><span class="cov8" title="1">{
                if workspaceBindingNames.Has(ws.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(
                                fmt.Sprintf("workspace name %q must be unique", ws.Name), "").ViaFieldIndex("workspaces", i))
                }</span>

                <span class="cov8" title="1">if ws.Workspace == "" </span><span class="cov8" title="1">{
                        if !workspaceNames.Has(ws.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(
                                        fmt.Sprintf("pipeline task %q expects workspace with name %q but none exists in pipeline spec", pt.Name, ws.Name),
                                        "",
                                ).ViaFieldIndex("workspaces", i))
                        }</span>
                } else<span class="cov8" title="1"> if !workspaceNames.Has(ws.Workspace) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(
                                fmt.Sprintf("pipeline task %q expects workspace with name %q but none exists in pipeline spec", pt.Name, ws.Workspace),
                                "",
                        ).ViaFieldIndex("workspaces", i))
                }</span>

                <span class="cov8" title="1">workspaceBindingNames.Insert(ws.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateEnabledInlineSpec validates that pipelineSpec or taskSpec is allowed by checking
// disable-inline-spec field
func (pt PipelineTask) validateEnabledInlineSpec(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipeline") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("taskSpec"))
                }</span>
        }
        <span class="cov8" title="1">if pt.PipelineSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipeline") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("pipelineSpec"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateRefOrSpec validates at least one of taskRef or taskSpec or pipelineRef or pipelineSpec is specified
func (pt PipelineTask) validateRefOrSpec(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // collect all the specified specifications
        nonNilFields := []string{}
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                nonNilFields = append(nonNilFields, taskRef)
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                nonNilFields = append(nonNilFields, taskSpec)
        }</span>
        <span class="cov8" title="1">if pt.PipelineRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, pipelineRef, config.AlphaAPIFields))
                nonNilFields = append(nonNilFields, pipelineRef)
        }</span>
        <span class="cov8" title="1">if pt.PipelineSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, pipelineSpec, config.AlphaAPIFields))
                nonNilFields = append(nonNilFields, pipelineSpec)
        }</span>

        // check the length of nonNilFields
        // if one of taskRef or taskSpec or pipelineRef or pipelineSpec is specified,
        // the length of nonNilFields should exactly be 1
        <span class="cov8" title="1">if len(nonNilFields) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("expected exactly one, got multiple", nonNilFields...))
        }</span> else<span class="cov8" title="1"> if len(nonNilFields) == 0 </span><span class="cov8" title="1">{
                cfg := config.FromContextOrDefaults(ctx)
                // check for TaskRef or TaskSpec or PipelineRef or PipelineSpec with alpha feature flag
                if cfg.FeatureFlags.EnableAPIFields == config.AlphaAPIFields </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingOneOf(taskRef, taskSpec, pipelineRef, pipelineSpec))
                }</span> else<span class="cov8" title="1"> {
                        // check for taskRef and taskSpec with beta/stable feature flag
                        errs = errs.Also(apis.ErrMissingOneOf(taskRef, taskSpec))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateCustomTask validates custom task specifications - checking kind and fail if not yet supported features specified
func (pt PipelineTask) validateCustomTask() (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.TaskRef != nil &amp;&amp; pt.TaskRef.Kind == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task ref must specify kind", "taskRef.kind"))
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Kind == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task spec must specify kind", "taskSpec.kind"))
        }</span>
        <span class="cov8" title="1">if pt.TaskRef != nil &amp;&amp; pt.TaskRef.APIVersion == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task ref must specify apiVersion", "taskRef.apiVersion"))
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.APIVersion == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task spec must specify apiVersion", "taskSpec.apiVersion"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateTask validates a pipeline task or a final task for taskRef and taskSpec
func (pt PipelineTask) validateTask(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate TaskSpec if it's present
        if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.TaskSpec.Validate(ctx).ViaField(taskSpec))
        }</span>
        <span class="cov8" title="1">if pt.TaskRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.TaskRef.Validate(ctx).ViaField(taskRef))
        }</span>
        <span class="cov8" title="1">if pt.PipelineRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.PipelineRef.Validate(ctx).ViaField(pipelineRef))
        }</span>
        <span class="cov8" title="1">if pt.PipelineSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.PipelineSpec.Validate(ctx).ViaField(pipelineSpec))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineWorkspacesDeclarations validates the specified workspaces, ensuring having unique name without any
// empty string,
func validatePipelineWorkspacesDeclarations(wss []PipelineWorkspaceDeclaration) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Workspace names must be non-empty and unique.
        wsTable := sets.NewString()
        for i, ws := range wss </span><span class="cov8" title="1">{
                if ws.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("workspace %d has empty name", i),
                                "").ViaFieldIndex("workspaces", i))
                }</span>
                <span class="cov8" title="1">if wsTable.Has(ws.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("workspace with name %q appears more than once", ws.Name),
                                "").ViaFieldIndex("workspaces", i))
                }</span>
                <span class="cov8" title="1">wsTable.Insert(ws.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineParameterUsage validates that parameters referenced in the Pipeline are declared by the Pipeline
func (ps *PipelineSpec) validatePipelineParameterUsage(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(PipelineTaskList(ps.Tasks).validateUsageOfDeclaredPipelineTaskParameters(ctx, ps.Params, "tasks"))
        errs = errs.Also(PipelineTaskList(ps.Finally).validateUsageOfDeclaredPipelineTaskParameters(ctx, ps.Params, "finally"))
        errs = errs.Also(validatePipelineTaskParameterUsage(ps.Tasks, ps.Params).ViaField("tasks"))
        errs = errs.Also(validatePipelineTaskParameterUsage(ps.Finally, ps.Params).ViaField("finally"))
        return errs
}</span>

// validatePipelineTaskParameterUsage validates that parameters referenced in the Pipeline Tasks are declared by the Pipeline
func validatePipelineTaskParameterUsage(tasks []PipelineTask, params ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        allParamNames := sets.NewString(params.GetNames()...)
        _, arrayParams, objectParams := params.SortByType()
        arrayParamNames := sets.NewString(arrayParams.GetNames()...)
        objectParameterNameKeys := map[string][]string{}
        for _, p := range objectParams </span><span class="cov8" title="1">{
                for k := range p.Properties </span><span class="cov8" title="1">{
                        objectParameterNameKeys[p.Name] = append(objectParameterNameKeys[p.Name], k)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validatePipelineParametersVariables(tasks, "params", allParamNames, arrayParamNames, objectParameterNameKeys))
        for i, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.Params.validateDuplicateParameters().ViaField("params").ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineWorkspacesUsage validates that workspaces referenced in the Pipeline are declared by the Pipeline
func (ps *PipelineSpec) validatePipelineWorkspacesUsage() (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(validatePipelineTasksWorkspacesUsage(ps.Workspaces, ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validatePipelineTasksWorkspacesUsage(ps.Workspaces, ps.Finally).ViaField("finally"))
        return errs
}</span>

// validatePipelineTasksWorkspacesUsage validates that all the referenced workspaces (by pipeline tasks) are specified in
// the pipeline
func validatePipelineTasksWorkspacesUsage(wss []PipelineWorkspaceDeclaration, pts []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaceNames := sets.NewString()
        for _, ws := range wss </span><span class="cov8" title="1">{
                workspaceNames.Insert(ws.Name)
        }</span>
        // Any workspaces used in PipelineTasks should have their name declared in the Pipeline's Workspaces list.
        <span class="cov8" title="1">for i, pt := range pts </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateWorkspaces(workspaceNames).ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidatePipelineParameterVariables validates parameters with those specified by each pipeline task,
// (1) it validates the type of parameter is either string or array (2) parameter default value matches
// with the type of that param (3) no duplication, feature flag and allowed param type when using param enum
func ValidatePipelineParameterVariables(ctx context.Context, tasks []PipelineTask, params ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        // validates all the types within a slice of ParamSpecs
        errs = errs.Also(ValidateParameterTypes(ctx, params).ViaField("params"))
        errs = errs.Also(params.ValidateNoDuplicateNames())
        errs = errs.Also(params.validateParamEnums(ctx).ViaField("params"))
        for i, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.Params.validateDuplicateParameters().ViaField("params").ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validatePipelineParametersVariables(tasks []PipelineTask, prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(validatePipelineParametersVariablesInTaskParameters(task.Params, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))
                if task.IsMatrixed() </span><span class="cov8" title="1">{
                        errs = errs.Also(task.Matrix.validatePipelineParametersVariablesInMatrixParameters(prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(task.When.validatePipelineParametersVariables(prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validatePipelineContextVariables(tasks []PipelineTask) *apis.FieldError <span class="cov8" title="1">{
        pipelineRunContextNames := sets.NewString().Insert(
                "name",
                "namespace",
                "uid",
        )
        pipelineContextNames := sets.NewString().Insert(
                "name",
        )
        pipelineTaskContextNames := sets.NewString().Insert(
                "retries",
        )
        var paramValues []string
        for _, task := range tasks </span><span class="cov8" title="1">{
                paramValues = task.extractAllParams().extractValues()
        }</span>
        <span class="cov8" title="1">errs := validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipelineRun", pipelineRunContextNames).
                Also(validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipeline", pipelineContextNames)).
                Also(validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipelineTask", pipelineTaskContextNames))
        return errs</span>
}

// extractAllParams extracts all the parameters in a PipelineTask:
// - pt.Params
// - pt.Matrix.Params
// - pt.Matrix.Include.Params
func (pt *PipelineTask) extractAllParams() Params <span class="cov8" title="1">{
        allParams := pt.Params
        if pt.Matrix.HasParams() </span><span class="cov8" title="1">{
                allParams = append(allParams, pt.Matrix.Params...)
        }</span>
        <span class="cov8" title="1">if pt.Matrix.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range pt.Matrix.Include </span><span class="cov8" title="1">{
                        allParams = append(allParams, include.Params...)
                }</span>
        }
        <span class="cov8" title="1">return allParams</span>
}

// GetVarSubstitutionExpressions extract all values between the parameters "$(" and ")" of steps and sidecars
func (pt *PipelineTask) GetVarSubstitutionExpressions() []string <span class="cov8" title="1">{
        var allExpressions []string
        if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                for _, step := range pt.TaskSpec.Steps </span><span class="cov8" title="1">{
                        stepExpressions := step.GetVarSubstitutionExpressions()
                        allExpressions = append(allExpressions, stepExpressions...)
                }</span>
                <span class="cov8" title="1">for _, sidecar := range pt.TaskSpec.Sidecars </span><span class="cov8" title="1">{
                        sidecarExpressions := sidecar.GetVarSubstitutionExpressions()
                        allExpressions = append(allExpressions, sidecarExpressions...)
                }</span>
        }
        <span class="cov8" title="1">return allExpressions</span>
}

// containsExecutionStatusRef checks if a specified param has a reference to execution status or reason
// $(tasks.&lt;task-name&gt;.status), $(tasks.status), or $(tasks.&lt;task-name&gt;.reason)
func containsExecutionStatusRef(p string) bool <span class="cov8" title="1">{
        if strings.HasPrefix(p, "tasks.") </span><span class="cov8" title="1">{
                if strings.HasSuffix(p, ".status") || strings.HasSuffix(p, ".reason") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func validateExecutionStatusVariables(tasks []PipelineTask, finallyTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(validateExecutionStatusVariablesInTasks(tasks).ViaField("tasks"))
        errs = errs.Also(validateExecutionStatusVariablesInFinally(PipelineTaskList(tasks).Names(), finallyTasks).ViaField("finally"))
        return errs
}</span>

// validate dag pipeline tasks, task params can not access execution status of any other task
// dag tasks cannot have param value as $(tasks.pipelineTask.status)
func validateExecutionStatusVariablesInTasks(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.validateExecutionStatusVariablesDisallowed().ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validate finally tasks accessing execution status of a dag task specified in the pipeline
// $(tasks.pipelineTask.status) is invalid if pipelineTask is not defined as a dag task
func validateExecutionStatusVariablesInFinally(tasksNames sets.String, finally []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range finally </span><span class="cov8" title="1">{
                errs = errs.Also(t.validateExecutionStatusVariablesAllowed(tasksNames).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (pt *PipelineTask) validateExecutionStatusVariablesDisallowed() (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, param := range pt.Params </span><span class="cov8" title="1">{
                if expressions, ok := param.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateContainsExecutionStatusVariablesDisallowed(expressions, "value").
                                ViaFieldKey("params", param.Name))
                }</span>
        }
        <span class="cov8" title="1">for i, we := range pt.When </span><span class="cov8" title="1">{
                if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateContainsExecutionStatusVariablesDisallowed(expressions, "").
                                ViaFieldIndex("when", i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (pt *PipelineTask) validateExecutionStatusVariablesAllowed(ptNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, param := range pt.Params </span><span class="cov8" title="1">{
                if expressions, ok := param.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateExecutionStatusVariablesExpressions(expressions, ptNames, "value").
                                ViaFieldKey("params", param.Name))
                }</span>
        }
        <span class="cov8" title="1">for i, we := range pt.When </span><span class="cov8" title="1">{
                if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateExecutionStatusVariablesExpressions(expressions, ptNames, "").
                                ViaFieldIndex("when", i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateContainsExecutionStatusVariablesDisallowed(expressions []string, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if containsExecutionStatusReferences(expressions) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("pipeline tasks can not refer to execution status"+
                        " of any other pipeline task or aggregate status of tasks", path))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func containsExecutionStatusReferences(expressions []string) bool <span class="cov8" title="1">{
        // validate tasks.pipelineTask.status/tasks.status if this expression is not a result reference
        if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                for _, e := range expressions </span><span class="cov8" title="1">{
                        // check if it contains context variable accessing execution status - $(tasks.taskname.status)
                        // or an aggregate status - $(tasks.status) or reason - $(tasks.taskname.reason)
                        if containsExecutionStatusRef(e) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func validateExecutionStatusVariablesExpressions(expressions []string, ptNames sets.String, fieldPath string) (errs *apis.FieldError) <span class="cov8" title="1">{
        // validate tasks.pipelineTask.status if this expression is not a result reference
        if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                for _, expression := range expressions </span><span class="cov8" title="1">{
                        // its a reference to aggregate status of dag tasks - $(tasks.status)
                        if expression == PipelineTasksAggregateStatus </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // check if it contains context variable accessing execution status - $(tasks.taskname.status) | $(tasks.taskname.reason)
                        <span class="cov8" title="1">if containsExecutionStatusRef(expression) </span><span class="cov8" title="1">{
                                var pt string
                                if strings.HasSuffix(expression, ".status") </span><span class="cov8" title="1">{
                                        // strip tasks. and .status from tasks.taskname.status to further verify task name
                                        pt = strings.TrimSuffix(strings.TrimPrefix(expression, "tasks."), ".status")
                                }</span>
                                <span class="cov8" title="1">if strings.HasSuffix(expression, ".reason") </span><span class="cov8" title="1">{
                                        // strip tasks. and .reason from tasks.taskname.reason to further verify task name
                                        pt = strings.TrimSuffix(strings.TrimPrefix(expression, "tasks."), ".reason")
                                }</span>
                                // report an error if the task name does not exist in the list of dag tasks
                                <span class="cov8" title="1">if !ptNames.Has(pt) </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("pipeline task %s is not defined in the pipeline", pt), fieldPath))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return errs</span>
}

func validatePipelineContextVariablesInParamValues(paramValues []string, prefix string, contextNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, paramValue := range paramValues </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(paramValue, prefix, contextNames).ViaField("value"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func filter(arr []string, cond func(string) bool) []string <span class="cov8" title="1">{
        result := []string{}
        for i := range arr </span><span class="cov8" title="1">{
                if cond(arr[i]) </span><span class="cov8" title="1">{
                        result = append(result, arr[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// validatePipelineResults ensure that pipeline result variables are properly configured
func validatePipelineResults(results []PipelineResult, tasks []PipelineTask, finally []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        pipelineTaskNames := getPipelineTasksNames(tasks)
        pipelineFinallyTaskNames := getPipelineTasksNames(finally)
        for idx, result := range results </span><span class="cov8" title="1">{
                expressions, ok := result.GetVarSubstitutionExpressions()
                if !ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("expected pipeline results to be task result expressions but no expressions were found",
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("expected pipeline results to be task result expressions but an invalid expressions was found",
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">expressions = filter(expressions, resultref.LooksLikeResultRef)
                resultRefs := NewResultRefs(expressions)
                if len(expressions) != len(resultRefs) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("expected all of the expressions %v to be result expressions but only %v were", expressions, resultRefs),
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">if !taskContainsResult(result.Value.StringVal, pipelineTaskNames, pipelineFinallyTaskNames) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("referencing a nonexistent task",
                                "value").ViaFieldIndex("results", idx))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// put task names in a set
func getPipelineTasksNames(pipelineTasks []PipelineTask) sets.String <span class="cov8" title="1">{
        pipelineTaskNames := make(sets.String)
        for _, pipelineTask := range pipelineTasks </span><span class="cov8" title="1">{
                pipelineTaskNames.Insert(pipelineTask.Name)
        }</span>

        <span class="cov8" title="1">return pipelineTaskNames</span>
}

// taskContainsResult ensures the result value is referenced within the
// task names
func taskContainsResult(resultExpression string, pipelineTaskNames sets.String, pipelineFinallyTaskNames sets.String) bool <span class="cov8" title="1">{
        // split incase of multiple resultExpressions in the same result.Value string
        // i.e "$(task.&lt;task-name).result.&lt;result-name&gt;) - $(task2.&lt;task2-name).result2.&lt;result2-name&gt;)"
        split := strings.Split(resultExpression, "$")
        for _, expression := range split </span><span class="cov8" title="1">{
                if expression != "" </span><span class="cov8" title="1">{
                        value := stripVarSubExpression("$" + expression)
                        pr, err := resultref.ParseTaskExpression(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return false
                        }</span>

                        <span class="cov8" title="1">if strings.HasPrefix(value, "tasks") &amp;&amp; !pipelineTaskNames.Has(pr.ResourceName) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if strings.HasPrefix(value, "finally") &amp;&amp; !pipelineFinallyTaskNames.Has(pr.ResourceName) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func validateTasksAndFinallySection(ps *PipelineSpec) *apis.FieldError <span class="cov8" title="1">{
        if len(ps.Finally) != 0 &amp;&amp; len(ps.Tasks) == 0 </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue(fmt.Sprintf("spec.tasks is empty but spec.finally has %d tasks", len(ps.Finally)), "finally")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateFinalTasks(tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, f := range finalTasks </span><span class="cov8" title="1">{
                if len(f.RunAfter) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("no runAfter allowed under spec.finally, final task %s has runAfter specified", f.Name), "").ViaFieldIndex("finally", idx))
                }</span>
        }

        <span class="cov8" title="1">ts := PipelineTaskList(tasks).Names()
        fts := PipelineTaskList(finalTasks).Names()

        errs = errs.Also(validateTaskResultReferenceInFinallyTasks(finalTasks, ts, fts))

        return errs</span>
}

func validateTaskResultReferenceInFinallyTasks(finalTasks []PipelineTask, ts sets.String, fts sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range finalTasks </span><span class="cov8" title="1">{
                for _, p := range t.Params </span><span class="cov8" title="1">{
                        if expressions, ok := p.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                                errs = errs.Also(validateResultsVariablesExpressionsInFinally(expressions, ts, fts, "value").ViaFieldKey(
                                        "params", p.Name).ViaFieldIndex("finally", idx))
                        }</span>
                }
                <span class="cov8" title="1">for i, we := range t.When </span><span class="cov8" title="1">{
                        if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                                errs = errs.Also(validateResultsVariablesExpressionsInFinally(expressions, ts, fts, "").ViaFieldIndex(
                                        "when", i).ViaFieldIndex("finally", idx))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func validateResultsVariablesExpressionsInFinally(expressions []string, pipelineTasksNames sets.String, finalTasksNames sets.String, fieldPath string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                resultRefs := NewResultRefs(expressions)
                for _, resultRef := range resultRefs </span><span class="cov8" title="1">{
                        pt := resultRef.PipelineTask
                        if finalTasksNames.Has(pt) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("invalid task result reference, "+
                                        "final task has task result reference from a final task %s", pt), fieldPath))
                        }</span> else<span class="cov8" title="1"> if !pipelineTasksNames.Has(resultRef.PipelineTask) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("invalid task result reference, "+
                                        "final task has task result reference from a task %s which is not defined in the pipeline", pt), fieldPath))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func validateWhenExpressions(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.When.validate(ctx).ViaFieldIndex("tasks", i))
        }</span>
        <span class="cov8" title="1">for i, t := range finalTasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.When.validate(ctx).ViaFieldIndex("finally", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateGraph ensures the Pipeline's dependency Graph (DAG) make sense: that there is no dependency
// cycle or that they rely on values from Tasks that ran previously.
func validateGraph(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        if _, err := dag.Build(PipelineTaskList(tasks), PipelineTaskList(tasks).Deps()); err != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(err.Error(), "tasks"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateMatrix(ctx context.Context, tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.validateMatrix(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateTaskResultsFromMatrixedPipelineTasksConsumed(tasks))
        return errs</span>
}

// findAndValidateResultRefsForMatrix checks that any result references to Matrixed PipelineTasks if consumed
// by another PipelineTask that the entire array of results produced by a matrix is consumed in aggregate
// since consuming a singular result produced by a matrix is currently not supported
func findAndValidateResultRefsForMatrix(tasks []PipelineTask, taskMapping map[string]PipelineTask) (resultRefs []*ResultRef, errs *apis.FieldError) <span class="cov8" title="1">{
        for _, t := range tasks </span><span class="cov8" title="1">{
                for _, p := range t.Params </span><span class="cov8" title="1">{
                        if expressions, ok := p.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                                if LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                                        resultRefs, errs = validateMatrixedPipelineTaskConsumed(expressions, taskMapping)
                                        if errs != nil </span><span class="cov8" title="1">{
                                                return nil, errs
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return resultRefs, errs</span>
}

// validateMatrixedPipelineTaskConsumed checks that any Matrixed Pipeline Task that the is being consumed is consumed in
// aggregate [*] since consuming a singular result produced by a matrix is currently not supported
func validateMatrixedPipelineTaskConsumed(expressions []string, taskMapping map[string]PipelineTask) (resultRefs []*ResultRef, errs *apis.FieldError) <span class="cov8" title="1">{
        var filteredExpressions []string
        for _, expression := range expressions </span><span class="cov8" title="1">{
                // if it is not matrix result ref expression, skip
                if !resultref.LooksLikeResultRef(expression) </span><span class="cov8" title="1">{
                        continue</span>
                }
                // ie. "tasks.&lt;pipelineTaskName&gt;.results.&lt;resultName&gt;[*]"
                <span class="cov8" title="1">subExpressions := strings.Split(expression, ".")
                pipelineTask := subExpressions[1] // pipelineTaskName
                taskConsumed := taskMapping[pipelineTask]
                if taskConsumed.IsMatrixed() </span><span class="cov8" title="1">{
                        if !strings.HasSuffix(expression, "[*]") </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric("A matrixed pipelineTask can only be consumed in aggregate using [*] notation, but is currently set to " + expression))
                        }</span>
                        <span class="cov8" title="1">filteredExpressions = append(filteredExpressions, expression)</span>
                }
        }
        <span class="cov8" title="1">return NewResultRefs(filteredExpressions), errs</span>
}

// validateTaskResultsFromMatrixedPipelineTasksConsumed checks that any Matrixed Pipeline Task that the is being consumed
// is consumed in aggregate [*] since consuming a singular result produced by a matrix is currently not supported.
// It also validates that a matrix emitting results can only emit results with the underlying type string
// if those results are being consumed by another PipelineTask.
func validateTaskResultsFromMatrixedPipelineTasksConsumed(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        taskMapping := createTaskMapping(tasks)
        resultRefs, errs := findAndValidateResultRefsForMatrix(tasks, taskMapping)
        if errs != nil </span><span class="cov8" title="1">{
                return errs
        }</span>

        <span class="cov8" title="1">errs = errs.Also(validateMatrixEmittingStringResults(resultRefs, taskMapping))
        return errs</span>
}

// createTaskMapping maps the PipelineTaskName to the PipelineTask to easily access
// the pipelineTask by Name
func createTaskMapping(tasks []PipelineTask) (taskMap map[string]PipelineTask) <span class="cov8" title="1">{
        taskMapping := make(map[string]PipelineTask)
        for _, task := range tasks </span><span class="cov8" title="1">{
                taskMapping[task.Name] = task
        }</span>
        <span class="cov8" title="1">return taskMapping</span>
}

// validateMatrixEmittingStringResults checks a matrix emitting results can only emit results with the underlying type string
// if those results are being consumed by another PipelineTask. Note: It is not possible to validate remote tasks
func validateMatrixEmittingStringResults(resultRefs []*ResultRef, taskMapping map[string]PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, resultRef := range resultRefs </span><span class="cov8" title="1">{
                task := taskMapping[resultRef.PipelineTask]
                resultName := resultRef.Result
                if task.TaskRef != nil </span><span class="cov8" title="1">{
                        referencedTask := taskMapping[task.TaskRef.Name]
                        if referencedTask.TaskSpec != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(validateStringResults(referencedTask.TaskSpec.Results, resultName))
                        }</span>
                } else<span class="cov8" title="1"> if task.TaskSpec != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(validateStringResults(task.TaskSpec.Results, resultName))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateStringResults ensure that the result type is string
func validateStringResults(results []TaskResult, resultName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Name == resultName </span><span class="cov8" title="1">{
                        if result.Type != ResultsTypeString </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(
                                        fmt.Sprintf("Matrixed PipelineTasks emitting results must have an underlying type string, but result %s has type %s in pipelineTask", resultName, string(result.Type)),
                                        "",
                                ))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// validateArtifactReference ensure that the feature flag enableArtifacts is set to true when using artifacts
func validateArtifactReference(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        if config.FromContextOrDefaults(ctx).FeatureFlags.EnableArtifacts </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">for i, t := range tasks </span><span class="cov8" title="1">{
                for _, v := range t.Params.extractValues() </span><span class="cov8" title="1">{
                        if len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(v, -1)) &gt; 0 </span><span class="cov8" title="1">{
                                return errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "").ViaField("params").ViaFieldIndex("tasks", i))
                        }</span>
                }
        }
        <span class="cov8" title="1">for i, t := range finalTasks </span><span class="cov8" title="1">{
                for _, v := range t.Params.extractValues() </span><span class="cov8" title="1">{
                        if len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(v, -1)) &gt; 0 </span><span class="cov8" title="1">{
                                return errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "").ViaField("params").ViaFieldIndex("finally", i))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// GetIndexingReferencesToArrayParams returns all strings referencing indices of PipelineRun array parameters
// from parameters, workspaces, and when expressions defined in the Pipeline's Tasks and Finally Tasks.
// For example, if a Task in the Pipeline has a parameter with a value "$(params.array-param-name[1])",
// this would be one of the strings returned.
func (ps *PipelineSpec) GetIndexingReferencesToArrayParams() sets.String <span class="cov8" title="1">{
        paramsRefs := []string{}
        for i := range ps.Tasks </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, ps.Tasks[i].Params.extractValues()...)
                if ps.Tasks[i].IsMatrixed() </span><span class="cov0" title="0">{
                        paramsRefs = append(paramsRefs, ps.Tasks[i].Matrix.Params.extractValues()...)
                }</span>
                <span class="cov8" title="1">for j := range ps.Tasks[i].Workspaces </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, ps.Tasks[i].Workspaces[j].SubPath)
                }</span>
                <span class="cov8" title="1">for _, wes := range ps.Tasks[i].When </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, wes.Input)
                        paramsRefs = append(paramsRefs, wes.Values...)
                }</span>
        }
        <span class="cov8" title="1">for i := range ps.Finally </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, ps.Finally[i].Params.extractValues()...)
                if ps.Finally[i].IsMatrixed() </span><span class="cov0" title="0">{
                        paramsRefs = append(paramsRefs, ps.Finally[i].Matrix.Params.extractValues()...)
                }</span>
                <span class="cov8" title="1">for _, wes := range ps.Finally[i].When </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, wes.Input)
                        paramsRefs = append(paramsRefs, wes.Values...)
                }</span>
        }
        // extract all array indexing references, for example []{"$(params.array-params[1])"}
        <span class="cov8" title="1">arrayIndexParamRefs := []string{}
        for _, p := range paramsRefs </span><span class="cov8" title="1">{
                arrayIndexParamRefs = append(arrayIndexParamRefs, extractArrayIndexingParamRefs(p)...)
        }</span>
        <span class="cov8" title="1">return sets.NewString(arrayIndexParamRefs...)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate ensures that a supplied PipelineRef field is populated
// correctly. No errors are returned for a nil PipelineRef.
func (ref *PipelineRef) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return validateRef(ctx, ref.Name, ref.Resolver, ref.Params)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*PipelineRun)(nil)

// ConvertTo implements apis.Convertible
func (pr *PipelineRun) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", sink)</span>
}

// ConvertFrom implements apis.Convertible
func (pr *PipelineRun) ConvertFrom(ctx context.Context, source apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", source)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "regexp"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmap"
)

var (
        _                              apis.Defaultable = (*PipelineRun)(nil)
        filterReservedAnnotationRegexp                  = regexp.MustCompile(pipeline.TektonReservedAnnotationExpr)
)

// SetDefaults implements apis.Defaultable
func (pr *PipelineRun) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        pr.Spec.SetDefaults(ctx)

        // Silently filtering out Tekton Reserved annotations at creation
        if apis.IsInCreate(ctx) </span><span class="cov8" title="1">{
                pr.ObjectMeta.Annotations = kmap.Filter(pr.ObjectMeta.Annotations, func(s string) bool </span><span class="cov8" title="1">{
                        return filterReservedAnnotationRegexp.MatchString(s)
                }</span>)
        }
}

// SetDefaults implements apis.Defaultable
func (prs *PipelineRunSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if prs.PipelineRef != nil &amp;&amp; prs.PipelineRef.Name == "" &amp;&amp; prs.PipelineRef.Resolver == "" </span><span class="cov8" title="1">{
                prs.PipelineRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
        }</span>

        <span class="cov8" title="1">if prs.Timeouts == nil </span><span class="cov8" title="1">{
                prs.Timeouts = &amp;TimeoutFields{}
        }</span>

        <span class="cov8" title="1">if prs.Timeouts.Pipeline == nil </span><span class="cov8" title="1">{
                prs.Timeouts.Pipeline = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
        }</span>

        <span class="cov8" title="1">defaultSA := cfg.Defaults.DefaultServiceAccount
        if prs.TaskRunTemplate.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                prs.TaskRunTemplate.ServiceAccountName = defaultSA
        }</span>

        <span class="cov8" title="1">defaultPodTemplate := cfg.Defaults.DefaultPodTemplate
        prs.TaskRunTemplate.PodTemplate = pod.MergePodTemplateWithDefault(prs.TaskRunTemplate.PodTemplate, defaultPodTemplate)

        if prs.PipelineSpec != nil </span><span class="cov8" title="1">{
                prs.PipelineSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        runv1beta1 "github.com/tektoncd/pipeline/pkg/apis/run/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// PipelineRun represents a single execution of a Pipeline. PipelineRuns are how
// the graph of Tasks declared in a Pipeline are executed; they specify inputs
// to Pipelines such as parameter values and capture operational aspects of the
// Tasks execution such as service account and tolerations. Creating a
// PipelineRun creates TaskRuns for Tasks in the referenced Pipeline.
//
// +k8s:openapi-gen=true
// +kubebuilder:storageversion
type PipelineRun struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec PipelineRunSpec `json:"spec,omitempty"`
        // +optional
        Status PipelineRunStatus `json:"status,omitempty"`
}

// GetName Returns the name of the PipelineRun
func (pr *PipelineRun) GetName() string <span class="cov0" title="0">{
        return pr.ObjectMeta.GetName()
}</span>

// GetStatusCondition returns the task run status as a ConditionAccessor
func (pr *PipelineRun) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;pr.Status
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*PipelineRun) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.PipelineRunControllerName)
}</span>

// IsDone returns true if the PipelineRun's status indicates that it is done.
func (pr *PipelineRun) IsDone() bool <span class="cov8" title="1">{
        return !pr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether pipelinerun has valid start time set in its status
func (pr *PipelineRun) HasStarted() bool <span class="cov8" title="1">{
        return pr.Status.StartTime != nil &amp;&amp; !pr.Status.StartTime.IsZero()
}</span>

// IsCancelled returns true if the PipelineRun's spec status is set to Cancelled state
func (pr *PipelineRun) IsCancelled() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusCancelled
}</span>

// IsGracefullyCancelled returns true if the PipelineRun's spec status is set to CancelledRunFinally state
func (pr *PipelineRun) IsGracefullyCancelled() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusCancelledRunFinally
}</span>

// IsGracefullyStopped returns true if the PipelineRun's spec status is set to StoppedRunFinally state
func (pr *PipelineRun) IsGracefullyStopped() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusStoppedRunFinally
}</span>

// PipelineTimeout returns the applicable timeout for the PipelineRun
func (pr *PipelineRun) PipelineTimeout(ctx context.Context) time.Duration <span class="cov8" title="1">{
        if pr.Spec.Timeouts != nil &amp;&amp; pr.Spec.Timeouts.Pipeline != nil </span><span class="cov8" title="1">{
                return pr.Spec.Timeouts.Pipeline.Duration
        }</span>
        <span class="cov8" title="1">return time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes) * time.Minute</span>
}

// TasksTimeout returns the tasks timeout for the PipelineRun, if set,
// or the tasks timeout computed from the Pipeline and Finally timeouts, if those are set.
func (pr *PipelineRun) TasksTimeout() *metav1.Duration <span class="cov8" title="1">{
        t := pr.Spec.Timeouts
        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t.Tasks != nil </span><span class="cov8" title="1">{
                return t.Tasks
        }</span>
        <span class="cov8" title="1">if t.Pipeline != nil &amp;&amp; t.Finally != nil </span><span class="cov8" title="1">{
                if t.Pipeline.Duration == config.NoTimeoutDuration || t.Finally.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return &amp;metav1.Duration{Duration: (t.Pipeline.Duration - t.Finally.Duration)}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// FinallyTimeout returns the finally timeout for the PipelineRun, if set,
// or the finally timeout computed from the Pipeline and Tasks timeouts, if those are set.
func (pr *PipelineRun) FinallyTimeout() *metav1.Duration <span class="cov8" title="1">{
        t := pr.Spec.Timeouts
        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t.Finally != nil </span><span class="cov8" title="1">{
                return t.Finally
        }</span>
        <span class="cov8" title="1">if t.Pipeline != nil &amp;&amp; t.Tasks != nil </span><span class="cov8" title="1">{
                if t.Pipeline.Duration == config.NoTimeoutDuration || t.Tasks.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return &amp;metav1.Duration{Duration: (t.Pipeline.Duration - t.Tasks.Duration)}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsPending returns true if the PipelineRun's spec status is set to Pending state
func (pr *PipelineRun) IsPending() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusPending
}</span>

// GetNamespacedName returns a k8s namespaced name that identifies this PipelineRun
func (pr *PipelineRun) GetNamespacedName() types.NamespacedName <span class="cov8" title="1">{
        return types.NamespacedName{Namespace: pr.Namespace, Name: pr.Name}
}</span>

// IsTimeoutConditionSet returns true when the pipelinerun has the pipelinerun timed out reason
func (pr *PipelineRun) IsTimeoutConditionSet() bool <span class="cov8" title="1">{
        condition := pr.Status.GetCondition(apis.ConditionSucceeded)
        return condition.IsFalse() &amp;&amp; condition.Reason == PipelineRunReasonTimedOut.String()
}</span>

// SetTimeoutCondition sets the status of the PipelineRun to timed out.
func (pr *PipelineRun) SetTimeoutCondition(ctx context.Context) <span class="cov8" title="1">{
        pr.Status.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionFalse,
                Reason:  PipelineRunReasonTimedOut.String(),
                Message: fmt.Sprintf("PipelineRun %q failed to finish within %q", pr.Name, pr.PipelineTimeout(ctx).String()),
        })
}</span>

// HasTimedOut returns true if a pipelinerun has exceeded its spec.Timeout based on its status.Timeout
func (pr *PipelineRun) HasTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.PipelineTimeout(ctx)
        startTime := pr.Status.StartTime

        if !startTime.IsZero() </span><span class="cov8" title="1">{
                if timeout == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasTimedOutForALongTime returns true if a pipelinerun has exceeed its spec.Timeout based its status.StartTime
// by a large margin
func (pr *PipelineRun) HasTimedOutForALongTime(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        if !pr.HasTimedOut(ctx, c) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := pr.PipelineTimeout(ctx)
        startTime := pr.Status.StartTime
        runtime := c.Since(startTime.Time)
        // We are arbitrarily defining large margin as doubling the spec.timeout
        return runtime &gt;= 2*timeout</span>
}

// HaveTasksTimedOut returns true if a pipelinerun has exceeded its spec.Timeouts.Tasks
func (pr *PipelineRun) HaveTasksTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.TasksTimeout()
        startTime := pr.Status.StartTime

        if !startTime.IsZero() &amp;&amp; timeout != nil </span><span class="cov8" title="1">{
                if timeout.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout.Duration </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasFinallyTimedOut returns true if a pipelinerun has exceeded its spec.Timeouts.Finally, based on status.FinallyStartTime
func (pr *PipelineRun) HasFinallyTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.FinallyTimeout()
        startTime := pr.Status.FinallyStartTime

        if startTime != nil &amp;&amp; !startTime.IsZero() &amp;&amp; timeout != nil </span><span class="cov8" title="1">{
                if timeout.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout.Duration </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasVolumeClaimTemplate returns true if PipelineRun contains volumeClaimTemplates that is
// used for creating PersistentVolumeClaims with an OwnerReference for each run
func (pr *PipelineRun) HasVolumeClaimTemplate() bool <span class="cov8" title="1">{
        for _, ws := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                if ws.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// PipelineRunSpec defines the desired state of PipelineRun
type PipelineRunSpec struct {
        // +optional
        PipelineRef *PipelineRef `json:"pipelineRef,omitempty"`
        // Specifying PipelineSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Pipeline.spec (API version: tekton.dev/v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`
        // Params is a list of parameter names and values.
        Params Params `json:"params,omitempty"`

        // Used for cancelling a pipelinerun (and maybe more later on)
        // +optional
        Status PipelineRunSpecStatus `json:"status,omitempty"`
        // Time after which the Pipeline times out.
        // Currently three keys are accepted in the map
        // pipeline, tasks and finally
        // with Timeouts.pipeline &gt;= Timeouts.tasks + Timeouts.finally
        // +optional
        Timeouts *TimeoutFields `json:"timeouts,omitempty"`

        // TaskRunTemplate represent template of taskrun
        // +optional
        TaskRunTemplate PipelineTaskRunTemplate `json:"taskRunTemplate,omitempty"`

        // Workspaces holds a set of workspace bindings that must match names
        // with those declared in the pipeline.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceBinding `json:"workspaces,omitempty"`
        // TaskRunSpecs holds a set of runtime specs
        // +optional
        // +listType=atomic
        TaskRunSpecs []PipelineTaskRunSpec `json:"taskRunSpecs,omitempty"`
}

// TimeoutFields allows granular specification of pipeline, task, and finally timeouts
type TimeoutFields struct {
        // Pipeline sets the maximum allowed duration for execution of the entire pipeline. The sum of individual timeouts for tasks and finally must not exceed this value.
        Pipeline *metav1.Duration `json:"pipeline,omitempty"`
        // Tasks sets the maximum allowed duration of this pipeline's tasks
        Tasks *metav1.Duration `json:"tasks,omitempty"`
        // Finally sets the maximum allowed duration of this pipeline's finally
        Finally *metav1.Duration `json:"finally,omitempty"`
}

// PipelineRunSpecStatus defines the pipelinerun spec status the user can provide
type PipelineRunSpecStatus string

const (
        // PipelineRunSpecStatusCancelled indicates that the user wants to cancel the task,
        // if not already cancelled or terminated
        PipelineRunSpecStatusCancelled = "Cancelled"

        // PipelineRunSpecStatusCancelledRunFinally indicates that the user wants to cancel the pipeline run,
        // if not already cancelled or terminated, but ensure finally is run normally
        PipelineRunSpecStatusCancelledRunFinally = "CancelledRunFinally"

        // PipelineRunSpecStatusStoppedRunFinally indicates that the user wants to stop the pipeline run,
        // wait for already running tasks to be completed and run finally
        // if not already cancelled or terminated
        PipelineRunSpecStatusStoppedRunFinally = "StoppedRunFinally"

        // PipelineRunSpecStatusPending indicates that the user wants to postpone starting a PipelineRun
        // until some condition is met
        PipelineRunSpecStatusPending = "PipelineRunPending"
)

// PipelineRunStatus defines the observed state of PipelineRun
type PipelineRunStatus struct {
        duckv1.Status `json:",inline"`

        // PipelineRunStatusFields inlines the status fields.
        PipelineRunStatusFields `json:",inline"`
}

// PipelineRunReason represents a reason for the pipeline run "Succeeded" condition
type PipelineRunReason string

const (
        // PipelineRunReasonStarted is the reason set when the PipelineRun has just started
        PipelineRunReasonStarted PipelineRunReason = "Started"
        // PipelineRunReasonRunning is the reason set when the PipelineRun is running
        PipelineRunReasonRunning PipelineRunReason = "Running"
        // PipelineRunReasonSuccessful is the reason set when the PipelineRun completed successfully
        PipelineRunReasonSuccessful PipelineRunReason = "Succeeded"
        // PipelineRunReasonCompleted is the reason set when the PipelineRun completed successfully with one or more skipped Tasks
        PipelineRunReasonCompleted PipelineRunReason = "Completed"
        // PipelineRunReasonFailed is the reason set when the PipelineRun completed with a failure
        PipelineRunReasonFailed PipelineRunReason = "Failed"
        // PipelineRunReasonCancelled is the reason set when the PipelineRun cancelled by the user
        // This reason may be found with a corev1.ConditionFalse status, if the cancellation was processed successfully
        // This reason may be found with a corev1.ConditionUnknown status, if the cancellation is being processed or failed
        PipelineRunReasonCancelled PipelineRunReason = "Cancelled"
        // PipelineRunReasonPending is the reason set when the PipelineRun is in the pending state
        PipelineRunReasonPending PipelineRunReason = "PipelineRunPending"
        // PipelineRunReasonTimedOut is the reason set when the PipelineRun has timed out
        PipelineRunReasonTimedOut PipelineRunReason = "PipelineRunTimeout"
        // PipelineRunReasonStopping indicates that no new Tasks will be scheduled by the controller, and the
        // pipeline will stop once all running tasks complete their work
        PipelineRunReasonStopping PipelineRunReason = "PipelineRunStopping"
        // PipelineRunReasonCancelledRunningFinally indicates that pipeline has been gracefully cancelled
        // and no new Tasks will be scheduled by the controller, but final tasks are now running
        PipelineRunReasonCancelledRunningFinally PipelineRunReason = "CancelledRunningFinally"
        // PipelineRunReasonStoppedRunningFinally indicates that pipeline has been gracefully stopped
        // and no new Tasks will be scheduled by the controller, but final tasks are now running
        PipelineRunReasonStoppedRunningFinally PipelineRunReason = "StoppedRunningFinally"
        // ReasonCouldntGetPipeline indicates that the reason for the failure status is that the
        // associated Pipeline couldn't be retrieved
        PipelineRunReasonCouldntGetPipeline PipelineRunReason = "CouldntGetPipeline"
        // ReasonInvalidBindings indicates that the reason for the failure status is that the
        // PipelineResources bound in the PipelineRun didn't match those declared in the Pipeline
        PipelineRunReasonInvalidBindings PipelineRunReason = "InvalidPipelineResourceBindings"
        // ReasonInvalidWorkspaceBinding indicates that a Pipeline expects a workspace but a
        // PipelineRun has provided an invalid binding.
        PipelineRunReasonInvalidWorkspaceBinding PipelineRunReason = "InvalidWorkspaceBindings"
        // ReasonInvalidTaskRunSpec indicates that PipelineRun.Spec.TaskRunSpecs[].PipelineTaskName is defined with
        // a not exist taskName in pipelineSpec.
        PipelineRunReasonInvalidTaskRunSpec PipelineRunReason = "InvalidTaskRunSpecs"
        // ReasonParameterTypeMismatch indicates that the reason for the failure status is that
        // parameter(s) declared in the PipelineRun do not have the some declared type as the
        // parameters(s) declared in the Pipeline that they are supposed to override.
        PipelineRunReasonParameterTypeMismatch PipelineRunReason = "ParameterTypeMismatch"
        // ReasonObjectParameterMissKeys indicates that the object param value provided from PipelineRun spec
        // misses some keys required for the object param declared in Pipeline spec.
        PipelineRunReasonObjectParameterMissKeys PipelineRunReason = "ObjectParameterMissKeys"
        // ReasonParamArrayIndexingInvalid indicates that the use of param array indexing is out of bound.
        PipelineRunReasonParamArrayIndexingInvalid PipelineRunReason = "ParamArrayIndexingInvalid"
        // ReasonCouldntGetTask indicates that the reason for the failure status is that the
        // associated Pipeline's Tasks couldn't all be retrieved
        PipelineRunReasonCouldntGetTask PipelineRunReason = "CouldntGetTask"
        // ReasonParameterMissing indicates that the reason for the failure status is that the
        // associated PipelineRun didn't provide all the required parameters
        PipelineRunReasonParameterMissing PipelineRunReason = "ParameterMissing"
        // ReasonFailedValidation indicates that the reason for failure status is
        // that pipelinerun failed runtime validation
        PipelineRunReasonFailedValidation PipelineRunReason = "PipelineValidationFailed"
        // PipelineRunReasonCouldntGetPipelineResult indicates that the pipeline fails to retrieve the
        // referenced result. This could be due to failed TaskRuns or Runs that were supposed to produce
        // the results
        PipelineRunReasonCouldntGetPipelineResult PipelineRunReason = "CouldntGetPipelineResult"
        // ReasonInvalidGraph indicates that the reason for the failure status is that the
        // associated Pipeline is an invalid graph (a.k.a wrong order, cycle, )
        PipelineRunReasonInvalidGraph PipelineRunReason = "PipelineInvalidGraph"
        // ReasonCouldntCancel indicates that a PipelineRun was cancelled but attempting to update
        // all of the running TaskRuns as cancelled failed.
        PipelineRunReasonCouldntCancel PipelineRunReason = "PipelineRunCouldntCancel"
        // ReasonCouldntTimeOut indicates that a PipelineRun was timed out but attempting to update
        // all of the running TaskRuns as timed out failed.
        PipelineRunReasonCouldntTimeOut PipelineRunReason = "PipelineRunCouldntTimeOut"
        // ReasonInvalidMatrixParameterTypes indicates a matrix contains invalid parameter types
        PipelineRunReasonInvalidMatrixParameterTypes PipelineRunReason = "InvalidMatrixParameterTypes"
        // ReasonInvalidTaskResultReference indicates a task result was declared
        // but was not initialized by that task
        PipelineRunReasonInvalidTaskResultReference PipelineRunReason = "InvalidTaskResultReference"
        // PipelineRunReasonInvalidPipelineResultReference indicates a pipeline result was declared
        // by the pipeline but not initialized in the pipelineTask
        PipelineRunReasonInvalidPipelineResultReference PipelineRunReason = "InvalidPipelineResultReference"
        // ReasonRequiredWorkspaceMarkedOptional indicates an optional workspace
        // has been passed to a Task that is expecting a non-optional workspace
        PipelineRunReasonRequiredWorkspaceMarkedOptional PipelineRunReason = "RequiredWorkspaceMarkedOptional"
        // ReasonResolvingPipelineRef indicates that the PipelineRun is waiting for
        // its pipelineRef to be asynchronously resolved.
        PipelineRunReasonResolvingPipelineRef PipelineRunReason = "ResolvingPipelineRef"
        // ReasonResourceVerificationFailed indicates that the pipeline fails the trusted resource verification,
        // it could be the content has changed, signature is invalid or public key is invalid
        PipelineRunReasonResourceVerificationFailed PipelineRunReason = "ResourceVerificationFailed"
        // ReasonCreateRunFailed indicates that the pipeline fails to create the taskrun or other run resources
        PipelineRunReasonCreateRunFailed PipelineRunReason = "CreateRunFailed"
        // ReasonCELEvaluationFailed indicates the pipeline fails the CEL evaluation
        PipelineRunReasonCELEvaluationFailed PipelineRunReason = "CELEvaluationFailed"
        // PipelineRunReasonInvalidParamValue indicates that the PipelineRun Param input value is not allowed.
        PipelineRunReasonInvalidParamValue PipelineRunReason = "InvalidParamValue"
)

// PipelineTaskOnErrorAnnotation is used to pass the failure strategy to TaskRun pods from PipelineTask OnError field
const PipelineTaskOnErrorAnnotation = "pipeline.tekton.dev/pipeline-task-on-error"

func (t PipelineRunReason) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

var pipelineRunCondSet = apis.NewBatchConditionSet()

// GetCondition returns the Condition matching the given type.
func (pr *PipelineRunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return pipelineRunCondSet.Manage(pr).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in pipelineRunCondSet to unknown for the PipelineRun
// and set the started time to the current time
func (pr *PipelineRunStatus) InitializeConditions(c clock.PassiveClock) <span class="cov8" title="1">{
        started := false
        if pr.StartTime.IsZero() </span><span class="cov8" title="1">{
                pr.StartTime = &amp;metav1.Time{Time: c.Now()}
                started = true
        }</span>
        <span class="cov8" title="1">conditionManager := pipelineRunCondSet.Manage(pr)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov8" title="1">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = PipelineRunReasonStarted.String()
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (pr *PipelineRunStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                pipelineRunCondSet.Manage(pr).SetCondition(*newCond)
        }</span>
}

// MarkSucceeded changes the Succeeded condition to True with the provided reason and message.
func (pr *PipelineRunStatus) MarkSucceeded(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        pipelineRunCondSet.Manage(pr).MarkTrueWithReason(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := pr.GetCondition(apis.ConditionSucceeded)
        pr.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkFailed changes the Succeeded condition to False with the provided reason and message.
func (pr *PipelineRunStatus) MarkFailed(reason, messageFormat string, messageA ...interface{}) <span class="cov8" title="1">{
        messageFormat = pipelineErrors.LabelUserError(messageFormat, messageA)
        pipelineRunCondSet.Manage(pr).MarkFalse(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := pr.GetCondition(apis.ConditionSucceeded)
        pr.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkRunning changes the Succeeded condition to Unknown with the provided reason and message.
func (pr *PipelineRunStatus) MarkRunning(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        pipelineRunCondSet.Manage(pr).MarkUnknown(apis.ConditionSucceeded, reason, messageFormat, messageA...)
}</span>

// ChildStatusReference is used to point to the statuses of individual TaskRuns and Runs within this PipelineRun.
type ChildStatusReference struct {
        runtime.TypeMeta `json:",inline"`
        // Name is the name of the TaskRun or Run this is referencing.
        Name string `json:"name,omitempty"`
        // DisplayName is a user-facing name of the pipelineTask that may be
        // used to populate a UI.
        DisplayName string `json:"displayName,omitempty"`
        // PipelineTaskName is the name of the PipelineTask this is referencing.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`

        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// PipelineRunStatusFields holds the fields of PipelineRunStatus' status.
// This is defined separately and inlined so that other types can readily
// consume these fields via duck typing.
type PipelineRunStatusFields struct {
        // StartTime is the time the PipelineRun is actually started.
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the PipelineRun completed.
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // Results are the list of results written out by the pipeline task's containers
        // +optional
        // +listType=atomic
        Results []PipelineRunResult `json:"results,omitempty"`

        // PipelineSpec contains the exact spec used to instantiate the run.
        // See Pipeline.spec (API version: tekton.dev/v1)
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`

        // list of tasks that were skipped due to when expressions evaluating to false
        // +optional
        // +listType=atomic
        SkippedTasks []SkippedTask `json:"skippedTasks,omitempty"`

        // list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.
        // +optional
        // +listType=atomic
        ChildReferences []ChildStatusReference `json:"childReferences,omitempty"`

        // FinallyStartTime is when all non-finally tasks have been completed and only finally tasks are being executed.
        // +optional
        FinallyStartTime *metav1.Time `json:"finallyStartTime,omitempty"`

        // Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
        // +optional
        Provenance *Provenance `json:"provenance,omitempty"`

        // SpanContext contains tracing span context fields
        SpanContext map[string]string `json:"spanContext,omitempty"`
}

// SkippedTask is used to describe the Tasks that were skipped due to their When Expressions
// evaluating to False. This is a struct because we are looking into including more details
// about the When Expressions that caused this Task to be skipped.
type SkippedTask struct {
        // Name is the Pipeline Task name
        Name string `json:"name"`
        // Reason is the cause of the PipelineTask being skipped.
        Reason SkippingReason `json:"reason"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// SkippingReason explains why a PipelineTask was skipped.
type SkippingReason string

const (
        // WhenExpressionsSkip means the task was skipped due to at least one of its when expressions evaluating to false
        WhenExpressionsSkip SkippingReason = "When Expressions evaluated to false"
        // ParentTasksSkip means the task was skipped because its parent was skipped
        ParentTasksSkip SkippingReason = "Parent Tasks were skipped"
        // StoppingSkip means the task was skipped because the pipeline run is stopping
        StoppingSkip SkippingReason = "PipelineRun was stopping"
        // GracefullyCancelledSkip means the task was skipped because the pipeline run has been gracefully cancelled
        GracefullyCancelledSkip SkippingReason = "PipelineRun was gracefully cancelled"
        // GracefullyStoppedSkip means the task was skipped because the pipeline run has been gracefully stopped
        GracefullyStoppedSkip SkippingReason = "PipelineRun was gracefully stopped"
        // MissingResultsSkip means the task was skipped because it's missing necessary results
        MissingResultsSkip SkippingReason = "Results were missing"
        // PipelineTimedOutSkip means the task was skipped because the PipelineRun has passed its overall timeout.
        PipelineTimedOutSkip SkippingReason = "PipelineRun timeout has been reached"
        // TasksTimedOutSkip means the task was skipped because the PipelineRun has passed its Timeouts.Tasks.
        TasksTimedOutSkip SkippingReason = "PipelineRun Tasks timeout has been reached"
        // FinallyTimedOutSkip means the task was skipped because the PipelineRun has passed its Timeouts.Finally.
        FinallyTimedOutSkip SkippingReason = "PipelineRun Finally timeout has been reached"
        // EmptyArrayInMatrixParams means the task was skipped because Matrix parameters contain empty array.
        EmptyArrayInMatrixParams SkippingReason = "Matrix Parameters have an empty array"
        // None means the task was not skipped
        None SkippingReason = "None"
)

// PipelineRunResult used to describe the results of a pipeline
type PipelineRunResult struct {
        // Name is the result's name as declared by the Pipeline
        Name string `json:"name"`

        // Value is the result returned from the execution of this PipelineRun
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// PipelineRunTaskRunStatus contains the name of the PipelineTask for this TaskRun and the TaskRun's Status
type PipelineRunTaskRunStatus struct {
        // PipelineTaskName is the name of the PipelineTask.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`
        // Status is the TaskRunStatus for the corresponding TaskRun
        // +optional
        Status *TaskRunStatus `json:"status,omitempty"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// PipelineRunRunStatus contains the name of the PipelineTask for this Run and the Run's Status
type PipelineRunRunStatus struct {
        // PipelineTaskName is the name of the PipelineTask.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`
        // Status is the RunStatus for the corresponding Run
        // +optional
        Status *runv1beta1.CustomRunStatus `json:"status,omitempty"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// PipelineRunList contains a list of PipelineRun
type PipelineRunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []PipelineRun `json:"items,omitempty"`
}

// PipelineTaskRun reports the results of running a step in the Task. Each
// task has the potential to succeed or fail (based on the exit code)
// and produces logs.
type PipelineTaskRun struct {
        Name string `json:"name,omitempty"`
}

// PipelineTaskRunSpec  can be used to configure specific
// specs for a concrete Task
type PipelineTaskRunSpec struct {
        PipelineTaskName   string           `json:"pipelineTaskName,omitempty"`
        ServiceAccountName string           `json:"serviceAccountName,omitempty"`
        PodTemplate        *pod.PodTemplate `json:"podTemplate,omitempty"`
        // +listType=atomic
        StepSpecs []TaskRunStepSpec `json:"stepSpecs,omitempty"`
        // +listType=atomic
        SidecarSpecs []TaskRunSidecarSpec `json:"sidecarSpecs,omitempty"`

        // +optional
        Metadata *PipelineTaskMetadata `json:"metadata,omitempty"`

        // Compute resources to use for this TaskRun
        ComputeResources *corev1.ResourceRequirements `json:"computeResources,omitempty"`

        // Duration after which the TaskRun times out. Overrides the timeout specified
        // on the Task's spec if specified. Takes lower precedence to PipelineRun's
        // `spec.timeouts.tasks`
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`
}

// GetTaskRunSpec returns the task specific spec for a given
// PipelineTask if configured, otherwise it returns the PipelineRun's default.
func (pr *PipelineRun) GetTaskRunSpec(pipelineTaskName string) PipelineTaskRunSpec <span class="cov8" title="1">{
        s := PipelineTaskRunSpec{
                PipelineTaskName:   pipelineTaskName,
                ServiceAccountName: pr.Spec.TaskRunTemplate.ServiceAccountName,
                PodTemplate:        pr.Spec.TaskRunTemplate.PodTemplate,
        }
        for _, task := range pr.Spec.TaskRunSpecs </span><span class="cov8" title="1">{
                if task.PipelineTaskName == pipelineTaskName </span><span class="cov8" title="1">{
                        // merge podTemplates specified in pipelineRun.spec.taskRunSpecs[].podTemplate and pipelineRun.spec.podTemplate
                        // with taskRunSpecs taking higher precedence
                        s.PodTemplate = pod.MergePodTemplateWithDefault(task.PodTemplate, s.PodTemplate)
                        if task.ServiceAccountName != "" </span><span class="cov8" title="1">{
                                s.ServiceAccountName = task.ServiceAccountName
                        }</span>
                        <span class="cov8" title="1">s.StepSpecs = task.StepSpecs
                        s.SidecarSpecs = task.SidecarSpecs
                        s.Metadata = task.Metadata
                        s.ComputeResources = task.ComputeResources
                        s.Timeout = task.Timeout</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

// PipelineTaskRunTemplate is used to specify run specifications for all Task in pipelinerun.
type PipelineTaskRunTemplate struct {
        // +optional
        PodTemplate *pod.PodTemplate `json:"podTemplate,omitempty"`
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "slices"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*PipelineRun)(nil)
        _ resourcesemantics.VerbLimited = (*PipelineRun)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (pr *PipelineRun) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate pipelinerun
func (pr *PipelineRun) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(pr.GetObjectMeta()).ViaField("metadata")

        if pr.IsPending() &amp;&amp; pr.HasStarted() </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("PipelineRun cannot be Pending after it is started", "spec.status"))
        }</span>

        <span class="cov8" title="1">return errs.Also(pr.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))</span>
}

// Validate pipelinerun spec
func (ps *PipelineRunSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate the spec changes
        errs = errs.Also(ps.ValidateUpdate(ctx))

        // Must have exactly one of pipelineRef and pipelineSpec.
        if ps.PipelineRef == nil &amp;&amp; ps.PipelineSpec == nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("pipelineRef", "pipelineSpec"))
        }</span>
        <span class="cov8" title="1">if ps.PipelineRef != nil &amp;&amp; ps.PipelineSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("pipelineRef", "pipelineSpec"))
        }</span>

        // Validate PipelineRef if it's present
        <span class="cov8" title="1">if ps.PipelineRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ps.PipelineRef.Validate(ctx).ViaField("pipelineRef"))
        }</span>

        // Validate PipelineSpec if it's present
        <span class="cov8" title="1">if ps.PipelineSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipelinerun") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("pipelineSpec"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(ps.PipelineSpec.Validate(ctx).ViaField("pipelineSpec"))</span>
        }

        // Validate PipelineRun parameters
        <span class="cov8" title="1">errs = errs.Also(ps.validatePipelineRunParameters(ctx))

        // Validate propagated parameters
        errs = errs.Also(ps.validateInlineParameters(ctx))

        if ps.Timeouts != nil </span><span class="cov8" title="1">{
                // tasks timeout should be a valid duration of at least 0.
                errs = errs.Also(validateTimeoutDuration("tasks", ps.Timeouts.Tasks))

                // finally timeout should be a valid duration of at least 0.
                errs = errs.Also(validateTimeoutDuration("finally", ps.Timeouts.Finally))

                // pipeline timeout should be a valid duration of at least 0.
                errs = errs.Also(validateTimeoutDuration("pipeline", ps.Timeouts.Pipeline))

                if ps.Timeouts.Pipeline != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(ps.validatePipelineTimeout(ps.Timeouts.Pipeline.Duration, "should be &lt;= pipeline duration"))
                }</span> else<span class="cov8" title="1"> {
                        defaultTimeout := time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes)
                        errs = errs.Also(ps.validatePipelineTimeout(defaultTimeout, "should be &lt;= default timeout duration"))
                }</span>
        }

        // Validate individual TaskRunSpecs with timeout context
        <span class="cov8" title="1">for idx, trs := range ps.TaskRunSpecs </span><span class="cov8" title="1">{
                errs = errs.Also(validateTaskRunSpec(ctx, trs, ps.Timeouts).ViaIndex(idx).ViaField("taskRunSpecs"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateSpecStatus(ps.Status))

        if ps.Workspaces != nil </span><span class="cov8" title="1">{
                wsNames := make(map[string]int)
                for idx, ws := range ps.Workspaces </span><span class="cov8" title="1">{
                        errs = errs.Also(ws.Validate(ctx).ViaFieldIndex("workspaces", idx))
                        if prevIdx, alreadyExists := wsNames[ws.Name]; alreadyExists </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace %q provided by pipelinerun more than once, at index %d and %d", ws.Name, prevIdx, idx), "name").ViaFieldIndex("workspaces", idx))
                        }</span>
                        <span class="cov8" title="1">wsNames[ws.Name] = idx</span>
                }
        }

        <span class="cov8" title="1">if ps.TaskRunTemplate.PodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *ps.TaskRunTemplate.PodTemplate).ViaField("taskRunTemplate"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateUpdate validates the update of a PipelineRunSpec
func (ps *PipelineRunSpec) ValidateUpdate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">oldObj, ok := apis.GetBaseline(ctx).(*PipelineRun)
        if !ok || oldObj == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if oldObj.IsDone() </span><span class="cov8" title="1">{
                // try comparing without any copying first
                // this handles the common case where only finalizers changed
                if equality.Semantic.DeepEqual(&amp;oldObj.Spec, ps) </span><span class="cov8" title="1">{
                        return nil // Specs identical, allow update
                }</span>

                // Specs differ, this could be due to different defaults after upgrade
                // Apply current defaults to old spec to normalize
                <span class="cov8" title="1">oldCopy := oldObj.Spec.DeepCopy()
                oldCopy.SetDefaults(ctx)

                if equality.Semantic.DeepEqual(oldCopy, ps) </span><span class="cov0" title="0">{
                        return nil // Difference was only defaults, allow update
                }</span>

                // Real spec changes detected, reject update
                <span class="cov8" title="1">errs = errs.Also(apis.ErrInvalidValue("Once the PipelineRun is complete, no updates are allowed", ""))
                return errs</span>
        }

        // Handle started but not done case
        <span class="cov8" title="1">old := oldObj.Spec.DeepCopy()
        old.Status = ps.Status
        if !equality.Semantic.DeepEqual(old, ps) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("Once the PipelineRun has started, only status updates are allowed", ""))
        }</span>

        <span class="cov8" title="1">return</span>
}

func (ps *PipelineRunSpec) validatePipelineRunParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(ps.Params) == 0 </span><span class="cov8" title="1">{
                return errs
        }</span>

        // Validate parameter types and uniqueness
        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ps.Params).ViaField("params"))

        // Validate that task results aren't used in param values
        for _, param := range ps.Params </span><span class="cov8" title="1">{
                expressions, ok := param.GetVarSubstitutionExpressions()
                if ok </span><span class="cov0" title="0">{
                        if LooksLikeContainsResultRefs(expressions) </span><span class="cov0" title="0">{
                                expressions = filter(expressions, resultref.LooksLikeResultRef)
                                resultRefs := NewResultRefs(expressions)
                                if len(resultRefs) &gt; 0 </span><span class="cov0" title="0">{
                                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("cannot use result expressions in %v as PipelineRun parameter values", expressions),
                                                "value").ViaFieldKey("params", param.Name))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// validateInlineParameters validates parameters that are defined inline.
// This is crucial for propagated parameters since the parameters could
// be defined under pipelineRun and then called directly in the task steps.
// In this case, parameters cannot be validated by the underlying pipelineSpec
// or taskSpec since they may not have the parameters declared because of propagation.
func (ps *PipelineRunSpec) validateInlineParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ps.PipelineSpec == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">paramSpecForValidation := make(map[string]ParamSpec)
        for _, p := range ps.Params </span><span class="cov8" title="1">{
                paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
        }</span>
        <span class="cov8" title="1">for _, p := range ps.PipelineSpec.Params </span><span class="cov8" title="1">{
                var err *apis.FieldError
                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                if err != nil </span><span class="cov0" title="0">{
                        errs = errs.Also(err)
                }</span>
        }
        <span class="cov8" title="1">for _, pt := range ps.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                paramSpecForValidation = appendPipelineTaskParams(paramSpecForValidation, pt.Params)
                if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Params != nil </span><span class="cov8" title="1">{
                        for _, p := range pt.TaskSpec.Params </span><span class="cov8" title="1">{
                                var err *apis.FieldError
                                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = errs.Also(err)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">var paramSpec []ParamSpec
        for _, v := range paramSpecForValidation </span><span class="cov8" title="1">{
                paramSpec = append(paramSpec, v)
        }</span>
        <span class="cov8" title="1">if ps.PipelineSpec != nil &amp;&amp; ps.PipelineSpec.Tasks != nil </span><span class="cov8" title="1">{
                for _, pt := range ps.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                        if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Steps != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(ValidateParameterTypes(ctx, paramSpec))
                                errs = errs.Also(ValidateParameterVariables(ctx, pt.TaskSpec.Steps, paramSpec))
                                errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, pt.TaskSpec.Steps, paramSpec))
                        }</span>
                }
                <span class="cov8" title="1">errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.PipelineSpec.Tasks, paramSpec))
                errs = errs.Also(validatePipelineTaskParameterUsage(ps.PipelineSpec.Tasks, paramSpec))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func appendPipelineTaskParams(paramSpecForValidation map[string]ParamSpec, params Params) map[string]ParamSpec <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                if pSpec, ok := paramSpecForValidation[p.Name]; ok </span><span class="cov8" title="1">{
                        if p.Value.ObjectVal != nil </span><span class="cov8" title="1">{
                                for k, v := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                                        pSpec.Default.ObjectVal[k] = v
                                        pSpec.Properties[k] = PropertySpec{Type: ParamTypeString}
                                }</span>
                        }
                        <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec</span>
                } else<span class="cov8" title="1"> {
                        paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
                }</span>
        }
        <span class="cov8" title="1">return paramSpecForValidation</span>
}

func validateSpecStatus(status PipelineRunSpecStatus) *apis.FieldError <span class="cov8" title="1">{
        switch status </span>{
        case "":<span class="cov8" title="1">
                return nil</span>
        case PipelineRunSpecStatusPending:<span class="cov8" title="1">
                return nil</span>
        case PipelineRunSpecStatusCancelled,
                PipelineRunSpecStatusCancelledRunFinally,
                PipelineRunSpecStatusStoppedRunFinally:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">return apis.ErrInvalidValue(fmt.Sprintf("%s should be %s, %s, %s or %s", status,
                PipelineRunSpecStatusCancelled,
                PipelineRunSpecStatusCancelledRunFinally,
                PipelineRunSpecStatusStoppedRunFinally,
                PipelineRunSpecStatusPending), "status")</span>
}

func validateTimeoutDuration(field string, d *metav1.Duration) (errs *apis.FieldError) <span class="cov8" title="1">{
        if d != nil &amp;&amp; d.Duration &lt; 0 </span><span class="cov8" title="1">{
                fieldPath := "timeouts." + field
                return errs.Also(apis.ErrInvalidValue(d.Duration.String()+" should be &gt;= 0", fieldPath))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ps *PipelineRunSpec) validatePipelineTimeout(timeout time.Duration, errorMsg string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ps.Timeouts.Tasks != nil </span><span class="cov8" title="1">{
                tasksTimeoutErr := false
                tasksTimeoutStr := ps.Timeouts.Tasks.Duration.String()
                if ps.Timeouts.Tasks.Duration &gt; timeout &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        tasksTimeoutErr = true
                }</span>
                <span class="cov8" title="1">if ps.Timeouts.Tasks.Duration == config.NoTimeoutDuration &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        tasksTimeoutErr = true
                        tasksTimeoutStr += " (no timeout)"
                }</span>
                <span class="cov8" title="1">if tasksTimeoutErr </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s %s", tasksTimeoutStr, errorMsg), "timeouts.tasks"))
                }</span>
        }

        <span class="cov8" title="1">if ps.Timeouts.Finally != nil </span><span class="cov8" title="1">{
                finallyTimeoutErr := false
                finallyTimeoutStr := ps.Timeouts.Finally.Duration.String()
                if ps.Timeouts.Finally.Duration &gt; timeout &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        finallyTimeoutErr = true
                }</span>
                <span class="cov8" title="1">if ps.Timeouts.Finally.Duration == config.NoTimeoutDuration &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        finallyTimeoutErr = true
                        finallyTimeoutStr += " (no timeout)"
                }</span>
                <span class="cov8" title="1">if finallyTimeoutErr </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s %s", finallyTimeoutStr, errorMsg), "timeouts.finally"))
                }</span>
        }

        <span class="cov8" title="1">if ps.Timeouts.Tasks != nil &amp;&amp; ps.Timeouts.Finally != nil </span><span class="cov8" title="1">{
                if ps.Timeouts.Tasks.Duration+ps.Timeouts.Finally.Duration &gt; timeout </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s + %s %s", ps.Timeouts.Tasks.Duration.String(), ps.Timeouts.Finally.Duration.String(), errorMsg), "timeouts.tasks"))
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s + %s %s", ps.Timeouts.Tasks.Duration.String(), ps.Timeouts.Finally.Duration.String(), errorMsg), "timeouts.finally"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateTaskRunSpec(ctx context.Context, trs PipelineTaskRunSpec, pipelineTimeouts *TimeoutFields) (errs *apis.FieldError) <span class="cov8" title="1">{
        if trs.StepSpecs != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "stepSpecs", config.BetaAPIFields).ViaField("stepSpecs"))
                errs = errs.Also(validateStepSpecs(trs.StepSpecs).ViaField("stepSpecs"))
        }</span>
        <span class="cov8" title="1">if trs.SidecarSpecs != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecarSpecs", config.BetaAPIFields).ViaField("sidecarSpecs"))
                errs = errs.Also(validateSidecarSpecs(trs.SidecarSpecs).ViaField("sidecarSpecs"))
        }</span>
        <span class="cov8" title="1">if trs.ComputeResources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "computeResources", config.BetaAPIFields).ViaField("computeResources"))
                errs = errs.Also(validateTaskRunComputeResources(trs.ComputeResources, trs.StepSpecs))
        }</span>
        <span class="cov8" title="1">if trs.PodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *trs.PodTemplate))
        }</span>

        <span class="cov8" title="1">errs = errs.Also(validateTaskRunSpecTimeout(ctx, trs.Timeout, pipelineTimeouts))

        return errs</span>
}

// validateTaskRunSpecTimeout validates a TaskRunSpec's timeout against pipeline timeouts.
// This function works in isolation and doesn't rely on previous validation steps.
func validateTaskRunSpecTimeout(ctx context.Context, timeout *metav1.Duration, pipelineTimeouts *TimeoutFields) *apis.FieldError <span class="cov8" title="1">{
        if timeout == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)

        // Validate basic timeout (negative values)
        if _, err := validateTimeout(timeout, cfg.Defaults.DefaultTimeoutMinutes); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Find applicable timeout limit: Tasks -&gt; Pipeline -&gt; Default (60min)
        <span class="cov8" title="1">var maxTimeout *metav1.Duration
        var timeoutSource string

        switch </span>{
        case pipelineTimeouts != nil &amp;&amp; pipelineTimeouts.Tasks != nil:<span class="cov8" title="1">
                if validatedTimeout, err := validateTimeout(pipelineTimeouts.Tasks, cfg.Defaults.DefaultTimeoutMinutes); err != nil </span><span class="cov0" title="0">{
                        // Return error if Tasks timeout is invalid (prevents silent failures)
                        return err
                }</span> else<span class="cov8" title="1"> {
                        maxTimeout = validatedTimeout
                        timeoutSource = "pipeline tasks duration"
                }</span>
        case pipelineTimeouts != nil &amp;&amp; pipelineTimeouts.Pipeline != nil:<span class="cov8" title="1">
                if validatedTimeout, err := validateTimeout(pipelineTimeouts.Pipeline, cfg.Defaults.DefaultTimeoutMinutes); err != nil </span><span class="cov0" title="0">{
                        // Return error if Pipeline timeout is invalid (prevents silent failures)
                        return err
                }</span> else<span class="cov8" title="1"> {
                        maxTimeout = validatedTimeout
                        timeoutSource = "pipeline duration"
                }</span>
        default:<span class="cov8" title="1">
                maxTimeout = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
                timeoutSource = "default pipeline duration"</span>
        }

        // always check against max timeout
        <span class="cov8" title="1">if maxTimeout != nil &amp;&amp; maxTimeout.Duration != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                if taskRunTimeout, _ := validateTimeout(timeout, cfg.Defaults.DefaultTimeoutMinutes); taskRunTimeout.Duration &gt; maxTimeout.Duration </span><span class="cov8" title="1">{ // We know this won't error from above
                        return apis.ErrInvalidValue(
                                fmt.Sprintf("%s should be &lt;= %s %s", taskRunTimeout.Duration, timeoutSource, maxTimeout.Duration),
                                "timeout")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateTimeout validates a timeout field and returns the validated timeout with defaults applied.
// If timeout is nil, returns default timeout. If timeout is negative, returns an error.
func validateTimeout(timeout *metav1.Duration, defaultTimeoutMinutes int) (*metav1.Duration, *apis.FieldError) <span class="cov8" title="1">{
        if timeout == nil </span><span class="cov0" title="0">{
                return &amp;metav1.Duration{Duration: time.Duration(defaultTimeoutMinutes) * time.Minute}, nil
        }</span>
        <span class="cov8" title="1">if timeout.Duration &lt; 0 </span><span class="cov8" title="1">{
                return nil, apis.ErrInvalidValue(timeout.Duration.String()+" should be &gt;= 0", "timeout")
        }</span>
        <span class="cov8" title="1">return timeout, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: pipeline.GroupName, Version: "v1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;Task{},
                &amp;TaskList{},
                &amp;Pipeline{},
                &amp;PipelineList{},
                &amp;TaskRun{},
                &amp;TaskRunList{},
                &amp;PipelineRun{},
                &amp;PipelineRunList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import "context"

// SetDefaults set the default type for TaskResult
func (tr *TaskResult) SetDefaults(context.Context) <span class="cov8" title="1">{
        if tr == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if tr.Type == "" </span><span class="cov8" title="1">{
                if tr.Properties != nil </span><span class="cov8" title="1">{
                        // Set type to object if `properties` is given
                        tr.Type = ResultsTypeObject
                }</span> else<span class="cov8" title="1"> {
                        // ResultsTypeString is the default value
                        tr.Type = ResultsTypeString
                }</span>
        }

        // Set default type of object values to string
        <span class="cov8" title="1">for key, propertySpec := range tr.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type == "" </span><span class="cov8" title="1">{
                        tr.Properties[key] = PropertySpec{Type: ParamType(ResultsTypeString)}
                }</span>
        }
}

// SetDefaults set the default type for StepResult
func (sr *StepResult) SetDefaults(context.Context) <span class="cov8" title="1">{
        if sr == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if sr.Type == "" </span><span class="cov8" title="1">{
                if sr.Properties != nil </span><span class="cov8" title="1">{
                        // Set type to object if `properties` is given
                        sr.Type = ResultsTypeObject
                }</span> else<span class="cov8" title="1"> {
                        // ResultsTypeString is the default value
                        sr.Type = ResultsTypeString
                }</span>
        }

        // Set default type of object values to string
        <span class="cov8" title="1">for key, propertySpec := range sr.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type == "" </span><span class="cov8" title="1">{
                        sr.Properties[key] = PropertySpec{Type: ParamType(ResultsTypeString)}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import "strings"

// TaskResult used to describe the results of a task
type TaskResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Properties is the JSON Schema properties to support key-value pairs results.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description,omitempty"`

        // Value the expression used to retrieve the value of the result from an underlying Step.
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value *ResultValue `json:"value,omitempty"`
}

// StepResult used to describe the Results of a Step.
type StepResult struct {
        // Name the given name
        Name string `json:"name"`

        // The possible types are 'string', 'array', and 'object', with 'string' as the default.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Properties is the JSON Schema properties to support key-value pairs results.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description,omitempty"`
}

// TaskRunResult used to describe the results of a task
type TaskRunResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Value the given value of the result
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// TaskRunStepResult is a type alias of TaskRunResult
type TaskRunStepResult = TaskRunResult

// ResultValue is a type alias of ParamValue
type ResultValue = ParamValue

// ResultsType indicates the type of a result;
// Used to distinguish between a single string and an array of strings.
// Note that there is ResultType used to find out whether a
// RunResult is from a task result or not, which is different from
// this ResultsType.
type ResultsType string

// Valid ResultsType:
const (
        ResultsTypeString ResultsType = "string"
        ResultsTypeArray  ResultsType = "array"
        ResultsTypeObject ResultsType = "object"
)

// AllResultsTypes can be used for ResultsTypes validation.
var AllResultsTypes = []ResultsType{ResultsTypeString, ResultsTypeArray, ResultsTypeObject}

// ResultsArrayReference returns the reference of the result. e.g. results.resultname from $(results.resultname[*])
func ResultsArrayReference(a string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimSuffix(strings.TrimPrefix(a, "$("), ")"), "[*]")
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "regexp"

        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// Validate implements apis.Validatable
func (tr TaskResult) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !resultNameFormatRegex.MatchString(tr.Name) </span><span class="cov8" title="1">{
                return apis.ErrInvalidKeyName(tr.Name, "name", fmt.Sprintf("Name must consist of alphanumeric characters, '-', '_', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my-name',  or 'my_name', regex used for validation is '%s')", ResultNameFormat))
        }</span>

        <span class="cov8" title="1">switch </span>{
        case tr.Type == ResultsTypeObject:<span class="cov8" title="1">
                errs = errs.Also(validateObjectResult(tr))</span>
        case tr.Type == ResultsTypeArray:<span class="cov8" title="1"></span>
        // Resources created before the result. Type was introduced may not have Type set
        // and should be considered valid
        case tr.Type == "":<span class="cov8" title="1"></span>
        // By default, the result type is string
        case tr.Type != ResultsTypeString:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrInvalidValue(tr.Type, "type", "type must be string"))</span>
        }
        <span class="cov8" title="1">return errs.Also(tr.validateValue(ctx))</span>
}

// validateObjectResult validates the object result and check if the Properties is missing
// for Properties values it will check if the type is string.
func validateObjectResult(tr TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ParamType(tr.Type) == ParamTypeObject &amp;&amp; tr.Properties == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(tr.Name + ".properties")
        }</span>

        <span class="cov8" title="1">invalidKeys := []string{}
        for key, propertySpec := range tr.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type != ParamTypeString </span><span class="cov8" title="1">{
                        invalidKeys = append(invalidKeys, key)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidKeys) != 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("The value type specified for these keys %v is invalid, the type must be string", invalidKeys),
                        Paths:   []string{tr.Name + ".properties"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateValue validates the value of the TaskResult.
// It requires that the value is of type string
// and format $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;)
func (tr TaskResult) validateValue(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if tr.Value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if tr.Value.Type != ParamTypeString </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf(
                                "Invalid Type. Wanted string but got: \"%v\"", tr.Value.Type),
                        Paths: []string{
                                tr.Name + ".type",
                        },
                }
        }</span>
        <span class="cov8" title="1">if tr.Value.StringVal != "" </span><span class="cov8" title="1">{
                stepName, resultName, err := ExtractStepResultName(tr.Value.StringVal)
                if err != nil </span><span class="cov8" title="1">{
                        return &amp;apis.FieldError{
                                Message: fmt.Sprintf("%v", err),
                                Paths:   []string{tr.Name + ".value"},
                        }
                }</span>
                <span class="cov8" title="1">if e := validation.IsDNS1123Label(stepName); len(e) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid extracted step name %q", stepName),
                                Paths:   []string{tr.Name + ".value"},
                                Details: "stepName in $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;) must be a valid DNS Label, For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        })
                }</span>
                <span class="cov8" title="1">if !resultNameFormatRegex.MatchString(resultName) </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid extracted result name %q", resultName),
                                Paths:   []string{tr.Name + ".value"},
                                Details: fmt.Sprintf("resultName in $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;) must consist of alphanumeric characters, '-', '_', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my-name',  or 'my_name', regex used for validation is '%s')", ResultNameFormat),
                        })
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Validate implements apis.Validatable
func (sr StepResult) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !resultNameFormatRegex.MatchString(sr.Name) </span><span class="cov8" title="1">{
                return apis.ErrInvalidKeyName(sr.Name, "name", fmt.Sprintf("Name must consist of alphanumeric characters, '-', '_', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my-name',  or 'my_name', regex used for validation is '%s')", ResultNameFormat))
        }</span>

        <span class="cov8" title="1">switch </span>{
        case sr.Type == ResultsTypeObject:<span class="cov8" title="1">
                return validateObjectStepResult(sr)</span>
        case sr.Type == ResultsTypeArray:<span class="cov8" title="1">
                return nil</span>
        // The Type is string by default if it is empty.
        case sr.Type == "":<span class="cov8" title="1">
                return nil</span>
        case sr.Type == ResultsTypeString:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return apis.ErrInvalidValue(sr.Type, "type", fmt.Sprintf("invalid type %s", sr.Type))</span>
        }
}

// validateObjectStepResult validates the object result and check if the Properties is missing
// for Properties values it will check if the type is string.
func validateObjectStepResult(sr StepResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ParamType(sr.Type) == ParamTypeObject &amp;&amp; sr.Properties == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(sr.Name + ".properties")
        }</span>

        <span class="cov8" title="1">invalidKeys := []string{}
        for key, propertySpec := range sr.Properties </span><span class="cov8" title="1">{
                // In case we need to support other types in the future like the nested objects #7069
                if propertySpec.Type != ParamTypeString </span><span class="cov8" title="1">{
                        invalidKeys = append(invalidKeys, key)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidKeys) != 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("the value type specified for these keys %v is invalid, the type must be string", invalidKeys),
                        Paths:   []string{sr.Name + ".properties"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ExtractStepResultName extracts the step name and result name from a string matching
// formtat $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;).
// If a match is not found, an error is retured.
func ExtractStepResultName(value string) (string, string, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`\$\(steps\.(.*?)\.results\.(.*?)\)`)
        rs := re.FindStringSubmatch(value)
        if len(rs) != 3 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("Could not extract step name and result name. Expected value to look like $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;) but got \"%v\"", value)
        }</span>
        <span class="cov8" title="1">return rs[1], rs[2], nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "regexp"
        "strings"

        "github.com/tektoncd/pipeline/pkg/internal/resultref"
)

// ResultRef is a type that represents a reference to a task run result
type ResultRef struct {
        PipelineTask string `json:"pipelineTask"`
        Result       string `json:"result"`
        ResultsIndex *int   `json:"resultsIndex"`
        Property     string `json:"property"`
}

const (
        // ResultTaskPart Constant used to define the "tasks" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultTaskPart = resultref.ResultTaskPart
        // ResultFinallyPart Constant used to define the "finally" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultFinallyPart = resultref.ResultFinallyPart
        // ResultResultPart Constant used to define the "results" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultResultPart = resultref.ResultResultPart
        // TODO(#2462) use one regex across all substitutions
        // variableSubstitutionFormat matches format like $result.resultname, $result.resultname[int] and $result.resultname[*]
        variableSubstitutionFormat = `\$\([_a-zA-Z0-9.-]+(\.[_a-zA-Z0-9.-]+)*(\[([0-9]+|\*)\])?\)`
        // exactVariableSubstitutionFormat matches strings that only contain a single reference to result or param variables, but nothing else
        // i.e. `$(result.resultname)` is a match, but `foo $(result.resultname)` is not.
        exactVariableSubstitutionFormat = `^\$\([_a-zA-Z0-9.-]+(\.[_a-zA-Z0-9.-]+)*(\[([0-9]+|\*)\])?\)$`
        // ResultNameFormat Constant used to define the regex Result.Name should follow
        ResultNameFormat = `^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$`
)

// VariableSubstitutionRegex is a regex to find all result matching substitutions
var VariableSubstitutionRegex = regexp.MustCompile(variableSubstitutionFormat)
var exactVariableSubstitutionRegex = regexp.MustCompile(exactVariableSubstitutionFormat)
var resultNameFormatRegex = regexp.MustCompile(ResultNameFormat)

// NewResultRefs extracts all ResultReferences from a param or a pipeline result.
// If the ResultReference can be extracted, they are returned. Expressions which are not
// results are ignored.
func NewResultRefs(expressions []string) []*ResultRef <span class="cov8" title="1">{
        var resultRefs []*ResultRef
        for _, expression := range expressions </span><span class="cov8" title="1">{
                pr, err := resultref.ParseTaskExpression(expression)
                // If the expression isn't a result but is some other expression,
                // parseTaskExpression will return an error, in which case we just skip that expression,
                // since although it's not a result ref, it might be some other kind of reference
                if err == nil </span><span class="cov8" title="1">{
                        resultRefs = append(resultRefs, &amp;ResultRef{
                                PipelineTask: pr.ResourceName,
                                Result:       pr.ResultName,
                                ResultsIndex: pr.ArrayIdx,
                                Property:     pr.ObjectKey,
                        })
                }</span>
        }
        <span class="cov8" title="1">return resultRefs</span>
}

// LooksLikeContainsResultRefs attempts to check if param or a pipeline result looks like it contains any
// result references.
// This is useful if we want to make sure the param looks like a ResultReference before
// performing strict validation
func LooksLikeContainsResultRefs(expressions []string) bool <span class="cov8" title="1">{
        for _, expression := range expressions </span><span class="cov8" title="1">{
                if resultref.LooksLikeResultRef(expression) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func validateString(value string) []string <span class="cov8" title="1">{
        expressions := VariableSubstitutionRegex.FindAllString(value, -1)
        if expressions == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var result []string
        for _, expression := range expressions </span><span class="cov8" title="1">{
                result = append(result, stripVarSubExpression(expression))
        }</span>
        <span class="cov8" title="1">return result</span>
}

func stripVarSubExpression(expression string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimPrefix(expression, "$("), ")")
}</span>

// ParseResultName parse the input string to extract resultName and result index.
// Array indexing:
// Input:  anArrayResult[1]
// Output: anArrayResult, "1"
// Array star reference:
// Input:  anArrayResult[*]
// Output: anArrayResult, "*"
// retained for backwards compatibility
func ParseResultName(resultName string) (string, string) <span class="cov8" title="1">{
        return resultref.ParseResultName(resultName)
}</span>

// PipelineTaskResultRefs walks all the places a result reference can be used
// in a PipelineTask and returns a list of any references that are found.
func PipelineTaskResultRefs(pt *PipelineTask) []*ResultRef <span class="cov8" title="1">{
        refs := []*ResultRef{}
        // TODO move the whenExpression.GetVarSubstitutionExpressions() and GetVarSubstitutionExpressionsForParam(p) as well
        // separate cleanup, reference https://github.com/tektoncd/pipeline/pull/7121
        for _, p := range pt.extractAllParams() </span><span class="cov8" title="1">{
                expressions, _ := p.GetVarSubstitutionExpressions()
                refs = append(refs, NewResultRefs(expressions)...)
        }</span>
        <span class="cov8" title="1">for _, whenExpression := range pt.When </span><span class="cov8" title="1">{
                expressions, _ := whenExpression.GetVarSubstitutionExpressions()
                refs = append(refs, NewResultRefs(expressions)...)
        }</span>
        <span class="cov8" title="1">taskSubExpressions := pt.GetVarSubstitutionExpressions()
        refs = append(refs, NewResultRefs(taskSubExpressions)...)
        return refs</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*Task)(nil)

// ConvertTo implements apis.Convertible
func (t *Task) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", sink)</span>
}

// ConvertFrom implements apis.Convertible
func (t *Task) ConvertFrom(ctx context.Context, source apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", source)</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*Task)(nil)

// SetDefaults implements apis.Defaultable
func (t *Task) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        t.Spec.SetDefaults(ctx)
}</span>

// SetDefaults set any defaults for the task spec
func (ts *TaskSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        for _, s := range ts.Steps </span><span class="cov8" title="1">{
                if s.Ref != nil &amp;&amp; s.Ref.Name == "" &amp;&amp; s.Ref.Resolver == "" </span><span class="cov8" title="1">{
                        s.Ref.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
                }</span>
        }
        <span class="cov8" title="1">for i := range ts.Params </span><span class="cov8" title="1">{
                ts.Params[i].SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">for i := range ts.Results </span><span class="cov8" title="1">{
                ts.Results[i].SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/kmeta"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Task represents a collection of sequential steps that are run as part of a
// Pipeline using a set of inputs and producing a set of outputs. Tasks execute
// when TaskRuns are created that provide the input parameters and resources and
// output resources the Task requires.
//
// +k8s:openapi-gen=true
// +kubebuilder:storageversion
type Task struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the Task from the client
        // +optional
        Spec TaskSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*Task)(nil)

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*Task) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.TaskControllerName)
}</span>

// Checksum computes the sha256 checksum of the task object.
// Prior to computing the checksum, it performs some preprocessing on the
// metadata of the object where it removes system provided annotations.
// Only the name, namespace, generateName, user-provided labels and annotations
// and the taskSpec are included for the checksum computation.
func (t *Task) Checksum() ([]byte, error) <span class="cov8" title="1">{
        objectMeta := checksum.PrepareObjectMeta(t)
        preprocessedTask := Task{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1",
                        Kind:       "Task"},
                ObjectMeta: objectMeta,
                Spec:       t.Spec,
        }
        sha256Checksum, err := checksum.ComputeSha256Checksum(preprocessedTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sha256Checksum, nil</span>
}

// +listType=atomic
type Volumes []corev1.Volume

// TaskSpec defines the desired state of Task.
type TaskSpec struct {
        // Params is a list of input parameters required to run the task. Params
        // must be supplied as inputs in TaskRuns unless they declare a default
        // value.
        // +optional
        Params ParamSpecs `json:"params,omitempty"`

        // DisplayName is a user-facing name of the task that may be
        // used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`

        // Description is a user-facing description of the task that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`

        // Steps are the steps of the build; each step is run sequentially with the
        // source mounted into /workspace.
        // +listType=atomic
        Steps []Step `json:"steps,omitempty"`

        // Volumes is a collection of volumes that are available to mount into the
        // steps of the build.
        // See Pod.spec.volumes (API version: v1)
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Volumes Volumes `json:"volumes,omitempty"`

        // StepTemplate can be used as the basis for all step containers within the
        // Task, so that the steps inherit settings on the base container.
        StepTemplate *StepTemplate `json:"stepTemplate,omitempty"`

        // Sidecars are run alongside the Task's step containers. They begin before
        // the steps start and end after the steps complete.
        // +listType=atomic
        Sidecars []Sidecar `json:"sidecars,omitempty"`

        // Workspaces are the volumes that this Task requires.
        // +listType=atomic
        Workspaces []WorkspaceDeclaration `json:"workspaces,omitempty"`

        // Results are values that this Task can output
        // +listType=atomic
        Results []TaskResult `json:"results,omitempty"`
}

// TaskList contains a list of Task
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TaskList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Task `json:"items"`
}

// StepList is a list of Steps
type StepList []Step

// SidecarList is a list of Sidecars
type SidecarList []Sidecar
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "path/filepath"
        "regexp"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/substitution"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

const (
        // stringAndArrayVariableNameFormat is the regex to validate if string/array variable name format follows the following rules.
        // - Must only contain alphanumeric characters, hyphens (-), underscores (_), and dots (.)
        // - Must begin with a letter or an underscore (_)
        stringAndArrayVariableNameFormat = "^[_a-zA-Z][_a-zA-Z0-9.-]*$"

        // objectVariableNameFormat is the regex used to validate object name and key names format
        // The difference with the array or string name format is that object variable names shouldn't contain dots.
        objectVariableNameFormat = "^[_a-zA-Z][_a-zA-Z0-9-]*$"
)

var (
        _ apis.Validatable              = (*Task)(nil)
        _ resourcesemantics.VerbLimited = (*Task)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (t *Task) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

var (
        stringAndArrayVariableNameFormatRegex = regexp.MustCompile(stringAndArrayVariableNameFormat)
        objectVariableNameFormatRegex         = regexp.MustCompile(objectVariableNameFormat)
)

// Validate implements apis.Validatable
func (t *Task) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(t.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        // When a Task is created directly, instead of declared inline in a TaskRun or PipelineRun,
        // we do not support propagated parameters. Validate that all params it uses are declared.
        errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, t.Spec.Steps, t.Spec.Params).ViaField("spec"))
        return errs
}</span>

// Validate implements apis.Validatable
func (ts *TaskSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(ts.Steps) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("steps"))
        }</span>

        <span class="cov8" title="1">errs = errs.Also(ValidateVolumes(ts.Volumes).ViaField("volumes"))
        errs = errs.Also(validateDeclaredWorkspaces(ts.Workspaces, ts.Steps, ts.StepTemplate).ViaField("workspaces"))
        errs = errs.Also(validateWorkspaceUsages(ctx, ts))
        mergedSteps, err := MergeStepsWithStepTemplate(ts.StepTemplate, ts.Steps)
        if err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("error merging step template and steps: %s", err),
                        Paths:   []string{"stepTemplate"},
                        Details: err.Error(),
                })
        }</span>

        <span class="cov8" title="1">errs = errs.Also(StepList(mergedSteps).Validate(ctx).ViaField("steps"))
        errs = errs.Also(SidecarList(ts.Sidecars).Validate(ctx).ViaField("sidecars"))
        errs = errs.Also(ValidateParameterTypes(ctx, ts.Params).ViaField("params"))
        errs = errs.Also(ValidateParameterVariables(ctx, ts.Steps, ts.Params))
        errs = errs.Also(validateTaskContextVariables(ctx, ts.Steps))
        errs = errs.Also(validateTaskResultsVariables(ctx, ts.Steps, ts.Results))
        errs = errs.Also(validateResults(ctx, ts.Results).ViaField("results"))
        return errs</span>
}

// ValidateUsageOfDeclaredParameters validates that all parameters referenced in the Task are declared by the Task.
func ValidateUsageOfDeclaredParameters(ctx context.Context, steps []Step, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        _, _, objectParams := params.SortByType()
        allParameterNames := sets.NewString(params.GetNames()...)
        errs = errs.Also(validateVariables(ctx, steps, "params", allParameterNames))
        errs = errs.Also(validateObjectUsage(ctx, steps, objectParams))
        errs = errs.Also(ValidateObjectParamsHaveProperties(ctx, params))
        return errs
}</span>

// ValidateObjectParamsHaveProperties returns an error if any declared object params are missing properties
func ValidateObjectParamsHaveProperties(ctx context.Context, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for _, p := range params </span><span class="cov8" title="1">{
                if p.Type == ParamTypeObject &amp;&amp; p.Properties == nil </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField(p.Name + ".properties"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateResults(ctx context.Context, results []TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        for index, result := range results </span><span class="cov8" title="1">{
                errs = errs.Also(result.Validate(ctx).ViaIndex(index))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// a mount path which conflicts with any other declared workspaces, with the explicitly
// declared volume mounts, or with the stepTemplate. The names must also be unique.
func validateDeclaredWorkspaces(workspaces []WorkspaceDeclaration, steps []Step, stepTemplate *StepTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        mountPaths := sets.NewString()
        for _, step := range steps </span><span class="cov8" title="1">{
                for _, vm := range step.VolumeMounts </span><span class="cov8" title="1">{
                        mountPaths.Insert(filepath.Clean(vm.MountPath))
                }</span>
        }
        <span class="cov8" title="1">if stepTemplate != nil </span><span class="cov8" title="1">{
                for _, vm := range stepTemplate.VolumeMounts </span><span class="cov8" title="1">{
                        mountPaths.Insert(filepath.Clean(vm.MountPath))
                }</span>
        }

        <span class="cov8" title="1">wsNames := sets.NewString()
        for idx, w := range workspaces </span><span class="cov8" title="1">{
                // Workspace names must be unique
                if wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace name %q must be unique", w.Name), "name").ViaIndex(idx))
                }</span> else<span class="cov8" title="1"> {
                        wsNames.Insert(w.Name)
                }</span>
                // Workspaces must not try to use mount paths that are already used
                <span class="cov8" title="1">mountPath := filepath.Clean(w.GetMountPath())
                if _, ok := mountPaths[mountPath]; ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace mount path %q must be unique", mountPath), "mountpath").ViaIndex(idx))
                }</span>
                <span class="cov8" title="1">mountPaths[mountPath] = struct{}{}</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateWorkspaceUsages checks that all WorkspaceUsage objects in Steps
// refer to workspaces that are defined in the Task.
//
// This is a beta feature and will fail validation if it's used by a step
// or sidecar when the enable-api-fields feature gate is anything but "beta".
func validateWorkspaceUsages(ctx context.Context, ts *TaskSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaces := ts.Workspaces
        steps := ts.Steps
        sidecars := ts.Sidecars

        wsNames := sets.NewString()
        for _, w := range workspaces </span><span class="cov8" title="1">{
                wsNames.Insert(w.Name)
        }</span>

        <span class="cov8" title="1">for stepIdx, step := range steps </span><span class="cov8" title="1">{
                if len(step.Workspaces) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step workspaces", config.BetaAPIFields).ViaIndex(stepIdx).ViaField("steps"))
                }</span>
                <span class="cov8" title="1">for workspaceIdx, w := range step.Workspaces </span><span class="cov8" title="1">{
                        if !wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("undefined workspace %q", w.Name), "name").ViaIndex(workspaceIdx).ViaField("workspaces").ViaIndex(stepIdx).ViaField("steps"))
                        }</span>
                }
        }

        <span class="cov8" title="1">for sidecarIdx, sidecar := range sidecars </span><span class="cov8" title="1">{
                if len(sidecar.Workspaces) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecar workspaces", config.BetaAPIFields).ViaIndex(sidecarIdx).ViaField("sidecars"))
                }</span>
                <span class="cov8" title="1">for workspaceIdx, w := range sidecar.Workspaces </span><span class="cov8" title="1">{
                        if !wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("undefined workspace %q", w.Name), "name").ViaIndex(workspaceIdx).ViaField("workspaces").ViaIndex(sidecarIdx).ViaField("sidecars"))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// ValidateVolumes validates a slice of volumes to make sure there are no duplicate names
func ValidateVolumes(volumes []corev1.Volume) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Task must not have duplicate volume names.
        vols := sets.NewString()
        for idx, v := range volumes </span><span class="cov8" title="1">{
                if vols.Has(v.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("multiple volumes with same name %q", v.Name), "name").ViaIndex(idx))
                }</span> else<span class="cov8" title="1"> {
                        vols.Insert(v.Name)
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Validate implements apis.Validatable
func (l StepList) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Task must not have duplicate step names.
        names := sets.NewString()
        for idx, s := range l </span><span class="cov8" title="1">{
                // names cannot be duplicated - checking that Step names are unique
                if s.Name != "" </span><span class="cov8" title="1">{
                        if names.Has(s.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name").ViaIndex(idx))
                        }</span>
                        <span class="cov8" title="1">names.Insert(s.Name)</span>
                }

                <span class="cov8" title="1">errs = errs.Also(s.Validate(ctx).ViaIndex(idx))
                if s.Results != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(ValidateStepResultsVariables(ctx, s.Results, s.Script).ViaIndex(idx))
                        errs = errs.Also(ValidateStepResults(ctx, s.Results).ViaIndex(idx).ViaField("results"))
                }</span>
                <span class="cov8" title="1">if len(s.When) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(s.When.validate(ctx).ViaIndex(idx))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateStepResults validates that all of the declared StepResults are valid.
func ValidateStepResults(ctx context.Context, results []StepResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        for index, result := range results </span><span class="cov8" title="1">{
                errs = errs.Also(result.Validate(ctx).ViaIndex(index))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateStepResultsVariables validates if the StepResults referenced in step script are defined in step's results.
func ValidateStepResultsVariables(ctx context.Context, results []StepResult, script string) (errs *apis.FieldError) <span class="cov8" title="1">{
        resultsNames := sets.NewString()
        for _, r := range results </span><span class="cov8" title="1">{
                resultsNames.Insert(r.Name)
        }</span>
        <span class="cov8" title="1">errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(script, "step.results", resultsNames).ViaField("script"))
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(script, "results", resultsNames).ViaField("script"))
        return errs</span>
}

func (l SidecarList) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, sc := range l </span><span class="cov8" title="1">{
                errs = errs.Also(sc.Validate(ctx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateParameterTypes validates all the types within a slice of ParamSpecs
func ValidateParameterTypes(ctx context.Context, params []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                errs = errs.Also(p.ValidateType(ctx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateType checks that the type of a ParamSpec is allowed and its default value matches that type
func (p ParamSpec) ValidateType(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Ensure param has a valid type.
        validType := false
        for _, allowedType := range AllParamTypes </span><span class="cov8" title="1">{
                if p.Type == allowedType </span><span class="cov8" title="1">{
                        validType = true
                }</span>
        }
        <span class="cov8" title="1">if !validType </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue(p.Type, p.Name+".type")
        }</span>

        // If a default value is provided, ensure its type matches param's declared type.
        <span class="cov8" title="1">if (p.Default != nil) &amp;&amp; (p.Default.Type != p.Type) </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf(
                                "\"%v\" type does not match default value's type: \"%v\"", p.Type, p.Default.Type),
                        Paths: []string{
                                p.Name + ".type",
                                p.Name + ".default.type",
                        },
                }
        }</span>

        // Check object type and its PropertySpec type
        <span class="cov8" title="1">return p.ValidateObjectType(ctx)</span>
}

// ValidateObjectType checks that object type parameter does not miss the
// definition of `properties` section and the type of a PropertySpec is allowed.
// (Currently, only string is allowed)
func (p ParamSpec) ValidateObjectType(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        invalidKeys := []string{}
        for key, propertySpec := range p.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type != ParamTypeString </span><span class="cov8" title="1">{
                        invalidKeys = append(invalidKeys, key)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidKeys) != 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("The value type specified for these keys %v is invalid", invalidKeys),
                        Paths:   []string{p.Name + ".properties"},
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateParameterVariables validates all variables within a slice of ParamSpecs against a slice of Steps
func ValidateParameterVariables(ctx context.Context, steps []Step, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        errs = errs.Also(params.ValidateNoDuplicateNames())
        errs = errs.Also(params.validateParamEnums(ctx).ViaField("params"))
        stringParams, arrayParams, objectParams := params.SortByType()
        stringParameterNames := sets.NewString(stringParams.GetNames()...)
        arrayParameterNames := sets.NewString(arrayParams.GetNames()...)
        errs = errs.Also(ValidateNameFormat(stringParameterNames.Insert(arrayParameterNames.List()...), objectParams))
        return errs.Also(validateArrayUsage(steps, "params", arrayParameterNames))
}</span>

// validateTaskContextVariables returns an error if any Steps reference context variables that don't exist.
func validateTaskContextVariables(ctx context.Context, steps []Step) *apis.FieldError <span class="cov8" title="1">{
        taskRunContextNames := sets.NewString().Insert(
                "name",
                "namespace",
                "uid",
        )
        taskContextNames := sets.NewString().Insert(
                "name",
                "retry-count",
        )
        errs := validateVariables(ctx, steps, "context\\.taskRun", taskRunContextNames)
        return errs.Also(validateVariables(ctx, steps, "context\\.task", taskContextNames))
}</span>

// validateTaskResultsVariables validates if the results referenced in step script are defined in task results
func validateTaskResultsVariables(ctx context.Context, steps []Step, results []TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        resultsNames := sets.NewString()
        for _, r := range results </span><span class="cov8" title="1">{
                resultsNames.Insert(r.Name)
        }</span>
        <span class="cov8" title="1">for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.Script, "results", resultsNames).ViaField("script").ViaFieldIndex("steps", idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateObjectUsage validates the usage of individual attributes of an object param and the usage of the entire object
func validateObjectUsage(ctx context.Context, steps []Step, params []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectParameterNames := sets.NewString()
        for _, p := range params </span><span class="cov8" title="1">{
                // collect all names of object type params
                objectParameterNames.Insert(p.Name)

                // collect all keys for this object param
                objectKeys := sets.NewString()
                for key := range p.Properties </span><span class="cov8" title="1">{
                        objectKeys.Insert(key)
                }</span>

                // check if the object's key names are referenced correctly i.e. param.objectParam.key1
                <span class="cov8" title="1">errs = errs.Also(validateVariables(ctx, steps, "params\\."+p.Name, objectKeys))</span>
        }

        <span class="cov8" title="1">return errs.Also(validateObjectUsageAsWhole(steps, "params", objectParameterNames))</span>
}

// validateObjectUsageAsWhole returns an error if the Steps contain references to the entire input object params in fields where these references are prohibited
func validateObjectUsageAsWhole(steps []Step, prefix string, vars sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepObjectUsageAsWhole(step, prefix, vars)).ViaFieldIndex("steps", idx)
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepObjectUsageAsWhole returns an error if the Step contains references to the entire input object params in fields where these references are prohibited
func validateStepObjectUsageAsWhole(step Step, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Name, prefix, vars).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Image, prefix, vars).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.WorkingDir, prefix, vars).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Script, prefix, vars).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.Name, prefix, vars).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.MountPath, prefix, vars).ViaField("mountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.SubPath, prefix, vars).ViaField("subPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateArrayUsage returns an error if the Steps contain references to the input array params in fields where these references are prohibited
func validateArrayUsage(steps []Step, prefix string, arrayParamNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepArrayUsage(step, prefix, arrayParamNames)).ViaFieldIndex("steps", idx)
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepArrayUsage returns an error if the Step contains references to the input array params in fields where these references are prohibited
func validateStepArrayUsage(step Step, prefix string, arrayParamNames sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToProhibitedVariables(step.Name, prefix, arrayParamNames).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.Image, prefix, arrayParamNames).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.WorkingDir, prefix, arrayParamNames).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.Script, prefix, arrayParamNames).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(cmd, prefix, arrayParamNames).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(arg, prefix, arrayParamNames).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(env.Value, prefix, arrayParamNames).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.Name, prefix, arrayParamNames).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.MountPath, prefix, arrayParamNames).ViaField("mountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.SubPath, prefix, arrayParamNames).ViaField("subPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateVariables returns an error if the Steps contain references to any unknown variables
func validateVariables(ctx context.Context, steps []Step, prefix string, vars sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepVariables(ctx, step, prefix, vars).ViaFieldIndex("steps", idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateNameFormat validates that the name format of all param types follows the rules
func ValidateNameFormat(stringAndArrayParams sets.String, objectParams []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        // checking string or array name format
        // ----
        invalidStringAndArrayNames := []string{}
        // Converting to sorted list here rather than just looping map keys
        // because we want the order of items in vars to be deterministic for purpose of unit testing
        for _, name := range stringAndArrayParams.List() </span><span class="cov8" title="1">{
                if !stringAndArrayVariableNameFormatRegex.MatchString(name) </span><span class="cov8" title="1">{
                        invalidStringAndArrayNames = append(invalidStringAndArrayNames, name)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidStringAndArrayNames) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("The format of following array and string variable names is invalid: %s", invalidStringAndArrayNames),
                        Paths:   []string{"params"},
                        Details: "String/Array Names: \nMust only contain alphanumeric characters, hyphens (-), underscores (_), and dots (.)\nMust begin with a letter or an underscore (_)",
                })
        }</span>

        // checking object name and key name format
        // -----
        <span class="cov8" title="1">invalidObjectNames := map[string][]string{}
        for _, obj := range objectParams </span><span class="cov8" title="1">{
                // check object param name
                if !objectVariableNameFormatRegex.MatchString(obj.Name) </span><span class="cov8" title="1">{
                        invalidObjectNames[obj.Name] = []string{}
                }</span>

                // check key names
                <span class="cov8" title="1">for k := range obj.Properties </span><span class="cov8" title="1">{
                        if !objectVariableNameFormatRegex.MatchString(k) </span><span class="cov8" title="1">{
                                invalidObjectNames[obj.Name] = append(invalidObjectNames[obj.Name], k)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(invalidObjectNames) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("Object param name and key name format is invalid: %s", invalidObjectNames),
                        Paths:   []string{"params"},
                        Details: "Object Names: \nMust only contain alphanumeric characters, hyphens (-), underscores (_) \nMust begin with a letter or an underscore (_)",
                })
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// validateStepVariables returns an error if the Step contains references to any unknown variables
func validateStepVariables(ctx context.Context, step Step, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(step.Name, prefix, vars).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.Image, prefix, vars).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.WorkingDir, prefix, vars).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.Script, prefix, vars).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.Name, prefix, vars).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.MountPath, prefix, vars).ViaField("MountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.SubPath, prefix, vars).ViaField("SubPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(string(step.OnError), prefix, vars).ViaField("onError"))
        return errs</span>
}

// GetIndexingReferencesToArrayParams returns all strings referencing indices of TaskRun array parameters
// from parameters, workspaces, and when expressions defined in the Task.
// For example, if a Task has a parameter with a value "$(params.array-param-name[1])",
// this would be one of the strings returned.
func (ts *TaskSpec) GetIndexingReferencesToArrayParams() sets.String <span class="cov8" title="1">{
        // collect all the possible places to use param references
        paramsRefs := []string{}
        paramsRefs = append(paramsRefs, extractParamRefsFromSteps(ts.Steps)...)
        paramsRefs = append(paramsRefs, extractParamRefsFromStepTemplate(ts.StepTemplate)...)
        paramsRefs = append(paramsRefs, extractParamRefsFromVolumes(ts.Volumes)...)
        for _, v := range ts.Workspaces </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.MountPath)
        }</span>
        <span class="cov8" title="1">paramsRefs = append(paramsRefs, extractParamRefsFromSidecars(ts.Sidecars)...)
        // extract all array indexing references, for example []{"$(params.array-params[1])"}
        arrayIndexParamRefs := []string{}
        for _, p := range paramsRefs </span><span class="cov8" title="1">{
                arrayIndexParamRefs = append(arrayIndexParamRefs, extractArrayIndexingParamRefs(p)...)
        }</span>
        <span class="cov8" title="1">return sets.NewString(arrayIndexParamRefs...)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

// TaskRef can be used to refer to a specific instance of a task.
type TaskRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // TaskKind indicates the Kind of the Task:
        // 1. Namespaced Task when Kind is set to "Task". If Kind is "", it defaults to "Task".
        // 2. Custom Task when Kind is non-empty and APIVersion is non-empty
        Kind TaskKind `json:"kind,omitempty"`
        // API version of the referent
        // Note: A Task with non-empty APIVersion and Kind is considered a Custom Task
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`

        // ResolverRef allows referencing a Task in a remote location
        // like a git repo. This field is only supported when the alpha
        // feature gate is enabled.
        // +optional
        ResolverRef `json:",omitempty"`
}

// TaskKind defines the type of Task used by the pipeline.
type TaskKind string

const (
        // NamespacedTaskKind indicates that the task type has a namespaced scope.
        NamespacedTaskKind TaskKind = "Task"
)

// IsCustomTask checks whether the reference is to a Custom Task
func (tr *TaskRef) IsCustomTask() bool <span class="cov8" title="1">{
        // Note that if `apiVersion` is set to `"tekton.dev/v1beta1"` and `kind` is set to `"Task"`,
        // the reference will be considered a Custom Task - https://github.com/tektoncd/pipeline/issues/6457
        return tr != nil &amp;&amp; tr.APIVersion != "" &amp;&amp; tr.Kind != ""
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate ensures that a supplied TaskRef field is populated
// correctly. No errors are returned for a nil TaskRef.
func (ref *TaskRef) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return validateRef(ctx, ref.Name, ref.Resolver, ref.Params)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*TaskRun)(nil)

// ConvertTo implements apis.Convertible
func (tr *TaskRun) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", sink)</span>
}

// ConvertFrom implements apis.Convertible
func (tr *TaskRun) ConvertFrom(ctx context.Context, source apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1 is the highest known version, got: %T", source)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmap"
)

var _ apis.Defaultable = (*TaskRun)(nil)

// ManagedByLabelKey is the label key used to mark what is managing this resource
const ManagedByLabelKey = "app.kubernetes.io/managed-by"

// SetDefaults implements apis.Defaultable
func (tr *TaskRun) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        ctx = apis.WithinParent(ctx, tr.ObjectMeta)
        tr.Spec.SetDefaults(ctx)

        // Silently filtering out Tekton Reserved annotations at creation
        if apis.IsInCreate(ctx) </span><span class="cov8" title="1">{
                tr.ObjectMeta.Annotations = kmap.Filter(tr.ObjectMeta.Annotations, func(s string) bool </span><span class="cov8" title="1">{
                        return filterReservedAnnotationRegexp.MatchString(s)
                }</span>)
        }

        // If the TaskRun doesn't have a managed-by label, apply the default
        // specified in the config.
        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)
        if tr.ObjectMeta.Labels == nil </span><span class="cov8" title="1">{
                tr.ObjectMeta.Labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">if _, found := tr.ObjectMeta.Labels[ManagedByLabelKey]; !found </span><span class="cov8" title="1">{
                tr.ObjectMeta.Labels[ManagedByLabelKey] = cfg.Defaults.DefaultManagedByLabelValue
        }</span>
}

// SetDefaults implements apis.Defaultable
func (trs *TaskRunSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if trs.TaskRef != nil </span><span class="cov8" title="1">{
                if trs.TaskRef.Name == "" &amp;&amp; trs.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        trs.TaskRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
                }</span>
                <span class="cov8" title="1">if trs.TaskRef.Kind == "" &amp;&amp; trs.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        trs.TaskRef.Kind = NamespacedTaskKind
                }</span>
        }

        <span class="cov8" title="1">if trs.Timeout == nil </span><span class="cov8" title="1">{
                trs.Timeout = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
        }</span>

        <span class="cov8" title="1">defaultSA := cfg.Defaults.DefaultServiceAccount
        if trs.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                trs.ServiceAccountName = defaultSA
        }</span>

        <span class="cov8" title="1">defaultPodTemplate := cfg.Defaults.DefaultPodTemplate
        trs.PodTemplate = pod.MergePodTemplateWithDefault(trs.PodTemplate, defaultPodTemplate)

        // If this taskrun has an embedded task, apply the usual task defaults
        if trs.TaskSpec != nil </span><span class="cov8" title="1">{
                trs.TaskSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        apisconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TaskRunSpec defines the desired state of TaskRun
type TaskRunSpec struct {
        // +optional
        Debug *TaskRunDebug `json:"debug,omitempty"`
        // +optional
        Params Params `json:"params,omitempty"`
        // +optional
        ServiceAccountName string `json:"serviceAccountName"`
        // no more than one of the TaskRef and TaskSpec may be specified.
        // +optional
        TaskRef *TaskRef `json:"taskRef,omitempty"`
        // Specifying TaskSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Task.spec (API version: tekton.dev/v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        TaskSpec *TaskSpec `json:"taskSpec,omitempty"`
        // Used for cancelling a TaskRun (and maybe more later on)
        // +optional
        Status TaskRunSpecStatus `json:"status,omitempty"`
        // Status message for cancellation.
        // +optional
        StatusMessage TaskRunSpecStatusMessage `json:"statusMessage,omitempty"`
        // Retries represents how many times this TaskRun should be retried in the event of task failure.
        // +optional
        Retries int `json:"retries,omitempty"`
        // Time after which one retry attempt times out. Defaults to 1 hour.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`
        // PodTemplate holds pod specific configuration
        PodTemplate *pod.PodTemplate `json:"podTemplate,omitempty"`
        // Workspaces is a list of WorkspaceBindings from volumes to workspaces.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceBinding `json:"workspaces,omitempty"`
        // Specs to apply to Steps in this TaskRun.
        // If a field is specified in both a Step and a StepSpec,
        // the value from the StepSpec will be used.
        // This field is only supported when the alpha feature gate is enabled.
        // +optional
        // +listType=atomic
        StepSpecs []TaskRunStepSpec `json:"stepSpecs,omitempty"`
        // Specs to apply to Sidecars in this TaskRun.
        // If a field is specified in both a Sidecar and a SidecarSpec,
        // the value from the SidecarSpec will be used.
        // This field is only supported when the alpha feature gate is enabled.
        // +optional
        // +listType=atomic
        SidecarSpecs []TaskRunSidecarSpec `json:"sidecarSpecs,omitempty"`
        // Compute resources to use for this TaskRun
        ComputeResources *corev1.ResourceRequirements `json:"computeResources,omitempty"`
}

// TaskRunSpecStatus defines the TaskRun spec status the user can provide
type TaskRunSpecStatus string

const (
        // TaskRunSpecStatusCancelled indicates that the user wants to cancel the task,
        // if not already cancelled or terminated
        TaskRunSpecStatusCancelled = "TaskRunCancelled"
)

// TaskRunSpecStatusMessage defines human readable status messages for the TaskRun.
type TaskRunSpecStatusMessage string

const (
        // TaskRunCancelledByPipelineMsg indicates that the PipelineRun of which this
        // TaskRun was a part of has been cancelled.
        TaskRunCancelledByPipelineMsg TaskRunSpecStatusMessage = "TaskRun cancelled as the PipelineRun it belongs to has been cancelled."
        // TaskRunCancelledByPipelineTimeoutMsg indicates that the TaskRun was cancelled because the PipelineRun running it timed out.
        TaskRunCancelledByPipelineTimeoutMsg TaskRunSpecStatusMessage = "TaskRun cancelled as the PipelineRun it belongs to has timed out."
)

const (
        // EnabledOnFailureBreakpoint is the value for TaskRunDebug.Breakpoints.OnFailure that means the breakpoint onFailure is enabled
        EnabledOnFailureBreakpoint = "enabled"
)

// TaskRunDebug defines the breakpoint config for a particular TaskRun
type TaskRunDebug struct {
        // +optional
        Breakpoints *TaskBreakpoints `json:"breakpoints,omitempty"`
}

// TaskBreakpoints defines the breakpoint config for a particular Task
type TaskBreakpoints struct {
        // if enabled, pause TaskRun on failure of a step
        // failed step will not exit
        // +optional
        OnFailure string `json:"onFailure,omitempty"`
        // +optional
        // +listType=atomic
        BeforeSteps []string `json:"beforeSteps,omitempty"`
}

// NeedsDebugOnFailure return true if the TaskRun is configured to debug on failure
func (trd *TaskRunDebug) NeedsDebugOnFailure() bool <span class="cov8" title="1">{
        if trd.Breakpoints == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return trd.Breakpoints.OnFailure == EnabledOnFailureBreakpoint</span>
}

// NeedsDebugBeforeStep return true if the step is configured to debug before execution
func (trd *TaskRunDebug) NeedsDebugBeforeStep(stepName string) bool <span class="cov8" title="1">{
        if trd.Breakpoints == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">beforeStepSets := sets.NewString(trd.Breakpoints.BeforeSteps...)
        return beforeStepSets.Has(stepName)</span>
}

// StepNeedsDebug return true if the step is configured to debug
func (trd *TaskRunDebug) StepNeedsDebug(stepName string) bool <span class="cov8" title="1">{
        return trd.NeedsDebugOnFailure() || trd.NeedsDebugBeforeStep(stepName)
}</span>

// NeedsDebug return true if defined onfailure or have any before, after steps
func (trd *TaskRunDebug) NeedsDebug() bool <span class="cov8" title="1">{
        return trd.NeedsDebugOnFailure() || trd.HaveBeforeSteps()
}</span>

// HaveBeforeSteps return true if have any before steps
func (trd *TaskRunDebug) HaveBeforeSteps() bool <span class="cov8" title="1">{
        return trd.Breakpoints != nil &amp;&amp; len(trd.Breakpoints.BeforeSteps) &gt; 0
}</span>

// TaskRunInputs holds the input values that this task was invoked with.
type TaskRunInputs struct {
        // +optional
        // +listType=atomic
        Params Params `json:"params,omitempty"`
}

var taskRunCondSet = apis.NewBatchConditionSet()

// TaskRunStatus defines the observed state of TaskRun
type TaskRunStatus struct {
        duckv1.Status `json:",inline"`

        // TaskRunStatusFields inlines the status fields.
        TaskRunStatusFields `json:",inline"`
}

// TaskRunReason is an enum used to store all TaskRun reason for
// the Succeeded condition that are controlled by the TaskRun itself. Failure
// reasons that emerge from underlying resources are not included here
type TaskRunReason string

const (
        // TaskRunReasonStarted is the reason set when the TaskRun has just started
        TaskRunReasonStarted TaskRunReason = "Started"
        // TaskRunReasonRunning is the reason set when the TaskRun is running
        TaskRunReasonRunning TaskRunReason = "Running"
        // TaskRunReasonSuccessful is the reason set when the TaskRun completed successfully
        TaskRunReasonSuccessful TaskRunReason = "Succeeded"
        // TaskRunReasonFailed is the reason set when the TaskRun completed with a failure
        TaskRunReasonFailed TaskRunReason = "Failed"
        // TaskRunReasonToBeRetried is the reason set when the last TaskRun execution failed, and will be retried
        TaskRunReasonToBeRetried TaskRunReason = "ToBeRetried"
        // TaskRunReasonCancelled is the reason set when the TaskRun is cancelled by the user
        TaskRunReasonCancelled TaskRunReason = "TaskRunCancelled"
        // TaskRunReasonTimedOut is the reason set when one TaskRun execution has timed out
        TaskRunReasonTimedOut TaskRunReason = "TaskRunTimeout"
        // TaskRunReasonResolvingTaskRef indicates that the TaskRun is waiting for
        // its taskRef to be asynchronously resolved.
        TaskRunReasonResolvingTaskRef = "ResolvingTaskRef"
        // TaskRunReasonResolvingStepActionRef indicates that the TaskRun is waiting for
        // its StepAction's Ref to be asynchronously resolved.
        TaskRunReasonResolvingStepActionRef = "ResolvingStepActionRef"
        // TaskRunReasonImagePullFailed is the reason set when the step of a task fails due to image not being pulled
        TaskRunReasonImagePullFailed TaskRunReason = "TaskRunImagePullFailed"
        // TaskRunReasonResultLargerThanAllowedLimit is the reason set when one of the results exceeds its maximum allowed limit of 1 KB
        TaskRunReasonResultLargerThanAllowedLimit TaskRunReason = "TaskRunResultLargerThanAllowedLimit"
        // TaskRunReasonStopSidecarFailed indicates that the sidecar is not properly stopped.
        TaskRunReasonStopSidecarFailed TaskRunReason = "TaskRunStopSidecarFailed"
        // TaskRunReasonInvalidParamValue indicates that the TaskRun Param input value is not allowed.
        TaskRunReasonInvalidParamValue TaskRunReason = "InvalidParamValue"
        // TaskRunReasonFailedResolution indicated that the reason for failure status is
        // that references within the TaskRun could not be resolved
        TaskRunReasonFailedResolution TaskRunReason = "TaskRunResolutionFailed"
        // TaskRunReasonFailedValidation indicated that the reason for failure status is
        // that taskrun failed runtime validation
        TaskRunReasonFailedValidation TaskRunReason = "TaskRunValidationFailed"
        // TaskRunReasonTaskFailedValidation indicated that the reason for failure status is
        // that task failed runtime validation
        TaskRunReasonTaskFailedValidation TaskRunReason = "TaskValidationFailed"
        // TaskRunReasonResourceVerificationFailed indicates that the task fails the trusted resource verification,
        // it could be the content has changed, signature is invalid or public key is invalid
        TaskRunReasonResourceVerificationFailed TaskRunReason = "ResourceVerificationFailed"
        // TaskRunReasonFailureIgnored is the reason set when the Taskrun has failed due to pod execution error and the failure is ignored for the owning PipelineRun.
        // TaskRuns failed due to reconciler/validation error should not use this reason.
        TaskRunReasonFailureIgnored TaskRunReason = "FailureIgnored"
)

func (t TaskRunReason) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

// GetStartedReason returns the reason set to the "Succeeded" condition when
// InitializeConditions is invoked
func (trs *TaskRunStatus) GetStartedReason() string <span class="cov0" title="0">{
        return TaskRunReasonStarted.String()
}</span>

// GetRunningReason returns the reason set to the "Succeeded" condition when
// the TaskRun starts running. This is used indicate that the resource
// could be validated is starting to perform its job.
func (trs *TaskRunStatus) GetRunningReason() string <span class="cov0" title="0">{
        return TaskRunReasonRunning.String()
}</span>

// MarkResourceOngoing sets the ConditionSucceeded condition to ConditionUnknown
// with the reason and message.
func (trs *TaskRunStatus) MarkResourceOngoing(reason TaskRunReason, message string) <span class="cov0" title="0">{
        taskRunCondSet.Manage(trs).SetCondition(apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionUnknown,
                Reason:  reason.String(),
                Message: message,
        })
}</span>

// MarkResourceFailed sets the ConditionSucceeded condition to ConditionFalse
// based on an error that occurred and a reason
func (trs *TaskRunStatus) MarkResourceFailed(reason TaskRunReason, err error) <span class="cov0" title="0">{
        taskRunCondSet.Manage(trs).SetCondition(apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionFalse,
                Reason:  reason.String(),
                Message: pipelineErrors.GetErrorMessage(err),
        })
        succeeded := trs.GetCondition(apis.ConditionSucceeded)
        trs.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// +listType=atomic
type RetriesStatus []TaskRunStatus

// TaskRunStatusFields holds the fields of TaskRun's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type TaskRunStatusFields struct {
        // PodName is the name of the pod responsible for executing this task's steps.
        PodName string `json:"podName"`

        // StartTime is the time the build is actually started.
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the build completed.
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // Steps describes the state of each build step container.
        // +optional
        // +listType=atomic
        Steps []StepState `json:"steps,omitempty"`

        // RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures.
        // All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        RetriesStatus RetriesStatus `json:"retriesStatus,omitempty"`

        // Results are the list of results written out by the task's containers
        // +optional
        // +listType=atomic
        Results []TaskRunResult `json:"results,omitempty"`

        // Artifacts are the list of artifacts written out by the task's containers
        // +optional
        Artifacts *Artifacts `json:"artifacts,omitempty"`

        // The list has one entry per sidecar in the manifest. Each entry is
        // represents the imageid of the corresponding sidecar.
        // +listType=atomic
        Sidecars []SidecarState `json:"sidecars,omitempty"`

        // TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun.
        TaskSpec *TaskSpec `json:"taskSpec,omitempty"`

        // Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
        // +optional
        Provenance *Provenance `json:"provenance,omitempty"`

        // SpanContext contains tracing span context fields
        SpanContext map[string]string `json:"spanContext,omitempty"`
}

// TaskRunStepSpec is used to override the values of a Step in the corresponding Task.
type TaskRunStepSpec struct {
        // The name of the Step to override.
        Name string `json:"name"`
        // The resource requirements to apply to the Step.
        ComputeResources corev1.ResourceRequirements `json:"computeResources"`
}

// TaskRunSidecarSpec is used to override the values of a Sidecar in the corresponding Task.
type TaskRunSidecarSpec struct {
        // The name of the Sidecar to override.
        Name string `json:"name"`
        // The resource requirements to apply to the Sidecar.
        ComputeResources corev1.ResourceRequirements `json:"computeResources"`
}

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*TaskRun) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.TaskRunControllerName)
}</span>

// GetStatusCondition returns the task run status as a ConditionAccessor
func (tr *TaskRun) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;tr.Status
}</span>

// GetCondition returns the Condition matching the given type.
func (trs *TaskRunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return taskRunCondSet.Manage(trs).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in taskRunCondSet to unknown for the TaskRun
// and set the started time to the current time
func (trs *TaskRunStatus) InitializeConditions() <span class="cov8" title="1">{
        started := false
        if trs.StartTime.IsZero() </span><span class="cov8" title="1">{
                trs.StartTime = &amp;metav1.Time{Time: time.Now()}
                started = true
        }</span>
        <span class="cov8" title="1">conditionManager := taskRunCondSet.Manage(trs)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov8" title="1">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = TaskRunReasonStarted.String()
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (trs *TaskRunStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                taskRunCondSet.Manage(trs).SetCondition(*newCond)
        }</span>
}

// StepState reports the results of running a step in a Task.
type StepState struct {
        corev1.ContainerState `json:",inline"`
        Name                  string                `json:"name,omitempty"`
        Container             string                `json:"container,omitempty"`
        ImageID               string                `json:"imageID,omitempty"`
        Results               []TaskRunStepResult   `json:"results,omitempty"`
        Provenance            *Provenance           `json:"provenance,omitempty"`
        TerminationReason     string                `json:"terminationReason,omitempty"`
        Inputs                []TaskRunStepArtifact `json:"inputs,omitempty"`
        Outputs               []TaskRunStepArtifact `json:"outputs,omitempty"`
}

// SidecarState reports the results of running a sidecar in a Task.
type SidecarState struct {
        corev1.ContainerState `json:",inline"`
        Name                  string `json:"name,omitempty"`
        Container             string `json:"container,omitempty"`
        ImageID               string `json:"imageID,omitempty"`
}

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TaskRun represents a single execution of a Task. TaskRuns are how the steps
// specified in a Task are executed; they specify the parameters and resources
// used to run the steps in a Task.
//
// +k8s:openapi-gen=true
// +kubebuilder:storageversion
type TaskRun struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec TaskRunSpec `json:"spec,omitempty"`
        // +optional
        Status TaskRunStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TaskRunList contains a list of TaskRun
type TaskRunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TaskRun `json:"items"`
}

// GetPipelineRunPVCName for TaskRun gets pipelinerun
func (tr *TaskRun) GetPipelineRunPVCName() string <span class="cov8" title="1">{
        if tr == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, ref := range tr.GetOwnerReferences() </span><span class="cov8" title="1">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov8" title="1">{
                        return ref.Name + "-pvc"
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// HasPipelineRunOwnerReference returns true of TaskRun has
// owner reference of type PipelineRun
func (tr *TaskRun) HasPipelineRunOwnerReference() bool <span class="cov8" title="1">{
        for _, ref := range tr.GetOwnerReferences() </span><span class="cov8" title="1">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsDone returns true if the TaskRun's status indicates that it is done.
func (tr *TaskRun) IsDone() bool <span class="cov8" title="1">{
        return !tr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether TaskRun has valid start time set in its status
func (tr *TaskRun) HasStarted() bool <span class="cov8" title="1">{
        return tr.Status.StartTime != nil &amp;&amp; !tr.Status.StartTime.IsZero()
}</span>

// IsSuccessful returns true if the TaskRun's status indicates that it has succeeded.
func (tr *TaskRun) IsSuccessful() bool <span class="cov8" title="1">{
        return tr != nil &amp;&amp; tr.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
}</span>

// IsFailure returns true if the TaskRun's status indicates that it has failed.
func (tr *TaskRun) IsFailure() bool <span class="cov8" title="1">{
        return tr != nil &amp;&amp; tr.Status.GetCondition(apis.ConditionSucceeded).IsFalse()
}</span>

// IsCancelled returns true if the TaskRun's spec status is set to Cancelled state
func (tr *TaskRun) IsCancelled() bool <span class="cov8" title="1">{
        return tr.Spec.Status == TaskRunSpecStatusCancelled
}</span>

// IsRetriable returns true if the TaskRun's Retries is not exhausted.
func (tr *TaskRun) IsRetriable() bool <span class="cov8" title="1">{
        return len(tr.Status.RetriesStatus) &lt; tr.Spec.Retries
}</span>

// HasTimedOut returns true if the TaskRun runtime is beyond the allowed timeout
func (tr *TaskRun) HasTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        if tr.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := tr.GetTimeout(ctx)
        // If timeout is set to 0 or defaulted to 0, there is no timeout.
        if timeout == apisconfig.NoTimeoutDuration </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">runtime := c.Since(tr.Status.StartTime.Time)
        return runtime &gt; timeout</span>
}

// GetTimeout returns the timeout for the TaskRun, or the default if not specified
func (tr *TaskRun) GetTimeout(ctx context.Context) time.Duration <span class="cov8" title="1">{
        // Use the platform default is no timeout is set
        if tr.Spec.Timeout == nil </span><span class="cov0" title="0">{
                defaultTimeout := time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes)
                return defaultTimeout * time.Minute //nolint:durationcheck
        }</span>
        <span class="cov8" title="1">return tr.Spec.Timeout.Duration</span>
}

// GetNamespacedName returns a k8s namespaced name that identifies this TaskRun
func (tr *TaskRun) GetNamespacedName() types.NamespacedName <span class="cov8" title="1">{
        return types.NamespacedName{Namespace: tr.Namespace, Name: tr.Name}
}</span>

// HasVolumeClaimTemplate returns true if TaskRun contains volumeClaimTemplates that is
// used for creating PersistentVolumeClaims with an OwnerReference for each run
func (tr *TaskRun) HasVolumeClaimTemplate() bool <span class="cov8" title="1">{
        for _, ws := range tr.Spec.Workspaces </span><span class="cov8" title="1">{
                if ws.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*TaskRun)(nil)
        _ resourcesemantics.VerbLimited = (*TaskRun)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (tr *TaskRun) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate taskrun
func (tr *TaskRun) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(tr.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tr.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
}</span>

// Validate taskrun spec
func (ts *TaskRunSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate the spec changes
        errs = errs.Also(ts.ValidateUpdate(ctx))

        // Must have exactly one of taskRef and taskSpec.
        if ts.TaskRef == nil &amp;&amp; ts.TaskSpec == nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("taskRef", "taskSpec"))
        }</span>
        <span class="cov8" title="1">if ts.TaskRef != nil &amp;&amp; ts.TaskSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("taskRef", "taskSpec"))
        }</span>
        // Validate TaskRef if it's present.
        <span class="cov8" title="1">if ts.TaskRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ts.TaskRef.Validate(ctx).ViaField("taskRef"))
        }</span>
        // Validate TaskSpec if it's present.
        <span class="cov8" title="1">if ts.TaskSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "taskrun") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("taskSpec"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(ts.TaskSpec.Validate(ctx).ViaField("taskSpec"))</span>
        }

        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ts.Params).ViaField("params"))

        // Validate propagated parameters
        errs = errs.Also(ts.validateInlineParameters(ctx))
        errs = errs.Also(ValidateWorkspaceBindings(ctx, ts.Workspaces).ViaField("workspaces"))
        if ts.Debug != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "debug", config.AlphaAPIFields).ViaField("debug"))
                errs = errs.Also(validateDebug(ts.Debug).ViaField("debug"))
        }</span>
        <span class="cov8" title="1">if ts.StepSpecs != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "stepSpecs", config.BetaAPIFields).ViaField("stepSpecs"))
                errs = errs.Also(validateStepSpecs(ts.StepSpecs).ViaField("stepSpecs"))
        }</span>
        <span class="cov8" title="1">if ts.SidecarSpecs != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecarSpecs", config.BetaAPIFields).ViaField("sidecarSpecs"))
                errs = errs.Also(validateSidecarSpecs(ts.SidecarSpecs).ViaField("sidecarSpecs"))
        }</span>
        <span class="cov8" title="1">if ts.ComputeResources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "computeResources", config.BetaAPIFields).ViaField("computeResources"))
                errs = errs.Also(validateTaskRunComputeResources(ts.ComputeResources, ts.StepSpecs))
        }</span>

        <span class="cov8" title="1">if ts.Status != "" </span><span class="cov8" title="1">{
                if ts.Status != TaskRunSpecStatusCancelled </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s should be %s", ts.Status, TaskRunSpecStatusCancelled), "status"))
                }</span>
        }
        <span class="cov8" title="1">if ts.Status == "" </span><span class="cov8" title="1">{
                if ts.StatusMessage != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("statusMessage should not be set if status is not set, but it is currently set to %s", ts.StatusMessage), "statusMessage"))
                }</span>
        }
        <span class="cov8" title="1">if ts.Retries &lt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%d should be &gt;= 0", ts.Retries), "retries"))
        }</span>

        <span class="cov8" title="1">if ts.PodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *ts.PodTemplate))
        }</span>

        <span class="cov8" title="1">if ts.Timeout != nil &amp;&amp; ts.Timeout.Duration &lt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(ts.Timeout.Duration.String()+" should be &gt;= 0", "timeout"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateUpdate validates the update of a TaskRunSpec
func (ts *TaskRunSpec) ValidateUpdate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">oldObj, ok := apis.GetBaseline(ctx).(*TaskRun)
        if !ok || oldObj == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if oldObj.IsDone() </span><span class="cov8" title="1">{
                // try comparing without any copying first
                // this handles the common case where only finalizers changed
                if equality.Semantic.DeepEqual(&amp;oldObj.Spec, ts) </span><span class="cov8" title="1">{
                        return nil // Specs identical, allow update
                }</span>

                // Specs differ, this could be due to different defaults after upgrade
                // Apply current defaults to old spec to normalize
                <span class="cov8" title="1">oldCopy := oldObj.Spec.DeepCopy()
                oldCopy.SetDefaults(ctx)

                if equality.Semantic.DeepEqual(oldCopy, ts) </span><span class="cov0" title="0">{
                        return nil // Difference was only defaults, allow update
                }</span>

                // Real spec changes detected, reject update
                <span class="cov8" title="1">errs = errs.Also(apis.ErrInvalidValue("Once the TaskRun is complete, no updates are allowed", ""))
                return errs</span>
        }

        // Handle started but not done case
        <span class="cov8" title="1">old := oldObj.Spec.DeepCopy()
        old.Status = ts.Status
        old.StatusMessage = ts.StatusMessage
        if !equality.Semantic.DeepEqual(old, ts) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("Once the TaskRun has started, only status and statusMessage updates are allowed", ""))
        }</span>

        <span class="cov8" title="1">return</span>
}

// validateInlineParameters validates that any parameters called in the
// Task spec are declared in the TaskRun.
// This is crucial for propagated parameters because the parameters could
// be defined under taskRun and then called directly in the task steps.
// In this case, parameters cannot be validated by the underlying taskSpec
// since they may not have the parameters declared because of propagation.
func (ts *TaskRunSpec) validateInlineParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ts.TaskSpec == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">paramSpecForValidation := make(map[string]ParamSpec)
        for _, p := range ts.Params </span><span class="cov8" title="1">{
                paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
        }</span>

        <span class="cov8" title="1">for _, p := range ts.TaskSpec.Params </span><span class="cov8" title="1">{
                var err *apis.FieldError
                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                if err != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(err)
                }</span>
        }
        <span class="cov8" title="1">var paramSpec []ParamSpec
        for _, v := range paramSpecForValidation </span><span class="cov8" title="1">{
                paramSpec = append(paramSpec, v)
        }</span>
        <span class="cov8" title="1">if ts.TaskSpec != nil &amp;&amp; ts.TaskSpec.Steps != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ValidateParameterTypes(ctx, paramSpec))
                errs = errs.Also(ValidateParameterVariables(ctx, ts.TaskSpec.Steps, paramSpec))
                errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, ts.TaskSpec.Steps, paramSpec))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validatePodTemplateEnv(ctx context.Context, podTemplate pod.Template) (errs *apis.FieldError) <span class="cov8" title="1">{
        forbiddenEnvsConfigured := config.FromContextOrDefaults(ctx).Defaults.DefaultForbiddenEnv
        if len(forbiddenEnvsConfigured) == 0 </span><span class="cov0" title="0">{
                return errs
        }</span>
        <span class="cov8" title="1">for _, pEnv := range podTemplate.Env </span><span class="cov8" title="1">{
                if slices.Contains(forbiddenEnvsConfigured, pEnv.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("PodTemplate cannot update a forbidden env: "+pEnv.Name, "PodTemplate.Env"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func createParamSpecFromParam(p Param, paramSpecForValidation map[string]ParamSpec) map[string]ParamSpec <span class="cov8" title="1">{
        value := p.Value
        pSpec := ParamSpec{
                Name:    p.Name,
                Default: &amp;value,
                Type:    p.Value.Type,
        }
        if p.Value.ObjectVal != nil </span><span class="cov8" title="1">{
                pSpec.Properties = make(map[string]PropertySpec)
                prop := make(map[string]PropertySpec)
                for k := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                        prop[k] = PropertySpec{Type: ParamTypeString}
                }</span>
                <span class="cov8" title="1">pSpec.Properties = prop</span>
        }
        <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec
        return paramSpecForValidation</span>
}

func combineParamSpec(p ParamSpec, paramSpecForValidation map[string]ParamSpec) (map[string]ParamSpec, *apis.FieldError) <span class="cov8" title="1">{
        if pSpec, ok := paramSpecForValidation[p.Name]; ok </span><span class="cov8" title="1">{
                // Merge defaults with provided values in the taskrun.
                if p.Default != nil &amp;&amp; p.Default.ObjectVal != nil </span><span class="cov8" title="1">{
                        for k, v := range p.Default.ObjectVal </span><span class="cov8" title="1">{
                                if pSpec.Default.ObjectVal == nil </span><span class="cov8" title="1">{
                                        pSpec.Default.ObjectVal = map[string]string{k: v}
                                }</span> else<span class="cov8" title="1"> {
                                        pSpec.Default.ObjectVal[k] = v
                                }</span>
                        }
                        // If Default values of object type are provided then Properties must also be fully declared.
                        <span class="cov8" title="1">if p.Properties == nil </span><span class="cov8" title="1">{
                                return paramSpecForValidation, apis.ErrMissingField(p.Name + ".properties")
                        }</span>
                }

                // Properties must be defined if paramSpec is of object Type
                <span class="cov8" title="1">if pSpec.Type == ParamTypeObject </span><span class="cov8" title="1">{
                        if p.Properties == nil </span><span class="cov0" title="0">{
                                return paramSpecForValidation, apis.ErrMissingField(p.Name + ".properties")
                        }</span>
                        // Expect Properties to be complete
                        <span class="cov8" title="1">pSpec.Properties = p.Properties</span>
                }
                <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec</span>
        } else<span class="cov8" title="1"> {
                // No values provided by task run but found a paramSpec declaration.
                // Expect it to be fully speced out.
                paramSpecForValidation[p.Name] = p
        }</span>
        <span class="cov8" title="1">return paramSpecForValidation, nil</span>
}

// validateDebug validates the debug section of the TaskRun.
// if set, onFailure breakpoint must be "enabled"
func validateDebug(db *TaskRunDebug) (errs *apis.FieldError) <span class="cov8" title="1">{
        if db == nil || db.Breakpoints == nil </span><span class="cov0" title="0">{
                return errs
        }</span>

        <span class="cov8" title="1">if db.Breakpoints.OnFailure == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("onFailure breakpoint is empty, it is only allowed to be set as enabled", "breakpoints.onFailure"))
        }</span>

        <span class="cov8" title="1">if db.Breakpoints.OnFailure != "" &amp;&amp; db.Breakpoints.OnFailure != EnabledOnFailureBreakpoint </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(db.Breakpoints.OnFailure+" is not a valid onFailure breakpoint value, onFailure breakpoint is only allowed to be set as enabled", "breakpoints.onFailure"))
        }</span>
        <span class="cov8" title="1">beforeSteps := sets.NewString()
        for i, step := range db.Breakpoints.BeforeSteps </span><span class="cov8" title="1">{
                if beforeSteps.Has(step) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("before step must be unique, the same step: %s is defined multiple times at", step), fmt.Sprintf("breakpoints.beforeSteps[%d]", i)))
                }</span>
                <span class="cov8" title="1">beforeSteps.Insert(step)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateWorkspaceBindings makes sure the volumes provided for the Task's declared workspaces make sense.
func ValidateWorkspaceBindings(ctx context.Context, wb []WorkspaceBinding) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for idx, w := range wb </span><span class="cov8" title="1">{
                names = append(names, w.Name)
                errs = errs.Also(w.Validate(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// ValidateParameters makes sure the params for the Task are valid.
func ValidateParameters(ctx context.Context, params Params) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for _, p := range params </span><span class="cov8" title="1">{
                names = append(names, p.Name)
        }</span>
        <span class="cov8" title="1">return errs.Also(validateNoDuplicateNames(names, false))</span>
}

func validateStepSpecs(specs []TaskRunStepSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for i, o := range specs </span><span class="cov8" title="1">{
                if o.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("name").ViaIndex(i))
                }</span> else<span class="cov8" title="1"> {
                        names = append(names, o.Name)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// validateTaskRunComputeResources ensures that compute resources are not configured at both the step level and the task level
func validateTaskRunComputeResources(computeResources *corev1.ResourceRequirements, specs []TaskRunStepSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, spec := range specs </span><span class="cov8" title="1">{
                if spec.ComputeResources.Size() != 0 &amp;&amp; computeResources != nil </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(
                                "stepSpecs.resources",
                                "computeResources",
                        )
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateSidecarSpecs(specs []TaskRunSidecarSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for i, o := range specs </span><span class="cov8" title="1">{
                if o.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("name").ViaIndex(i))
                }</span> else<span class="cov8" title="1"> {
                        names = append(names, o.Name)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// validateNoDuplicateNames returns an error for each name that is repeated in names.
// Case insensitive.
// If byIndex is true, the error will be reported by index instead of by key.
func validateNoDuplicateNames(names []string, byIndex bool) (errs *apis.FieldError) <span class="cov8" title="1">{
        seen := sets.NewString()
        for i, n := range names </span><span class="cov8" title="1">{
                if seen.Has(strings.ToLower(n)) </span><span class="cov8" title="1">{
                        if byIndex </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name").ViaIndex(i))
                        }</span> else<span class="cov8" title="1"> {
                                errs = errs.Also(apis.ErrMultipleOneOf("name").ViaKey(n))
                        }</span>
                }
                <span class="cov8" title="1">seen.Insert(strings.ToLower(n))</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import (
        "github.com/google/go-cmp/cmp"
)

// Algorithm Standard cryptographic hash algorithm
type Algorithm string

// Artifact represents an artifact within a system, potentially containing multiple values
// associated with it.
type Artifact struct {
        // The artifact's identifying category name
        Name string `json:"name,omitempty"`
        // A collection of values related to the artifact
        Values []ArtifactValue `json:"values,omitempty"`
        // Indicate if the artifact is a build output or a by-product
        BuildOutput bool `json:"buildOutput,omitempty"`
}

// ArtifactValue represents a specific value or data element within an Artifact.
type ArtifactValue struct {
        Digest map[Algorithm]string `json:"digest,omitempty"` // Algorithm-specific digests for verifying the content (e.g., SHA256)
        Uri    string               `json:"uri,omitempty"`    // Location where the artifact value can be retrieved
}

// TaskRunStepArtifact represents an artifact produced or used by a step within a task run.
// It directly uses the Artifact type for its structure.
type TaskRunStepArtifact = Artifact

// Artifacts represents the collection of input and output artifacts associated with
// a task run or a similar process. Artifacts in this context are units of data or resources
// that the process either consumes as input or produces as output.
type Artifacts struct {
        Inputs  []Artifact `json:"inputs,omitempty"`
        Outputs []Artifact `json:"outputs,omitempty"`
}

func (a *Artifacts) Merge(another *Artifacts) <span class="cov0" title="0">{
        inputMap := make(map[string][]ArtifactValue)
        var newInputs []Artifact

        for _, v := range a.Inputs </span><span class="cov0" title="0">{
                inputMap[v.Name] = v.Values
        }</span>
        <span class="cov0" title="0">if another != nil </span><span class="cov0" title="0">{
                for _, v := range another.Inputs </span><span class="cov0" title="0">{
                        _, ok := inputMap[v.Name]
                        if !ok </span><span class="cov0" title="0">{
                                inputMap[v.Name] = []ArtifactValue{}
                        }</span>
                        <span class="cov0" title="0">for _, vv := range v.Values </span><span class="cov0" title="0">{
                                exists := false
                                for _, av := range inputMap[v.Name] </span><span class="cov0" title="0">{
                                        if cmp.Equal(vv, av) </span><span class="cov0" title="0">{
                                                exists = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        inputMap[v.Name] = append(inputMap[v.Name], vv)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for k, v := range inputMap </span><span class="cov0" title="0">{
                newInputs = append(newInputs, Artifact{
                        Name:   k,
                        Values: v,
                })
        }</span>

        <span class="cov0" title="0">outputMap := make(map[string]Artifact)
        var newOutputs []Artifact
        for _, v := range a.Outputs </span><span class="cov0" title="0">{
                outputMap[v.Name] = v
        }</span>

        <span class="cov0" title="0">if another != nil </span><span class="cov0" title="0">{
                for _, v := range another.Outputs </span><span class="cov0" title="0">{
                        _, ok := outputMap[v.Name]
                        if !ok </span><span class="cov0" title="0">{
                                outputMap[v.Name] = Artifact{Name: v.Name, Values: []ArtifactValue{}, BuildOutput: v.BuildOutput}
                        }</span>
                        // only update buildOutput to true.
                        // Do not convert to false if it was true before.
                        <span class="cov0" title="0">if v.BuildOutput </span><span class="cov0" title="0">{
                                art := outputMap[v.Name]
                                art.BuildOutput = v.BuildOutput
                                outputMap[v.Name] = art
                        }</span>
                        <span class="cov0" title="0">for _, vv := range v.Values </span><span class="cov0" title="0">{
                                exists := false
                                for _, av := range outputMap[v.Name].Values </span><span class="cov0" title="0">{
                                        if cmp.Equal(vv, av) </span><span class="cov0" title="0">{
                                                exists = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        art := outputMap[v.Name]
                                        art.Values = append(art.Values, vv)
                                        outputMap[v.Name] = art
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for _, v := range outputMap </span><span class="cov0" title="0">{
                newOutputs = append(newOutputs, Artifact{
                        Name:        v.Name,
                        Values:      v.Values,
                        BuildOutput: v.BuildOutput,
                })
        }</span>
        <span class="cov0" title="0">a.Inputs = newInputs
        a.Outputs = newOutputs</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import (
        "encoding/json"
        "strings"
)

// ParamType indicates the type of an input parameter;
// Used to distinguish between a single string and an array of strings.
type ParamType string

// Valid ParamTypes:
const (
        ParamTypeString ParamType = "string"
        ParamTypeArray  ParamType = "array"
        ParamTypeObject ParamType = "object"
)

// AllParamTypes can be used for ParamType validation.
var AllParamTypes = []ParamType{ParamTypeString, ParamTypeArray, ParamTypeObject}

// ParamValues is modeled after IntOrString in kubernetes/apimachinery:

// ParamValue is a type that can hold a single string, string array, or string map.
// Used in JSON unmarshalling so that a single JSON field can accept
// either an individual string or an array of strings.
type ParamValue struct {
        Type      ParamType // Represents the stored type of ParamValues.
        StringVal string
        // +listType=atomic
        ArrayVal  []string
        ObjectVal map[string]string
}

// PropertySpec defines the struct for object keys
type PropertySpec struct {
        Type ParamType `json:"type,omitempty"`
}

// ParamsPrefix is the prefix used in $(...) expressions referring to parameters
const ParamsPrefix = "params"

// ArrayReference returns the name of the parameter from array parameter reference
// returns arrayParam from $(params.arrayParam[*])
func ArrayReference(a string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(strings.TrimPrefix(a, "$("+ParamsPrefix+"."), "[*])")
}</span>

// UnmarshalJSON implements the json.Unmarshaller interface.
func (paramValues *ParamValue) UnmarshalJSON(value []byte) error <span class="cov0" title="0">{
        // ParamValues is used for Results Value as well, the results can be any kind of
        // data so we need to check if it is empty.
        if len(value) == 0 </span><span class="cov0" title="0">{
                paramValues.Type = ParamTypeString
                return nil
        }</span>
        <span class="cov0" title="0">if value[0] == '[' </span><span class="cov0" title="0">{
                // We're trying to Unmarshal to []string, but for cases like []int or other types
                // of nested array which we don't support yet, we should continue and Unmarshal
                // it to String. If the Type being set doesn't match what it actually should be,
                // it will be captured by validation in reconciler.
                // if failed to unmarshal to array, we will convert the value to string and marshal it to string
                var a []string
                if err := json.Unmarshal(value, &amp;a); err == nil </span><span class="cov0" title="0">{
                        paramValues.Type = ParamTypeArray
                        paramValues.ArrayVal = a
                        return nil
                }</span>
        }
        <span class="cov0" title="0">if value[0] == '{' </span><span class="cov0" title="0">{
                // if failed to unmarshal to map, we will convert the value to string and marshal it to string
                var m map[string]string
                if err := json.Unmarshal(value, &amp;m); err == nil </span><span class="cov0" title="0">{
                        paramValues.Type = ParamTypeObject
                        paramValues.ObjectVal = m
                        return nil
                }</span>
        }

        // By default we unmarshal to string
        <span class="cov0" title="0">paramValues.Type = ParamTypeString
        if err := json.Unmarshal(value, &amp;paramValues.StringVal); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">paramValues.StringVal = string(value)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright 2025 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import "strings"

// TaskResult used to describe the results of a task
type TaskResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Properties is the JSON Schema properties to support key-value pairs results.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description,omitempty"`

        // Value the expression used to retrieve the value of the result from an underlying Step.
        // +optional
        Value *ResultValue `json:"value,omitempty"`
}

// StepResult used to describe the Results of a Step.
type StepResult struct {
        // Name the given name
        Name string `json:"name"`

        // The possible types are 'string', 'array', and 'object', with 'string' as the default.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Properties is the JSON Schema properties to support key-value pairs results.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description,omitempty"`
}

// TaskRunResult used to describe the results of a task
type TaskRunResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Value the given value of the result
        Value ResultValue `json:"value"`
}

// TaskRunStepResult is a type alias of TaskRunResult
type TaskRunStepResult = TaskRunResult

// ResultValue is a type alias of ParamValue
type ResultValue = ParamValue

// ResultsType indicates the type of a result;
// Used to distinguish between a single string and an array of strings.
// Note that there is ResultType used to find out whether a
// RunResult is from a task result or not, which is different from
// this ResultsType.
type ResultsType string

// Valid ResultsType:
const (
        ResultsTypeString ResultsType = "string"
        ResultsTypeArray  ResultsType = "array"
        ResultsTypeObject ResultsType = "object"
)

// AllResultsTypes can be used for ResultsTypes validation.
var AllResultsTypes = []ResultsType{ResultsTypeString, ResultsTypeArray, ResultsTypeObject}

// ResultsArrayReference returns the reference of the result. e.g. results.resultname from $(results.resultname[*])
func ResultsArrayReference(a string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(strings.TrimSuffix(strings.TrimPrefix(a, "$("), ")"), "[*]")
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import (
        "regexp"
        "strings"
)

const (
        // TODO(#2462) use one regex across all substitutions
        // variableSubstitutionFormat matches format like $result.resultname, $result.resultname[int] and $result.resultname[*]
        variableSubstitutionFormat = `\$\([_a-zA-Z0-9.-]+(\.[_a-zA-Z0-9.-]+)*(\[([0-9]+|\*)\])?\)`
)

// VariableSubstitutionRegex is a regex to find all result matching substitutions
var VariableSubstitutionRegex = regexp.MustCompile(variableSubstitutionFormat)

func stripVarSubExpression(expression string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(strings.TrimPrefix(expression, "$("), ")")
}</span>

func validateString(value string) []string <span class="cov0" title="0">{
        expressions := VariableSubstitutionRegex.FindAllString(value, -1)
        if expressions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var result []string
        for _, expression := range expressions </span><span class="cov0" title="0">{
                result = append(result, stripVarSubExpression(expression))
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import (
        "fmt"

        "github.com/tektoncd/pipeline/pkg/substitution"
        "k8s.io/apimachinery/pkg/selection"
)

// WhenExpression allows a PipelineTask to declare expressions to be evaluated before the Task is run
// to determine whether the Task should be executed or skipped
type WhenExpression struct {
        // Input is the string for guard checking which can be a static input or an output from a parent Task
        Input string `json:"input,omitempty"`

        // Operator that represents an Input's relationship to the values
        Operator selection.Operator `json:"operator,omitempty"`

        // Values is an array of strings, which is compared against the input, for guard checking
        // It must be non-empty
        // +listType=atomic
        Values []string `json:"values,omitempty"`

        // CEL is a string of Common Language Expression, which can be used to conditionally execute
        // the task based on the result of the expression evaluation
        // More info about CEL syntax: https://github.com/google/cel-spec/blob/master/doc/langdef.md
        // +optional
        CEL string `json:"cel,omitempty"`
}

func (we *WhenExpression) isInputInValues() bool <span class="cov0" title="0">{
        for i := range we.Values </span><span class="cov0" title="0">{
                if we.Values[i] == we.Input </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (we *WhenExpression) isTrue() bool <span class="cov0" title="0">{
        if we.Operator == selection.In </span><span class="cov0" title="0">{
                return we.isInputInValues()
        }</span>
        // selection.NotIn
        <span class="cov0" title="0">return !we.isInputInValues()</span>
}

func (we *WhenExpression) applyReplacements(replacements map[string]string, arrayReplacements map[string][]string) WhenExpression <span class="cov0" title="0">{
        replacedInput := substitution.ApplyReplacements(we.Input, replacements)
        replacedCEL := substitution.ApplyReplacements(we.CEL, replacements)

        var replacedValues []string
        for _, val := range we.Values </span><span class="cov0" title="0">{
                // arrayReplacements holds a list of array parameters with a pattern - params.arrayParam1
                // array params are referenced using $(params.arrayParam1[*])
                // array results are referenced using $(results.resultname[*])
                // check if the param exist in the arrayReplacements to replace it with a list of values
                if _, ok := arrayReplacements[fmt.Sprintf("%s.%s", ParamsPrefix, ArrayReference(val))]; ok </span><span class="cov0" title="0">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov0" title="0"> if _, ok := arrayReplacements[ResultsArrayReference(val)]; ok </span><span class="cov0" title="0">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov0" title="0"> {
                        replacedValues = append(replacedValues, substitution.ApplyReplacements(val, replacements))
                }</span>
        }

        <span class="cov0" title="0">return WhenExpression{Input: replacedInput, Operator: we.Operator, Values: replacedValues, CEL: replacedCEL}</span>
}

// GetVarSubstitutionExpressions extracts all the values between "$(" and ")" in a When Expression
func (we *WhenExpression) GetVarSubstitutionExpressions() ([]string, bool) <span class="cov0" title="0">{
        var allExpressions []string
        allExpressions = append(allExpressions, validateString(we.Input)...)
        allExpressions = append(allExpressions, validateString(we.CEL)...)
        for _, value := range we.Values </span><span class="cov0" title="0">{
                allExpressions = append(allExpressions, validateString(value)...)
        }</span>
        <span class="cov0" title="0">return allExpressions, len(allExpressions) != 0</span>
}

// WhenExpressions are used to specify whether a Task should be executed or skipped
// All of them need to evaluate to True for a guarded Task to be executed.
type WhenExpressions []WhenExpression

type StepWhenExpressions = WhenExpressions

// AllowsExecution evaluates an Input's relationship to an array of Values, based on the Operator,
// to determine whether all the When Expressions are True. If they are all True, the guarded Task is
// executed, otherwise it is skipped.
// If CEL expression exists, AllowsExecution will get the evaluated results from evaluatedCEL and determine
// if the Task should be skipped.
func (wes WhenExpressions) AllowsExecution(evaluatedCEL map[string]bool) bool <span class="cov0" title="0">{
        for _, we := range wes </span><span class="cov0" title="0">{
                if !we.isTrue() || (we.CEL != "" &amp;&amp; !evaluatedCEL[we.CEL]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ReplaceVariables interpolates variables, such as Parameters and Results, in
// the Input and Values.
func (wes WhenExpressions) ReplaceVariables(replacements map[string]string, arrayReplacements map[string][]string) WhenExpressions <span class="cov0" title="0">{
        replaced := wes
        for i := range wes </span><span class="cov0" title="0">{
                replaced[i] = wes[i].applyReplacements(replacements, arrayReplacements)
        }</span>
        <span class="cov0" title="0">return replaced</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "fmt"

        "github.com/tektoncd/pipeline/pkg/substitution"
        "k8s.io/apimachinery/pkg/selection"
)

// WhenExpression allows a PipelineTask to declare expressions to be evaluated before the Task is run
// to determine whether the Task should be executed or skipped
type WhenExpression struct {
        // Input is the string for guard checking which can be a static input or an output from a parent Task
        Input string `json:"input,omitempty"`

        // Operator that represents an Input's relationship to the values
        Operator selection.Operator `json:"operator,omitempty"`

        // Values is an array of strings, which is compared against the input, for guard checking
        // It must be non-empty
        // +listType=atomic
        Values []string `json:"values,omitempty"`

        // CEL is a string of Common Language Expression, which can be used to conditionally execute
        // the task based on the result of the expression evaluation
        // More info about CEL syntax: https://github.com/google/cel-spec/blob/master/doc/langdef.md
        // +optional
        CEL string `json:"cel,omitempty"`
}

func (we *WhenExpression) isInputInValues() bool <span class="cov8" title="1">{
        for i := range we.Values </span><span class="cov8" title="1">{
                if we.Values[i] == we.Input </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (we *WhenExpression) isTrue() bool <span class="cov8" title="1">{
        if we.Operator == selection.In </span><span class="cov8" title="1">{
                return we.isInputInValues()
        }</span>
        // selection.NotIn
        <span class="cov8" title="1">return !we.isInputInValues()</span>
}

func (we *WhenExpression) applyReplacements(replacements map[string]string, arrayReplacements map[string][]string) WhenExpression <span class="cov8" title="1">{
        replacedInput := substitution.ApplyReplacements(we.Input, replacements)
        replacedCEL := substitution.ApplyReplacements(we.CEL, replacements)

        var replacedValues []string
        for _, val := range we.Values </span><span class="cov8" title="1">{
                // arrayReplacements holds a list of array parameters with a pattern - params.arrayParam1
                // array params are referenced using $(params.arrayParam1[*])
                // array results are referenced using $(results.resultname[*])
                // check if the param exist in the arrayReplacements to replace it with a list of values
                if _, ok := arrayReplacements[fmt.Sprintf("%s.%s", ParamsPrefix, ArrayReference(val))]; ok </span><span class="cov8" title="1">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov8" title="1"> if _, ok := arrayReplacements[ResultsArrayReference(val)]; ok </span><span class="cov8" title="1">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov8" title="1"> {
                        replacedValues = append(replacedValues, substitution.ApplyReplacements(val, replacements))
                }</span>
        }

        <span class="cov8" title="1">return WhenExpression{Input: replacedInput, Operator: we.Operator, Values: replacedValues, CEL: replacedCEL}</span>
}

// GetVarSubstitutionExpressions extracts all the values between "$(" and ")" in a When Expression
func (we *WhenExpression) GetVarSubstitutionExpressions() ([]string, bool) <span class="cov8" title="1">{
        var allExpressions []string
        allExpressions = append(allExpressions, validateString(we.Input)...)
        allExpressions = append(allExpressions, validateString(we.CEL)...)
        for _, value := range we.Values </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(value)...)
        }</span>
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}

// WhenExpressions are used to specify whether a Task should be executed or skipped
// All of them need to evaluate to True for a guarded Task to be executed.
type WhenExpressions []WhenExpression

type StepWhenExpressions = WhenExpressions

// AllowsExecution evaluates an Input's relationship to an array of Values, based on the Operator,
// to determine whether all the When Expressions are True. If they are all True, the guarded Task is
// executed, otherwise it is skipped.
// If CEL expression exists, AllowsExecution will get the evaluated results from evaluatedCEL and determine
// if the Task should be skipped.
func (wes WhenExpressions) AllowsExecution(evaluatedCEL map[string]bool) bool <span class="cov8" title="1">{
        for _, we := range wes </span><span class="cov8" title="1">{
                if !we.isTrue() || (we.CEL != "" &amp;&amp; !evaluatedCEL[we.CEL]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ReplaceVariables interpolates variables, such as Parameters and Results, in
// the Input and Values.
func (wes WhenExpressions) ReplaceVariables(replacements map[string]string, arrayReplacements map[string][]string) WhenExpressions <span class="cov8" title="1">{
        replaced := wes
        for i := range wes </span><span class="cov8" title="1">{
                replaced[i] = wes[i].applyReplacements(replacements, arrayReplacements)
        }</span>
        <span class="cov8" title="1">return replaced</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/selection"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var validWhenOperators = []string{
        string(selection.In),
        string(selection.NotIn),
}

func (wes WhenExpressions) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        return wes.validateWhenExpressionsFields(ctx).ViaField("when")
}</span>

func (wes WhenExpressions) validateWhenExpressionsFields(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, we := range wes </span><span class="cov8" title="1">{
                errs = errs.Also(we.validateWhenExpressionFields(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (we *WhenExpression) validateWhenExpressionFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if we.CEL != "" </span><span class="cov8" title="1">{
                if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableCELInWhenExpression </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use CEL: %s in WhenExpression", config.EnableCELInWhenExpression, we.CEL), "")
                }</span>
                <span class="cov8" title="1">if we.Input != "" || we.Operator != "" || len(we.Values) != 0 </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("cel and input+operator+values cannot be set in one WhenExpression: %v", we))
                }</span>

                // We need to compile the CEL expression and check if it is a valid expression
                // note that at the validation webhook, Tekton's variables are not substituted,
                // so they need to be wrapped with single quotes.
                // e.g.  This is a valid CEL expression: '$(params.foo)' == 'foo';
                //       But this is not a valid expression since CEL cannot recognize: $(params.foo) == 'foo';
                //       This is not valid since we don't pass params to CEL's environment: params.foo == 'foo';
                <span class="cov8" title="1">env, _ := cel.NewEnv()
                _, iss := env.Compile(we.CEL)
                if iss.Err() != nil </span><span class="cov8" title="1">{
                        return apis.ErrGeneric("invalid cel expression: %s with err: %s", we.CEL, iss.Err().Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if equality.Semantic.DeepEqual(we, &amp;WhenExpression{}) || we == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(apis.CurrentField)
        }</span>
        <span class="cov8" title="1">if !sets.NewString(validWhenOperators...).Has(string(we.Operator)) </span><span class="cov8" title="1">{
                message := fmt.Sprintf("operator %q is not recognized. valid operators: %s", we.Operator, strings.Join(validWhenOperators, ","))
                return apis.ErrInvalidValue(message, apis.CurrentField)
        }</span>
        <span class="cov8" title="1">if len(we.Values) == 0 </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue("expecting non-empty values field", apis.CurrentField)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (wes WhenExpressions) validatePipelineParametersVariables(prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, we := range wes </span><span class="cov8" title="1">{
                errs = errs.Also(validateStringVariable(we.Input, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("input").ViaFieldIndex("when", idx))
                for _, val := range we.Values </span><span class="cov8" title="1">{
                        // one of the values could be a reference to an array param, such as, $(params.foo[*])
                        // extract the variable name from the pattern $(params.foo[*]), if the variable name matches with one of the array params
                        // validate the param as an array variable otherwise, validate it as a string variable
                        if arrayParamNames.Has(ArrayReference(val)) </span><span class="cov8" title="1">{
                                errs = errs.Also(validateArrayVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("values").ViaFieldIndex("when", idx))
                        }</span> else<span class="cov8" title="1"> {
                                errs = errs.Also(validateStringVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("values").ViaFieldIndex("when", idx))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "path/filepath"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        corev1 "k8s.io/api/core/v1"
)

// WorkspaceDeclaration is a declaration of a volume that a Task requires.
type WorkspaceDeclaration struct {
        // Name is the name by which you can bind the volume at runtime.
        Name string `json:"name"`
        // Description is an optional human readable description of this volume.
        // +optional
        Description string `json:"description,omitempty"`
        // MountPath overrides the directory that the volume will be made available at.
        // +optional
        MountPath string `json:"mountPath,omitempty"`
        // ReadOnly dictates whether a mounted volume is writable. By default this
        // field is false and so mounted volumes are writable.
        ReadOnly bool `json:"readOnly,omitempty"`
        // Optional marks a Workspace as not being required in TaskRuns. By default
        // this field is false and so declared workspaces are required.
        Optional bool `json:"optional,omitempty"`
}

// GetMountPath returns the mountPath for w which is the MountPath if provided or the
// default if not.
func (w *WorkspaceDeclaration) GetMountPath() string <span class="cov8" title="1">{
        if w.MountPath != "" </span><span class="cov8" title="1">{
                return w.MountPath
        }</span>
        <span class="cov8" title="1">return filepath.Join(pipeline.WorkspaceDir, w.Name)</span>
}

// WorkspaceBinding maps a Task's declared workspace to a Volume.
type WorkspaceBinding struct {
        // Name is the name of the workspace populated by the volume.
        Name string `json:"name"`
        // SubPath is optionally a directory on the volume which should be used
        // for this binding (i.e. the volume will be mounted at this sub directory).
        // +optional
        SubPath string `json:"subPath,omitempty"`
        // VolumeClaimTemplate is a template for a claim that will be created in the same namespace.
        // The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.
        // See PersistentVolumeClaim (API version: v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        VolumeClaimTemplate *corev1.PersistentVolumeClaim `json:"volumeClaimTemplate,omitempty"`
        // PersistentVolumeClaimVolumeSource represents a reference to a
        // PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.
        // +optional
        PersistentVolumeClaim *corev1.PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`
        // EmptyDir represents a temporary directory that shares a Task's lifetime.
        // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        // Either this OR PersistentVolumeClaim can be used.
        // +optional
        EmptyDir *corev1.EmptyDirVolumeSource `json:"emptyDir,omitempty"`
        // ConfigMap represents a configMap that should populate this workspace.
        // +optional
        ConfigMap *corev1.ConfigMapVolumeSource `json:"configMap,omitempty"`
        // Secret represents a secret that should populate this workspace.
        // +optional
        Secret *corev1.SecretVolumeSource `json:"secret,omitempty"`
        // Projected represents a projected volume that should populate this workspace.
        // +optional
        Projected *corev1.ProjectedVolumeSource `json:"projected,omitempty"`
        // CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
        // +optional
        CSI *corev1.CSIVolumeSource `json:"csi,omitempty"`
}

// WorkspacePipelineDeclaration creates a named slot in a Pipeline that a PipelineRun
// is expected to populate with a workspace binding.
//
// Deprecated: use PipelineWorkspaceDeclaration type instead
type WorkspacePipelineDeclaration = PipelineWorkspaceDeclaration

// PipelineWorkspaceDeclaration creates a named slot in a Pipeline that a PipelineRun
// is expected to populate with a workspace binding.
type PipelineWorkspaceDeclaration struct {
        // Name is the name of a workspace to be provided by a PipelineRun.
        Name string `json:"name"`
        // Description is a human readable string describing how the workspace will be
        // used in the Pipeline. It can be useful to include a bit of detail about which
        // tasks are intended to have access to the data on the workspace.
        // +optional
        Description string `json:"description,omitempty"`
        // Optional marks a Workspace as not being required in PipelineRuns. By default
        // this field is false and so declared workspaces are required.
        Optional bool `json:"optional,omitempty"`
}

// WorkspacePipelineTaskBinding describes how a workspace passed into the pipeline should be
// mapped to a task's declared workspace.
type WorkspacePipelineTaskBinding struct {
        // Name is the name of the workspace as declared by the task
        Name string `json:"name"`
        // Workspace is the name of the workspace declared by the pipeline
        // +optional
        Workspace string `json:"workspace,omitempty"`
        // SubPath is optionally a directory on the volume which should be used
        // for this binding (i.e. the volume will be mounted at this sub directory).
        // +optional
        SubPath string `json:"subPath,omitempty"`
}

// WorkspaceUsage is used by a Step or Sidecar to declare that it wants isolated access
// to a Workspace defined in a Task.
type WorkspaceUsage struct {
        // Name is the name of the workspace this Step or Sidecar wants access to.
        Name string `json:"name"`
        // MountPath is the path that the workspace should be mounted to inside the Step or Sidecar,
        // overriding any MountPath specified in the Task's WorkspaceDeclaration.
        MountPath string `json:"mountPath"`
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"

        "k8s.io/apimachinery/pkg/api/equality"
        "knative.dev/pkg/apis"
)

// allVolumeSourceFields is a list of all the volume source field paths that a
// WorkspaceBinding may include.
var allVolumeSourceFields = []string{
        "persistentvolumeclaim",
        "volumeclaimtemplate",
        "emptydir",
        "configmap",
        "secret",
}

// Validate looks at the Volume provided in wb and makes sure that it is valid.
// This means that only one VolumeSource can be specified, and also that the
// supported VolumeSource is itself valid.
func (b *WorkspaceBinding) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(b, &amp;WorkspaceBinding{}) || b == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(apis.CurrentField)
        }</span>

        <span class="cov8" title="1">numSources := b.numSources()

        if numSources &gt; 1 </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf(allVolumeSourceFields...)
        }</span>

        <span class="cov8" title="1">if numSources == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf(allVolumeSourceFields...)
        }</span>

        // For a PersistentVolumeClaim to work, you must at least provide the name of the PVC to use.
        <span class="cov8" title="1">if b.PersistentVolumeClaim != nil &amp;&amp; b.PersistentVolumeClaim.ClaimName == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("persistentvolumeclaim.claimname")
        }</span>

        // For a ConfigMap to work, you must provide the name of the ConfigMap to use.
        <span class="cov8" title="1">if b.ConfigMap != nil &amp;&amp; b.ConfigMap.LocalObjectReference.Name == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("configmap.name")
        }</span>

        // For a Secret to work, you must provide the name of the Secret to use.
        <span class="cov8" title="1">if b.Secret != nil &amp;&amp; b.Secret.SecretName == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("secret.secretName")
        }</span>

        // For a Projected volume to work, you must provide at least one source.
        <span class="cov8" title="1">if b.Projected != nil &amp;&amp; len(b.Projected.Sources) == 0 </span><span class="cov8" title="1">{
                if len(b.Projected.Sources) == 0 </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("projected.sources")
                }</span>
        }

        // For a CSI to work, you must provide and have installed the driver to use.
        <span class="cov8" title="1">if b.CSI != nil </span><span class="cov8" title="1">{
                if b.CSI.Driver == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("csi.driver")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// numSources returns the total number of volume sources that this WorkspaceBinding
// has been configured with.
func (b *WorkspaceBinding) numSources() int <span class="cov8" title="1">{
        n := 0
        if b.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.EmptyDir != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.ConfigMap != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.Secret != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.Projected != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.CSI != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: pipeline.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;Run{},
                &amp;RunList{},
                &amp;VerificationPolicy{},
                &amp;VerificationPolicyList{},
                &amp;StepAction{},
                &amp;StepActionList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*Run)(nil)

// SetDefaults implements apis.Defaultable
func (r *Run) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        ctx = apis.WithinParent(ctx, r.ObjectMeta)
        r.Spec.SetDefaults(apis.WithinSpec(ctx))
}</span>

// SetDefaults implements apis.Defaultable
func (rs *RunSpec) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        cfg := config.FromContextOrDefaults(ctx)
        defaultSA := cfg.Defaults.DefaultServiceAccount
        if rs.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov0" title="0">{
                rs.ServiceAccountName = defaultSA
        }</span>
        <span class="cov0" title="0">defaultPodTemplate := cfg.Defaults.DefaultPodTemplate
        if rs.PodTemplate == nil </span><span class="cov0" title="0">{
                rs.PodTemplate = defaultPodTemplate
        }</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"
        "time"

        apisconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        runv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/run/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// EmbeddedRunSpec allows custom task definitions to be embedded
type EmbeddedRunSpec struct {
        runtime.TypeMeta `json:",inline"`

        // +optional
        Metadata v1beta1.PipelineTaskMetadata `json:"metadata,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        Spec runtime.RawExtension `json:"spec,omitempty"`
}

// RunSpec defines the desired state of Run
type RunSpec struct {
        // +optional
        Ref *v1beta1.TaskRef `json:"ref,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        Spec *EmbeddedRunSpec `json:"spec,omitempty"`

        // +optional
        Params v1beta1.Params `json:"params,omitempty"`

        // Used for cancelling a run (and maybe more later on)
        // +optional
        Status RunSpecStatus `json:"status,omitempty"`

        // Status message for cancellation.
        // +optional
        StatusMessage RunSpecStatusMessage `json:"statusMessage,omitempty"`

        // Used for propagating retries count to custom tasks
        // +optional
        Retries int `json:"retries,omitempty"`

        // +optional
        ServiceAccountName string `json:"serviceAccountName"`

        // PodTemplate holds pod specific configuration
        // +optional
        PodTemplate *pod.PodTemplate `json:"podTemplate,omitempty"`

        // Time after which the custom-task times out.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // Workspaces is a list of WorkspaceBindings from volumes to workspaces.
        // +optional
        Workspaces []v1beta1.WorkspaceBinding `json:"workspaces,omitempty"`
}

// RunSpecStatus defines the taskrun spec status the user can provide
type RunSpecStatus string

const (
        // RunSpecStatusCancelled indicates that the user wants to cancel the run,
        // if not already cancelled or terminated
        RunSpecStatusCancelled RunSpecStatus = "RunCancelled"
)

// RunSpecStatusMessage defines human readable status messages for the TaskRun.
type RunSpecStatusMessage string

const (
        // RunCancelledByPipelineMsg indicates that the PipelineRun of which part this Run was
        // has been cancelled.
        RunCancelledByPipelineMsg RunSpecStatusMessage = "Run cancelled as the PipelineRun it belongs to has been cancelled."
        // RunCancelledByPipelineTimeoutMsg indicates that the Run was cancelled because the PipelineRun running it timed out.
        RunCancelledByPipelineTimeoutMsg RunSpecStatusMessage = "Run cancelled as the PipelineRun it belongs to has timed out."
)

// GetParam gets the Param from the RunSpec with the given name
// TODO(jasonhall): Move this to a Params type so other code can use it?
func (rs RunSpec) GetParam(name string) *v1beta1.Param <span class="cov8" title="1">{
        for _, p := range rs.Params </span><span class="cov8" title="1">{
                if p.Name == name </span><span class="cov8" title="1">{
                        return &amp;p
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RunReason is an enum used to store all Run reason for the Succeeded condition that are controlled by the Run itself.
type RunReason string

const (
        // RunReasonStarted is the reason set when the Run has just started.
        RunReasonStarted RunReason = "Started"
        // RunReasonRunning is the reason set when the Run is running.
        RunReasonRunning RunReason = "Running"
        // RunReasonSuccessful is the reason set when the Run completed successfully.
        RunReasonSuccessful RunReason = "Succeeded"
        // RunReasonFailed is the reason set when the Run completed with a failure.
        RunReasonFailed RunReason = "Failed"
        // RunReasonCancelled must be used in the Condition Reason to indicate that a Run was cancelled.
        RunReasonCancelled RunReason = "RunCancelled"
        // RunReasonTimedOut must be used in the Condition Reason to indicate that a Run was timed out.
        RunReasonTimedOut RunReason = "RunTimedOut"
        // RunReasonWorkspaceNotSupported can be used in the Condition Reason to indicate that the
        // Run contains a workspace which is not supported by this custom task.
        RunReasonWorkspaceNotSupported RunReason = "RunWorkspaceNotSupported"
        // RunReasonPodTemplateNotSupported can be used in the Condition Reason to indicate that the
        // Run contains a pod template which is not supported by this custom task.
        RunReasonPodTemplateNotSupported RunReason = "RunPodTemplateNotSupported"
)

func (t RunReason) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

// RunStatus defines the observed state of Run.
type RunStatus = runv1alpha1.RunStatus

var runCondSet = apis.NewBatchConditionSet()

// GetConditionSet retrieves the condition set for this resource. Implements
// the KRShaped interface.
func (r *Run) GetConditionSet() apis.ConditionSet <span class="cov0" title="0">{ return runCondSet }</span>

// GetStatus retrieves the status of the Parallel. Implements the KRShaped
// interface.
func (r *Run) GetStatus() *duckv1.Status <span class="cov0" title="0">{ return &amp;r.Status.Status }</span>

// RunStatusFields holds the fields of Run's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type RunStatusFields = runv1alpha1.RunStatusFields

// RunResult used to describe the results of a task
type RunResult = runv1alpha1.RunResult

// +genclient
// +genreconciler
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Run represents a single execution of a Custom Task.
//
// +k8s:openapi-gen=true
type Run struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec RunSpec `json:"spec,omitempty"`
        // +optional
        Status RunStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// RunList contains a list of Run
type RunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Run `json:"items"`
}

// GetStatusCondition returns the task run status as a ConditionAccessor
func (r *Run) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;r.Status
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*Run) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.RunControllerName)
}</span>

// HasPipelineRunOwnerReference returns true of Run has
// owner reference of type PipelineRun
func (r *Run) HasPipelineRunOwnerReference() bool <span class="cov0" title="0">{
        for _, ref := range r.GetOwnerReferences() </span><span class="cov0" title="0">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsCancelled returns true if the Run's spec status is set to Cancelled state
func (r *Run) IsCancelled() bool <span class="cov8" title="1">{
        return r.Spec.Status == RunSpecStatusCancelled
}</span>

// IsDone returns true if the Run's status indicates that it is done.
func (r *Run) IsDone() bool <span class="cov8" title="1">{
        return !r.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether taskrun has valid start time set in its status
func (r *Run) HasStarted() bool <span class="cov8" title="1">{
        return r.Status.StartTime != nil &amp;&amp; !r.Status.StartTime.IsZero()
}</span>

// IsSuccessful returns true if the Run's status indicates that it has succeeded.
func (r *Run) IsSuccessful() bool <span class="cov8" title="1">{
        return r != nil &amp;&amp; r.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
}</span>

// GetRunKey return the run's key for timeout handler map
func (r *Run) GetRunKey() string <span class="cov0" title="0">{
        // The address of the pointer is a threadsafe unique identifier for the run
        return fmt.Sprintf("%s/%p", "Run", r)
}</span>

// HasTimedOut returns true if the Run's running time is beyond the allowed timeout
func (r *Run) HasTimedOut(c clock.PassiveClock) bool <span class="cov8" title="1">{
        if r.Status.StartTime == nil || r.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := r.GetTimeout()
        // If timeout is set to 0 or defaulted to 0, there is no timeout.
        if timeout == apisconfig.NoTimeoutDuration </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">runtime := c.Since(r.Status.StartTime.Time)
        return runtime &gt; timeout</span>
}

// GetTimeout returns the timeout for this run, or the default if not configured
func (r *Run) GetTimeout() time.Duration <span class="cov8" title="1">{
        // Use the platform default if no timeout is set
        if r.Spec.Timeout == nil </span><span class="cov8" title="1">{
                return apisconfig.DefaultTimeoutMinutes * time.Minute
        }</span>
        <span class="cov8" title="1">return r.Spec.Timeout.Duration</span>
}

// GetRetryCount returns the number of times this Run has already been retried
func (r *Run) GetRetryCount() int <span class="cov8" title="1">{
        return len(r.Status.RetriesStatus)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ apis.Validatable = (*Run)(nil)
var _ resourcesemantics.VerbLimited = (*Run)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (r *Run) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate taskrun
func (r *Run) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if err := validate.ObjectMetadata(r.GetObjectMeta()).ViaField("metadata"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return r.Spec.Validate(ctx)</span>
}

// Validate Run spec
func (rs *RunSpec) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // this covers the case rs.Ref == nil &amp;&amp; rs.Spec == nil
        if equality.Semantic.DeepEqual(rs, &amp;RunSpec{}) </span><span class="cov8" title="1">{
                return apis.ErrMissingField("spec")
        }</span>

        <span class="cov8" title="1">if rs.Ref != nil &amp;&amp; rs.Spec != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.ref", "spec.spec")
        }</span>
        <span class="cov8" title="1">if rs.Ref == nil &amp;&amp; rs.Spec == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.ref", "spec.spec")
        }</span>
        <span class="cov8" title="1">if rs.Ref != nil </span><span class="cov8" title="1">{
                if rs.Ref.APIVersion == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.ref.apiVersion")
                }</span>
                <span class="cov8" title="1">if rs.Ref.Kind == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.ref.kind")
                }</span>
        }
        <span class="cov8" title="1">if rs.Spec != nil </span><span class="cov8" title="1">{
                if rs.Spec.APIVersion == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.spec.apiVersion")
                }</span>
                <span class="cov8" title="1">if rs.Spec.Kind == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.spec.kind")
                }</span>
        }
        <span class="cov8" title="1">if rs.Status == "" </span><span class="cov8" title="1">{
                if rs.StatusMessage != "" </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(fmt.Sprintf("statusMessage should not be set if status is not set, but it is currently set to %s", rs.StatusMessage), "statusMessage")
                }</span>
        }
        <span class="cov8" title="1">if err := v1beta1.ValidateParameters(ctx, rs.Params).ViaField("spec.params"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return v1beta1.ValidateWorkspaceBindings(ctx, rs.Workspaces).ViaField("spec.workspaces")</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*StepAction)(nil)

// ConvertTo implements apis.Convertible
func (s *StepAction) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := to.(type) </span>{
        case *v1beta1.StepAction:<span class="cov8" title="1">
                sink.ObjectMeta = s.ObjectMeta
                return s.Spec.ConvertTo(ctx, &amp;sink.Spec)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo implements apis.Convertible
func (ss *StepActionSpec) ConvertTo(ctx context.Context, sink *v1beta1.StepActionSpec) error <span class="cov8" title="1">{
        sink.Description = ss.Description
        sink.Image = ss.Image
        sink.Command = ss.Command
        sink.Args = ss.Args
        sink.Env = ss.Env
        sink.Script = ss.Script
        sink.WorkingDir = ss.WorkingDir
        sink.Params = ss.Params
        sink.Results = ss.Results
        sink.SecurityContext = ss.SecurityContext
        sink.VolumeMounts = ss.VolumeMounts

        return nil
}</span>

// ConvertFrom implements apis.Convertible
func (s *StepAction) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch source := from.(type) </span>{
        case *v1beta1.StepAction:<span class="cov8" title="1">
                s.ObjectMeta = source.ObjectMeta
                return s.Spec.ConvertFrom(ctx, &amp;source.Spec)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", source)</span>
        }
}

// ConvertFrom implements apis.Convertible
func (ss *StepActionSpec) ConvertFrom(ctx context.Context, source *v1beta1.StepActionSpec) error <span class="cov8" title="1">{
        ss.Description = source.Description
        ss.Image = source.Image
        ss.Command = source.Command
        ss.Args = source.Args
        ss.Env = source.Env
        ss.Script = source.Script
        ss.WorkingDir = source.WorkingDir

        ss.Params = source.Params
        ss.Results = source.Results
        ss.SecurityContext = source.SecurityContext
        ss.VolumeMounts = source.VolumeMounts

        return nil
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*StepAction)(nil)

// SetDefaults implements apis.Defaultable
func (s *StepAction) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        s.Spec.SetDefaults(ctx)
}</span>

// SetDefaults set any defaults for the StepAction spec
func (ss *StepActionSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        for i := range ss.Params </span><span class="cov8" title="1">{
                ss.Params[i].SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">for i := range ss.Results </span><span class="cov8" title="1">{
                ss.Results[i].SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmeta"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// StepAction represents the actionable components of Step.
// The Step can only reference it from the cluster or using remote resolution.
//
// +k8s:openapi-gen=true
type StepAction struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the Step from the client
        // +optional
        Spec StepActionSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*StepAction)(nil)

// StepAction returns the step action's spec
func (s *StepAction) StepActionSpec() StepActionSpec <span class="cov0" title="0">{
        return s.Spec
}</span>

// StepActionMetadata returns the step action's ObjectMeta
func (s *StepAction) StepActionMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return s.ObjectMeta
}</span>

// Copy returns a deep copy of the stepaction
func (s *StepAction) Copy() StepActionObject <span class="cov0" title="0">{
        return s.DeepCopy()
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*StepAction) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("StepAction")
}</span>

// StepActionList contains a list of StepActions
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type StepActionList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []StepAction `json:"items"`
}

// StepActionSpec contains the actionable components of a step.
type StepActionSpec struct {
        // Description is a user-facing description of the stepaction that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Image reference name to run for this StepAction.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // List of environment variables to set in the container.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
        // +optional
        Script string `json:"script,omitempty"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // Params is a list of input parameters required to run the stepAction.
        // Params must be supplied as inputs in Steps unless they declare a defaultvalue.
        // +optional
        Params v1.ParamSpecs `json:"params,omitempty"`
        // Results are values that this StepAction can output
        // +optional
        // +listType=atomic
        Results []v1.StepResult `json:"results,omitempty"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // The value set in StepAction will take precedence over the value from Task.
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
}

// ToStep converts the StepActionSpec to a Step struct
func (ss *StepActionSpec) ToStep() *v1.Step <span class="cov0" title="0">{
        return &amp;v1.Step{
                Image:           ss.Image,
                Command:         ss.Command,
                Args:            ss.Args,
                WorkingDir:      ss.WorkingDir,
                Script:          ss.Script,
                Env:             ss.Env,
                VolumeMounts:    ss.VolumeMounts,
                SecurityContext: ss.SecurityContext,
                Results:         ss.Results,
        }
}</span>

// StepActionObject is implemented by StepAction
type StepActionObject interface {
        apis.Defaultable
        StepActionMetadata() metav1.ObjectMeta
        StepActionSpec() StepActionSpec
        Copy() StepActionObject
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/substitution"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*StepAction)(nil)
        _ resourcesemantics.VerbLimited = (*StepAction)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (s *StepAction) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate implements apis.Validatable
func (s *StepAction) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = validate.ObjectMetadata(s.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(s.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        return errs
}</span>

// Validate implements apis.Validatable
func (ss *StepActionSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ss.Image == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("Image"))
        }</span>

        <span class="cov8" title="1">if ss.Script != "" </span><span class="cov8" title="1">{
                if len(ss.Command) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "script cannot be used with command",
                                Paths:   []string{"script"},
                        })
                }</span>

                <span class="cov8" title="1">cleaned := strings.TrimSpace(ss.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "windows script support", config.AlphaAPIFields).ViaField("script"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(validateNoParamSubstitutionsInScript(ss.Script))</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateUsageOfDeclaredParameters(ctx, *ss))
        errs = errs.Also(v1.ValidateParameterTypes(ctx, ss.Params).ViaField("params"))
        errs = errs.Also(validateParameterVariables(ctx, *ss, ss.Params))
        errs = errs.Also(v1.ValidateStepResultsVariables(ctx, ss.Results, ss.Script))
        errs = errs.Also(v1.ValidateStepResults(ctx, ss.Results).ViaField("results"))
        errs = errs.Also(validateVolumeMounts(ss.VolumeMounts, ss.Params).ViaField("volumeMounts"))
        return errs</span>
}

// validateNoParamSubstitutionsInScript validates that param substitutions are not invoked in the script
func validateNoParamSubstitutionsInScript(script string) *apis.FieldError <span class="cov8" title="1">{
        _, present, errString := substitution.ExtractVariablesFromString(script, "params")
        if errString != "" || present </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: "param substitution in scripts is not allowed.",
                        Paths:   []string{"script"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateUsageOfDeclaredParameters validates that all parameters referenced in the Task are declared by the Task.
func validateUsageOfDeclaredParameters(ctx context.Context, sas StepActionSpec) *apis.FieldError <span class="cov8" title="1">{
        params := sas.Params
        var errs *apis.FieldError
        _, _, objectParams := params.SortByType()
        allParameterNames := sets.NewString(params.GetNames()...)
        errs = errs.Also(validateStepActionVariables(ctx, sas, "params", allParameterNames))
        errs = errs.Also(validateObjectUsage(ctx, sas, objectParams))
        errs = errs.Also(v1.ValidateObjectParamsHaveProperties(ctx, params))
        return errs
}</span>

func validateVolumeMounts(volumeMounts []corev1.VolumeMount, params v1.ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(volumeMounts) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">paramNames := sets.String{}
        for _, p := range params </span><span class="cov8" title="1">{
                paramNames.Insert(p.Name)
        }</span>
        <span class="cov8" title="1">for idx, v := range volumeMounts </span><span class="cov8" title="1">{
                matches, _ := substitution.ExtractVariableExpressions(v.Name, "params")
                if len(matches) != 1 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(v.Name, "name", "expect the Name to be a single param reference").ViaIndex(idx))
                        return errs
                }</span> else<span class="cov8" title="1"> if matches[0] != v.Name </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(v.Name, "name", "expect the Name to be a single param reference").ViaIndex(idx))
                        return errs
                }</span>
                <span class="cov8" title="1">errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.Name, "params", paramNames).ViaIndex(idx))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateParameterVariables validates all variables within a slice of ParamSpecs against a StepAction
func validateParameterVariables(ctx context.Context, sas StepActionSpec, params v1.ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        errs = errs.Also(params.ValidateNoDuplicateNames())
        stringParams, arrayParams, objectParams := params.SortByType()
        stringParameterNames := sets.NewString(stringParams.GetNames()...)
        arrayParameterNames := sets.NewString(arrayParams.GetNames()...)
        errs = errs.Also(v1.ValidateNameFormat(stringParameterNames.Insert(arrayParameterNames.List()...), objectParams))
        errs = errs.Also(validateStepActionArrayUsage(sas, "params", arrayParameterNames))
        return errs.Also(validateDefaultParameterReferences(params))
}</span>

// validateDefaultParameterReferences ensures that parameters referenced in default values are defined
func validateDefaultParameterReferences(params v1.ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        allParams := sets.NewString(params.GetNames()...)

        // First pass: collect all parameters that have no references in their default values
        resolvedParams := sets.NewString()
        paramsNeedingResolution := make(map[string][]string)

        for _, p := range params </span><span class="cov8" title="1">{
                if p.Default != nil </span><span class="cov8" title="1">{
                        matches, _ := substitution.ExtractVariableExpressions(p.Default.StringVal, "params")
                        if len(matches) == 0 </span><span class="cov8" title="1">{
                                resolvedParams.Insert(p.Name)
                        }</span> else<span class="cov8" title="1"> {
                                // Track which parameters this parameter depends on
                                referencedParams := make([]string, 0, len(matches))
                                hasUndefinedParam := false
                                for _, match := range matches </span><span class="cov8" title="1">{
                                        paramName := strings.TrimSuffix(strings.TrimPrefix(match, "$(params."), ")")
                                        if !allParams.Has(paramName) </span><span class="cov8" title="1">{
                                                hasUndefinedParam = true
                                                errs = errs.Also(&amp;apis.FieldError{
                                                        Message: fmt.Sprintf("param %q default value references param %q which is not defined", p.Name, paramName),
                                                        Paths:   []string{"params"},
                                                })
                                        }</span>
                                        <span class="cov8" title="1">referencedParams = append(referencedParams, paramName)</span>
                                }
                                // Only track dependencies if all referenced parameters exist
                                <span class="cov8" title="1">if !hasUndefinedParam </span><span class="cov8" title="1">{
                                        paramsNeedingResolution[p.Name] = referencedParams
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        resolvedParams.Insert(p.Name)
                }</span>
        }

        // Second pass: iteratively resolve parameters whose dependencies are satisfied
        <span class="cov8" title="1">for len(paramsNeedingResolution) &gt; 0 </span><span class="cov8" title="1">{
                paramWasResolved := false
                for paramName, referencedParams := range paramsNeedingResolution </span><span class="cov8" title="1">{
                        canResolveParam := true
                        for _, referencedParam := range referencedParams </span><span class="cov8" title="1">{
                                if !resolvedParams.Has(referencedParam) </span><span class="cov8" title="1">{
                                        canResolveParam = false
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if canResolveParam </span><span class="cov8" title="1">{
                                resolvedParams.Insert(paramName)
                                delete(paramsNeedingResolution, paramName)
                                paramWasResolved = true
                        }</span>
                }
                <span class="cov8" title="1">if !paramWasResolved </span><span class="cov8" title="1">{
                        // If we couldn't resolve any parameters in this iteration,
                        // we have a circular dependency
                        for paramName := range paramsNeedingResolution </span><span class="cov8" title="1">{
                                errs = errs.Also(&amp;apis.FieldError{
                                        Message: fmt.Sprintf("param %q default value has a circular dependency", paramName),
                                        Paths:   []string{"params"},
                                })
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// validateObjectUsage validates the usage of individual attributes of an object param and the usage of the entire object
func validateObjectUsage(ctx context.Context, sas StepActionSpec, params v1.ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectParameterNames := sets.NewString()
        for _, p := range params </span><span class="cov8" title="1">{
                // collect all names of object type params
                objectParameterNames.Insert(p.Name)

                // collect all keys for this object param
                objectKeys := sets.NewString()
                for key := range p.Properties </span><span class="cov8" title="1">{
                        objectKeys.Insert(key)
                }</span>

                // check if the object's key names are referenced correctly i.e. param.objectParam.key1
                <span class="cov8" title="1">errs = errs.Also(validateStepActionVariables(ctx, sas, "params\\."+p.Name, objectKeys))</span>
        }

        <span class="cov8" title="1">return errs.Also(validateStepActionObjectUsageAsWhole(sas, "params", objectParameterNames))</span>
}

// validateStepActionObjectUsageAsWhole returns an error if the StepAction contains references to the entire input object params in fields where these references are prohibited
func validateStepActionObjectUsageAsWhole(sas StepActionSpec, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToEntireProhibitedVariables(sas.Image, prefix, vars).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(sas.Script, prefix, vars).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(vm.Name, prefix, vars).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepActionArrayUsage returns an error if the Step contains references to the input array params in fields where these references are prohibited
func validateStepActionArrayUsage(sas StepActionSpec, prefix string, arrayParamNames sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToProhibitedVariables(sas.Image, prefix, arrayParamNames).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(sas.Script, prefix, arrayParamNames).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(cmd, prefix, arrayParamNames).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(arg, prefix, arrayParamNames).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(env.Value, prefix, arrayParamNames).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(vm.Name, prefix, arrayParamNames).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepActionVariables returns an error if the StepAction contains references to any unknown variables
func validateStepActionVariables(ctx context.Context, sas StepActionSpec, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(sas.Image, prefix, vars).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(sas.Script, prefix, vars).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(vm.Name, prefix, vars).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*VerificationPolicy)(nil)

// SetDefaults implements apis.Defaultable
func (v *VerificationPolicy) SetDefaults(ctx context.Context) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "crypto"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// VerificationPolicy defines the rules to verify Tekton resources.
// VerificationPolicy can config the mapping from resources to a list of public
// keys, so when verifying the resources we can use the corresponding public keys.
// +k8s:openapi-gen=true
type VerificationPolicy struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the VerificationPolicy.
        Spec VerificationPolicySpec `json:"spec"`
}

// VerificationPolicyList contains a list of VerificationPolicy
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type VerificationPolicyList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []VerificationPolicy `json:"items"`
}

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*VerificationPolicy) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("VerificationPolicy")
}</span>

// VerificationPolicySpec defines the patterns and authorities.
type VerificationPolicySpec struct {
        // Resources defines the patterns of resources sources that should be subject to this policy.
        // For example, we may want to apply this Policy from a certain GitHub repo.
        // Then the ResourcesPattern should be valid regex. E.g. If using gitresolver, and we want to config keys from a certain git repo.
        // `ResourcesPattern` can be `https://github.com/tektoncd/catalog.git`, we will use regex to filter out those resources.
        Resources []ResourcePattern `json:"resources"`
        // Authorities defines the rules for validating signatures.
        Authorities []Authority `json:"authorities"`
        // Mode controls whether a failing policy will fail the taskrun/pipelinerun, or only log the warnings
        // enforce - fail the taskrun/pipelinerun if verification fails (default)
        // warn - don't fail the taskrun/pipelinerun if verification fails but log warnings
        // +optional
        Mode ModeType `json:"mode,omitempty"`
}

// ResourcePattern defines the pattern of the resource source
type ResourcePattern struct {
        // Pattern defines a resource pattern. Regex is created to filter resources based on `Pattern`
        // Example patterns:
        // GitHub resource: https://github.com/tektoncd/catalog.git, https://github.com/tektoncd/*
        // Bundle resource: gcr.io/tekton-releases/catalog/upstream/git-clone, gcr.io/tekton-releases/catalog/upstream/*
        // Hub resource: https://artifacthub.io/*,
        Pattern string `json:"pattern"`
}

// The Authority block defines the keys for validating signatures.
type Authority struct {
        // Name is the name for this authority.
        Name string `json:"name"`
        // Key contains the public key to validate the resource.
        Key *KeyRef `json:"key,omitempty"`
}

// ModeType indicates the type of a mode for VerificationPolicy
type ModeType string

// Valid ModeType:
const (
        ModeWarn    ModeType = "warn"
        ModeEnforce ModeType = "enforce"
)

// KeyRef defines the reference to a public key
type KeyRef struct {
        // SecretRef sets a reference to a secret with the key.
        // +optional
        SecretRef *v1.SecretReference `json:"secretRef,omitempty"`
        // Data contains the inline public key.
        // +optional
        Data string `json:"data,omitempty"`
        // KMS contains the KMS url of the public key
        // Supported formats differ based on the KMS system used.
        // One example of a KMS url could be:
        // gcpkms://projects/[PROJECT]/locations/[LOCATION]&gt;/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[KEY_VERSION]
        // For more examples please refer https://docs.sigstore.dev/cosign/kms_support.
        // Note that the KMS is not supported yet.
        // +optional
        KMS string `json:"kms,omitempty"`
        // HashAlgorithm always defaults to sha256 if the algorithm hasn't been explicitly set
        // +optional
        HashAlgorithm HashAlgorithm `json:"hashAlgorithm,omitempty"`
}

// HashAlgorithm defines the hash algorithm used for the public key
type HashAlgorithm string

const (
        sha224 HashAlgorithm = "sha224"
        sha256 HashAlgorithm = "sha256"
        sha384 HashAlgorithm = "sha384"
        sha512 HashAlgorithm = "sha512"
        empty  HashAlgorithm = ""
)

// SupportedSignatureAlgorithms sets a list of support signature algorithms that is similar to the list supported by cosign.
// empty HashAlgorithm is allowed and will be set to SHA256.
var SupportedSignatureAlgorithms = map[HashAlgorithm]crypto.Hash{
        sha224: crypto.SHA224,
        sha256: crypto.SHA256,
        sha384: crypto.SHA384,
        sha512: crypto.SHA512,
        empty:  crypto.SHA256,
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

var _ apis.Validatable = (*VerificationPolicy)(nil)

var (
        // InvalidResourcePatternErr is returned when the pattern is not valid regex expression
        InvalidResourcePatternErr = "resourcePattern cannot be compiled by regex"
)

// Validate VerificationPolicy
func (v *VerificationPolicy) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(validate.ObjectMetadata(v.GetObjectMeta()).ViaField("metadata"))
        errs = errs.Also(v.Spec.Validate(ctx))
        return errs
}</span>

// Validate VerificationPolicySpec, the validation requires Resources is not empty, for each
// resource it must be able to be regex expression and can be compiled with no error. The Authorities
// shouldn't be empty and each Authority should be valid.
func (vs *VerificationPolicySpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(vs.Resources) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("resources"))
        }</span>
        <span class="cov8" title="1">for _, r := range vs.Resources </span><span class="cov8" title="1">{
                errs = errs.Also(r.Validate(ctx))
        }</span>
        <span class="cov8" title="1">if len(vs.Authorities) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("authorities"))
        }</span>
        <span class="cov8" title="1">for i, a := range vs.Authorities </span><span class="cov8" title="1">{
                if a.Key != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(a.Key.Validate(ctx).ViaFieldIndex("key", i))
                }</span>
        }
        <span class="cov8" title="1">if vs.Mode != "" &amp;&amp; vs.Mode != ModeEnforce &amp;&amp; vs.Mode != ModeWarn </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("available values are: %s, %s, but got: %s", ModeEnforce, ModeWarn, vs.Mode), "mode"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// Validate KeyRef will check if one of KeyRef's Data or SecretRef exists, and the
// Supported HashAlgorithm is in supportedSignatureAlgorithms.
func (key *KeyRef) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate that one and only one of Data, SecretRef, KMS is defined.
        keyCount := 0
        if key.Data != "" </span><span class="cov8" title="1">{
                keyCount++
        }</span>
        <span class="cov8" title="1">if key.SecretRef != nil </span><span class="cov8" title="1">{
                keyCount++
        }</span>
        <span class="cov8" title="1">if key.KMS != "" </span><span class="cov8" title="1">{
                keyCount++
        }</span>

        <span class="cov8" title="1">switch keyCount </span>{
        case 0:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingOneOf("data", "kms", "secretref"))</span>
        case 1:<span class="cov8" title="1"></span>
                // do nothing -- a single key definition is valid
        default:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMultipleOneOf("data", "kms", "secretref"))</span>
        }

        <span class="cov8" title="1">errs = errs.Also(validateHashAlgorithm(key.HashAlgorithm))

        return errs</span>
}

// Validate ResourcePattern and make sure the Pattern is valid regex expression
func (r *ResourcePattern) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if _, err := regexp.Compile(r.Pattern); err != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(r.Pattern, "ResourcePattern", fmt.Sprintf("%v: %v", InvalidResourcePatternErr, err)))
                return errs
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateHashAlgorithm checks if the algorithm is supported
func validateHashAlgorithm(algorithmName HashAlgorithm) (errs *apis.FieldError) <span class="cov8" title="1">{
        normalizedAlgo := strings.ToLower(string(algorithmName))
        _, exists := SupportedSignatureAlgorithms[HashAlgorithm(normalizedAlgo)]
        if !exists </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue(algorithmName, "HashAlgorithm")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (r Ref) convertTo(ctx context.Context, sink *v1.Ref) <span class="cov8" title="1">{
        sink.Name = r.Name
        new := v1.ResolverRef{}
        r.ResolverRef.convertTo(ctx, &amp;new)
        sink.ResolverRef = new
}</span>

func (r *Ref) convertFrom(ctx context.Context, source v1.Ref) <span class="cov8" title="1">{
        r.Name = source.Name
        new := ResolverRef{}
        new.convertFrom(ctx, source.ResolverRef)
        r.ResolverRef = new
}</span>

func (s Step) convertTo(ctx context.Context, sink *v1.Step) <span class="cov8" title="1">{
        sink.Name = s.Name
        sink.Image = s.Image
        sink.Command = s.Command
        sink.Args = s.Args
        sink.WorkingDir = s.WorkingDir
        sink.EnvFrom = s.EnvFrom
        sink.Env = s.Env
        sink.ComputeResources = s.Resources
        sink.VolumeMounts = s.VolumeMounts
        sink.VolumeDevices = s.VolumeDevices
        sink.ImagePullPolicy = s.ImagePullPolicy
        sink.SecurityContext = s.SecurityContext
        sink.Script = s.Script
        sink.Timeout = s.Timeout

        sink.Workspaces = nil
        for _, w := range s.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspaceUsage{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
        <span class="cov8" title="1">sink.OnError = (v1.OnErrorType)(s.OnError)
        sink.StdoutConfig = (*v1.StepOutputConfig)(s.StdoutConfig)
        sink.StderrConfig = (*v1.StepOutputConfig)(s.StderrConfig)
        if s.Ref != nil </span><span class="cov8" title="1">{
                sink.Ref = &amp;v1.Ref{}
                s.Ref.convertTo(ctx, sink.Ref)
        }</span>
        <span class="cov8" title="1">sink.Params = nil
        for _, p := range s.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.Results = s.Results
        for _, w := range s.When </span><span class="cov8" title="1">{
                new := v1.WhenExpression{}
                w.convertTo(ctx, &amp;new)
                sink.When = append(sink.When, new)
        }</span>
}

func (s *Step) convertFrom(ctx context.Context, source v1.Step) <span class="cov8" title="1">{
        s.Name = source.Name
        s.Image = source.Image
        s.Command = source.Command
        s.Args = source.Args
        s.WorkingDir = source.WorkingDir
        s.EnvFrom = source.EnvFrom
        s.Env = source.Env
        s.Resources = source.ComputeResources
        s.VolumeMounts = source.VolumeMounts
        s.VolumeDevices = source.VolumeDevices
        s.ImagePullPolicy = source.ImagePullPolicy
        s.SecurityContext = source.SecurityContext
        s.Script = source.Script
        s.Timeout = source.Timeout

        s.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspaceUsage{}
                new.convertFrom(ctx, w)
                s.Workspaces = append(s.Workspaces, new)
        }</span>
        <span class="cov8" title="1">s.OnError = (OnErrorType)(source.OnError)
        s.StdoutConfig = (*StepOutputConfig)(source.StdoutConfig)
        s.StderrConfig = (*StepOutputConfig)(source.StderrConfig)
        if source.Ref != nil </span><span class="cov8" title="1">{
                newRef := Ref{}
                newRef.convertFrom(ctx, *source.Ref)
                s.Ref = &amp;newRef
        }</span>
        <span class="cov8" title="1">s.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, p)
                s.Params = append(s.Params, new)
        }</span>
        <span class="cov8" title="1">s.Results = source.Results
        for _, w := range source.When </span><span class="cov8" title="1">{
                new := WhenExpression{}
                new.convertFrom(ctx, w)
                s.When = append(s.When, new)
        }</span>
}

func (s StepTemplate) convertTo(ctx context.Context, sink *v1.StepTemplate) <span class="cov8" title="1">{
        sink.Image = s.Image
        sink.Command = s.Command
        sink.Args = s.Args
        sink.WorkingDir = s.WorkingDir
        sink.EnvFrom = s.EnvFrom
        sink.Env = s.Env
        sink.ComputeResources = s.Resources
        sink.VolumeMounts = s.VolumeMounts
        sink.VolumeDevices = s.VolumeDevices
        sink.ImagePullPolicy = s.ImagePullPolicy
        sink.SecurityContext = s.SecurityContext
        // TODO(#4546): Handle deprecated fields
        // Name, Ports, LivenessProbe, ReadinessProbe, StartupProbe, Lifecycle, TerminationMessagePath
        // TerminationMessagePolicy, Stdin, StdinOnce, TTY
}</span>

func (s *StepTemplate) convertFrom(ctx context.Context, source *v1.StepTemplate) <span class="cov8" title="1">{
        s.Image = source.Image
        s.Command = source.Command
        s.Args = source.Args
        s.WorkingDir = source.WorkingDir
        s.EnvFrom = source.EnvFrom
        s.Env = source.Env
        s.Resources = source.ComputeResources
        s.VolumeMounts = source.VolumeMounts
        s.VolumeDevices = source.VolumeDevices
        s.ImagePullPolicy = source.ImagePullPolicy
        s.SecurityContext = source.SecurityContext
}</span>

func (s Sidecar) convertTo(ctx context.Context, sink *v1.Sidecar) <span class="cov8" title="1">{
        sink.Name = s.Name
        sink.Image = s.Image
        sink.Command = s.Command
        sink.Args = s.Args
        sink.WorkingDir = s.WorkingDir
        sink.Ports = s.Ports
        sink.EnvFrom = s.EnvFrom
        sink.Env = s.Env
        sink.ComputeResources = s.Resources
        sink.VolumeMounts = s.VolumeMounts
        sink.VolumeDevices = s.VolumeDevices
        sink.LivenessProbe = s.LivenessProbe
        sink.ReadinessProbe = s.ReadinessProbe
        sink.StartupProbe = s.StartupProbe
        sink.Lifecycle = s.Lifecycle
        sink.TerminationMessagePath = s.TerminationMessagePath
        sink.TerminationMessagePolicy = s.TerminationMessagePolicy
        sink.ImagePullPolicy = s.ImagePullPolicy
        sink.SecurityContext = s.SecurityContext
        sink.Stdin = s.Stdin
        sink.StdinOnce = s.StdinOnce
        sink.TTY = s.TTY
        sink.Script = s.Script
        sink.Workspaces = nil
        for _, w := range s.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspaceUsage{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
}

func (s *Sidecar) convertFrom(ctx context.Context, source v1.Sidecar) <span class="cov8" title="1">{
        s.Name = source.Name
        s.Image = source.Image
        s.Command = source.Command
        s.Args = source.Args
        s.WorkingDir = source.WorkingDir
        s.Ports = source.Ports
        s.EnvFrom = source.EnvFrom
        s.Env = source.Env
        s.Resources = source.ComputeResources
        s.VolumeMounts = source.VolumeMounts
        s.VolumeDevices = source.VolumeDevices
        s.LivenessProbe = source.LivenessProbe
        s.ReadinessProbe = source.ReadinessProbe
        s.StartupProbe = source.StartupProbe
        s.Lifecycle = source.Lifecycle
        s.TerminationMessagePath = source.TerminationMessagePath
        s.TerminationMessagePolicy = source.TerminationMessagePolicy
        s.ImagePullPolicy = source.ImagePullPolicy
        s.SecurityContext = source.SecurityContext
        s.Stdin = source.Stdin
        s.StdinOnce = source.StdinOnce
        s.TTY = source.TTY
        s.Script = source.Script
        s.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspaceUsage{}
                new.convertFrom(ctx, w)
                s.Workspaces = append(s.Workspaces, new)
        }</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Step runs a subcomponent of a Task
type Step struct {
        // Name of the Step specified as a DNS_LABEL.
        // Each Step in a Task must have a unique name.
        Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
        // Image reference name to run for this Step.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of ports to expose from the Step's container. Exposing a port here gives
        // the system additional information about the network connections a
        // container uses, but is primarily informational. Not specifying a port here
        // DOES NOT prevent that port from being exposed. Any port which is
        // listening on the default "0.0.0.0" address inside a container will be
        // accessible from the network.
        // Cannot be updated.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        // +patchMergeKey=containerPort
        // +patchStrategy=merge
        // +listType=map
        // +listMapKey=containerPort
        // +listMapKey=protocol
        DeprecatedPorts []corev1.ContainerPort `json:"ports,omitempty" patchMergeKey:"containerPort" patchStrategy:"merge" protobuf:"bytes,6,rep,name=ports"`
        // List of sources to populate environment variables in the container.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the container is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the container.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // Compute Resources required by this Step.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        Resources corev1.ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Step.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Periodic probe of container liveness.
        // Step will be restarted if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedLivenessProbe *corev1.Probe `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
        // Periodic probe of container service readiness.
        // Step will be removed from service endpoints if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedReadinessProbe *corev1.Probe `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`

        // DeprecatedStartupProbe indicates that the Pod this Step runs in has successfully initialized.
        // If specified, no other probes are executed until this completes successfully.
        // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
        // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
        // when it might take a long time to load data or warm a cache, than during steady-state operation.
        // This cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStartupProbe *corev1.Probe `json:"startupProbe,omitempty" protobuf:"bytes,22,opt,name=startupProbe"`
        // Actions that the management system should take in response to container lifecycle events.
        // Cannot be updated.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedLifecycle *corev1.Lifecycle `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
        // Deprecated: This field will be removed in a future release and can't be meaningfully used.
        // +optional
        DeprecatedTerminationMessagePath string `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
        // Deprecated: This field will be removed in a future release and can't be meaningfully used.
        // +optional
        DeprecatedTerminationMessagePolicy corev1.TerminationMessagePolicy `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

        // Variables for interactive containers, these are deprecated and should not be used.

        // Whether this container should allocate a buffer for stdin in the container runtime. If this
        // is not set, reads from stdin in the container will always result in EOF.
        // Default is false.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStdin bool `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
        // Whether the container runtime should close the stdin channel after it has been opened by
        // a single attach. When stdin is true the stdin stream will remain open across multiple attach
        // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
        // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        // at which time stdin is closed and remains closed until the container is restarted. If this
        // flag is false, a container processes that reads from stdin will never receive an EOF.
        // Default is false
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStdinOnce bool `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
        // Whether this container should allocate a DeprecatedTTY for itself, also requires 'stdin' to be true.
        // Default is false.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedTTY bool `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`

        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
        // +optional
        Script string `json:"script,omitempty"`

        // Timeout is the time after which the step times out. Defaults to never.
        // Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
        // for this field to be supported.
        //
        // Workspaces is a list of workspaces from the Task that this Step wants
        // exclusive access to. Adding a workspace to this list means that any
        // other Step or Sidecar that does not also request this Workspace will
        // not have access to it.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceUsage `json:"workspaces,omitempty"`

        // OnError defines the exiting behavior of a container on error
        // can be set to [ continue | stopAndFail ]
        OnError OnErrorType `json:"onError,omitempty"`

        // Stores configuration for the stdout stream of the step.
        // +optional
        StdoutConfig *StepOutputConfig `json:"stdoutConfig,omitempty"`
        // Stores configuration for the stderr stream of the step.
        // +optional
        StderrConfig *StepOutputConfig `json:"stderrConfig,omitempty"`

        // Contains the reference to an existing StepAction.
        //+optional
        Ref *Ref `json:"ref,omitempty"`
        // Params declares parameters passed to this step action.
        // +optional
        Params Params `json:"params,omitempty"`
        // Results declares StepResults produced by the Step.
        //
        // It can be used in an inlined Step when used to store Results to $(step.results.resultName.path).
        // It cannot be used when referencing StepActions using [v1beta1.Step.Ref].
        // The Results declared by the StepActions will be stored here instead.
        // +optional
        // +listType=atomic
        Results []v1.StepResult `json:"results,omitempty"`

        When StepWhenExpressions `json:"when,omitempty"`
}

// Ref can be used to refer to a specific instance of a StepAction.
type Ref struct {
        // Name of the referenced step
        Name string `json:"name,omitempty"`
        // ResolverRef allows referencing a StepAction in a remote location
        // like a git repo.
        // +optional
        ResolverRef `json:",omitempty"`
}

// OnErrorType defines a list of supported exiting behavior of a container on error
type OnErrorType string

const (
        // StopAndFail indicates exit the taskRun if the container exits with non-zero exit code
        StopAndFail OnErrorType = "stopAndFail"
        // Continue indicates continue executing the rest of the steps irrespective of the container exit code
        Continue OnErrorType = "continue"
)

// StepOutputConfig stores configuration for a step output stream.
type StepOutputConfig struct {
        // Path to duplicate stdout stream to on container's local filesystem.
        // +optional
        Path string `json:"path,omitempty"`
}

// ToK8sContainer converts the Step to a Kubernetes Container struct
func (s *Step) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        return &amp;corev1.Container{
                Name:                     s.Name,
                Image:                    s.Image,
                Command:                  s.Command,
                Args:                     s.Args,
                WorkingDir:               s.WorkingDir,
                Ports:                    s.DeprecatedPorts,
                EnvFrom:                  s.EnvFrom,
                Env:                      s.Env,
                Resources:                s.Resources,
                VolumeMounts:             s.VolumeMounts,
                VolumeDevices:            s.VolumeDevices,
                LivenessProbe:            s.DeprecatedLivenessProbe,
                ReadinessProbe:           s.DeprecatedReadinessProbe,
                StartupProbe:             s.DeprecatedStartupProbe,
                Lifecycle:                s.DeprecatedLifecycle,
                TerminationMessagePath:   s.DeprecatedTerminationMessagePath,
                TerminationMessagePolicy: s.DeprecatedTerminationMessagePolicy,
                ImagePullPolicy:          s.ImagePullPolicy,
                SecurityContext:          s.SecurityContext,
                Stdin:                    s.DeprecatedStdin,
                StdinOnce:                s.DeprecatedStdinOnce,
                TTY:                      s.DeprecatedTTY,
        }
}</span>

// SetContainerFields sets the fields of the Step to the values of the corresponding fields in the Container
func (s *Step) SetContainerFields(c corev1.Container) <span class="cov8" title="1">{
        s.Name = c.Name
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.DeprecatedPorts = c.Ports
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.Resources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.DeprecatedLivenessProbe = c.LivenessProbe
        s.DeprecatedReadinessProbe = c.ReadinessProbe
        s.DeprecatedStartupProbe = c.StartupProbe
        s.DeprecatedLifecycle = c.Lifecycle
        s.DeprecatedTerminationMessagePath = c.TerminationMessagePath
        s.DeprecatedTerminationMessagePolicy = c.TerminationMessagePolicy
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
        s.DeprecatedStdin = c.Stdin
        s.DeprecatedStdinOnce = c.StdinOnce
        s.DeprecatedTTY = c.TTY
}</span>

// StepTemplate is a template for a Step
type StepTemplate struct {
        // Default name for each Step specified as a DNS_LABEL.
        // Each Step in a Task must have a unique name.
        // Cannot be updated.
        //
        // Deprecated: This field will be removed in a future release.
        //
        DeprecatedName string `json:"name" protobuf:"bytes,1,opt,name=name"`
        // Default image name to use for each Step.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // This field is optional to allow higher level config management to default or override
        // container images in workload controllers like Deployments and StatefulSets.
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The docker image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of ports to expose from the Step's container. Exposing a port here gives
        // the system additional information about the network connections a
        // container uses, but is primarily informational. Not specifying a port here
        // DOES NOT prevent that port from being exposed. Any port which is
        // listening on the default "0.0.0.0" address inside a container will be
        // accessible from the network.
        // Cannot be updated.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        // +patchMergeKey=containerPort
        // +patchStrategy=merge
        // +listType=map
        // +listMapKey=containerPort
        // +listMapKey=protocol
        DeprecatedPorts []corev1.ContainerPort `json:"ports,omitempty" patchMergeKey:"containerPort" patchStrategy:"merge" protobuf:"bytes,6,rep,name=ports"`
        // List of sources to populate environment variables in the Step.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the container is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the container.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // Compute Resources required by this Step.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        Resources corev1.ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Step.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Periodic probe of container liveness.
        // Container will be restarted if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedLivenessProbe *corev1.Probe `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
        // Periodic probe of container service readiness.
        // Container will be removed from service endpoints if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedReadinessProbe *corev1.Probe `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`
        // DeprecatedStartupProbe indicates that the Pod has successfully initialized.
        // If specified, no other probes are executed until this completes successfully.
        // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
        // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
        // when it might take a long time to load data or warm a cache, than during steady-state operation.
        // This cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStartupProbe *corev1.Probe `json:"startupProbe,omitempty" protobuf:"bytes,22,opt,name=startupProbe"`
        // Actions that the management system should take in response to container lifecycle events.
        // Cannot be updated.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedLifecycle *corev1.Lifecycle `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
        // Deprecated: This field will be removed in a future release and cannot be meaningfully used.
        // +optional
        DeprecatedTerminationMessagePath string `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
        // Deprecated: This field will be removed in a future release and cannot be meaningfully used.
        // +optional
        DeprecatedTerminationMessagePolicy corev1.TerminationMessagePolicy `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

        // Variables for interactive containers, these are deprecated and should not be used.

        // Whether this Step should allocate a buffer for stdin in the container runtime. If this
        // is not set, reads from stdin in the Step will always result in EOF.
        // Default is false.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStdin bool `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
        // Whether the container runtime should close the stdin channel after it has been opened by
        // a single attach. When stdin is true the stdin stream will remain open across multiple attach
        // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
        // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        // at which time stdin is closed and remains closed until the container is restarted. If this
        // flag is false, a container processes that reads from stdin will never receive an EOF.
        // Default is false
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedStdinOnce bool `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
        // Whether this Step should allocate a DeprecatedTTY for itself, also requires 'stdin' to be true.
        // Default is false.
        //
        // Deprecated: This field will be removed in a future release.
        //
        // +optional
        DeprecatedTTY bool `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`
}

// SetContainerFields sets the fields of the Step to the values of the corresponding fields in the Container
func (s *StepTemplate) SetContainerFields(c corev1.Container) <span class="cov0" title="0">{
        s.DeprecatedName = c.Name
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.DeprecatedPorts = c.Ports
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.Resources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.DeprecatedLivenessProbe = c.LivenessProbe
        s.DeprecatedReadinessProbe = c.ReadinessProbe
        s.DeprecatedStartupProbe = c.StartupProbe
        s.DeprecatedLifecycle = c.Lifecycle
        s.DeprecatedTerminationMessagePath = c.TerminationMessagePath
        s.DeprecatedTerminationMessagePolicy = c.TerminationMessagePolicy
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
        s.DeprecatedStdin = c.Stdin
        s.DeprecatedStdinOnce = c.StdinOnce
        s.DeprecatedTTY = c.TTY
}</span>

// ToK8sContainer converts the StepTemplate to a Kubernetes Container struct
func (s *StepTemplate) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        return &amp;corev1.Container{
                Name:                     s.DeprecatedName,
                Image:                    s.Image,
                Command:                  s.Command,
                Args:                     s.Args,
                WorkingDir:               s.WorkingDir,
                Ports:                    s.DeprecatedPorts,
                EnvFrom:                  s.EnvFrom,
                Env:                      s.Env,
                Resources:                s.Resources,
                VolumeMounts:             s.VolumeMounts,
                VolumeDevices:            s.VolumeDevices,
                LivenessProbe:            s.DeprecatedLivenessProbe,
                ReadinessProbe:           s.DeprecatedReadinessProbe,
                StartupProbe:             s.DeprecatedStartupProbe,
                Lifecycle:                s.DeprecatedLifecycle,
                TerminationMessagePath:   s.DeprecatedTerminationMessagePath,
                TerminationMessagePolicy: s.DeprecatedTerminationMessagePolicy,
                ImagePullPolicy:          s.ImagePullPolicy,
                SecurityContext:          s.SecurityContext,
                Stdin:                    s.DeprecatedStdin,
                StdinOnce:                s.DeprecatedStdinOnce,
                TTY:                      s.DeprecatedTTY,
        }
}</span>

// Sidecar has nearly the same data structure as Step but does not have the ability to timeout.
type Sidecar struct {
        // Name of the Sidecar specified as a DNS_LABEL.
        // Each Sidecar in a Task must have a unique name (DNS_LABEL).
        // Cannot be updated.
        Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
        // Image name to be used by the Sidecar.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the Sidecar's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // Sidecar's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // List of ports to expose from the Sidecar. Exposing a port here gives
        // the system additional information about the network connections a
        // container uses, but is primarily informational. Not specifying a port here
        // DOES NOT prevent that port from being exposed. Any port which is
        // listening on the default "0.0.0.0" address inside a container will be
        // accessible from the network.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=containerPort
        // +patchStrategy=merge
        // +listType=map
        // +listMapKey=containerPort
        // +listMapKey=protocol
        Ports []corev1.ContainerPort `json:"ports,omitempty" patchMergeKey:"containerPort" patchStrategy:"merge" protobuf:"bytes,6,rep,name=ports"`
        // List of sources to populate environment variables in the Sidecar.
        // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        // will be reported as an event when the Sidecar is starting. When a key exists in multiple
        // sources, the value associated with the last source will take precedence.
        // Values defined by an Env with a duplicate key will take precedence.
        // Cannot be updated.
        // +optional
        // +listType=atomic
        EnvFrom []corev1.EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
        // List of environment variables to set in the Sidecar.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // Compute Resources required by this Sidecar.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        // +optional
        Resources corev1.ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`
        // Volumes to mount into the Sidecar's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
        // volumeDevices is the list of block devices to be used by the Sidecar.
        // +patchMergeKey=devicePath
        // +patchStrategy=merge
        // +optional
        // +listType=atomic
        VolumeDevices []corev1.VolumeDevice `json:"volumeDevices,omitempty" patchMergeKey:"devicePath" patchStrategy:"merge" protobuf:"bytes,21,rep,name=volumeDevices"`
        // Periodic probe of Sidecar liveness.
        // Container will be restarted if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        LivenessProbe *corev1.Probe `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
        // Periodic probe of Sidecar service readiness.
        // Container will be removed from service endpoints if the probe fails.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        ReadinessProbe *corev1.Probe `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`
        // StartupProbe indicates that the Pod the Sidecar is running in has successfully initialized.
        // If specified, no other probes are executed until this completes successfully.
        // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
        // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
        // when it might take a long time to load data or warm a cache, than during steady-state operation.
        // This cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        // +optional
        StartupProbe *corev1.Probe `json:"startupProbe,omitempty" protobuf:"bytes,22,opt,name=startupProbe"`
        // Actions that the management system should take in response to Sidecar lifecycle events.
        // Cannot be updated.
        // +optional
        Lifecycle *corev1.Lifecycle `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
        // Optional: Path at which the file to which the Sidecar's termination message
        // will be written is mounted into the Sidecar's filesystem.
        // Message written is intended to be brief final status, such as an assertion failure message.
        // Will be truncated by the node if greater than 4096 bytes. The total message length across
        // all containers will be limited to 12kb.
        // Defaults to /dev/termination-log.
        // Cannot be updated.
        // +optional
        TerminationMessagePath string `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
        // Indicate how the termination message should be populated. File will use the contents of
        // terminationMessagePath to populate the Sidecar status message on both success and failure.
        // FallbackToLogsOnError will use the last chunk of Sidecar log output if the termination
        // message file is empty and the Sidecar exited with an error.
        // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
        // Defaults to File.
        // Cannot be updated.
        // +optional
        TerminationMessagePolicy corev1.TerminationMessagePolicy `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
        // Image pull policy.
        // One of Always, Never, IfNotPresent.
        // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        // Cannot be updated.
        // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        // +optional
        ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
        // SecurityContext defines the security options the Sidecar should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

        // Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
        // and shouldn't be used for general purpose containers.

        // Whether this Sidecar should allocate a buffer for stdin in the container runtime. If this
        // is not set, reads from stdin in the Sidecar will always result in EOF.
        // Default is false.
        // +optional
        Stdin bool `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
        // Whether the container runtime should close the stdin channel after it has been opened by
        // a single attach. When stdin is true the stdin stream will remain open across multiple attach
        // sessions. If stdinOnce is set to true, stdin is opened on Sidecar start, is empty until the
        // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        // at which time stdin is closed and remains closed until the Sidecar is restarted. If this
        // flag is false, a container processes that reads from stdin will never receive an EOF.
        // Default is false
        // +optional
        StdinOnce bool `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
        // Whether this Sidecar should allocate a TTY for itself, also requires 'stdin' to be true.
        // Default is false.
        // +optional
        TTY bool `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`

        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command or Args.
        // +optional
        Script string `json:"script,omitempty"`

        // This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
        // for this field to be supported.
        //
        // Workspaces is a list of workspaces from the Task that this Sidecar wants
        // exclusive access to. Adding a workspace to this list means that any
        // other Step or Sidecar that does not also request this Workspace will
        // not have access to it.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceUsage `json:"workspaces,omitempty"`

        // RestartPolicy refers to kubernetes RestartPolicy. It can only be set for an
        // initContainer and must have it's policy set to "Always". It is currently
        // left optional to help support Kubernetes versions prior to 1.29 when this feature
        // was introduced.
        // +optional
        RestartPolicy *corev1.ContainerRestartPolicy `json:"restartPolicy,omitempty"`
}

// ToK8sContainer converts the Sidecar to a Kubernetes Container struct
func (s *Sidecar) ToK8sContainer() *corev1.Container <span class="cov8" title="1">{
        if s.RestartPolicy == nil </span><span class="cov8" title="1">{
                return &amp;corev1.Container{
                        Name:                     s.Name,
                        Image:                    s.Image,
                        Command:                  s.Command,
                        Args:                     s.Args,
                        WorkingDir:               s.WorkingDir,
                        Ports:                    s.Ports,
                        EnvFrom:                  s.EnvFrom,
                        Env:                      s.Env,
                        Resources:                s.Resources,
                        VolumeMounts:             s.VolumeMounts,
                        VolumeDevices:            s.VolumeDevices,
                        LivenessProbe:            s.LivenessProbe,
                        ReadinessProbe:           s.ReadinessProbe,
                        StartupProbe:             s.StartupProbe,
                        Lifecycle:                s.Lifecycle,
                        TerminationMessagePath:   s.TerminationMessagePath,
                        TerminationMessagePolicy: s.TerminationMessagePolicy,
                        ImagePullPolicy:          s.ImagePullPolicy,
                        SecurityContext:          s.SecurityContext,
                        Stdin:                    s.Stdin,
                        StdinOnce:                s.StdinOnce,
                        TTY:                      s.TTY,
                }
        }</span>
        <span class="cov0" title="0">return &amp;corev1.Container{
                Name:                     s.Name,
                Image:                    s.Image,
                Command:                  s.Command,
                Args:                     s.Args,
                WorkingDir:               s.WorkingDir,
                Ports:                    s.Ports,
                EnvFrom:                  s.EnvFrom,
                Env:                      s.Env,
                Resources:                s.Resources,
                VolumeMounts:             s.VolumeMounts,
                VolumeDevices:            s.VolumeDevices,
                LivenessProbe:            s.LivenessProbe,
                ReadinessProbe:           s.ReadinessProbe,
                RestartPolicy:            s.RestartPolicy,
                StartupProbe:             s.StartupProbe,
                Lifecycle:                s.Lifecycle,
                TerminationMessagePath:   s.TerminationMessagePath,
                TerminationMessagePolicy: s.TerminationMessagePolicy,
                ImagePullPolicy:          s.ImagePullPolicy,
                SecurityContext:          s.SecurityContext,
                Stdin:                    s.Stdin,
                StdinOnce:                s.StdinOnce,
                TTY:                      s.TTY,
        }</span>
}

// SetContainerFields sets the fields of the Sidecar to the values of the corresponding fields in the Container
func (s *Sidecar) SetContainerFields(c corev1.Container) <span class="cov0" title="0">{
        s.Name = c.Name
        s.Image = c.Image
        s.Command = c.Command
        s.Args = c.Args
        s.WorkingDir = c.WorkingDir
        s.Ports = c.Ports
        s.EnvFrom = c.EnvFrom
        s.Env = c.Env
        s.Resources = c.Resources
        s.VolumeMounts = c.VolumeMounts
        s.VolumeDevices = c.VolumeDevices
        s.LivenessProbe = c.LivenessProbe
        s.ReadinessProbe = c.ReadinessProbe
        s.StartupProbe = c.StartupProbe
        s.Lifecycle = c.Lifecycle
        s.TerminationMessagePath = c.TerminationMessagePath
        s.TerminationMessagePolicy = c.TerminationMessagePolicy
        s.ImagePullPolicy = c.ImagePullPolicy
        s.SecurityContext = c.SecurityContext
        s.Stdin = c.Stdin
        s.StdinOnce = c.StdinOnce
        s.TTY = c.TTY
        s.RestartPolicy = c.RestartPolicy
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

func validateRef(ctx context.Context, refName string, refResolver ResolverName, refParams Params) (errs *apis.FieldError) <span class="cov8" title="1">{
        switch </span>{
        case refResolver != "" || refParams != nil:<span class="cov8" title="1">
                if refParams != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver params", config.BetaAPIFields).ViaField("params"))
                        if refName != "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name", "params"))
                        }</span>
                        <span class="cov8" title="1">if refResolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, refParams))</span>
                }
                <span class="cov8" title="1">if refResolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver", config.BetaAPIFields).ViaField("resolver"))
                        if refName != "" </span><span class="cov8" title="1">{
                                // make sure that the name is url-like.
                                err := RefNameLikeUrl(refName)
                                if err == nil &amp;&amp; !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                        // If name is url-like then concise resolver syntax must be enabled
                                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(err, "name"))
                                }</span>
                        }
                }
        case refName != "":<span class="cov8" title="1">
                // ref name can be a Url-like format.
                if err := RefNameLikeUrl(refName); err == nil </span><span class="cov8" title="1">{
                        // If name is url-like then concise resolver syntax must be enabled
                        if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                        }</span>
                        // In stage1 of concise remote resolvers syntax, this is a required field.
                        // TODO: remove this check when implementing stage 2 where this is optional.
                        <span class="cov8" title="1">if refResolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        // Or, it must be a valid k8s name
                } else<span class="cov8" title="1"> {
                        // ref name must be a valid k8s name
                        if errSlice := validation.IsQualifiedName(refName); len(errSlice) != 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(strings.Join(errSlice, ","), "name"))
                        }</span>
                }
        default:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("name"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Validate ensures that a supplied Ref field is populated
// correctly. No errors are returned for a nil Ref.
func (ref *Ref) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return validateRef(ctx, ref.Name, ref.Resolver, ref.Params)</span>
}

// RefNameLikeUrl checks if the name is url parsable and returns an error if it isn't.
func RefNameLikeUrl(name string) error <span class="cov8" title="1">{
        schemeRegex := regexp.MustCompile(`[\w-]+:\/\/*`)
        if !schemeRegex.MatchString(name) </span><span class="cov8" title="1">{
                return errors.New("invalid URI for request")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*CustomRun)(nil)

// SetDefaults implements apis.Defaultable
func (r *CustomRun) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        ctx = apis.WithinParent(ctx, r.ObjectMeta)
        r.Spec.SetDefaults(apis.WithinSpec(ctx))
}</span>

// SetDefaults implements apis.Defaultable
func (rs *CustomRunSpec) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        cfg := config.FromContextOrDefaults(ctx)
        defaultSA := cfg.Defaults.DefaultServiceAccount
        if rs.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov0" title="0">{
                rs.ServiceAccountName = defaultSA
        }</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
        "time"

        apisconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        runv1beta1 "github.com/tektoncd/pipeline/pkg/apis/run/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// EmbeddedCustomRunSpec allows custom task definitions to be embedded
type EmbeddedCustomRunSpec struct {
        runtime.TypeMeta `json:",inline"`

        // +optional
        Metadata PipelineTaskMetadata `json:"metadata,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        Spec runtime.RawExtension `json:"spec,omitempty"`
}

// CustomRunSpec defines the desired state of CustomRun
type CustomRunSpec struct {
        // +optional
        CustomRef *TaskRef `json:"customRef,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        CustomSpec *EmbeddedCustomRunSpec `json:"customSpec,omitempty"`

        // +optional
        Params Params `json:"params,omitempty"`

        // Used for cancelling a customrun (and maybe more later on)
        // +optional
        Status CustomRunSpecStatus `json:"status,omitempty"`

        // Status message for cancellation.
        // +optional
        StatusMessage CustomRunSpecStatusMessage `json:"statusMessage,omitempty"`

        // Used for propagating retries count to custom tasks
        // +optional
        Retries int `json:"retries,omitempty"`

        // +optional
        ServiceAccountName string `json:"serviceAccountName"`

        // Time after which the custom-task times out.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // Workspaces is a list of WorkspaceBindings from volumes to workspaces.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceBinding `json:"workspaces,omitempty"`
}

// CustomRunSpecStatus defines the taskrun spec status the user can provide
type CustomRunSpecStatus string

const (
        // CustomRunSpecStatusCancelled indicates that the user wants to cancel the run,
        // if not already cancelled or terminated
        CustomRunSpecStatusCancelled CustomRunSpecStatus = "RunCancelled"
)

// CustomRunSpecStatusMessage defines human readable status messages for the TaskRun.
type CustomRunSpecStatusMessage string

const (
        // CustomRunCancelledByPipelineMsg indicates that the PipelineRun of which part this CustomRun was
        // has been cancelled.
        CustomRunCancelledByPipelineMsg CustomRunSpecStatusMessage = "CustomRun cancelled as the PipelineRun it belongs to has been cancelled."
        // CustomRunCancelledByPipelineTimeoutMsg indicates that the Run was cancelled because the PipelineRun running it timed out.
        CustomRunCancelledByPipelineTimeoutMsg CustomRunSpecStatusMessage = "CustomRun cancelled as the PipelineRun it belongs to has timed out."
)

// GetParam gets the Param from the CustomRunSpec with the given name
// TODO(jasonhall): Move this to a Params type so other code can use it?
func (rs CustomRunSpec) GetParam(name string) *Param <span class="cov8" title="1">{
        for _, p := range rs.Params </span><span class="cov8" title="1">{
                if p.Name == name </span><span class="cov8" title="1">{
                        return &amp;p
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CustomRunReason is an enum used to store all Run reason for the Succeeded condition that are controlled by the CustomRun itself.
type CustomRunReason string

const (
        // CustomRunReasonStarted is the reason set when the CustomRun has just started.
        CustomRunReasonStarted CustomRunReason = "Started"
        // CustomRunReasonRunning is the reason set when the CustomRun is running.
        CustomRunReasonRunning CustomRunReason = "Running"
        // CustomRunReasonSuccessful is the reason set when the CustomRun completed successfully.
        CustomRunReasonSuccessful CustomRunReason = "Succeeded"
        // CustomRunReasonFailed is the reason set when the CustomRun completed with a failure.
        CustomRunReasonFailed CustomRunReason = "Failed"
        // CustomRunReasonCancelled must be used in the Condition Reason to indicate that a CustomRun was cancelled.
        CustomRunReasonCancelled CustomRunReason = "CustomRunCancelled"
        // CustomRunReasonTimedOut must be used in the Condition Reason to indicate that a CustomRun was timed out.
        CustomRunReasonTimedOut CustomRunReason = "CustomRunTimedOut"
        // CustomRunReasonWorkspaceNotSupported can be used in the Condition Reason to indicate that the
        // CustomRun contains a workspace which is not supported by this custom task.
        CustomRunReasonWorkspaceNotSupported CustomRunReason = "CustomRunWorkspaceNotSupported"
)

func (t CustomRunReason) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

// CustomRunStatus defines the observed state of CustomRun.
type CustomRunStatus = runv1beta1.CustomRunStatus

var customrunCondSet = apis.NewBatchConditionSet()

// GetConditionSet retrieves the condition set for this resource. Implements
// the KRShaped interface.
func (r *CustomRun) GetConditionSet() apis.ConditionSet <span class="cov0" title="0">{ return customrunCondSet }</span>

// GetStatus retrieves the status of the Parallel. Implements the KRShaped
// interface.
func (r *CustomRun) GetStatus() *duckv1.Status <span class="cov0" title="0">{ return &amp;r.Status.Status }</span>

// CustomRunStatusFields holds the fields of CustomRun's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type CustomRunStatusFields = runv1beta1.CustomRunStatusFields

// CustomRunResult used to describe the results of a task
type CustomRunResult = runv1beta1.CustomRunResult

// +genclient
// +genreconciler
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// CustomRun represents a single execution of a Custom Task.
//
// +k8s:openapi-gen=true
type CustomRun struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec CustomRunSpec `json:"spec,omitempty"`
        // +optional
        Status CustomRunStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// CustomRunList contains a list of CustomRun
type CustomRunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []CustomRun `json:"items"`
}

// GetStatusCondition returns the task run status as a ConditionAccessor
func (r *CustomRun) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;r.Status
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*CustomRun) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.CustomRunControllerName)
}</span>

// HasPipelineRunOwnerReference returns true of CustomRun has
// owner reference of type PipelineRun
func (r *CustomRun) HasPipelineRunOwnerReference() bool <span class="cov0" title="0">{
        for _, ref := range r.GetOwnerReferences() </span><span class="cov0" title="0">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsCancelled returns true if the CustomRun's spec status is set to Cancelled state
func (r *CustomRun) IsCancelled() bool <span class="cov8" title="1">{
        return r.Spec.Status == CustomRunSpecStatusCancelled
}</span>

// IsDone returns true if the CustomRun's status indicates that it is done.
func (r *CustomRun) IsDone() bool <span class="cov8" title="1">{
        return !r.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether taskrun has valid start time set in its status
func (r *CustomRun) HasStarted() bool <span class="cov8" title="1">{
        return r.Status.StartTime != nil &amp;&amp; !r.Status.StartTime.IsZero()
}</span>

// IsSuccessful returns true if the CustomRun's status indicates that it has succeeded.
func (r *CustomRun) IsSuccessful() bool <span class="cov8" title="1">{
        return r != nil &amp;&amp; r.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
}</span>

// IsFailure returns true if the CustomRun's status indicates that it has failed.
func (r *CustomRun) IsFailure() bool <span class="cov0" title="0">{
        return r != nil &amp;&amp; r.Status.GetCondition(apis.ConditionSucceeded).IsFalse()
}</span>

// GetCustomRunKey return the customrun's key for timeout handler map
func (r *CustomRun) GetCustomRunKey() string <span class="cov0" title="0">{
        // The address of the pointer is a threadsafe unique identifier for the customrun
        return fmt.Sprintf("%s/%p", "CustomRun", r)
}</span>

// HasTimedOut returns true if the CustomRun's running time is beyond the allowed timeout
func (r *CustomRun) HasTimedOut(c clock.PassiveClock) bool <span class="cov8" title="1">{
        if r.Status.StartTime == nil || r.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := r.GetTimeout()
        // If timeout is set to 0 or defaulted to 0, there is no timeout.
        if timeout == apisconfig.NoTimeoutDuration </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">runtime := c.Since(r.Status.StartTime.Time)
        return runtime &gt; timeout</span>
}

// GetTimeout returns the timeout for this customrun, or the default if not configured
func (r *CustomRun) GetTimeout() time.Duration <span class="cov8" title="1">{
        // Use the platform default if no timeout is set
        if r.Spec.Timeout == nil </span><span class="cov8" title="1">{
                return apisconfig.DefaultTimeoutMinutes * time.Minute
        }</span>
        <span class="cov8" title="1">return r.Spec.Timeout.Duration</span>
}

// GetRetryCount returns the number of times this CustomRun has already been retried
func (r *CustomRun) GetRetryCount() int <span class="cov8" title="1">{
        return len(r.Status.RetriesStatus)
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ apis.Validatable = (*CustomRun)(nil)
var _ resourcesemantics.VerbLimited = (*CustomRun)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (r *CustomRun) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate customRun
func (r *CustomRun) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if err := validate.ObjectMetadata(r.GetObjectMeta()).ViaField("metadata"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return r.Spec.Validate(ctx)</span>
}

// Validate CustomRun spec
func (rs *CustomRunSpec) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // this covers the case rs.customRef == nil &amp;&amp; rs.customSpec == nil
        if equality.Semantic.DeepEqual(rs, &amp;CustomRunSpec{}) </span><span class="cov8" title="1">{
                return apis.ErrMissingField("spec")
        }</span>

        <span class="cov8" title="1">if rs.CustomRef != nil &amp;&amp; rs.CustomSpec != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.customRef", "spec.customSpec")
        }</span>
        <span class="cov8" title="1">if rs.CustomRef == nil &amp;&amp; rs.CustomSpec == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.customRef", "spec.customSpec")
        }</span>
        <span class="cov8" title="1">if rs.CustomRef != nil </span><span class="cov8" title="1">{
                if rs.CustomRef.APIVersion == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.customRef.apiVersion")
                }</span>
                <span class="cov8" title="1">if rs.CustomRef.Kind == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.customRef.kind")
                }</span>
        }
        <span class="cov8" title="1">if rs.CustomSpec != nil </span><span class="cov8" title="1">{
                if rs.CustomSpec.APIVersion == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.customSpec.apiVersion")
                }</span>
                <span class="cov8" title="1">if rs.CustomSpec.Kind == "" </span><span class="cov8" title="1">{
                        return apis.ErrMissingField("spec.customSpec.kind")
                }</span>
        }
        <span class="cov8" title="1">if rs.Status == "" </span><span class="cov8" title="1">{
                if rs.StatusMessage != "" </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(fmt.Sprintf("statusMessage should not be set if status is not set, but it is currently set to %s", rs.StatusMessage), "statusMessage")
                }</span>
        }
        <span class="cov8" title="1">if err := ValidateParameters(ctx, rs.Params).ViaField("spec.params"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return ValidateWorkspaceBindings(ctx, rs.Workspaces).ViaField("spec.workspaces")</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "maps"
        "sort"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
)

// Matrix is used to fan out Tasks in a Pipeline
type Matrix struct {
        // Params is a list of parameters used to fan out the pipelineTask
        // Params takes only `Parameters` of type `"array"`
        // Each array element is supplied to the `PipelineTask` by substituting `params` of type `"string"` in the underlying `Task`.
        // The names of the `params` in the `Matrix` must match the names of the `params` in the underlying `Task` that they will be substituting.
        Params Params `json:"params,omitempty"`

        // Include is a list of IncludeParams which allows passing in specific combinations of Parameters into the Matrix.
        // +optional
        Include IncludeParamsList `json:"include,omitempty"`
}

// IncludeParamsList is a list of IncludeParams which allows passing in specific combinations of Parameters into the Matrix.
// +listType=atomic
type IncludeParamsList []IncludeParams

// IncludeParams allows passing in a specific combinations of Parameters into the Matrix.
type IncludeParams struct {
        // Name the specified combination
        Name string `json:"name,omitempty"`

        // Params takes only `Parameters` of type `"string"`
        // The names of the `params` must match the names of the `params` in the underlying `Task`
        Params Params `json:"params,omitempty"`
}

// Combination is a map, mainly defined to hold a single combination from a Matrix with key as param.Name and value as param.Value
type Combination map[string]string

// Combinations is a Combination list
type Combinations []Combination

// FanOut returns an list of params that represent combinations
func (m *Matrix) FanOut() []Params <span class="cov8" title="1">{
        var combinations, includeCombinations Combinations
        includeCombinations = m.getIncludeCombinations()
        if m.HasInclude() &amp;&amp; !m.HasParams() </span><span class="cov8" title="1">{
                // If there are only Matrix Include Parameters return explicit combinations
                return includeCombinations.toParams()
        }</span>
        // Generate combinations from Matrix Parameters
        <span class="cov8" title="1">for _, parameter := range m.Params </span><span class="cov8" title="1">{
                combinations = combinations.fanOutMatrixParams(parameter)
        }</span>
        <span class="cov8" title="1">combinations.overwriteCombinations(includeCombinations)
        combinations = combinations.addNewCombinations(includeCombinations)
        return combinations.toParams()</span>
}

// overwriteCombinations replaces any missing include params in the initial
// matrix params combinations by overwriting the initial combinations with the
// include combinations
func (cs Combinations) overwriteCombinations(ics Combinations) <span class="cov8" title="1">{
        for _, paramCombination := range cs </span><span class="cov8" title="1">{
                for _, includeCombination := range ics </span><span class="cov8" title="1">{
                        if paramCombination.contains(includeCombination) </span><span class="cov8" title="1">{
                                // overwrite the parameter name and value in existing combination
                                // with the include combination
                                for name, val := range includeCombination </span><span class="cov8" title="1">{
                                        paramCombination[name] = val
                                }</span>
                        }
                }
        }
}

// addNewCombinations creates a new combination for any include parameter
// values that are missing entirely from the initial combinations and
// returns all combinations
func (cs Combinations) addNewCombinations(ics Combinations) Combinations <span class="cov8" title="1">{
        for _, includeCombination := range ics </span><span class="cov8" title="1">{
                if cs.shouldAddNewCombination(includeCombination) </span><span class="cov8" title="1">{
                        cs = append(cs, includeCombination)
                }</span>
        }
        <span class="cov8" title="1">return cs</span>
}

// contains returns true if the include parameter name and value exists in combinations
func (c Combination) contains(includeCombination Combination) bool <span class="cov8" title="1">{
        for name, val := range includeCombination </span><span class="cov8" title="1">{
                if _, exist := c[name]; exist </span><span class="cov8" title="1">{
                        if c[name] != val </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// shouldAddNewCombination returns true if the include parameter name exists but the value is
// missing from combinations
func (cs Combinations) shouldAddNewCombination(includeCombination map[string]string) bool <span class="cov8" title="1">{
        if len(includeCombination) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, paramCombination := range cs </span><span class="cov8" title="1">{
                for name, val := range includeCombination </span><span class="cov8" title="1">{
                        if _, exist := paramCombination[name]; exist </span><span class="cov8" title="1">{
                                if paramCombination[name] == val </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return true</span>
}

// toParams transforms Combinations from a slice of map[string]string to a slice of Params
// such that, these combinations can be directly consumed in creating taskRun/run object
func (cs Combinations) toParams() []Params <span class="cov8" title="1">{
        listOfParams := make([]Params, len(cs))
        for i := range cs </span><span class="cov8" title="1">{
                var params Params
                combination := cs[i]
                order, _ := combination.sortCombination()
                for _, key := range order </span><span class="cov8" title="1">{
                        params = append(params, Param{
                                Name:  key,
                                Value: ParamValue{Type: ParamTypeString, StringVal: combination[key]},
                        })
                }</span>
                <span class="cov8" title="1">listOfParams[i] = params</span>
        }
        <span class="cov8" title="1">return listOfParams</span>
}

// fanOutMatrixParams generates new combinations based on Matrix Parameters.
func (cs Combinations) fanOutMatrixParams(param Param) Combinations <span class="cov8" title="1">{
        if len(cs) == 0 </span><span class="cov8" title="1">{
                return initializeCombinations(param)
        }</span>
        <span class="cov8" title="1">return cs.distribute(param)</span>
}

// getIncludeCombinations generates combinations based on Matrix Include Parameters
func (m *Matrix) getIncludeCombinations() Combinations <span class="cov8" title="1">{
        var combinations Combinations
        for i := range m.Include </span><span class="cov8" title="1">{
                includeParams := m.Include[i].Params
                newCombination := make(Combination)
                for _, param := range includeParams </span><span class="cov8" title="1">{
                        newCombination[param.Name] = param.Value.StringVal
                }</span>
                <span class="cov8" title="1">combinations = append(combinations, newCombination)</span>
        }
        <span class="cov8" title="1">return combinations</span>
}

// distribute generates a new Combination of Parameters by adding a new Parameter to an existing list of Combinations.
func (cs Combinations) distribute(param Param) Combinations <span class="cov8" title="1">{
        var expandedCombinations Combinations
        for _, value := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                for _, combination := range cs </span><span class="cov8" title="1">{
                        newCombination := make(Combination)
                        maps.Copy(newCombination, combination)
                        newCombination[param.Name] = value
                        _, orderedCombination := newCombination.sortCombination()
                        expandedCombinations = append(expandedCombinations, orderedCombination)
                }</span>
        }
        <span class="cov8" title="1">return expandedCombinations</span>
}

// initializeCombinations generates a new Combination based on the first Parameter in the Matrix.
func initializeCombinations(param Param) Combinations <span class="cov8" title="1">{
        var combinations Combinations
        for _, value := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                combinations = append(combinations, Combination{param.Name: value})
        }</span>
        <span class="cov8" title="1">return combinations</span>
}

// sortCombination sorts the given Combination based on the Parameter names to produce a deterministic ordering
func (c Combination) sortCombination() ([]string, Combination) <span class="cov8" title="1">{
        sortedCombination := make(Combination, len(c))
        order := make([]string, 0, len(c))
        for key := range c </span><span class="cov8" title="1">{
                order = append(order, key)
        }</span>
        <span class="cov8" title="1">sort.Slice(order, func(i, j int) bool </span><span class="cov8" title="1">{
                return order[i] &lt;= order[j]
        }</span>)
        <span class="cov8" title="1">for _, key := range order </span><span class="cov8" title="1">{
                sortedCombination[key] = c[key]
        }</span>
        <span class="cov8" title="1">return order, sortedCombination</span>
}

// CountCombinations returns the count of Combinations of Parameters generated from the Matrix in PipelineTask.
func (m *Matrix) CountCombinations() int <span class="cov8" title="1">{
        // Iterate over Matrix Parameters and compute count of all generated Combinations
        count := m.countGeneratedCombinationsFromParams()

        // Add any additional Combinations generated from Matrix Include Parameters
        count += m.countNewCombinationsFromInclude()

        return count
}</span>

// countGeneratedCombinationsFromParams returns the count of Combinations of Parameters generated from the Matrix
// Parameters
func (m *Matrix) countGeneratedCombinationsFromParams() int <span class="cov8" title="1">{
        if !m.HasParams() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">count := 1
        for _, param := range m.Params </span><span class="cov8" title="1">{
                count *= len(param.Value.ArrayVal)
        }</span>
        <span class="cov8" title="1">return count</span>
}

// countNewCombinationsFromInclude returns the count of Combinations of Parameters generated from the Matrix
// Include Parameters
func (m *Matrix) countNewCombinationsFromInclude() int <span class="cov8" title="1">{
        if !m.HasInclude() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if !m.HasParams() </span><span class="cov8" title="1">{
                return len(m.Include)
        }</span>
        <span class="cov8" title="1">count := 0
        matrixParamMap := m.Params.extractParamMapArrVals()
        for _, include := range m.Include </span><span class="cov8" title="1">{
                for _, param := range include.Params </span><span class="cov8" title="1">{
                        if val, exist := matrixParamMap[param.Name]; exist </span><span class="cov8" title="1">{
                                // If the Matrix Include param values does not exist, a new Combination will be generated
                                if !slices.Contains(val, param.Value.StringVal) </span><span class="cov8" title="1">{
                                        count++
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return count</span>
}

// HasInclude returns true if the Matrix has Include Parameters
func (m *Matrix) HasInclude() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.Include != nil &amp;&amp; len(m.Include) &gt; 0
}</span>

// HasParams returns true if the Matrix has Parameters
func (m *Matrix) HasParams() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.Params != nil &amp;&amp; len(m.Params) &gt; 0
}</span>

// GetAllParams returns a list of all Matrix Parameters
func (m *Matrix) GetAllParams() Params <span class="cov8" title="1">{
        var params Params
        if m.HasParams() </span><span class="cov8" title="1">{
                params = append(params, m.Params...)
        }</span>
        <span class="cov8" title="1">if m.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range m.Include </span><span class="cov8" title="1">{
                        params = append(params, include.Params...)
                }</span>
        }
        <span class="cov8" title="1">return params</span>
}

func (m *Matrix) validateCombinationsCount(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        matrixCombinationsCount := m.CountCombinations()
        maxMatrixCombinationsCount := config.FromContextOrDefaults(ctx).Defaults.DefaultMaxMatrixCombinationsCount
        if matrixCombinationsCount &gt; maxMatrixCombinationsCount </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrOutOfBoundsValue(matrixCombinationsCount, 0, maxMatrixCombinationsCount, "matrix"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateUniqueParams validates Matrix.Params for a unique list of params
// and a unique list of params in each Matrix.Include.Params specification
func (m *Matrix) validateUniqueParams() (errs *apis.FieldError) <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                if m.HasInclude() </span><span class="cov8" title="1">{
                        for i, include := range m.Include </span><span class="cov8" title="1">{
                                errs = errs.Also(include.Params.validateDuplicateParameters().ViaField(fmt.Sprintf("matrix.include[%d].params", i)))
                        }</span>
                }
                <span class="cov8" title="1">if m.HasParams() </span><span class="cov8" title="1">{
                        errs = errs.Also(m.Params.validateDuplicateParameters().ViaField("matrix.params"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineParametersVariablesInMatrixParameters validates all pipeline parameter variables including Matrix.Params and Matrix.Include.Params
// that may contain the reference(s) to other params to make sure those references are used appropriately.
func (m *Matrix) validatePipelineParametersVariablesInMatrixParameters(prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if m.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range m.Include </span><span class="cov8" title="1">{
                        for idx, param := range include.Params </span><span class="cov8" title="1">{
                                stringElement := param.Value.StringVal
                                // Matrix Include Params must be of type string
                                errs = errs.Also(validateStringVariable(stringElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("", idx).ViaField("matrix.include.params", ""))
                        }</span>
                }
        }
        <span class="cov8" title="1">if m.HasParams() </span><span class="cov8" title="1">{
                for _, param := range m.Params </span><span class="cov8" title="1">{
                        for idx, arrayElement := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                // Matrix Params must be of type array
                                errs = errs.Also(validateArrayVariable(arrayElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("value", idx).ViaFieldKey("matrix.params", param.Name))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (m *Matrix) validateParameterInOneOfMatrixOrParams(params Params) (errs *apis.FieldError) <span class="cov8" title="1">{
        matrixParamNames := m.GetAllParams().ExtractNames()
        for _, param := range params </span><span class="cov8" title="1">{
                if matrixParamNames.Has(param.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("matrix["+param.Name+"]", "params["+param.Name+"]"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/json"

        corev1 "k8s.io/api/core/v1"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/strategicpatch"
)

// mergeData is used to store the intermediate data needed to merge an object
// with a template. It's provided to avoid repeatedly re-serializing the template.
// +k8s:openapi-gen=false
type mergeData struct {
        emptyJSON    []byte
        templateJSON []byte
        patchSchema  strategicpatch.PatchMetaFromStruct
}

// MergeStepsWithStepTemplate takes a possibly nil container template and a
// list of steps, merging each of the steps with the container template, if
// it's not nil, and returning the resulting list.
func MergeStepsWithStepTemplate(template *StepTemplate, steps []Step) ([]Step, error) <span class="cov8" title="1">{
        if template == nil </span><span class="cov8" title="1">{
                return steps, nil
        }</span>

        <span class="cov8" title="1">md, err := getMergeData(template.ToK8sContainer(), &amp;corev1.Container{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                // If the stepaction has not been fetched yet then do not merge.
                // Skip over to the next one
                if s.Ref != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := corev1.Container{}
                err := mergeObjWithTemplateBytes(md, s.ToK8sContainer(), &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // If the container's args is nil, reset it to empty instead
                <span class="cov8" title="1">if merged.Args == nil &amp;&amp; s.Args != nil </span><span class="cov0" title="0">{
                        merged.Args = []string{}
                }</span>

                <span class="cov8" title="1">amendConflictingContainerFields(&amp;merged, s)

                // Pass through original step Script, for later conversion.
                newStep := Step{Script: s.Script, OnError: s.OnError, Timeout: s.Timeout, StdoutConfig: s.StdoutConfig, StderrConfig: s.StderrConfig, When: s.When}
                newStep.SetContainerFields(merged)
                steps[i] = newStep</span>
        }
        <span class="cov8" title="1">return steps, nil</span>
}

// MergeStepsWithOverrides takes a possibly nil list of overrides and a
// list of steps, merging each of the steps with the overrides' resource requirements, if
// it's not nil, and returning the resulting list.
func MergeStepsWithOverrides(steps []Step, overrides []TaskRunStepOverride) ([]Step, error) <span class="cov8" title="1">{
        stepNameToOverride := make(map[string]TaskRunStepOverride, len(overrides))
        for _, o := range overrides </span><span class="cov8" title="1">{
                stepNameToOverride[o.Name] = o
        }</span>
        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                o, found := stepNameToOverride[s.Name]
                if !found </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := v1.ResourceRequirements{}
                err := mergeObjWithTemplate(&amp;s.Resources, &amp;o.Resources, &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">steps[i].Resources = merged</span>
        }
        <span class="cov8" title="1">return steps, nil</span>
}

// MergeSidecarsWithOverrides takes a possibly nil list of overrides and a
// list of sidecars, merging each of the sidecars with the overrides' resource requirements, if
// it's not nil, and returning the resulting list.
func MergeSidecarsWithOverrides(sidecars []Sidecar, overrides []TaskRunSidecarOverride) ([]Sidecar, error) <span class="cov8" title="1">{
        if len(overrides) == 0 </span><span class="cov8" title="1">{
                return sidecars, nil
        }</span>
        <span class="cov8" title="1">sidecarNameToOverride := make(map[string]TaskRunSidecarOverride, len(overrides))
        for _, o := range overrides </span><span class="cov8" title="1">{
                sidecarNameToOverride[o.Name] = o
        }</span>
        <span class="cov8" title="1">for i, s := range sidecars </span><span class="cov8" title="1">{
                o, found := sidecarNameToOverride[s.Name]
                if !found </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">merged := v1.ResourceRequirements{}
                err := mergeObjWithTemplate(&amp;s.Resources, &amp;o.Resources, &amp;merged)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">sidecars[i].Resources = merged</span>
        }
        <span class="cov8" title="1">return sidecars, nil</span>
}

// mergeObjWithTemplate merges obj with template and updates out to reflect the merged result.
// template, obj, and out should point to the same type. out points to the zero value of that type.
func mergeObjWithTemplate(template, obj, out interface{}) error <span class="cov8" title="1">{
        md, err := getMergeData(template, out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return mergeObjWithTemplateBytes(md, obj, out)</span>
}

// getMergeData serializes the template and empty object to get the intermediate results necessary for
// merging an object of the same type with this template.
// This function is provided to avoid repeatedly serializing an identical template.
func getMergeData(template, empty interface{}) (*mergeData, error) <span class="cov8" title="1">{
        // We need JSON bytes to generate a patch to merge the object
        // onto the template, so marshal the template.
        templateJSON, err := json.Marshal(template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // We need to do a three-way merge to actually merge the template and
        // object, so we need an empty object as the "original"
        <span class="cov8" title="1">emptyJSON, err := json.Marshal(empty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Get the patch meta, which is needed for generating and applying the merge patch.
        <span class="cov8" title="1">patchSchema, err := strategicpatch.NewPatchMetaFromStruct(template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;mergeData{templateJSON: templateJSON, emptyJSON: emptyJSON, patchSchema: patchSchema}, nil</span>
}

// mergeObjWithTemplateBytes merges obj with md's template JSON and updates out to reflect the merged result.
// out is a pointer to the zero value of obj's type.
// This function is provided to avoid repeatedly serializing an identical template.
func mergeObjWithTemplateBytes(md *mergeData, obj, out interface{}) error <span class="cov8" title="1">{
        // Marshal the object to JSON
        objAsJSON, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Create a merge patch, with the empty JSON as the original, the object JSON as the modified, and the template
        // JSON as the current - this lets us do a deep merge of the template and object, with awareness of
        // the "patchMerge" tags.
        <span class="cov8" title="1">patch, err := strategicpatch.CreateThreeWayMergePatch(md.emptyJSON, objAsJSON, md.templateJSON, md.patchSchema, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Actually apply the merge patch to the template JSON.
        <span class="cov8" title="1">mergedAsJSON, err := strategicpatch.StrategicMergePatchUsingLookupPatchMeta(md.templateJSON, patch, md.patchSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Unmarshal the merged JSON to a pointer, and return it.
        <span class="cov8" title="1">return json.Unmarshal(mergedAsJSON, out)</span>
}

// amendConflictingContainerFields amends conflicting container fields after merge, and overrides conflicting fields
// by fields in step.
func amendConflictingContainerFields(container *corev1.Container, step Step) <span class="cov8" title="1">{
        if container == nil || len(step.Env) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">envNameToStepEnv := make(map[string]corev1.EnvVar, len(step.Env))
        for _, e := range step.Env </span><span class="cov8" title="1">{
                envNameToStepEnv[e.Name] = e
        }</span>

        <span class="cov8" title="1">for index, env := range container.Env </span><span class="cov8" title="1">{
                if env.ValueFrom != nil &amp;&amp; len(env.Value) &gt; 0 </span><span class="cov8" title="1">{
                        if e, ok := envNameToStepEnv[env.Name]; ok </span><span class="cov8" title="1">{
                                container.Env[index] = e
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (p ParamSpec) convertTo(ctx context.Context, sink *v1.ParamSpec) <span class="cov8" title="1">{
        sink.Name = p.Name
        if p.Type != "" </span><span class="cov8" title="1">{
                sink.Type = v1.ParamType(p.Type)
        }</span> else<span class="cov8" title="1"> {
                sink.Type = v1.ParamType(ParamTypeString)
        }</span>
        <span class="cov8" title="1">sink.Description = p.Description
        sink.Enum = p.Enum
        var properties map[string]v1.PropertySpec
        if p.Properties != nil </span><span class="cov8" title="1">{
                properties = make(map[string]v1.PropertySpec)
        }</span>
        <span class="cov8" title="1">for k, v := range p.Properties </span><span class="cov8" title="1">{
                properties[k] = v1.PropertySpec{Type: v1.ParamType(v.Type)}
        }</span>
        <span class="cov8" title="1">sink.Properties = properties
        if p.Default != nil </span><span class="cov8" title="1">{
                sink.Default = &amp;v1.ParamValue{
                        Type: v1.ParamType(p.Default.Type), StringVal: p.Default.StringVal,
                        ArrayVal: p.Default.ArrayVal, ObjectVal: p.Default.ObjectVal,
                }
        }</span>
}

func (p *ParamSpec) convertFrom(ctx context.Context, source v1.ParamSpec) <span class="cov8" title="1">{
        p.Name = source.Name
        if source.Type != "" </span><span class="cov8" title="1">{
                p.Type = ParamType(source.Type)
        }</span> else<span class="cov8" title="1"> {
                p.Type = ParamTypeString
        }</span>
        <span class="cov8" title="1">p.Description = source.Description
        p.Enum = source.Enum
        var properties map[string]PropertySpec
        if source.Properties != nil </span><span class="cov8" title="1">{
                properties = make(map[string]PropertySpec)
        }</span>
        <span class="cov8" title="1">for k, v := range source.Properties </span><span class="cov8" title="1">{
                properties[k] = PropertySpec{Type: ParamType(v.Type)}
        }</span>
        <span class="cov8" title="1">p.Properties = properties
        if source.Default != nil </span><span class="cov8" title="1">{
                p.Default = &amp;ParamValue{
                        Type: ParamType(source.Default.Type), StringVal: source.Default.StringVal,
                        ArrayVal: source.Default.ArrayVal, ObjectVal: source.Default.ObjectVal,
                }
        }</span>
}

func (p Param) convertTo(ctx context.Context, sink *v1.Param) <span class="cov8" title="1">{
        sink.Name = p.Name
        newValue := v1.ParamValue{}
        p.Value.convertTo(ctx, &amp;newValue)
        sink.Value = newValue
}</span>

// ConvertFrom converts v1beta1 Param from v1 Param
func (p *Param) ConvertFrom(ctx context.Context, source v1.Param) <span class="cov8" title="1">{
        p.Name = source.Name
        newValue := ParamValue{}
        newValue.convertFrom(ctx, source.Value)
        p.Value = newValue
}</span>

func (v ParamValue) convertTo(ctx context.Context, sink *v1.ParamValue) <span class="cov8" title="1">{
        if v.Type != "" </span><span class="cov8" title="1">{
                sink.Type = v1.ParamType(v.Type)
        }</span> else<span class="cov8" title="1"> {
                sink.Type = v1.ParamType(ParamTypeString)
        }</span>
        <span class="cov8" title="1">sink.StringVal = v.StringVal
        sink.ArrayVal = v.ArrayVal
        sink.ObjectVal = v.ObjectVal</span>
}

func (v *ParamValue) convertFrom(ctx context.Context, source v1.ParamValue) <span class="cov8" title="1">{
        if source.Type != "" </span><span class="cov8" title="1">{
                v.Type = ParamType(source.Type)
        }</span> else<span class="cov8" title="1"> {
                v.Type = ParamTypeString
        }</span>
        <span class="cov8" title="1">v.StringVal = source.StringVal
        v.ArrayVal = source.ArrayVal
        v.ObjectVal = source.ObjectVal</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/substitution"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
)

// ParamsPrefix is the prefix used in $(...) expressions referring to parameters
const ParamsPrefix = "params"

// ParamSpec defines arbitrary parameters needed beyond typed inputs (such as
// resources). Parameter values are provided by users as inputs on a TaskRun
// or PipelineRun.
type ParamSpec struct {
        // Name declares the name by which a parameter is referenced.
        Name string `json:"name"`
        // Type is the user-specified type of the parameter. The possible types
        // are currently "string", "array" and "object", and "string" is the default.
        // +optional
        Type ParamType `json:"type,omitempty"`
        // Description is a user-facing description of the parameter that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Properties is the JSON Schema properties to support key-value pairs parameter.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`
        // Default is the value a parameter takes if no input value is supplied. If
        // default is set, a Task may be executed without a supplied value for the
        // parameter.
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Default *ParamValue `json:"default,omitempty"`
        // Enum declares a set of allowed param input values for tasks/pipelines that can be validated.
        // If Enum is not set, no input validation is performed for the param.
        // +optional
        Enum []string `json:"enum,omitempty"`
}

// ParamSpecs is a list of ParamSpec
// +listType=atomic
type ParamSpecs []ParamSpec

// PropertySpec defines the struct for object keys
type PropertySpec struct {
        Type ParamType `json:"type,omitempty"`
}

// SetDefaults set the default type
func (pp *ParamSpec) SetDefaults(context.Context) <span class="cov8" title="1">{
        if pp == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Propagate inferred type to the parent ParamSpec's type, and default type to the PropertySpec's type
        // The sequence to look at is type in ParamSpec -&gt; properties -&gt; type in default -&gt; array/string/object value in default
        // If neither `properties` or `default` section is provided, ParamTypeString will be the default type.
        <span class="cov8" title="1">switch </span>{
        case pp.Type != "":<span class="cov8" title="1">
                // If param type is provided by the author, do nothing but just set default type for PropertySpec in case `properties` section is provided.
                pp.setDefaultsForProperties()</span>
        case pp.Properties != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeObject
                // Also set default type for PropertySpec
                pp.setDefaultsForProperties()</span>
        case pp.Default == nil:<span class="cov8" title="1">
                // ParamTypeString is the default value (when no type can be inferred from the default value)
                pp.Type = ParamTypeString</span>
        case pp.Default.Type != "":<span class="cov8" title="1">
                pp.Type = pp.Default.Type</span>
        case pp.Default.ArrayVal != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeArray</span>
        case pp.Default.ObjectVal != nil:<span class="cov8" title="1">
                pp.Type = ParamTypeObject</span>
        default:<span class="cov8" title="1">
                pp.Type = ParamTypeString</span>
        }
}

// getNames returns all the names of the declared parameters
func (ps ParamSpecs) getNames() []string <span class="cov8" title="1">{
        var names []string
        for _, p := range ps </span><span class="cov8" title="1">{
                names = append(names, p.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// sortByType splits the input params into string params, array params, and object params, in that order
func (ps ParamSpecs) sortByType() (ParamSpecs, ParamSpecs, ParamSpecs) <span class="cov8" title="1">{
        var stringParams, arrayParams, objectParams ParamSpecs
        for _, p := range ps </span><span class="cov8" title="1">{
                switch p.Type </span>{
                case ParamTypeArray:<span class="cov8" title="1">
                        arrayParams = append(arrayParams, p)</span>
                case ParamTypeObject:<span class="cov8" title="1">
                        objectParams = append(objectParams, p)</span>
                case ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        stringParams = append(stringParams, p)</span>
                }
        }
        <span class="cov8" title="1">return stringParams, arrayParams, objectParams</span>
}

// validateNoDuplicateNames returns an error if any of the params have the same name
func (ps ParamSpecs) validateNoDuplicateNames() *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        names := ps.getNames()
        for dup := range findDups(names) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("parameter appears more than once", "").ViaFieldKey("params", dup))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateParamEnums validates feature flag, duplication and allowed types for Param Enum
func (ps ParamSpecs) validateParamEnums(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for _, p := range ps </span><span class="cov8" title="1">{
                if len(p.Enum) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                        errs = errs.Also(errs, apis.ErrGeneric(fmt.Sprintf("feature flag `%s` should be set to true to use Enum", config.EnableParamEnum), "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">if p.Type != ParamTypeString </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("enum can only be set with string type param", "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">for dup := range findDups(p.Enum) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("parameter enum value %v appears more than once", dup), "").ViaKey(p.Name))
                }</span>
                <span class="cov8" title="1">if p.Default != nil &amp;&amp; p.Default.StringVal != "" </span><span class="cov8" title="1">{
                        if !slices.Contains(p.Enum, p.Default.StringVal) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("param default value %v not in the enum list", p.Default.StringVal), "").ViaKey(p.Name))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// findDups returns the duplicate element in the given slice
func findDups(vals []string) sets.String <span class="cov8" title="1">{
        seen := sets.String{}
        dups := sets.String{}
        for _, val := range vals </span><span class="cov8" title="1">{
                if seen.Has(val) </span><span class="cov8" title="1">{
                        dups.Insert(val)
                }</span>
                <span class="cov8" title="1">seen.Insert(val)</span>
        }
        <span class="cov8" title="1">return dups</span>
}

// setDefaultsForProperties sets default type for PropertySpec (string) if it's not specified
func (pp *ParamSpec) setDefaultsForProperties() <span class="cov8" title="1">{
        for key, propertySpec := range pp.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type == "" </span><span class="cov8" title="1">{
                        pp.Properties[key] = PropertySpec{Type: ParamTypeString}
                }</span>
        }
}

// Param declares an ParamValues to use for the parameter called name.
type Param struct {
        Name string `json:"name"`
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ParamValue `json:"value"`
}

// Params is a list of Param
// +listType=atomic
type Params []Param

// ExtractNames returns a set of unique names
func (ps Params) ExtractNames() sets.String <span class="cov8" title="1">{
        names := sets.String{}
        for _, p := range ps </span><span class="cov8" title="1">{
                names.Insert(p.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

func (ps Params) extractValues() []string <span class="cov8" title="1">{
        pvs := []string{}
        for i := range ps </span><span class="cov8" title="1">{
                pvs = append(pvs, ps[i].Value.StringVal)
                pvs = append(pvs, ps[i].Value.ArrayVal...)
                for _, v := range ps[i].Value.ObjectVal </span><span class="cov8" title="1">{
                        pvs = append(pvs, v)
                }</span>
        }
        <span class="cov8" title="1">return pvs</span>
}

// extractParamMapArrVals creates a param map with the key: param.Name and
// val: param.Value.ArrayVal
func (ps Params) extractParamMapArrVals() map[string][]string <span class="cov8" title="1">{
        paramsMap := make(map[string][]string)
        for _, p := range ps </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.ArrayVal
        }</span>
        <span class="cov8" title="1">return paramsMap</span>
}

// ExtractParamArrayLengths extract and return the lengths of all array params
// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
func (ps Params) ExtractParamArrayLengths() map[string]int <span class="cov8" title="1">{
        // Collect all array params
        arrayParamsLengths := make(map[string]int)

        // Collect array params lengths from params
        for _, p := range ps </span><span class="cov8" title="1">{
                if p.Value.Type == ParamTypeArray </span><span class="cov8" title="1">{
                        arrayParamsLengths[p.Name] = len(p.Value.ArrayVal)
                }</span>
        }
        <span class="cov8" title="1">return arrayParamsLengths</span>
}

// validateDuplicateParameters checks if a parameter with the same name is defined more than once
func (ps Params) validateDuplicateParameters() (errs *apis.FieldError) <span class="cov8" title="1">{
        taskParamNames := sets.NewString()
        for i, param := range ps </span><span class="cov8" title="1">{
                if taskParamNames.Has(param.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("parameter names must be unique,"+
                                " the parameter \"%s\" is also defined at", param.Name), fmt.Sprintf("[%d].name", i)))
                }</span>
                <span class="cov8" title="1">taskParamNames.Insert(param.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ReplaceVariables applies string, array and object replacements to variables in Params
func (ps Params) ReplaceVariables(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) Params <span class="cov8" title="1">{
        params := ps.DeepCopy()
        for i := range params </span><span class="cov8" title="1">{
                params[i].Value.ApplyReplacements(stringReplacements, arrayReplacements, objectReplacements)
        }</span>
        <span class="cov8" title="1">return params</span>
}

// ExtractDefaultParamArrayLengths extract and return the lengths of all array param defaults
// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
func (ps ParamSpecs) ExtractDefaultParamArrayLengths() map[string]int <span class="cov8" title="1">{
        // Collect all array params
        arrayParamsLengths := make(map[string]int)

        // Collect array params lengths from defaults
        for _, p := range ps </span><span class="cov8" title="1">{
                if p.Default != nil </span><span class="cov8" title="1">{
                        if p.Default.Type == ParamTypeArray </span><span class="cov8" title="1">{
                                arrayParamsLengths[p.Name] = len(p.Default.ArrayVal)
                        }</span>
                }
        }
        <span class="cov8" title="1">return arrayParamsLengths</span>
}

// extractArrayIndexingParamRefs takes a string of the form `foo-$(params.array-param[1])-bar` and extracts the portions of the string that reference an element in an array param.
// For example, for the string foo-$(params.array-param[1])-bar-$(params.other-array-param[2])-$(params.string-param)`,
// it would return ["$(params.array-param[1])", "$(params.other-array-param[2])"].
func extractArrayIndexingParamRefs(paramReference string) []string <span class="cov8" title="1">{
        l := []string{}
        list := substitution.ExtractArrayIndexingParamsExpressions(paramReference)
        for _, val := range list </span><span class="cov8" title="1">{
                indexString := substitution.ExtractIndexString(val)
                if indexString != "" </span><span class="cov8" title="1">{
                        l = append(l, val)
                }</span>
        }
        <span class="cov8" title="1">return l</span>
}

// extractParamRefsFromSteps get all array indexing references from steps
func extractParamRefsFromSteps(steps []Step) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for _, step := range steps </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, step.Script)
                container := step.ToK8sContainer()
                paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromStepTemplate get all array indexing references from StepsTemplate
func extractParamRefsFromStepTemplate(stepTemplate *StepTemplate) []string <span class="cov8" title="1">{
        if stepTemplate == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">container := stepTemplate.ToK8sContainer()
        return extractParamRefsFromContainer(container)</span>
}

// extractParamRefsFromSidecars get all array indexing references from sidecars
func extractParamRefsFromSidecars(sidecars []Sidecar) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for _, s := range sidecars </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, s.Script)
                container := s.ToK8sContainer()
                paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromVolumes get all array indexing references from volumes
func extractParamRefsFromVolumes(volumes []corev1.Volume) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        for i, v := range volumes </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.Name)
                if v.VolumeSource.ConfigMap != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.ConfigMap.Name)
                        for _, item := range v.ConfigMap.Items </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, item.Key)
                                paramsRefs = append(paramsRefs, item.Path)
                        }</span>
                }
                <span class="cov8" title="1">if v.VolumeSource.Secret != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.Secret.SecretName)
                        for _, item := range v.Secret.Items </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, item.Key)
                                paramsRefs = append(paramsRefs, item.Path)
                        }</span>
                }
                <span class="cov8" title="1">if v.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, v.PersistentVolumeClaim.ClaimName)
                }</span>
                <span class="cov8" title="1">if v.Projected != nil </span><span class="cov8" title="1">{
                        for _, s := range volumes[i].Projected.Sources </span><span class="cov8" title="1">{
                                if s.ConfigMap != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.ConfigMap.Name)
                                }</span>
                                <span class="cov8" title="1">if s.Secret != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.Secret.Name)
                                }</span>
                                <span class="cov8" title="1">if s.ServiceAccountToken != nil </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, s.ServiceAccountToken.Audience)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if v.CSI != nil </span><span class="cov8" title="1">{
                        if v.CSI.NodePublishSecretRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, v.CSI.NodePublishSecretRef.Name)
                        }</span>
                        <span class="cov8" title="1">if v.CSI.VolumeAttributes != nil </span><span class="cov8" title="1">{
                                for _, value := range v.CSI.VolumeAttributes </span><span class="cov8" title="1">{
                                        paramsRefs = append(paramsRefs, value)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return paramsRefs</span>
}

// extractParamRefsFromContainer get all array indexing references from container
func extractParamRefsFromContainer(c *corev1.Container) []string <span class="cov8" title="1">{
        paramsRefs := []string{}
        paramsRefs = append(paramsRefs, c.Name)
        paramsRefs = append(paramsRefs, c.Image)
        paramsRefs = append(paramsRefs, string(c.ImagePullPolicy))
        paramsRefs = append(paramsRefs, c.Args...)

        for ie, e := range c.Env </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, e.Value)
                if c.Env[ie].ValueFrom != nil </span><span class="cov8" title="1">{
                        if e.ValueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.LocalObjectReference.Name)
                                paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.Key)
                        }</span>
                        <span class="cov8" title="1">if e.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                                paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name)
                                paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.Key)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, e := range c.EnvFrom </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, e.Prefix)
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, e.ConfigMapRef.LocalObjectReference.Name)
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, e.SecretRef.LocalObjectReference.Name)
                }</span>
        }

        <span class="cov8" title="1">paramsRefs = append(paramsRefs, c.WorkingDir)
        paramsRefs = append(paramsRefs, c.Command...)

        for _, v := range c.VolumeMounts </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.Name)
                paramsRefs = append(paramsRefs, v.MountPath)
                paramsRefs = append(paramsRefs, v.SubPath)
        }</span>
        <span class="cov8" title="1">return paramsRefs</span>
}

// ParamType indicates the type of an input parameter;
// Used to distinguish between a single string and an array of strings.
type ParamType string

// Valid ParamTypes:
const (
        ParamTypeString ParamType = "string"
        ParamTypeArray  ParamType = "array"
        ParamTypeObject ParamType = "object"
)

// AllParamTypes can be used for ParamType validation.
var AllParamTypes = []ParamType{ParamTypeString, ParamTypeArray, ParamTypeObject}

// ParamValues is modeled after IntOrString in kubernetes/apimachinery:

// ParamValue is a type that can hold a single string or string array.
// Used in JSON unmarshalling so that a single JSON field can accept
// either an individual string or an array of strings.
type ParamValue struct {
        Type      ParamType // Represents the stored type of ParamValues.
        StringVal string
        // +listType=atomic
        ArrayVal  []string
        ObjectVal map[string]string
}

// ArrayOrString is deprecated, this is to keep backward compatibility
//
// Deprecated: Use ParamValue instead.
type ArrayOrString = ParamValue

// UnmarshalJSON implements the json.Unmarshaller interface.
func (paramValues *ParamValue) UnmarshalJSON(value []byte) error <span class="cov8" title="1">{
        // ParamValues is used for Results Value as well, the results can be any kind of
        // data so we need to check if it is empty.
        if len(value) == 0 </span><span class="cov8" title="1">{
                paramValues.Type = ParamTypeString
                return nil
        }</span>
        <span class="cov8" title="1">if value[0] == '[' </span><span class="cov8" title="1">{
                // We're trying to Unmarshal to []string, but for cases like []int or other types
                // of nested array which we don't support yet, we should continue and Unmarshal
                // it to String. If the Type being set doesn't match what it actually should be,
                // it will be captured by validation in reconciler.
                // if failed to unmarshal to array, we will convert the value to string and marshal it to string
                var a []string
                if err := json.Unmarshal(value, &amp;a); err == nil </span><span class="cov8" title="1">{
                        paramValues.Type = ParamTypeArray
                        paramValues.ArrayVal = a
                        return nil
                }</span>
        }
        <span class="cov8" title="1">if value[0] == '{' </span><span class="cov8" title="1">{
                // if failed to unmarshal to map, we will convert the value to string and marshal it to string
                var m map[string]string
                if err := json.Unmarshal(value, &amp;m); err == nil </span><span class="cov8" title="1">{
                        paramValues.Type = ParamTypeObject
                        paramValues.ObjectVal = m
                        return nil
                }</span>
        }

        // By default we unmarshal to string
        <span class="cov8" title="1">paramValues.Type = ParamTypeString
        if err := json.Unmarshal(value, &amp;paramValues.StringVal); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">paramValues.StringVal = string(value)

        return nil</span>
}

// MarshalJSON implements the json.Marshaller interface.
func (paramValues ParamValue) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        switch paramValues.Type </span>{
        case ParamTypeString:<span class="cov8" title="1">
                return json.Marshal(paramValues.StringVal)</span>
        case ParamTypeArray:<span class="cov8" title="1">
                return json.Marshal(paramValues.ArrayVal)</span>
        case ParamTypeObject:<span class="cov8" title="1">
                return json.Marshal(paramValues.ObjectVal)</span>
        default:<span class="cov0" title="0">
                return []byte{}, fmt.Errorf("impossible ParamValues.Type: %q", paramValues.Type)</span>
        }
}

// ApplyReplacements applyes replacements for ParamValues type
func (paramValues *ParamValue) ApplyReplacements(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) <span class="cov8" title="1">{
        switch paramValues.Type </span>{
        case ParamTypeArray:<span class="cov8" title="1">
                newArrayVal := []string{}
                for _, v := range paramValues.ArrayVal </span><span class="cov8" title="1">{
                        newArrayVal = append(newArrayVal, substitution.ApplyArrayReplacements(v, stringReplacements, arrayReplacements)...)
                }</span>
                <span class="cov8" title="1">paramValues.ArrayVal = newArrayVal</span>
        case ParamTypeObject:<span class="cov8" title="1">
                newObjectVal := map[string]string{}
                for k, v := range paramValues.ObjectVal </span><span class="cov8" title="1">{
                        newObjectVal[k] = substitution.ApplyReplacements(v, stringReplacements)
                }</span>
                <span class="cov8" title="1">paramValues.ObjectVal = newObjectVal</span>
        case ParamTypeString:<span class="cov8" title="1">
                fallthrough</span>
        default:<span class="cov8" title="1">
                paramValues.applyOrCorrect(stringReplacements, arrayReplacements, objectReplacements)</span>
        }
}

// applyOrCorrect deals with string param whose value can be string literal or a reference to a string/array/object param/result.
// If the value of paramValues is a reference to array or object, the type will be corrected from string to array/object.
func (paramValues *ParamValue) applyOrCorrect(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) <span class="cov8" title="1">{
        stringVal := paramValues.StringVal

        // if the stringVal is a string literal or a string that mixed with var references
        // just do the normal string replacement
        if !exactVariableSubstitutionRegex.MatchString(stringVal) </span><span class="cov8" title="1">{
                paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
                return
        }</span>

        // trim the head "$(" and the tail ")" or "[*])"
        // i.e. get "params.name" from "$(params.name)" or "$(params.name[*])"
        <span class="cov8" title="1">trimedStringVal := substitution.StripStarVarSubExpression(stringVal)

        // if the stringVal is a reference to a string param
        if _, ok := stringReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
        }</span>

        // if the stringVal is a reference to an array param, we need to change the type other than apply replacement
        <span class="cov8" title="1">if _, ok := arrayReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = ""
                paramValues.ArrayVal = substitution.ApplyArrayReplacements(stringVal, stringReplacements, arrayReplacements)
                paramValues.Type = ParamTypeArray
        }</span>

        // if the stringVal is a reference an object param, we need to change the type other than apply replacement
        <span class="cov8" title="1">if _, ok := objectReplacements[trimedStringVal]; ok </span><span class="cov8" title="1">{
                paramValues.StringVal = ""
                paramValues.ObjectVal = objectReplacements[trimedStringVal]
                paramValues.Type = ParamTypeObject
        }</span>
}

// NewStructuredValues creates an ParamValues of type ParamTypeString or ParamTypeArray, based on
// how many inputs are given (&gt;1 input will create an array, not string).
func NewStructuredValues(value string, values ...string) *ParamValue <span class="cov8" title="1">{
        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;ParamValue{
                        Type:     ParamTypeArray,
                        ArrayVal: append([]string{value}, values...),
                }
        }</span>
        <span class="cov8" title="1">return &amp;ParamValue{
                Type:      ParamTypeString,
                StringVal: value,
        }</span>
}

// NewArrayOrString is the deprecated, this is to keep backward compatibility
var NewArrayOrString = NewStructuredValues

// NewObject creates an ParamValues of type ParamTypeObject using the provided key-value pairs
func NewObject(pairs map[string]string) *ParamValue <span class="cov8" title="1">{
        return &amp;ParamValue{
                Type:      ParamTypeObject,
                ObjectVal: pairs,
        }
}</span>

// ArrayReference returns the name of the parameter from array parameter reference
// returns arrayParam from $(params.arrayParam[*])
func ArrayReference(a string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimPrefix(a, "$("+ParamsPrefix+"."), "[*])")
}</span>

// validatePipelineParametersVariablesInTaskParameters validates param value that
// may contain the reference(s) to other params to make sure those references are used appropriately.
func validatePipelineParametersVariablesInTaskParameters(params Params, prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(params.validateDuplicateParameters()).ViaField("params")
        for _, param := range params </span><span class="cov8" title="1">{
                switch param.Value.Type </span>{
                case ParamTypeArray:<span class="cov8" title="1">
                        for idx, arrayElement := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                errs = errs.Also(validateArrayVariable(arrayElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("value", idx).ViaFieldKey("params", param.Name))
                        }</span>
                case ParamTypeObject:<span class="cov8" title="1">
                        for key, val := range param.Value.ObjectVal </span><span class="cov8" title="1">{
                                errs = errs.Also(validateStringVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldKey("properties", key).ViaFieldKey("params", param.Name))
                        }</span>
                case ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(validateParamStringValue(param, prefix, paramNames, arrayParamNames, objectParamNameKeys))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// validateParamStringValue validates the param value field of string type
// that may contain references to other isolated array/object params other than string param.
func validateParamStringValue(param Param, prefix string, paramNames sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        stringValue := param.Value.StringVal

        // if the provided param value is an isolated reference to the whole array/object, we just check if the param name exists.
        isIsolated, errs := substitution.ValidateWholeArrayOrObjectRefInStringVariable(param.Name, stringValue, prefix, paramNames)
        if isIsolated </span><span class="cov0" title="0">{
                return errs
        }</span>

        // if the provided param value is string literal and/or contains multiple variables
        // valid example: "$(params.myString) and another $(params.myObject.key1)"
        // invalid example: "$(params.myString) and another $(params.myObject[*])"
        <span class="cov8" title="1">return validateStringVariable(stringValue, prefix, paramNames, arrayVars, objectParamNameKeys).ViaFieldKey("params", param.Name)</span>
}

// validateStringVariable validates the normal string fields that can only accept references to string param or individual keys of object param
func validateStringVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
        errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
        return errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(value, prefix, arrayVars))
}</span>

func validateArrayVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
        errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
        return errs.Also(substitution.ValidateVariableReferenceIsIsolated(value, prefix, arrayVars))
}</span>

func validateObjectVariable(value, prefix string, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectNames := sets.NewString()
        for objectParamName, keys := range objectParamNameKeys </span><span class="cov8" title="1">{
                objectNames.Insert(objectParamName)
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(value, fmt.Sprintf("%s\\.%s", prefix, objectParamName), sets.NewString(keys...)))
        }</span>

        <span class="cov8" title="1">return errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(value, prefix, objectNames))</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/version"
        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*Pipeline)(nil)

// ConvertTo implements apis.Convertible
func (p *Pipeline) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := to.(type) </span>{
        case *v1.Pipeline:<span class="cov8" title="1">
                sink.ObjectMeta = p.ObjectMeta
                if err := serializePipelineResources(&amp;sink.ObjectMeta, &amp;p.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return p.Spec.ConvertTo(ctx, &amp;sink.Spec, &amp;sink.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo implements apis.Convertible
func (ps *PipelineSpec) ConvertTo(ctx context.Context, sink *v1.PipelineSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        sink.DisplayName = ps.DisplayName
        sink.Description = ps.Description
        sink.Tasks = nil
        for _, t := range ps.Tasks </span><span class="cov8" title="1">{
                new := v1.PipelineTask{}
                err := t.convertTo(ctx, &amp;new, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sink.Tasks = append(sink.Tasks, new)</span>
        }
        <span class="cov8" title="1">sink.Params = nil
        for _, p := range ps.Params </span><span class="cov8" title="1">{
                new := v1.ParamSpec{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.Workspaces = nil
        for _, w := range ps.Workspaces </span><span class="cov8" title="1">{
                new := v1.PipelineWorkspaceDeclaration{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
        <span class="cov8" title="1">sink.Results = nil
        for _, r := range ps.Results </span><span class="cov8" title="1">{
                new := v1.PipelineResult{}
                r.convertTo(ctx, &amp;new)
                sink.Results = append(sink.Results, new)
        }</span>
        <span class="cov8" title="1">sink.Finally = nil
        for _, f := range ps.Finally </span><span class="cov8" title="1">{
                new := v1.PipelineTask{}
                err := f.convertTo(ctx, &amp;new, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sink.Finally = append(sink.Finally, new)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom implements apis.Convertible
func (p *Pipeline) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        switch source := from.(type) </span>{
        case *v1.Pipeline:<span class="cov8" title="1">
                p.ObjectMeta = source.ObjectMeta
                if err := deserializePipelineResources(&amp;p.ObjectMeta, &amp;p.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return p.Spec.ConvertFrom(ctx, &amp;source.Spec, &amp;p.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", p)</span>
        }
}

// ConvertFrom implements apis.Convertible
func (ps *PipelineSpec) ConvertFrom(ctx context.Context, source *v1.PipelineSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        ps.DisplayName = source.DisplayName
        ps.Description = source.Description
        ps.Tasks = nil
        for _, t := range source.Tasks </span><span class="cov8" title="1">{
                new := PipelineTask{}
                err := new.convertFrom(ctx, t, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ps.Tasks = append(ps.Tasks, new)</span>
        }
        <span class="cov8" title="1">ps.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := ParamSpec{}
                new.convertFrom(ctx, p)
                ps.Params = append(ps.Params, new)
        }</span>
        <span class="cov8" title="1">ps.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := PipelineWorkspaceDeclaration{}
                new.convertFrom(ctx, w)
                ps.Workspaces = append(ps.Workspaces, new)
        }</span>
        <span class="cov8" title="1">ps.Results = nil
        for _, r := range source.Results </span><span class="cov8" title="1">{
                new := PipelineResult{}
                new.convertFrom(ctx, r)
                ps.Results = append(ps.Results, new)
        }</span>
        <span class="cov8" title="1">ps.Finally = nil
        for _, f := range source.Finally </span><span class="cov8" title="1">{
                new := PipelineTask{}
                err := new.convertFrom(ctx, f, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ps.Finally = append(ps.Finally, new)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (pt PipelineTask) convertTo(ctx context.Context, sink *v1.PipelineTask, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        sink.Name = pt.Name
        sink.DisplayName = pt.DisplayName
        sink.Description = pt.Description
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                sink.TaskRef = &amp;v1.TaskRef{}
                pt.TaskRef.convertTo(ctx, sink.TaskRef)
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                sink.TaskSpec = &amp;v1.EmbeddedTask{}
                err := pt.TaskSpec.convertTo(ctx, sink.TaskSpec, meta, pt.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">sink.When = nil
        for _, we := range pt.WhenExpressions </span><span class="cov8" title="1">{
                new := v1.WhenExpression{}
                we.convertTo(ctx, &amp;new)
                sink.When = append(sink.When, new)
        }</span>
        <span class="cov8" title="1">sink.OnError = (v1.PipelineTaskOnErrorType)(pt.OnError)
        sink.Retries = pt.Retries
        sink.RunAfter = pt.RunAfter
        sink.Params = nil
        for _, p := range pt.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.Matrix = nil
        if pt.IsMatrixed() </span><span class="cov8" title="1">{
                new := v1.Matrix{}
                pt.Matrix.convertTo(ctx, &amp;new)
                sink.Matrix = &amp;new
        }</span>
        <span class="cov8" title="1">sink.Workspaces = nil
        for _, w := range pt.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspacePipelineTaskBinding{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>

        <span class="cov8" title="1">sink.Timeout = pt.Timeout
        return nil</span>
}

func (pt *PipelineTask) convertFrom(ctx context.Context, source v1.PipelineTask, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        pt.Name = source.Name
        pt.DisplayName = source.DisplayName
        pt.Description = source.Description
        if source.TaskRef != nil </span><span class="cov8" title="1">{
                newTaskRef := TaskRef{}
                newTaskRef.ConvertFrom(ctx, *source.TaskRef)
                pt.TaskRef = &amp;newTaskRef
        }</span>
        <span class="cov8" title="1">if source.TaskSpec != nil </span><span class="cov8" title="1">{
                newTaskSpec := EmbeddedTask{}
                err := newTaskSpec.convertFrom(ctx, *source.TaskSpec, meta, pt.Name)
                pt.TaskSpec = &amp;newTaskSpec
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">pt.WhenExpressions = nil
        for _, we := range source.When </span><span class="cov8" title="1">{
                new := WhenExpression{}
                new.convertFrom(ctx, we)
                pt.WhenExpressions = append(pt.WhenExpressions, new)
        }</span>
        <span class="cov8" title="1">pt.OnError = (PipelineTaskOnErrorType)(source.OnError)
        pt.Retries = source.Retries
        pt.RunAfter = source.RunAfter
        pt.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, p)
                pt.Params = append(pt.Params, new)
        }</span>
        <span class="cov8" title="1">pt.Matrix = nil
        if source.IsMatrixed() </span><span class="cov8" title="1">{
                new := Matrix{}
                new.convertFrom(ctx, *source.Matrix)
                pt.Matrix = &amp;new
        }</span>
        <span class="cov8" title="1">pt.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspacePipelineTaskBinding{}
                new.convertFrom(ctx, w)
                pt.Workspaces = append(pt.Workspaces, new)
        }</span>

        <span class="cov8" title="1">pt.Timeout = source.Timeout
        return nil</span>
}

func (et EmbeddedTask) convertTo(ctx context.Context, sink *v1.EmbeddedTask, meta *metav1.ObjectMeta, taskName string) error <span class="cov8" title="1">{
        sink.TypeMeta = et.TypeMeta
        sink.Spec = et.Spec
        sink.Metadata = v1.PipelineTaskMetadata(et.Metadata)
        sink.TaskSpec = v1.TaskSpec{}
        return et.TaskSpec.ConvertTo(ctx, &amp;sink.TaskSpec, meta, taskName)
}</span>

func (et *EmbeddedTask) convertFrom(ctx context.Context, source v1.EmbeddedTask, meta *metav1.ObjectMeta, taskName string) error <span class="cov8" title="1">{
        et.TypeMeta = source.TypeMeta
        et.Spec = source.Spec
        et.Metadata = PipelineTaskMetadata(source.Metadata)
        et.TaskSpec = TaskSpec{}
        return et.TaskSpec.ConvertFrom(ctx, &amp;source.TaskSpec, meta, taskName)
}</span>

func (we WhenExpression) convertTo(ctx context.Context, sink *v1.WhenExpression) <span class="cov8" title="1">{
        sink.Input = we.Input
        sink.Operator = we.Operator
        sink.Values = we.Values
        sink.CEL = we.CEL
}</span>

func (we *WhenExpression) convertFrom(ctx context.Context, source v1.WhenExpression) <span class="cov8" title="1">{
        we.Input = source.Input
        we.Operator = source.Operator
        we.Values = source.Values
        we.CEL = source.CEL
}</span>

func (m *Matrix) convertTo(ctx context.Context, sink *v1.Matrix) <span class="cov8" title="1">{
        for _, param := range m.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                param.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">for i, include := range m.Include </span><span class="cov8" title="1">{
                sink.Include = append(sink.Include, v1.IncludeParams{Name: include.Name})
                for _, param := range include.Params </span><span class="cov8" title="1">{
                        newIncludeParam := v1.Param{}
                        param.convertTo(ctx, &amp;newIncludeParam)
                        sink.Include[i].Params = append(sink.Include[i].Params, newIncludeParam)
                }</span>
        }
}

func (m *Matrix) convertFrom(ctx context.Context, source v1.Matrix) <span class="cov8" title="1">{
        for _, param := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, param)
                m.Params = append(m.Params, new)
        }</span>

        <span class="cov8" title="1">for i, include := range source.Include </span><span class="cov8" title="1">{
                m.Include = append(m.Include, IncludeParams{Name: include.Name})
                for _, p := range include.Params </span><span class="cov8" title="1">{
                        new := Param{}
                        new.ConvertFrom(ctx, p)
                        m.Include[i].Params = append(m.Include[i].Params, new)
                }</span>
        }
}

func (pr PipelineResult) convertTo(ctx context.Context, sink *v1.PipelineResult) <span class="cov8" title="1">{
        sink.Name = pr.Name
        sink.Type = v1.ResultsType(pr.Type)
        sink.Description = pr.Description
        newValue := v1.ParamValue{}
        pr.Value.convertTo(ctx, &amp;newValue)
        sink.Value = newValue
}</span>

func (pr *PipelineResult) convertFrom(ctx context.Context, source v1.PipelineResult) <span class="cov8" title="1">{
        pr.Name = source.Name
        pr.Type = ResultsType(source.Type)
        pr.Description = source.Description
        newValue := ParamValue{}
        newValue.convertFrom(ctx, source.Value)
        pr.Value = newValue
}</span>

func (ptm PipelineTaskMetadata) convertTo(ctx context.Context, sink *v1.PipelineTaskMetadata) <span class="cov8" title="1">{
        sink.Labels = ptm.Labels
        sink.Annotations = ptm.Annotations
}</span>

func (ptm *PipelineTaskMetadata) convertFrom(ctx context.Context, source v1.PipelineTaskMetadata) <span class="cov8" title="1">{
        ptm.Labels = source.Labels
        ptm.Annotations = source.Labels
}</span>

func serializePipelineResources(meta *metav1.ObjectMeta, spec *PipelineSpec) error <span class="cov8" title="1">{
        if spec.Resources == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, spec.Resources, resourcesAnnotationKey)</span>
}

func deserializePipelineResources(meta *metav1.ObjectMeta, spec *PipelineSpec) error <span class="cov8" title="1">{
        resources := &amp;[]PipelineDeclaredResource{}
        err := version.DeserializeFromMetadata(meta, resources, resourcesAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(*resources) != 0 </span><span class="cov8" title="1">{
                spec.Resources = *resources
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*Pipeline)(nil)

// SetDefaults sets default values on the Pipeline's Spec
func (p *Pipeline) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        p.Spec.SetDefaults(ctx)
}</span>

// SetDefaults sets default values for the PipelineSpec's Params, Tasks, and Finally
func (ps *PipelineSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        for i := range ps.Params </span><span class="cov8" title="1">{
                ps.Params[i].SetDefaults(ctx)
        }</span>

        <span class="cov8" title="1">for _, pt := range ps.Tasks </span><span class="cov8" title="1">{
                pt.SetDefaults(ctx)
        }</span>

        <span class="cov8" title="1">for _, ft := range ps.Finally </span><span class="cov8" title="1">{
                ctx := ctx // Ensure local scoping per Task
                ft.SetDefaults(ctx)
        }</span>
}

// SetDefaults sets default values for a PipelineTask
func (pt *PipelineTask) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                if pt.TaskRef.Name == "" &amp;&amp; pt.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        pt.TaskRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
                }</span>
                <span class="cov8" title="1">if pt.TaskRef.Kind == "" &amp;&amp; pt.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        pt.TaskRef.Kind = NamespacedTaskKind
                }</span>
        }
        <span class="cov8" title="1">if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                pt.TaskSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/kmeta"
)

// PipelineTaskOnErrorType defines a list of supported failure handling behaviors of a PipelineTask on error
type PipelineTaskOnErrorType string

const (
        // PipelineTasksAggregateStatus is a param representing aggregate status of all dag pipelineTasks
        PipelineTasksAggregateStatus = "tasks.status"
        // PipelineTasks is a value representing a task is a member of "tasks" section of the pipeline
        PipelineTasks = "tasks"
        // PipelineFinallyTasks is a value representing a task is a member of "finally" section of the pipeline
        PipelineFinallyTasks = "finally"
        // PipelineTaskStopAndFail indicates to stop and fail the PipelineRun if the PipelineTask fails
        PipelineTaskStopAndFail PipelineTaskOnErrorType = "stopAndFail"
        // PipelineTaskContinue indicates to continue executing the rest of the DAG when the PipelineTask fails
        PipelineTaskContinue PipelineTaskOnErrorType = "continue"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// Pipeline describes a list of Tasks to execute. It expresses how outputs
// of tasks feed into inputs of subsequent tasks.
//
// Deprecated: Please use v1.Pipeline instead.
type Pipeline struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the Pipeline from the client
        // +optional
        Spec PipelineSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*Pipeline)(nil)

// PipelineMetadata returns the Pipeline's ObjectMeta, implementing PipelineObject
func (p *Pipeline) PipelineMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return p.ObjectMeta
}</span>

// PipelineSpec returns the Pipeline's Spec, implementing PipelineObject
func (p *Pipeline) PipelineSpec() PipelineSpec <span class="cov0" title="0">{
        return p.Spec
}</span>

// Copy returns a deep copy of the Pipeline, implementing PipelineObject
func (p *Pipeline) Copy() PipelineObject <span class="cov0" title="0">{
        return p.DeepCopy()
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*Pipeline) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.PipelineControllerName)
}</span>

// Checksum computes the sha256 checksum of the task object.
// Prior to computing the checksum, it performs some preprocessing on the
// metadata of the object where it removes system provided annotations.
// Only the name, namespace, generateName, user-provided labels and annotations
// and the pipelineSpec are included for the checksum computation.
func (p *Pipeline) Checksum() ([]byte, error) <span class="cov8" title="1">{
        objectMeta := checksum.PrepareObjectMeta(p)
        preprocessedPipeline := Pipeline{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1beta1",
                        Kind:       "Pipeline"},
                ObjectMeta: objectMeta,
                Spec:       p.Spec,
        }
        sha256Checksum, err := checksum.ComputeSha256Checksum(preprocessedPipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sha256Checksum, nil</span>
}

// PipelineSpec defines the desired state of Pipeline.
type PipelineSpec struct {
        // DisplayName is a user-facing name of the pipeline that may be
        // used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`
        // Description is a user-facing description of the pipeline that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Deprecated: Unused, preserved only for backwards compatibility
        // +listType=atomic
        Resources []PipelineDeclaredResource `json:"resources,omitempty"`
        // Tasks declares the graph of Tasks that execute when this Pipeline is run.
        // +listType=atomic
        Tasks []PipelineTask `json:"tasks,omitempty"`
        // Params declares a list of input parameters that must be supplied when
        // this Pipeline is run.
        Params ParamSpecs `json:"params,omitempty"`
        // Workspaces declares a set of named workspaces that are expected to be
        // provided by a PipelineRun.
        // +optional
        // +listType=atomic
        Workspaces []PipelineWorkspaceDeclaration `json:"workspaces,omitempty"`
        // Results are values that this pipeline can output once run
        // +optional
        // +listType=atomic
        Results []PipelineResult `json:"results,omitempty"`
        // Finally declares the list of Tasks that execute just before leaving the Pipeline
        // i.e. either after all Tasks are finished executing successfully
        // or after a failure which would result in ending the Pipeline
        // +listType=atomic
        Finally []PipelineTask `json:"finally,omitempty"`
}

// PipelineResult used to describe the results of a pipeline
type PipelineResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result.
        // The possible types are 'string', 'array', and 'object', with 'string' as the default.
        // 'array' and 'object' types are alpha features.
        Type ResultsType `json:"type,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description"`

        // Value the expression used to retrieve the value
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// PipelineTaskMetadata contains the labels or annotations for an EmbeddedTask
type PipelineTaskMetadata struct {
        // +optional
        Labels map[string]string `json:"labels,omitempty"`

        // +optional
        Annotations map[string]string `json:"annotations,omitempty"`
}

// EmbeddedTask is used to define a Task inline within a Pipeline's PipelineTasks.
type EmbeddedTask struct {
        // +optional
        runtime.TypeMeta `json:",inline,omitempty"`

        // Spec is a specification of a custom task
        // +optional
        Spec runtime.RawExtension `json:"spec,omitempty"`

        // +optional
        Metadata PipelineTaskMetadata `json:"metadata,omitempty"`

        // TaskSpec is a specification of a task
        // +optional
        TaskSpec `json:",inline,omitempty"`
}

// PipelineTask defines a task in a Pipeline, passing inputs from both
// Params and from the output of previous tasks.
type PipelineTask struct {
        // Name is the name of this task within the context of a Pipeline. Name is
        // used as a coordinate with the `from` and `runAfter` fields to establish
        // the execution order of tasks relative to one another.
        Name string `json:"name,omitempty"`

        // DisplayName is the display name of this task within the context of a Pipeline.
        // This display name may be used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`

        // Description is the description of this task within the context of a Pipeline.
        // This description may be used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`

        // TaskRef is a reference to a task definition.
        // +optional
        TaskRef *TaskRef `json:"taskRef,omitempty"`

        // TaskSpec is a specification of a task
        // Specifying TaskSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Task.spec (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        TaskSpec *EmbeddedTask `json:"taskSpec,omitempty"`

        // WhenExpressions is a list of when expressions that need to be true for the task to run
        // +optional
        WhenExpressions WhenExpressions `json:"when,omitempty"`

        // Retries represents how many times this task should be retried in case of task failure: ConditionSucceeded set to False
        // +optional
        Retries int `json:"retries,omitempty"`

        // RunAfter is the list of PipelineTask names that should be executed before
        // this Task executes. (Used to force a specific ordering in graph execution.)
        // +optional
        // +listType=atomic
        RunAfter []string `json:"runAfter,omitempty"`

        // Deprecated: Unused, preserved only for backwards compatibility
        // +optional
        Resources *PipelineTaskResources `json:"resources,omitempty"`

        // Parameters declares parameters passed to this task.
        // +optional
        Params Params `json:"params,omitempty"`

        // Matrix declares parameters used to fan out this task.
        // +optional
        Matrix *Matrix `json:"matrix,omitempty"`

        // Workspaces maps workspaces from the pipeline spec to the workspaces
        // declared in the Task.
        // +optional
        // +listType=atomic
        Workspaces []WorkspacePipelineTaskBinding `json:"workspaces,omitempty"`

        // Duration after which the TaskRun times out. Defaults to 1 hour.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`

        // PipelineRef is a reference to a pipeline definition
        // Note: PipelineRef is in preview mode and not yet supported
        // +optional
        PipelineRef *PipelineRef `json:"pipelineRef,omitempty"`

        // PipelineSpec is a specification of a pipeline
        // Note: PipelineSpec is in preview mode and not yet supported
        // Specifying PipelineSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Pipeline.spec (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`

        // OnError defines the exiting behavior of a PipelineRun on error
        // can be set to [ continue | stopAndFail ]
        // +optional
        OnError PipelineTaskOnErrorType `json:"onError,omitempty"`
}

// IsCustomTask checks whether an embedded TaskSpec is a Custom Task
func (et *EmbeddedTask) IsCustomTask() bool <span class="cov8" title="1">{
        // Note that if `apiVersion` is set to `"tekton.dev/v1beta1"` and `kind` is set to `"Task"`,
        // the reference will be considered a Custom Task - https://github.com/tektoncd/pipeline/issues/6457
        return et != nil &amp;&amp; et.APIVersion != "" &amp;&amp; et.Kind != ""
}</span>

// IsMatrixed return whether pipeline task is matrixed
func (pt *PipelineTask) IsMatrixed() bool <span class="cov8" title="1">{
        return pt.Matrix.HasParams() || pt.Matrix.HasInclude()
}</span>

// TaskSpecMetadata returns the metadata of the PipelineTask's EmbeddedTask spec.
func (pt *PipelineTask) TaskSpecMetadata() PipelineTaskMetadata <span class="cov0" title="0">{
        return pt.TaskSpec.Metadata
}</span>

// HashKey is the name of the PipelineTask, and is used as the key for this PipelineTask in the DAG
func (pt PipelineTask) HashKey() string <span class="cov8" title="1">{
        return pt.Name
}</span>

// Deps returns all other PipelineTask dependencies of this PipelineTask, based on resource usage or ordering
func (pt PipelineTask) Deps() []string <span class="cov8" title="1">{
        // hold the list of dependencies in a set to avoid duplicates
        deps := sets.NewString()

        // add any new dependents from result references - resource dependency
        for _, ref := range PipelineTaskResultRefs(&amp;pt) </span><span class="cov8" title="1">{
                deps.Insert(ref.PipelineTask)
        }</span>

        // add any new dependents from runAfter - order dependency
        <span class="cov8" title="1">for _, runAfter := range pt.RunAfter </span><span class="cov8" title="1">{
                deps.Insert(runAfter)
        }</span>

        <span class="cov8" title="1">return deps.List()</span>
}

// PipelineTaskList is a list of PipelineTasks
type PipelineTaskList []PipelineTask

// Deps returns a map with key as name of a pipelineTask and value as a list of its dependencies
func (l PipelineTaskList) Deps() map[string][]string <span class="cov8" title="1">{
        deps := map[string][]string{}
        for _, pt := range l </span><span class="cov8" title="1">{
                // get the list of deps for this pipelineTask
                d := pt.Deps()
                // add the pipelineTask into the map if it has any deps
                if len(d) &gt; 0 </span><span class="cov8" title="1">{
                        deps[pt.HashKey()] = d
                }</span>
        }
        <span class="cov8" title="1">return deps</span>
}

// Items returns a slice of all tasks in the PipelineTaskList, converted to dag.Tasks
func (l PipelineTaskList) Items() []dag.Task <span class="cov8" title="1">{
        tasks := []dag.Task{}
        for _, t := range l </span><span class="cov8" title="1">{
                tasks = append(tasks, dag.Task(t))
        }</span>
        <span class="cov8" title="1">return tasks</span>
}

// Names returns a set of pipeline task names from the given list of pipeline tasks
func (l PipelineTaskList) Names() sets.String <span class="cov8" title="1">{
        names := sets.String{}
        for _, pt := range l </span><span class="cov8" title="1">{
                names.Insert(pt.Name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// PipelineTaskParam is used to provide arbitrary string parameters to a Task.
type PipelineTaskParam struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// PipelineList contains a list of Pipeline
type PipelineList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Pipeline `json:"items"`
}
</pre>
		
		<pre class="file" id="file104" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        "github.com/tektoncd/pipeline/pkg/substitution"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*Pipeline)(nil)
        _ resourcesemantics.VerbLimited = (*Pipeline)(nil)
)

const (
        taskRef      = "taskRef"
        taskSpec     = "taskSpec"
        pipelineRef  = "pipelineRef"
        pipelineSpec = "pipelineSpec"
)

// SupportedVerbs returns the operations that validation should be called for
func (p *Pipeline) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate checks that the Pipeline structure is valid but does not validate
// that any references resources exist, that is done at run time.
func (p *Pipeline) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(p.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(p.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        // When a Pipeline is created directly, instead of declared inline in a PipelineRun,
        // we do not support propagated parameters and workspaces.
        // Validate that all params and workspaces it uses are declared.
        errs = errs.Also(p.Spec.validatePipelineParameterUsage(ctx).ViaField("spec"))
        return errs.Also(p.Spec.validatePipelineWorkspacesUsage().ViaField("spec"))
}</span>

// Validate checks that taskNames in the Pipeline are valid and that the graph
// of Tasks expressed in the Pipeline makes sense.
func (ps *PipelineSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(ps.ValidateBetaFields(ctx))
        if equality.Semantic.DeepEqual(ps, &amp;PipelineSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("expected at least one, got none", "description", "params", "resources", "tasks", "workspaces"))
        }</span>
        // PipelineTask must have a valid unique label and at least one of taskRef or taskSpec should be specified
        <span class="cov8" title="1">errs = errs.Also(ValidatePipelineTasks(ctx, ps.Tasks, ps.Finally))
        if len(ps.Resources) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("resources"))
        }</span>
        // Validate the pipeline task graph
        <span class="cov8" title="1">errs = errs.Also(validateGraph(ps.Tasks))
        // The parameter variables should be valid
        errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.Tasks, ps.Params).ViaField("tasks"))
        errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.Finally, ps.Params).ViaField("finally"))
        errs = errs.Also(validatePipelineContextVariables(ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validatePipelineContextVariables(ps.Finally).ViaField("finally"))
        errs = errs.Also(validateExecutionStatusVariables(ps.Tasks, ps.Finally))
        // Validate the pipeline's workspaces.
        errs = errs.Also(validatePipelineWorkspacesDeclarations(ps.Workspaces))
        // Validate the pipeline's results
        errs = errs.Also(validatePipelineResults(ps.Results, ps.Tasks, ps.Finally))
        errs = errs.Also(validateTasksAndFinallySection(ps))
        errs = errs.Also(validateFinalTasks(ps.Tasks, ps.Finally))
        errs = errs.Also(validateWhenExpressions(ctx, ps.Tasks, ps.Finally))
        errs = errs.Also(validateArtifactReference(ctx, ps.Tasks, ps.Finally))
        errs = errs.Also(validateMatrix(ctx, ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validateMatrix(ctx, ps.Finally).ViaField("finally"))
        return errs</span>
}

// ValidateBetaFields returns an error if the PipelineSpec uses beta specifications governed by
// `enable-api-fields` but does not have "enable-api-fields" set to "alpha" or "beta".
func (ps *PipelineSpec) ValidateBetaFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for i, pt := range ps.Tasks </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateBetaFields(ctx).ViaFieldIndex("tasks", i))
        }</span>
        <span class="cov8" title="1">for i, pt := range ps.Finally </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateBetaFields(ctx).ViaFieldIndex("finally", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateBetaFields returns an error if the PipelineTask uses beta features but does not
// have "enable-api-fields" set to "alpha" or "beta".
func (pt *PipelineTask) validateBetaFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                // Resolvers
                if pt.TaskRef.Resolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "taskref.resolver", config.BetaAPIFields))
                }</span>
                <span class="cov8" title="1">if len(pt.TaskRef.Params) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "taskref.params", config.BetaAPIFields))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidatePipelineTasks ensures that pipeline tasks has unique label, pipeline tasks has specified one of
// taskRef or taskSpec, and in case of a pipeline task with taskRef, it has a reference to a valid task (task name)
func ValidatePipelineTasks(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) *apis.FieldError <span class="cov8" title="1">{
        taskNames := sets.NewString()
        var errs *apis.FieldError
        errs = errs.Also(PipelineTaskList(tasks).Validate(ctx, taskNames, "tasks"))
        errs = errs.Also(PipelineTaskList(finalTasks).Validate(ctx, taskNames, "finally"))
        return errs
}</span>

// Validate a list of pipeline tasks including custom task and bundles
func (l PipelineTaskList) Validate(ctx context.Context, taskNames sets.String, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range l </span><span class="cov8" title="1">{
                // validate pipeline task name
                errs = errs.Also(t.ValidateName().ViaFieldIndex(path, i))
                // names cannot be duplicated - checking that pipelineTask names are unique
                if _, ok := taskNames[t.Name]; ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("name").ViaFieldIndex(path, i))
                }</span>
                <span class="cov8" title="1">taskNames.Insert(t.Name)
                // validate custom task, bundle, dag, or final task
                errs = errs.Also(t.Validate(ctx).ViaFieldIndex(path, i))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateUsageOfDeclaredPipelineTaskParameters validates that all parameters referenced in the pipeline Task are declared by the pipeline Task.
func (l PipelineTaskList) validateUsageOfDeclaredPipelineTaskParameters(ctx context.Context, additionalParams []ParamSpec, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range l </span><span class="cov8" title="1">{
                if t.TaskSpec != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, t.TaskSpec.Steps, append(t.TaskSpec.Params, additionalParams...)).ViaFieldIndex(path, i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateName checks whether the PipelineTask's name is a valid DNS label
func (pt PipelineTask) ValidateName() *apis.FieldError <span class="cov8" title="1">{
        if err := validation.IsDNS1123Label(pt.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid value %q", pt.Name),
                        Paths:   []string{"name"},
                        Details: "Pipeline Task name must be a valid DNS Label." +
                                "For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate classifies whether a task is a custom task, bundle, or a regular task(dag/final)
// calls the validation routine based on the type of the task
func (pt PipelineTask) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(pt.validateRefOrSpec(ctx))

        errs = errs.Also(pt.validateEnabledInlineSpec(ctx))

        errs = errs.Also(pt.validateEmbeddedOrType())

        if pt.Resources != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrDisallowedFields("resources"))
        }</span>
        // taskKinds contains the kinds when the apiVersion is not set, they are not custom tasks,
        // if apiVersion is set they are custom tasks.
        <span class="cov8" title="1">taskKinds := map[TaskKind]bool{
                "":                 true,
                NamespacedTaskKind: true,
        }

        errs = errs.Also(pt.ValidateOnError(ctx))

        // Pipeline task having taskRef/taskSpec with APIVersion is classified as custom task
        switch </span>{
        case pt.TaskRef != nil &amp;&amp; !taskKinds[pt.TaskRef.Kind]:<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskRef != nil &amp;&amp; pt.TaskRef.APIVersion != "":<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskSpec != nil &amp;&amp; !taskKinds[TaskKind(pt.TaskSpec.Kind)]:<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        case pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.APIVersion != "":<span class="cov8" title="1">
                errs = errs.Also(pt.validateCustomTask())</span>
        default:<span class="cov8" title="1">
                errs = errs.Also(pt.validateTask(ctx))</span>
        }
        <span class="cov8" title="1">return</span> //nolint:nakedret
}

// ValidateOnError validates the OnError field of a PipelineTask
func (pt PipelineTask) ValidateOnError(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.OnError != "" &amp;&amp; !isParamRefs(string(pt.OnError)) </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "OnError", config.BetaAPIFields))
                if pt.OnError != PipelineTaskContinue &amp;&amp; pt.OnError != PipelineTaskStopAndFail </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(pt.OnError, "OnError", "PipelineTask OnError must be either \"continue\" or \"stopAndFail\""))
                }</span>
                <span class="cov8" title="1">if pt.OnError == PipelineTaskContinue &amp;&amp; pt.Retries &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("PipelineTask OnError cannot be set to \"continue\" when Retries is greater than 0"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateEnabledInlineSpec validates that pipelineSpec or taskSpec is allowed by checking
// disable-inline-spec field
func (pt PipelineTask) validateEnabledInlineSpec(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipeline") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("taskSpec"))
                }</span>
        }
        <span class="cov8" title="1">if pt.PipelineSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipeline") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("pipelineSpec"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (pt *PipelineTask) validateMatrix(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.IsMatrixed() </span><span class="cov8" title="1">{
                // This is a beta feature and will fail validation if it's used in a pipeline spec
                // when the enable-api-fields feature gate is set to "stable".
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "matrix", config.BetaAPIFields))
                errs = errs.Also(pt.Matrix.validateCombinationsCount(ctx))
                errs = errs.Also(pt.Matrix.validateUniqueParams())
        }</span>
        <span class="cov8" title="1">errs = errs.Also(pt.Matrix.validateParameterInOneOfMatrixOrParams(pt.Params))
        return errs</span>
}

func (pt PipelineTask) validateEmbeddedOrType() (errs *apis.FieldError) <span class="cov8" title="1">{
        // Reject cases where APIVersion and/or Kind are specified alongside an embedded Task.
        // We determine if this is an embedded Task by checking of TaskSpec.TaskSpec.Steps has items.
        if pt.TaskSpec != nil &amp;&amp; len(pt.TaskSpec.TaskSpec.Steps) &gt; 0 </span><span class="cov8" title="1">{
                if pt.TaskSpec.APIVersion != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "taskSpec.apiVersion cannot be specified when using taskSpec.steps",
                                Paths:   []string{"taskSpec.apiVersion"},
                        })
                }</span>
                <span class="cov8" title="1">if pt.TaskSpec.Kind != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "taskSpec.kind cannot be specified when using taskSpec.steps",
                                Paths:   []string{"taskSpec.kind"},
                        })
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (pt *PipelineTask) validateWorkspaces(workspaceNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaceBindingNames := sets.NewString()
        for i, ws := range pt.Workspaces </span><span class="cov8" title="1">{
                if workspaceBindingNames.Has(ws.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(
                                fmt.Sprintf("workspace name %q must be unique", ws.Name), "").ViaFieldIndex("workspaces", i))
                }</span>

                <span class="cov8" title="1">if ws.Workspace == "" </span><span class="cov8" title="1">{
                        if !workspaceNames.Has(ws.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(
                                        fmt.Sprintf("pipeline task %q expects workspace with name %q but none exists in pipeline spec", pt.Name, ws.Name),
                                        "",
                                ).ViaFieldIndex("workspaces", i))
                        }</span>
                } else<span class="cov8" title="1"> if !workspaceNames.Has(ws.Workspace) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(
                                fmt.Sprintf("pipeline task %q expects workspace with name %q but none exists in pipeline spec", pt.Name, ws.Workspace),
                                "",
                        ).ViaFieldIndex("workspaces", i))
                }</span>

                <span class="cov8" title="1">workspaceBindingNames.Insert(ws.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateRefOrSpec validates at least one of taskRef or taskSpec or pipelineRef or pipelineSpec is specified
func (pt PipelineTask) validateRefOrSpec(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // collect all the specified specifications
        nonNilFields := []string{}
        if pt.TaskRef != nil </span><span class="cov8" title="1">{
                nonNilFields = append(nonNilFields, taskRef)
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                nonNilFields = append(nonNilFields, taskSpec)
        }</span>
        <span class="cov8" title="1">if pt.PipelineRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, pipelineRef, config.AlphaAPIFields))
                nonNilFields = append(nonNilFields, pipelineRef)
        }</span>
        <span class="cov8" title="1">if pt.PipelineSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, pipelineSpec, config.AlphaAPIFields))
                nonNilFields = append(nonNilFields, pipelineSpec)
        }</span>

        // check the length of nonNilFields
        // if one of taskRef or taskSpec or pipelineRef or pipelineSpec is specified,
        // the length of nonNilFields should exactly be 1
        <span class="cov8" title="1">if len(nonNilFields) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("expected exactly one, got multiple", nonNilFields...))
        }</span> else<span class="cov8" title="1"> if len(nonNilFields) == 0 </span><span class="cov8" title="1">{
                cfg := config.FromContextOrDefaults(ctx)
                // check for TaskRef or TaskSpec or PipelineRef or PipelineSpec with alpha feature flag
                if cfg.FeatureFlags.EnableAPIFields == config.AlphaAPIFields </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingOneOf(taskRef, taskSpec, pipelineRef, pipelineSpec))
                }</span> else<span class="cov8" title="1"> {
                        // check for taskRef and taskSpec with beta/stable feature flag
                        errs = errs.Also(apis.ErrMissingOneOf(taskRef, taskSpec))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateCustomTask validates custom task specifications - checking kind and fail if not yet supported features specified
func (pt PipelineTask) validateCustomTask() (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.TaskRef != nil &amp;&amp; pt.TaskRef.Kind == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task ref must specify kind", "taskRef.kind"))
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Kind == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task spec must specify kind", "taskSpec.kind"))
        }</span>
        <span class="cov8" title="1">if pt.TaskRef != nil &amp;&amp; pt.TaskRef.APIVersion == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task ref must specify apiVersion", "taskRef.apiVersion"))
        }</span>
        <span class="cov8" title="1">if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.APIVersion == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("custom task spec must specify apiVersion", "taskSpec.apiVersion"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateTask validates a pipeline task or a final task for taskRef and taskSpec
func (pt PipelineTask) validateTask(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pt.TaskSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.TaskSpec.Validate(ctx).ViaField("taskSpec"))
        }</span>
        <span class="cov8" title="1">if pt.TaskRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(pt.TaskRef.Validate(ctx).ViaField("taskRef"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineWorkspacesDeclarations validates the specified workspaces, ensuring having unique name without any
// empty string,
func validatePipelineWorkspacesDeclarations(wss []PipelineWorkspaceDeclaration) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Workspace names must be non-empty and unique.
        wsTable := sets.NewString()
        for i, ws := range wss </span><span class="cov8" title="1">{
                if ws.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("workspace %d has empty name", i),
                                "").ViaFieldIndex("workspaces", i))
                }</span>
                <span class="cov8" title="1">if wsTable.Has(ws.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("workspace with name %q appears more than once", ws.Name),
                                "").ViaFieldIndex("workspaces", i))
                }</span>
                <span class="cov8" title="1">wsTable.Insert(ws.Name)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineParameterUsage validates that parameters referenced in the Pipeline are declared by the Pipeline
func (ps *PipelineSpec) validatePipelineParameterUsage(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(PipelineTaskList(ps.Tasks).validateUsageOfDeclaredPipelineTaskParameters(ctx, ps.Params, "tasks"))
        errs = errs.Also(PipelineTaskList(ps.Finally).validateUsageOfDeclaredPipelineTaskParameters(ctx, ps.Params, "finally"))
        errs = errs.Also(validatePipelineTaskParameterUsage(ps.Tasks, ps.Params).ViaField("tasks"))
        errs = errs.Also(validatePipelineTaskParameterUsage(ps.Finally, ps.Params).ViaField("finally"))
        return errs
}</span>

// validatePipelineTaskParameterUsage validates that parameters referenced in the Pipeline Tasks are declared by the Pipeline
func validatePipelineTaskParameterUsage(tasks []PipelineTask, params ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        allParamNames := sets.NewString(params.getNames()...)
        _, arrayParams, objectParams := params.sortByType()
        arrayParamNames := sets.NewString(arrayParams.getNames()...)
        objectParameterNameKeys := map[string][]string{}
        for _, p := range objectParams </span><span class="cov8" title="1">{
                for k := range p.Properties </span><span class="cov8" title="1">{
                        objectParameterNameKeys[p.Name] = append(objectParameterNameKeys[p.Name], k)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validatePipelineParametersVariables(tasks, "params", allParamNames, arrayParamNames, objectParameterNameKeys))
        for i, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.Params.validateDuplicateParameters().ViaField("params").ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validatePipelineWorkspacesUsage validates that Workspaces referenced in the Pipeline are declared by the Pipeline
func (ps *PipelineSpec) validatePipelineWorkspacesUsage() (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(validatePipelineTasksWorkspacesUsage(ps.Workspaces, ps.Tasks).ViaField("tasks"))
        errs = errs.Also(validatePipelineTasksWorkspacesUsage(ps.Workspaces, ps.Finally).ViaField("finally"))
        return errs
}</span>

// validatePipelineTasksWorkspacesUsage validates that all the referenced workspaces (by pipeline tasks) are specified in
// the pipeline
func validatePipelineTasksWorkspacesUsage(wss []PipelineWorkspaceDeclaration, pts []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaceNames := sets.NewString()
        for _, ws := range wss </span><span class="cov8" title="1">{
                workspaceNames.Insert(ws.Name)
        }</span>
        // Any workspaces used in PipelineTasks should have their name declared in the Pipeline's Workspaces list.
        <span class="cov8" title="1">for i, pt := range pts </span><span class="cov8" title="1">{
                errs = errs.Also(pt.validateWorkspaces(workspaceNames).ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidatePipelineParameterVariables validates parameters with those specified by each pipeline task,
// (1) it validates the type of parameter is either string or array (2) parameter default value matches
// with the type of that param (3) no duplication, feature flag and allowed param type when using param enum
func ValidatePipelineParameterVariables(ctx context.Context, tasks []PipelineTask, params ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        // validates all the types within a slice of ParamSpecs
        errs = errs.Also(ValidateParameterTypes(ctx, params).ViaField("params"))
        errs = errs.Also(params.validateNoDuplicateNames())
        errs = errs.Also(params.validateParamEnums(ctx).ViaField("params"))
        for i, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.Params.validateDuplicateParameters().ViaField("params").ViaIndex(i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validatePipelineParametersVariables(tasks []PipelineTask, prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(validatePipelineParametersVariablesInTaskParameters(task.Params, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))
                if task.IsMatrixed() </span><span class="cov8" title="1">{
                        errs = errs.Also(task.Matrix.validatePipelineParametersVariablesInMatrixParameters(prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(task.WhenExpressions.validatePipelineParametersVariables(prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaIndex(idx))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validatePipelineContextVariables(tasks []PipelineTask) *apis.FieldError <span class="cov8" title="1">{
        pipelineRunContextNames := sets.NewString().Insert(
                "name",
                "namespace",
                "uid",
        )
        pipelineContextNames := sets.NewString().Insert(
                "name",
        )
        pipelineTaskContextNames := sets.NewString().Insert(
                "retries",
        )
        var paramValues []string
        for _, task := range tasks </span><span class="cov8" title="1">{
                paramValues = task.extractAllParams().extractValues()
        }</span>
        <span class="cov8" title="1">errs := validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipelineRun", pipelineRunContextNames).
                Also(validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipeline", pipelineContextNames)).
                Also(validatePipelineContextVariablesInParamValues(paramValues, "context\\.pipelineTask", pipelineTaskContextNames))
        return errs</span>
}

// extractAllParams extracts all the parameters in a PipelineTask:
// - pt.Params
// - pt.Matrix.Params
// - pt.Matrix.Include.Params
func (pt *PipelineTask) extractAllParams() Params <span class="cov8" title="1">{
        allParams := pt.Params
        if pt.Matrix.HasParams() </span><span class="cov8" title="1">{
                allParams = append(allParams, pt.Matrix.Params...)
        }</span>
        <span class="cov8" title="1">if pt.Matrix.HasInclude() </span><span class="cov8" title="1">{
                for _, include := range pt.Matrix.Include </span><span class="cov8" title="1">{
                        allParams = append(allParams, include.Params...)
                }</span>
        }
        <span class="cov8" title="1">return allParams</span>
}

// containsExecutionStatusRef checks if a specified param has a reference to execution status or reason
// $(tasks.&lt;task-name&gt;.status), $(tasks.status), or $(tasks.&lt;task-name&gt;.reason)
func containsExecutionStatusRef(p string) bool <span class="cov8" title="1">{
        if strings.HasPrefix(p, "tasks.") </span><span class="cov8" title="1">{
                if strings.HasSuffix(p, ".status") || strings.HasSuffix(p, ".reason") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func validateExecutionStatusVariables(tasks []PipelineTask, finallyTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(validateExecutionStatusVariablesInTasks(tasks).ViaField("tasks"))
        errs = errs.Also(validateExecutionStatusVariablesInFinally(PipelineTaskList(tasks).Names(), finallyTasks).ViaField("finally"))
        return errs
}</span>

// validate dag pipeline tasks, task params can not access execution status of any other task
// dag tasks cannot have param value as $(tasks.pipelineTask.status)
func validateExecutionStatusVariablesInTasks(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.validateExecutionStatusVariablesDisallowed().ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validate finally tasks accessing execution status of a dag task specified in the pipeline
// $(tasks.pipelineTask.status) is invalid if pipelineTask is not defined as a dag task
func validateExecutionStatusVariablesInFinally(tasksNames sets.String, finally []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range finally </span><span class="cov8" title="1">{
                errs = errs.Also(t.validateExecutionStatusVariablesAllowed(tasksNames).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (pt *PipelineTask) validateExecutionStatusVariablesDisallowed() (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, param := range pt.Params </span><span class="cov8" title="1">{
                if expressions, ok := GetVarSubstitutionExpressionsForParam(param); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateContainsExecutionStatusVariablesDisallowed(expressions, "value").
                                ViaFieldKey("params", param.Name))
                }</span>
        }
        <span class="cov8" title="1">for i, we := range pt.WhenExpressions </span><span class="cov8" title="1">{
                if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateContainsExecutionStatusVariablesDisallowed(expressions, "").
                                ViaFieldIndex("when", i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateContainsExecutionStatusVariablesDisallowed(expressions []string, path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if containsExecutionStatusReferences(expressions) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("pipeline tasks can not refer to execution status"+
                        " of any other pipeline task or aggregate status of tasks", path))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func containsExecutionStatusReferences(expressions []string) bool <span class="cov8" title="1">{
        // validate tasks.pipelineTask.status/tasks.status if this expression is not a result reference
        if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                for _, e := range expressions </span><span class="cov8" title="1">{
                        // check if it contains context variable accessing execution status - $(tasks.taskname.status)
                        // or an aggregate status - $(tasks.status)
                        if containsExecutionStatusRef(e) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (pt *PipelineTask) validateExecutionStatusVariablesAllowed(ptNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, param := range pt.Params </span><span class="cov8" title="1">{
                if expressions, ok := GetVarSubstitutionExpressionsForParam(param); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateExecutionStatusVariablesExpressions(expressions, ptNames, "value").
                                ViaFieldKey("params", param.Name))
                }</span>
        }
        <span class="cov8" title="1">for i, we := range pt.WhenExpressions </span><span class="cov8" title="1">{
                if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        errs = errs.Also(validateExecutionStatusVariablesExpressions(expressions, ptNames, "").
                                ViaFieldIndex("when", i))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateExecutionStatusVariablesExpressions(expressions []string, ptNames sets.String, fieldPath string) (errs *apis.FieldError) <span class="cov8" title="1">{
        // validate tasks.pipelineTask.status if this expression is not a result reference
        if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                for _, expression := range expressions </span><span class="cov8" title="1">{
                        // its a reference to aggregate status of dag tasks - $(tasks.status)
                        if expression == PipelineTasksAggregateStatus </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // check if it contains context variable accessing execution status - $(tasks.taskname.status) | $(tasks.taskname.reason)
                        <span class="cov8" title="1">if containsExecutionStatusRef(expression) </span><span class="cov8" title="1">{
                                var pt string
                                if strings.HasSuffix(expression, ".status") </span><span class="cov8" title="1">{
                                        // strip tasks. and .status from tasks.taskname.status to further verify task name
                                        pt = strings.TrimSuffix(strings.TrimPrefix(expression, "tasks."), ".status")
                                }</span>
                                <span class="cov8" title="1">if strings.HasSuffix(expression, ".reason") </span><span class="cov8" title="1">{
                                        // strip tasks. and .reason from tasks.taskname.reason to further verify task name
                                        pt = strings.TrimSuffix(strings.TrimPrefix(expression, "tasks."), ".reason")
                                }</span>
                                // report an error if the task name does not exist in the list of dag tasks
                                <span class="cov8" title="1">if !ptNames.Has(pt) </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("pipeline task %s is not defined in the pipeline", pt), fieldPath))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func validatePipelineContextVariablesInParamValues(paramValues []string, prefix string, contextNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, paramValue := range paramValues </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(paramValue, prefix, contextNames).ViaField("value"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func filter(arr []string, cond func(string) bool) []string <span class="cov8" title="1">{
        result := []string{}
        for i := range arr </span><span class="cov8" title="1">{
                if cond(arr[i]) </span><span class="cov8" title="1">{
                        result = append(result, arr[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// validatePipelineResults ensure that pipeline result variables are properly configured
func validatePipelineResults(results []PipelineResult, tasks []PipelineTask, finally []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        pipelineTaskNames := getPipelineTasksNames(tasks)
        pipelineFinallyTaskNames := getPipelineTasksNames(finally)
        for idx, result := range results </span><span class="cov8" title="1">{
                expressions, ok := GetVarSubstitutionExpressionsForPipelineResult(result)
                if !ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("expected pipeline results to be task result expressions but no expressions were found",
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">if !LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("expected pipeline results to be task result expressions but an invalid expressions was found",
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">expressions = filter(expressions, resultref.LooksLikeResultRef)
                resultRefs := NewResultRefs(expressions)
                if len(expressions) != len(resultRefs) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("expected all of the expressions %v to be result expressions but only %v were", expressions, resultRefs),
                                "value").ViaFieldIndex("results", idx))
                }</span>

                <span class="cov8" title="1">if !taskContainsResult(result.Value.StringVal, pipelineTaskNames, pipelineFinallyTaskNames) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("referencing a nonexistent task",
                                "value").ViaFieldIndex("results", idx))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// put task names in a set
func getPipelineTasksNames(pipelineTasks []PipelineTask) sets.String <span class="cov8" title="1">{
        pipelineTaskNames := make(sets.String)
        for _, pipelineTask := range pipelineTasks </span><span class="cov8" title="1">{
                pipelineTaskNames.Insert(pipelineTask.Name)
        }</span>

        <span class="cov8" title="1">return pipelineTaskNames</span>
}

// taskContainsResult ensures the result value is referenced within the
// task names
func taskContainsResult(resultExpression string, pipelineTaskNames sets.String, pipelineFinallyTaskNames sets.String) bool <span class="cov8" title="1">{
        // split incase of multiple resultExpressions in the same result.Value string
        // i.e "$(task.&lt;task-name).result.&lt;result-name&gt;) - $(task2.&lt;task2-name).result2.&lt;result2-name&gt;)"
        split := strings.Split(resultExpression, "$")
        for _, expression := range split </span><span class="cov8" title="1">{
                if expression != "" </span><span class="cov8" title="1">{
                        value := stripVarSubExpression("$" + expression)
                        pr, err := resultref.ParseTaskExpression(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return false
                        }</span>

                        <span class="cov8" title="1">if strings.HasPrefix(value, "tasks") &amp;&amp; !pipelineTaskNames.Has(pr.ResourceName) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if strings.HasPrefix(value, "finally") &amp;&amp; !pipelineFinallyTaskNames.Has(pr.ResourceName) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func validateTasksAndFinallySection(ps *PipelineSpec) *apis.FieldError <span class="cov8" title="1">{
        if len(ps.Finally) != 0 &amp;&amp; len(ps.Tasks) == 0 </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue(fmt.Sprintf("spec.tasks is empty but spec.finally has %d tasks", len(ps.Finally)), "finally")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateFinalTasks(tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, f := range finalTasks </span><span class="cov8" title="1">{
                if len(f.RunAfter) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("no runAfter allowed under spec.finally, final task %s has runAfter specified", f.Name), "").ViaFieldIndex("finally", idx))
                }</span>
        }

        <span class="cov8" title="1">ts := PipelineTaskList(tasks).Names()
        fts := PipelineTaskList(finalTasks).Names()

        errs = errs.Also(validateTaskResultReferenceInFinallyTasks(finalTasks, ts, fts))

        return errs</span>
}

func validateTaskResultReferenceInFinallyTasks(finalTasks []PipelineTask, ts sets.String, fts sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, t := range finalTasks </span><span class="cov8" title="1">{
                for _, p := range t.Params </span><span class="cov8" title="1">{
                        if expressions, ok := GetVarSubstitutionExpressionsForParam(p); ok </span><span class="cov8" title="1">{
                                errs = errs.Also(validateResultsVariablesExpressionsInFinally(expressions, ts, fts, "value").ViaFieldKey(
                                        "params", p.Name).ViaFieldIndex("finally", idx))
                        }</span>
                }
                <span class="cov8" title="1">for i, we := range t.WhenExpressions </span><span class="cov8" title="1">{
                        if expressions, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                                errs = errs.Also(validateResultsVariablesExpressionsInFinally(expressions, ts, fts, "").ViaFieldIndex(
                                        "when", i).ViaFieldIndex("finally", idx))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func validateResultsVariablesExpressionsInFinally(expressions []string, pipelineTasksNames sets.String, finalTasksNames sets.String, fieldPath string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                resultRefs := NewResultRefs(expressions)
                for _, resultRef := range resultRefs </span><span class="cov8" title="1">{
                        pt := resultRef.PipelineTask
                        if finalTasksNames.Has(pt) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("invalid task result reference, "+
                                        "final task has task result reference from a final task %s", pt), fieldPath))
                        }</span> else<span class="cov8" title="1"> if !pipelineTasksNames.Has(resultRef.PipelineTask) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("invalid task result reference, "+
                                        "final task has task result reference from a task %s which is not defined in the pipeline", pt), fieldPath))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func validateWhenExpressions(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, t := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.WhenExpressions.validate(ctx).ViaFieldIndex("tasks", i))
        }</span>
        <span class="cov8" title="1">for i, t := range finalTasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.WhenExpressions.validate(ctx).ViaFieldIndex("finally", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateGraph ensures the Pipeline's dependency Graph (DAG) make sense: that there is no dependency
// cycle or that they rely on values from Tasks that ran previously, and that the PipelineResource
// is actually an output of the Task it should come from.
func validateGraph(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        if _, err := dag.Build(PipelineTaskList(tasks), PipelineTaskList(tasks).Deps()); err != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(err.Error(), "tasks"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateMatrix(ctx context.Context, tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, task := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(task.validateMatrix(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateTaskResultsFromMatrixedPipelineTasksConsumed(tasks))
        return errs</span>
}

// findAndValidateResultRefsForMatrix checks that any result references to Matrixed PipelineTasks if consumed
// by another PipelineTask that the entire array of results produced by a matrix is consumed in aggregate
// since consuming a singular result produced by a matrix is currently not supported
func findAndValidateResultRefsForMatrix(tasks []PipelineTask, taskMapping map[string]PipelineTask) (resultRefs []*ResultRef, errs *apis.FieldError) <span class="cov8" title="1">{
        for _, t := range tasks </span><span class="cov8" title="1">{
                for _, p := range t.Params </span><span class="cov8" title="1">{
                        if expressions, ok := GetVarSubstitutionExpressionsForParam(p); ok </span><span class="cov8" title="1">{
                                if LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                                        resultRefs, errs = validateMatrixedPipelineTaskConsumed(expressions, taskMapping)
                                        if errs != nil </span><span class="cov8" title="1">{
                                                return nil, errs
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return resultRefs, errs</span>
}

// validateMatrixedPipelineTaskConsumed checks that any Matrixed Pipeline Task that the is being consumed is consumed in
// aggregate [*] since consuming a singular result produced by a matrix is currently not supported
func validateMatrixedPipelineTaskConsumed(expressions []string, taskMapping map[string]PipelineTask) (resultRefs []*ResultRef, errs *apis.FieldError) <span class="cov8" title="1">{
        var filteredExpressions []string
        for _, expression := range expressions </span><span class="cov8" title="1">{
                // ie. "tasks.&lt;pipelineTaskName&gt;.results.&lt;resultName&gt;[*]"
                subExpressions := strings.Split(expression, ".")
                pipelineTask := subExpressions[1] // pipelineTaskName
                taskConsumed := taskMapping[pipelineTask]
                if taskConsumed.IsMatrixed() </span><span class="cov8" title="1">{
                        if !strings.HasSuffix(expression, "[*]") </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric("A matrixed pipelineTask can only be consumed in aggregate using [*] notation, but is currently set to " + expression))
                        }</span>
                        <span class="cov8" title="1">filteredExpressions = append(filteredExpressions, expression)</span>
                }
        }
        <span class="cov8" title="1">return NewResultRefs(filteredExpressions), errs</span>
}

// validateTaskResultsFromMatrixedPipelineTasksConsumed checks that any Matrixed Pipeline Task that the is being consumed
// is consumed in aggregate [*] since consuming a singular result produced by a matrix is currently not supported.
// It also validates that a matrix emitting results can only emit results with the underlying type string
// if those results are being consumed by another PipelineTask.
func validateTaskResultsFromMatrixedPipelineTasksConsumed(tasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        taskMapping := createTaskMapping(tasks)
        resultRefs, errs := findAndValidateResultRefsForMatrix(tasks, taskMapping)
        if errs != nil </span><span class="cov8" title="1">{
                return errs
        }</span>

        <span class="cov8" title="1">errs = errs.Also(validateMatrixEmittingStringResults(resultRefs, taskMapping))
        return errs</span>
}

// createTaskMapping maps the PipelineTaskName to the PipelineTask to easily access
// the pipelineTask by Name
func createTaskMapping(tasks []PipelineTask) (taskMap map[string]PipelineTask) <span class="cov8" title="1">{
        taskMapping := make(map[string]PipelineTask)
        for _, task := range tasks </span><span class="cov8" title="1">{
                taskMapping[task.Name] = task
        }</span>
        <span class="cov8" title="1">return taskMapping</span>
}

// validateMatrixEmittingStringResults checks a matrix emitting results can only emit results with the underlying type string
// if those results are being consumed by another PipelineTask.
func validateMatrixEmittingStringResults(resultRefs []*ResultRef, taskMapping map[string]PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, resultRef := range resultRefs </span><span class="cov8" title="1">{
                task := taskMapping[resultRef.PipelineTask]
                resultName := resultRef.Result
                if task.TaskRef != nil </span><span class="cov8" title="1">{
                        referencedTaskName := task.TaskRef.Name
                        referencedTask := taskMapping[referencedTaskName]
                        if referencedTask.TaskSpec != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(validateStringResults(referencedTask.TaskSpec.Results, resultName))
                        }</span>
                } else<span class="cov8" title="1"> if task.TaskSpec != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(validateStringResults(task.TaskSpec.Results, resultName))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateStringResults ensure that the result type is string
func validateStringResults(results []TaskResult, resultName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Name == resultName </span><span class="cov8" title="1">{
                        if result.Type != ResultsTypeString </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(
                                        fmt.Sprintf("Matrixed PipelineTasks emitting results must have an underlying type string, but result %s has type %s in pipelineTask", resultName, string(result.Type)),
                                        "",
                                ))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// validateArtifactReference ensure that the feature flag enableArtifacts is set to true when using artifacts
func validateArtifactReference(ctx context.Context, tasks []PipelineTask, finalTasks []PipelineTask) (errs *apis.FieldError) <span class="cov8" title="1">{
        if config.FromContextOrDefaults(ctx).FeatureFlags.EnableArtifacts </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">for i, t := range tasks </span><span class="cov8" title="1">{
                for _, v := range t.Params.extractValues() </span><span class="cov8" title="1">{
                        if len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(v, -1)) &gt; 0 </span><span class="cov8" title="1">{
                                return errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "").ViaField("params").ViaFieldIndex("tasks", i))
                        }</span>
                }
        }
        <span class="cov8" title="1">for i, t := range finalTasks </span><span class="cov8" title="1">{
                for _, v := range t.Params.extractValues() </span><span class="cov8" title="1">{
                        if len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(v, -1)) &gt; 0 </span><span class="cov8" title="1">{
                                return errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "").ViaField("params").ViaFieldIndex("finally", i))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// GetIndexingReferencesToArrayParams returns all strings referencing indices of PipelineRun array parameters
// from parameters, workspaces, and when expressions defined in the Pipeline's Tasks and Finally Tasks.
// For example, if a Task in the Pipeline has a parameter with a value "$(params.array-param-name[1])",
// this would be one of the strings returned.
func (ps *PipelineSpec) GetIndexingReferencesToArrayParams() sets.String <span class="cov8" title="1">{
        paramsRefs := []string{}
        for i := range ps.Tasks </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, ps.Tasks[i].Params.extractValues()...)
                if ps.Tasks[i].IsMatrixed() </span><span class="cov0" title="0">{
                        paramsRefs = append(paramsRefs, ps.Tasks[i].Matrix.Params.extractValues()...)
                }</span>
                <span class="cov8" title="1">for j := range ps.Tasks[i].Workspaces </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, ps.Tasks[i].Workspaces[j].SubPath)
                }</span>
                <span class="cov8" title="1">for _, wes := range ps.Tasks[i].WhenExpressions </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, wes.Input)
                        paramsRefs = append(paramsRefs, wes.Values...)
                }</span>
        }
        <span class="cov8" title="1">for i := range ps.Finally </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, ps.Finally[i].Params.extractValues()...)
                if ps.Finally[i].IsMatrixed() </span><span class="cov0" title="0">{
                        paramsRefs = append(paramsRefs, ps.Finally[i].Matrix.Params.extractValues()...)
                }</span>
                <span class="cov8" title="1">for _, wes := range ps.Finally[i].WhenExpressions </span><span class="cov8" title="1">{
                        paramsRefs = append(paramsRefs, wes.Input)
                        paramsRefs = append(paramsRefs, wes.Values...)
                }</span>
        }
        // extract all array indexing references, for example []{"$(params.array-params[1])"}
        <span class="cov8" title="1">arrayIndexParamRefs := []string{}
        for _, p := range paramsRefs </span><span class="cov8" title="1">{
                arrayIndexParamRefs = append(arrayIndexParamRefs, extractArrayIndexingParamRefs(p)...)
        }</span>
        <span class="cov8" title="1">return sets.NewString(arrayIndexParamRefs...)</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (pr PipelineRef) convertTo(ctx context.Context, sink *v1.PipelineRef) <span class="cov8" title="1">{
        sink.Name = pr.Name
        sink.APIVersion = pr.APIVersion
        new := v1.ResolverRef{}
        pr.ResolverRef.convertTo(ctx, &amp;new)
        sink.ResolverRef = new
}</span>

func (pr *PipelineRef) convertFrom(ctx context.Context, source v1.PipelineRef) <span class="cov8" title="1">{
        pr.Name = source.Name
        pr.APIVersion = source.APIVersion
        new := ResolverRef{}
        new.convertFrom(ctx, source.ResolverRef)
        pr.ResolverRef = new
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// Validate ensures that a supplied PipelineRef field is populated
// correctly. No errors are returned for a nil PipelineRef.
func (ref *PipelineRef) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">if apis.IsInCreate(ctx) &amp;&amp; ref.Bundle != "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("bundle"))
        }</span>
        <span class="cov8" title="1">switch </span>{
        case ref.Resolver != "" || ref.Params != nil:<span class="cov8" title="1">
                if ref.Params != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver params", config.BetaAPIFields).ViaField("params"))
                        if ref.Name != "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name", "params"))
                        }</span>
                        <span class="cov8" title="1">if ref.Resolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ref.Params))</span>
                }
                <span class="cov8" title="1">if ref.Resolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver", config.BetaAPIFields).ViaField("resolver"))
                        if ref.Name != "" </span><span class="cov8" title="1">{
                                // make sure that the name is url-like.
                                err := RefNameLikeUrl(ref.Name)
                                if err == nil &amp;&amp; !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                        // If name is url-like then concise resolver syntax must be enabled
                                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(err, "name"))
                                }</span>
                        }
                }
        case ref.Name != "":<span class="cov8" title="1">
                // ref name can be a Url-like format.
                if err := RefNameLikeUrl(ref.Name); err == nil </span><span class="cov8" title="1">{
                        // If name is url-like then concise resolver syntax must be enabled
                        if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                        }</span>
                        // In stage1 of concise remote resolvers syntax, this is a required field.
                        // TODO: remove this check when implementing stage 2 where this is optional.
                        <span class="cov8" title="1">if ref.Resolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        // Or, it must be a valid k8s name
                } else<span class="cov8" title="1"> {
                        // ref name must be a valid k8s name
                        if errSlice := validation.IsQualifiedName(ref.Name); len(errSlice) != 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(strings.Join(errSlice, ","), "name"))
                        }</span>
                }
        default:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("name"))</span>
        }
        <span class="cov8" title="1">return</span> //nolint:nakedret
}
</pre>
		
		<pre class="file" id="file107" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/version"
        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*PipelineRun)(nil)

// ConvertTo implements apis.Convertible
func (pr *PipelineRun) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := to.(type) </span>{
        case *v1.PipelineRun:<span class="cov8" title="1">
                sink.ObjectMeta = pr.ObjectMeta
                if err := serializePipelineRunResources(&amp;sink.ObjectMeta, &amp;pr.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := pr.Status.convertTo(ctx, &amp;sink.Status, &amp;sink.ObjectMeta); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return pr.Spec.ConvertTo(ctx, &amp;sink.Spec, &amp;sink.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo implements apis.Convertible
func (prs PipelineRunSpec) ConvertTo(ctx context.Context, sink *v1.PipelineRunSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        if prs.PipelineRef != nil </span><span class="cov8" title="1">{
                sink.PipelineRef = &amp;v1.PipelineRef{}
                prs.PipelineRef.convertTo(ctx, sink.PipelineRef)
        }</span>
        <span class="cov8" title="1">if prs.PipelineSpec != nil </span><span class="cov8" title="1">{
                sink.PipelineSpec = &amp;v1.PipelineSpec{}
                err := prs.PipelineSpec.ConvertTo(ctx, sink.PipelineSpec, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">sink.Params = nil
        for _, p := range prs.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.Status = v1.PipelineRunSpecStatus(prs.Status)
        if prs.Timeouts != nil </span><span class="cov8" title="1">{
                sink.Timeouts = &amp;v1.TimeoutFields{}
                prs.Timeouts.convertTo(ctx, sink.Timeouts)
        }</span>
        <span class="cov8" title="1">if prs.Timeout != nil </span><span class="cov8" title="1">{
                sink.Timeouts = &amp;v1.TimeoutFields{}
                sink.Timeouts.Pipeline = prs.Timeout
        }</span>
        <span class="cov8" title="1">sink.TaskRunTemplate = v1.PipelineTaskRunTemplate{}
        sink.TaskRunTemplate.PodTemplate = prs.PodTemplate
        sink.TaskRunTemplate.ServiceAccountName = prs.ServiceAccountName
        sink.Workspaces = nil
        for _, w := range prs.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspaceBinding{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
        <span class="cov8" title="1">sink.TaskRunSpecs = nil
        for _, ptrs := range prs.TaskRunSpecs </span><span class="cov8" title="1">{
                new := v1.PipelineTaskRunSpec{}
                ptrs.convertTo(ctx, &amp;new)
                sink.TaskRunSpecs = append(sink.TaskRunSpecs, new)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom implements apis.Convertible
func (pr *PipelineRun) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        switch source := from.(type) </span>{
        case *v1.PipelineRun:<span class="cov8" title="1">
                pr.ObjectMeta = source.ObjectMeta
                if err := deserializePipelineRunResources(&amp;pr.ObjectMeta, &amp;pr.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := pr.Status.convertFrom(ctx, &amp;source.Status, &amp;pr.ObjectMeta); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return pr.Spec.ConvertFrom(ctx, &amp;source.Spec, &amp;pr.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", pr)</span>
        }
}

// ConvertFrom implements apis.Convertible
func (prs *PipelineRunSpec) ConvertFrom(ctx context.Context, source *v1.PipelineRunSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        if source.PipelineRef != nil </span><span class="cov8" title="1">{
                newPipelineRef := PipelineRef{}
                newPipelineRef.convertFrom(ctx, *source.PipelineRef)
                prs.PipelineRef = &amp;newPipelineRef
        }</span>
        <span class="cov8" title="1">if source.PipelineSpec != nil </span><span class="cov8" title="1">{
                newPipelineSpec := PipelineSpec{}
                err := newPipelineSpec.ConvertFrom(ctx, source.PipelineSpec, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">prs.PipelineSpec = &amp;newPipelineSpec</span>
        }
        <span class="cov8" title="1">prs.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, p)
                prs.Params = append(prs.Params, new)
        }</span>
        <span class="cov8" title="1">prs.ServiceAccountName = source.TaskRunTemplate.ServiceAccountName
        prs.Status = PipelineRunSpecStatus(source.Status)
        if source.Timeouts != nil </span><span class="cov8" title="1">{
                newTimeouts := &amp;TimeoutFields{}
                newTimeouts.convertFrom(ctx, *source.Timeouts)
                prs.Timeouts = newTimeouts
        }</span>
        <span class="cov8" title="1">prs.PodTemplate = source.TaskRunTemplate.PodTemplate
        prs.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspaceBinding{}
                new.ConvertFrom(ctx, w)
                prs.Workspaces = append(prs.Workspaces, new)
        }</span>
        <span class="cov8" title="1">prs.TaskRunSpecs = nil
        for _, trs := range source.TaskRunSpecs </span><span class="cov8" title="1">{
                new := PipelineTaskRunSpec{}
                new.convertFrom(ctx, trs)
                prs.TaskRunSpecs = append(prs.TaskRunSpecs, new)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (tf TimeoutFields) convertTo(ctx context.Context, sink *v1.TimeoutFields) <span class="cov8" title="1">{
        sink.Pipeline = tf.Pipeline
        sink.Tasks = tf.Tasks
        sink.Finally = tf.Finally
}</span>

func (tf *TimeoutFields) convertFrom(ctx context.Context, source v1.TimeoutFields) <span class="cov8" title="1">{
        tf.Pipeline = source.Pipeline
        tf.Tasks = source.Tasks
        tf.Finally = source.Finally
}</span>

func (ptrs PipelineTaskRunSpec) convertTo(ctx context.Context, sink *v1.PipelineTaskRunSpec) <span class="cov8" title="1">{
        sink.PipelineTaskName = ptrs.PipelineTaskName
        sink.ServiceAccountName = ptrs.TaskServiceAccountName
        sink.PodTemplate = ptrs.TaskPodTemplate
        sink.StepSpecs = nil
        for _, so := range ptrs.StepOverrides </span><span class="cov8" title="1">{
                new := v1.TaskRunStepSpec{}
                so.convertTo(ctx, &amp;new)
                sink.StepSpecs = append(sink.StepSpecs, new)
        }</span>
        <span class="cov8" title="1">sink.SidecarSpecs = nil
        for _, so := range ptrs.SidecarOverrides </span><span class="cov8" title="1">{
                new := v1.TaskRunSidecarSpec{}
                so.convertTo(ctx, &amp;new)
                sink.SidecarSpecs = append(sink.SidecarSpecs, new)
        }</span>
        <span class="cov8" title="1">if ptrs.Metadata != nil </span><span class="cov8" title="1">{
                sink.Metadata = &amp;v1.PipelineTaskMetadata{}
                ptrs.Metadata.convertTo(ctx, sink.Metadata)
        }</span>
        <span class="cov8" title="1">sink.ComputeResources = ptrs.ComputeResources
        sink.Timeout = ptrs.Timeout</span>
}

func (ptrs *PipelineTaskRunSpec) convertFrom(ctx context.Context, source v1.PipelineTaskRunSpec) <span class="cov8" title="1">{
        ptrs.PipelineTaskName = source.PipelineTaskName
        ptrs.TaskServiceAccountName = source.ServiceAccountName
        ptrs.TaskPodTemplate = source.PodTemplate
        ptrs.StepOverrides = nil
        for _, so := range source.StepSpecs </span><span class="cov8" title="1">{
                new := TaskRunStepOverride{}
                new.convertFrom(ctx, so)
                ptrs.StepOverrides = append(ptrs.StepOverrides, new)
        }</span>
        <span class="cov8" title="1">ptrs.SidecarOverrides = nil
        for _, so := range source.SidecarSpecs </span><span class="cov8" title="1">{
                new := TaskRunSidecarOverride{}
                new.convertFrom(ctx, so)
                ptrs.SidecarOverrides = append(ptrs.SidecarOverrides, new)
        }</span>
        <span class="cov8" title="1">if source.Metadata != nil </span><span class="cov8" title="1">{
                newMetadata := PipelineTaskMetadata{}
                newMetadata.convertFrom(ctx, *source.Metadata)
                ptrs.Metadata = &amp;newMetadata
        }</span>
        <span class="cov8" title="1">ptrs.ComputeResources = source.ComputeResources
        ptrs.Timeout = source.Timeout</span>
}

func (prs *PipelineRunStatus) convertTo(ctx context.Context, sink *v1.PipelineRunStatus, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        sink.Status = prs.Status
        sink.StartTime = prs.StartTime
        sink.CompletionTime = prs.CompletionTime
        sink.Results = nil
        for _, pr := range prs.PipelineResults </span><span class="cov8" title="1">{
                new := v1.PipelineRunResult{}
                pr.convertTo(ctx, &amp;new)
                sink.Results = append(sink.Results, new)
        }</span>
        <span class="cov8" title="1">if prs.PipelineSpec != nil </span><span class="cov8" title="1">{
                sink.PipelineSpec = &amp;v1.PipelineSpec{}
                err := prs.PipelineSpec.ConvertTo(ctx, sink.PipelineSpec, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">sink.SkippedTasks = nil
        for _, st := range prs.SkippedTasks </span><span class="cov8" title="1">{
                new := v1.SkippedTask{}
                st.convertTo(ctx, &amp;new)
                sink.SkippedTasks = append(sink.SkippedTasks, new)
        }</span>
        <span class="cov8" title="1">sink.ChildReferences = nil
        for _, cr := range prs.ChildReferences </span><span class="cov8" title="1">{
                new := v1.ChildStatusReference{}
                cr.convertTo(ctx, &amp;new)
                sink.ChildReferences = append(sink.ChildReferences, new)
        }</span>
        <span class="cov8" title="1">sink.FinallyStartTime = prs.FinallyStartTime
        if prs.Provenance != nil </span><span class="cov8" title="1">{
                new := v1.Provenance{}
                prs.Provenance.convertTo(ctx, &amp;new)
                sink.Provenance = &amp;new
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (prs *PipelineRunStatus) convertFrom(ctx context.Context, source *v1.PipelineRunStatus, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        prs.Status = source.Status
        prs.StartTime = source.StartTime
        prs.CompletionTime = source.CompletionTime
        prs.PipelineResults = nil
        for _, pr := range source.Results </span><span class="cov8" title="1">{
                new := PipelineRunResult{}
                new.convertFrom(ctx, pr)
                prs.PipelineResults = append(prs.PipelineResults, new)
        }</span>
        <span class="cov8" title="1">if source.PipelineSpec != nil </span><span class="cov8" title="1">{
                newPipelineSpec := PipelineSpec{}
                err := newPipelineSpec.ConvertFrom(ctx, source.PipelineSpec, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">prs.PipelineSpec = &amp;newPipelineSpec</span>
        }
        <span class="cov8" title="1">prs.SkippedTasks = nil
        for _, st := range source.SkippedTasks </span><span class="cov8" title="1">{
                new := SkippedTask{}
                new.convertFrom(ctx, st)
                prs.SkippedTasks = append(prs.SkippedTasks, new)
        }</span>
        <span class="cov8" title="1">prs.ChildReferences = nil
        for _, cr := range source.ChildReferences </span><span class="cov8" title="1">{
                new := ChildStatusReference{}
                new.convertFrom(ctx, cr)
                prs.ChildReferences = append(prs.ChildReferences, new)
        }</span>

        <span class="cov8" title="1">prs.FinallyStartTime = source.FinallyStartTime
        if source.Provenance != nil </span><span class="cov8" title="1">{
                new := Provenance{}
                new.convertFrom(ctx, *source.Provenance)
                prs.Provenance = &amp;new
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (prr PipelineRunResult) convertTo(ctx context.Context, sink *v1.PipelineRunResult) <span class="cov8" title="1">{
        sink.Name = prr.Name
        newValue := v1.ParamValue{}
        prr.Value.convertTo(ctx, &amp;newValue)
        sink.Value = newValue
}</span>

func (prr *PipelineRunResult) convertFrom(ctx context.Context, source v1.PipelineRunResult) <span class="cov8" title="1">{
        prr.Name = source.Name
        newValue := ParamValue{}
        newValue.convertFrom(ctx, source.Value)
        prr.Value = newValue
}</span>

func (st SkippedTask) convertTo(ctx context.Context, sink *v1.SkippedTask) <span class="cov8" title="1">{
        sink.Name = st.Name
        sink.Reason = v1.SkippingReason(st.Reason)
        sink.WhenExpressions = nil
        for _, we := range st.WhenExpressions </span><span class="cov8" title="1">{
                new := v1.WhenExpression{}
                we.convertTo(ctx, &amp;new)
                sink.WhenExpressions = append(sink.WhenExpressions, new)
        }</span>
}

func (st *SkippedTask) convertFrom(ctx context.Context, source v1.SkippedTask) <span class="cov8" title="1">{
        st.Name = source.Name
        st.Reason = SkippingReason(source.Reason)
        st.WhenExpressions = nil
        for _, we := range source.WhenExpressions </span><span class="cov8" title="1">{
                new := WhenExpression{}
                new.convertFrom(ctx, we)
                st.WhenExpressions = append(st.WhenExpressions, new)
        }</span>
}

func (csr ChildStatusReference) convertTo(ctx context.Context, sink *v1.ChildStatusReference) <span class="cov8" title="1">{
        sink.TypeMeta = csr.TypeMeta
        sink.Name = csr.Name
        sink.DisplayName = csr.DisplayName
        sink.PipelineTaskName = csr.PipelineTaskName
        sink.WhenExpressions = nil
        for _, we := range csr.WhenExpressions </span><span class="cov8" title="1">{
                new := v1.WhenExpression{}
                we.convertTo(ctx, &amp;new)
                sink.WhenExpressions = append(sink.WhenExpressions, new)
        }</span>
}

func (csr *ChildStatusReference) convertFrom(ctx context.Context, source v1.ChildStatusReference) <span class="cov8" title="1">{
        csr.TypeMeta = source.TypeMeta
        csr.Name = source.Name
        csr.DisplayName = source.DisplayName
        csr.PipelineTaskName = source.PipelineTaskName
        csr.WhenExpressions = nil
        for _, we := range source.WhenExpressions </span><span class="cov8" title="1">{
                new := WhenExpression{}
                new.convertFrom(ctx, we)
                csr.WhenExpressions = append(csr.WhenExpressions, new)
        }</span>
}

func serializePipelineRunResources(meta *metav1.ObjectMeta, spec *PipelineRunSpec) error <span class="cov8" title="1">{
        if spec.Resources == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, spec.Resources, resourcesAnnotationKey)</span>
}

func deserializePipelineRunResources(meta *metav1.ObjectMeta, spec *PipelineRunSpec) error <span class="cov8" title="1">{
        resources := []PipelineResourceBinding{}
        err := version.DeserializeFromMetadata(meta, &amp;resources, resourcesAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(resources) != 0 </span><span class="cov8" title="1">{
                spec.Resources = resources
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "regexp"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmap"
)

var (
        _                              apis.Defaultable = (*PipelineRun)(nil)
        filterReservedAnnotationRegexp                  = regexp.MustCompile(pipeline.TektonReservedAnnotationExpr)
)

// SetDefaults implements apis.Defaultable
func (pr *PipelineRun) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        pr.Spec.SetDefaults(ctx)

        // Silently filtering out Tekton Reserved annotations at creation
        if apis.IsInCreate(ctx) </span><span class="cov8" title="1">{
                pr.ObjectMeta.Annotations = kmap.Filter(pr.ObjectMeta.Annotations, func(s string) bool </span><span class="cov8" title="1">{
                        return filterReservedAnnotationRegexp.MatchString(s)
                }</span>)
        }
}

// SetDefaults implements apis.Defaultable
func (prs *PipelineRunSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if prs.PipelineRef != nil &amp;&amp; prs.PipelineRef.Name == "" &amp;&amp; prs.PipelineRef.Resolver == "" </span><span class="cov8" title="1">{
                prs.PipelineRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
        }</span>

        <span class="cov8" title="1">if prs.Timeout == nil &amp;&amp; prs.Timeouts == nil </span><span class="cov8" title="1">{
                prs.Timeout = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
        }</span>

        <span class="cov8" title="1">if prs.Timeouts != nil &amp;&amp; prs.Timeouts.Pipeline == nil </span><span class="cov8" title="1">{
                prs.Timeouts.Pipeline = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
        }</span>

        <span class="cov8" title="1">defaultSA := cfg.Defaults.DefaultServiceAccount
        if prs.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                prs.ServiceAccountName = defaultSA
        }</span>

        <span class="cov8" title="1">defaultPodTemplate := cfg.Defaults.DefaultPodTemplate
        prs.PodTemplate = pod.MergePodTemplateWithDefault(prs.PodTemplate, defaultPodTemplate)

        if prs.PipelineSpec != nil </span><span class="cov8" title="1">{
                prs.PipelineSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        apisconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// PipelineRun represents a single execution of a Pipeline. PipelineRuns are how
// the graph of Tasks declared in a Pipeline are executed; they specify inputs
// to Pipelines such as parameter values and capture operational aspects of the
// Tasks execution such as service account and tolerations. Creating a
// PipelineRun creates TaskRuns for Tasks in the referenced Pipeline.
//
// Deprecated: Please use v1.PipelineRun instead.
type PipelineRun struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec PipelineRunSpec `json:"spec,omitempty"`
        // +optional
        Status PipelineRunStatus `json:"status,omitempty"`
}

// GetName Returns the name of the PipelineRun
func (pr *PipelineRun) GetName() string <span class="cov0" title="0">{
        return pr.ObjectMeta.GetName()
}</span>

// GetStatusCondition returns the task run status as a ConditionAccessor
func (pr *PipelineRun) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;pr.Status
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*PipelineRun) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.PipelineRunControllerName)
}</span>

// IsDone returns true if the PipelineRun's status indicates that it is done.
func (pr *PipelineRun) IsDone() bool <span class="cov8" title="1">{
        return !pr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether pipelinerun has valid start time set in its status
func (pr *PipelineRun) HasStarted() bool <span class="cov8" title="1">{
        return pr.Status.StartTime != nil &amp;&amp; !pr.Status.StartTime.IsZero()
}</span>

// IsCancelled returns true if the PipelineRun's spec status is set to Cancelled state
func (pr *PipelineRun) IsCancelled() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusCancelled
}</span>

// IsGracefullyCancelled returns true if the PipelineRun's spec status is set to CancelledRunFinally state
func (pr *PipelineRun) IsGracefullyCancelled() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusCancelledRunFinally
}</span>

// IsGracefullyStopped returns true if the PipelineRun's spec status is set to StoppedRunFinally state
func (pr *PipelineRun) IsGracefullyStopped() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusStoppedRunFinally
}</span>

// PipelineTimeout returns the applicable timeout for the PipelineRun
func (pr *PipelineRun) PipelineTimeout(ctx context.Context) time.Duration <span class="cov8" title="1">{
        if pr.Spec.Timeout != nil </span><span class="cov8" title="1">{
                return pr.Spec.Timeout.Duration
        }</span>
        <span class="cov8" title="1">if pr.Spec.Timeouts != nil &amp;&amp; pr.Spec.Timeouts.Pipeline != nil </span><span class="cov8" title="1">{
                return pr.Spec.Timeouts.Pipeline.Duration
        }</span>
        <span class="cov8" title="1">return time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes) * time.Minute</span>
}

// TasksTimeout returns the tasks timeout for the PipelineRun, if set,
// or the tasks timeout computed from the Pipeline and Finally timeouts, if those are set.
func (pr *PipelineRun) TasksTimeout() *metav1.Duration <span class="cov8" title="1">{
        t := pr.Spec.Timeouts
        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t.Tasks != nil </span><span class="cov8" title="1">{
                return t.Tasks
        }</span>
        <span class="cov8" title="1">if t.Pipeline != nil &amp;&amp; t.Finally != nil </span><span class="cov8" title="1">{
                if t.Pipeline.Duration == apisconfig.NoTimeoutDuration || t.Finally.Duration == apisconfig.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return &amp;metav1.Duration{Duration: (t.Pipeline.Duration - t.Finally.Duration)}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// FinallyTimeout returns the finally timeout for the PipelineRun, if set,
// or the finally timeout computed from the Pipeline and Tasks timeouts, if those are set.
func (pr *PipelineRun) FinallyTimeout() *metav1.Duration <span class="cov8" title="1">{
        t := pr.Spec.Timeouts
        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t.Finally != nil </span><span class="cov8" title="1">{
                return t.Finally
        }</span>
        <span class="cov8" title="1">if t.Pipeline != nil &amp;&amp; t.Tasks != nil </span><span class="cov8" title="1">{
                if t.Pipeline.Duration == apisconfig.NoTimeoutDuration || t.Tasks.Duration == apisconfig.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return &amp;metav1.Duration{Duration: (t.Pipeline.Duration - t.Tasks.Duration)}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsPending returns true if the PipelineRun's spec status is set to Pending state
func (pr *PipelineRun) IsPending() bool <span class="cov8" title="1">{
        return pr.Spec.Status == PipelineRunSpecStatusPending
}</span>

// GetNamespacedName returns a k8s namespaced name that identifies this PipelineRun
func (pr *PipelineRun) GetNamespacedName() types.NamespacedName <span class="cov8" title="1">{
        return types.NamespacedName{Namespace: pr.Namespace, Name: pr.Name}
}</span>

// IsTimeoutConditionSet returns true when the pipelinerun has the pipelinerun timed out reason
func (pr *PipelineRun) IsTimeoutConditionSet() bool <span class="cov8" title="1">{
        condition := pr.Status.GetCondition(apis.ConditionSucceeded)
        return condition.IsFalse() &amp;&amp; condition.Reason == PipelineRunReasonTimedOut.String()
}</span>

// SetTimeoutCondition sets the status of the PipelineRun to timed out.
func (pr *PipelineRun) SetTimeoutCondition(ctx context.Context) <span class="cov8" title="1">{
        pr.Status.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionFalse,
                Reason:  PipelineRunReasonTimedOut.String(),
                Message: fmt.Sprintf("PipelineRun %q failed to finish within %q", pr.Name, pr.PipelineTimeout(ctx).String()),
        })
}</span>

// HasTimedOut returns true if a pipelinerun has exceeded its spec.Timeout based on its status.Timeout
func (pr *PipelineRun) HasTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.PipelineTimeout(ctx)
        startTime := pr.Status.StartTime

        if !startTime.IsZero() </span><span class="cov8" title="1">{
                if timeout == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasTimedOutForALongTime returns true if a pipelinerun has exceeed its spec.Timeout based its status.StartTime
// by a large margin
func (pr *PipelineRun) HasTimedOutForALongTime(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        if !pr.HasTimedOut(ctx, c) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := pr.PipelineTimeout(ctx)
        startTime := pr.Status.StartTime
        runtime := c.Since(startTime.Time)
        // We are arbitrarily defining large margin as doubling the spec.timeout
        return runtime &gt;= 2*timeout</span>
}

// HaveTasksTimedOut returns true if a pipelinerun has exceeded its spec.Timeouts.Tasks
func (pr *PipelineRun) HaveTasksTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.TasksTimeout()
        startTime := pr.Status.StartTime

        if !startTime.IsZero() &amp;&amp; timeout != nil </span><span class="cov8" title="1">{
                if timeout.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout.Duration </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasFinallyTimedOut returns true if a pipelinerun has exceeded its spec.Timeouts.Finally, based on status.FinallyStartTime
func (pr *PipelineRun) HasFinallyTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        timeout := pr.FinallyTimeout()
        startTime := pr.Status.FinallyStartTime

        if startTime != nil &amp;&amp; !startTime.IsZero() &amp;&amp; timeout != nil </span><span class="cov8" title="1">{
                if timeout.Duration == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">runtime := c.Since(startTime.Time)
                if runtime &gt; timeout.Duration </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasVolumeClaimTemplate returns true if PipelineRun contains volumeClaimTemplates that is
// used for creating PersistentVolumeClaims with an OwnerReference for each run
func (pr *PipelineRun) HasVolumeClaimTemplate() bool <span class="cov8" title="1">{
        for _, ws := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                if ws.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// PipelineRunSpec defines the desired state of PipelineRun
type PipelineRunSpec struct {
        // +optional
        PipelineRef *PipelineRef `json:"pipelineRef,omitempty"`
        // Specifying PipelineSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Pipeline.spec (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`
        // Resources is a list of bindings specifying which actual instances of
        // PipelineResources to use for the resources the Pipeline has declared
        // it needs.
        //
        // Deprecated: Unused, preserved only for backwards compatibility
        // +listType=atomic
        Resources []PipelineResourceBinding `json:"resources,omitempty"`
        // Params is a list of parameter names and values.
        Params Params `json:"params,omitempty"`
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`

        // Used for cancelling a pipelinerun (and maybe more later on)
        // +optional
        Status PipelineRunSpecStatus `json:"status,omitempty"`
        // Time after which the Pipeline times out.
        // Currently three keys are accepted in the map
        // pipeline, tasks and finally
        // with Timeouts.pipeline &gt;= Timeouts.tasks + Timeouts.finally
        // +optional
        Timeouts *TimeoutFields `json:"timeouts,omitempty"`

        // Timeout is the Time after which the Pipeline times out.
        // Defaults to never.
        // Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        //
        // Deprecated: use pipelineRunSpec.Timeouts.Pipeline instead
        //
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`
        // PodTemplate holds pod specific configuration
        PodTemplate *pod.PodTemplate `json:"podTemplate,omitempty"`
        // Workspaces holds a set of workspace bindings that must match names
        // with those declared in the pipeline.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceBinding `json:"workspaces,omitempty"`
        // TaskRunSpecs holds a set of runtime specs
        // +optional
        // +listType=atomic
        TaskRunSpecs []PipelineTaskRunSpec `json:"taskRunSpecs,omitempty"`
}

// TimeoutFields allows granular specification of pipeline, task, and finally timeouts
type TimeoutFields struct {
        // Pipeline sets the maximum allowed duration for execution of the entire pipeline. The sum of individual timeouts for tasks and finally must not exceed this value.
        Pipeline *metav1.Duration `json:"pipeline,omitempty"`
        // Tasks sets the maximum allowed duration of this pipeline's tasks
        Tasks *metav1.Duration `json:"tasks,omitempty"`
        // Finally sets the maximum allowed duration of this pipeline's finally
        Finally *metav1.Duration `json:"finally,omitempty"`
}

// PipelineRunSpecStatus defines the pipelinerun spec status the user can provide
type PipelineRunSpecStatus string

const (
        // PipelineRunSpecStatusCancelled indicates that the user wants to cancel the task,
        // if not already cancelled or terminated
        PipelineRunSpecStatusCancelled = "Cancelled"

        // PipelineRunSpecStatusCancelledRunFinally indicates that the user wants to cancel the pipeline run,
        // if not already cancelled or terminated, but ensure finally is run normally
        PipelineRunSpecStatusCancelledRunFinally = "CancelledRunFinally"

        // PipelineRunSpecStatusStoppedRunFinally indicates that the user wants to stop the pipeline run,
        // wait for already running tasks to be completed and run finally
        // if not already cancelled or terminated
        PipelineRunSpecStatusStoppedRunFinally = "StoppedRunFinally"

        // PipelineRunSpecStatusPending indicates that the user wants to postpone starting a PipelineRun
        // until some condition is met
        PipelineRunSpecStatusPending = "PipelineRunPending"
)

// PipelineRunStatus defines the observed state of PipelineRun
type PipelineRunStatus struct {
        duckv1.Status `json:",inline"`

        // PipelineRunStatusFields inlines the status fields.
        PipelineRunStatusFields `json:",inline"`
}

// PipelineRunReason represents a reason for the pipeline run "Succeeded" condition
type PipelineRunReason string

const (
        // PipelineRunReasonStarted is the reason set when the PipelineRun has just started
        PipelineRunReasonStarted PipelineRunReason = "Started"
        // PipelineRunReasonRunning is the reason set when the PipelineRun is running
        PipelineRunReasonRunning PipelineRunReason = "Running"
        // PipelineRunReasonSuccessful is the reason set when the PipelineRun completed successfully
        PipelineRunReasonSuccessful PipelineRunReason = "Succeeded"
        // PipelineRunReasonCompleted is the reason set when the PipelineRun completed successfully with one or more skipped Tasks
        PipelineRunReasonCompleted PipelineRunReason = "Completed"
        // PipelineRunReasonFailed is the reason set when the PipelineRun completed with a failure
        PipelineRunReasonFailed PipelineRunReason = "Failed"
        // PipelineRunReasonCancelled is the reason set when the PipelineRun cancelled by the user
        // This reason may be found with a corev1.ConditionFalse status, if the cancellation was processed successfully
        // This reason may be found with a corev1.ConditionUnknown status, if the cancellation is being processed or failed
        PipelineRunReasonCancelled PipelineRunReason = "Cancelled"
        // PipelineRunReasonPending is the reason set when the PipelineRun is in the pending state
        PipelineRunReasonPending PipelineRunReason = "PipelineRunPending"
        // PipelineRunReasonTimedOut is the reason set when the PipelineRun has timed out
        PipelineRunReasonTimedOut PipelineRunReason = "PipelineRunTimeout"
        // PipelineRunReasonStopping indicates that no new Tasks will be scheduled by the controller, and the
        // pipeline will stop once all running tasks complete their work
        PipelineRunReasonStopping PipelineRunReason = "PipelineRunStopping"
        // PipelineRunReasonCancelledRunningFinally indicates that pipeline has been gracefully cancelled
        // and no new Tasks will be scheduled by the controller, but final tasks are now running
        PipelineRunReasonCancelledRunningFinally PipelineRunReason = "CancelledRunningFinally"
        // PipelineRunReasonStoppedRunningFinally indicates that pipeline has been gracefully stopped
        // and no new Tasks will be scheduled by the controller, but final tasks are now running
        PipelineRunReasonStoppedRunningFinally PipelineRunReason = "StoppedRunningFinally"
)

func (t PipelineRunReason) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

var pipelineRunCondSet = apis.NewBatchConditionSet()

// GetCondition returns the Condition matching the given type.
func (pr *PipelineRunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return pipelineRunCondSet.Manage(pr).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in pipelineRunCondSet to unknown for the PipelineRun
// and set the started time to the current time
func (pr *PipelineRunStatus) InitializeConditions(c clock.PassiveClock) <span class="cov8" title="1">{
        started := false
        if pr.StartTime.IsZero() </span><span class="cov8" title="1">{
                pr.StartTime = &amp;metav1.Time{Time: c.Now()}
                started = true
        }</span>
        <span class="cov8" title="1">conditionManager := pipelineRunCondSet.Manage(pr)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov8" title="1">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = PipelineRunReasonStarted.String()
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (pr *PipelineRunStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                pipelineRunCondSet.Manage(pr).SetCondition(*newCond)
        }</span>
}

// MarkSucceeded changes the Succeeded condition to True with the provided reason and message.
func (pr *PipelineRunStatus) MarkSucceeded(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        pipelineRunCondSet.Manage(pr).MarkTrueWithReason(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := pr.GetCondition(apis.ConditionSucceeded)
        pr.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkFailed changes the Succeeded condition to False with the provided reason and message.
func (pr *PipelineRunStatus) MarkFailed(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        pipelineRunCondSet.Manage(pr).MarkFalse(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := pr.GetCondition(apis.ConditionSucceeded)
        pr.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkRunning changes the Succeeded condition to Unknown with the provided reason and message.
func (pr *PipelineRunStatus) MarkRunning(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        pipelineRunCondSet.Manage(pr).MarkUnknown(apis.ConditionSucceeded, reason, messageFormat, messageA...)
}</span>

// ChildStatusReference is used to point to the statuses of individual TaskRuns and Runs within this PipelineRun.
type ChildStatusReference struct {
        runtime.TypeMeta `json:",inline"`
        // Name is the name of the TaskRun or Run this is referencing.
        Name string `json:"name,omitempty"`
        // DisplayName is a user-facing name of the pipelineTask that may be
        // used to populate a UI.
        DisplayName string `json:"displayName,omitempty"`
        // PipelineTaskName is the name of the PipelineTask this is referencing.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`

        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// PipelineRunStatusFields holds the fields of PipelineRunStatus' status.
// This is defined separately and inlined so that other types can readily
// consume these fields via duck typing.
type PipelineRunStatusFields struct {
        // StartTime is the time the PipelineRun is actually started.
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the PipelineRun completed.
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // TaskRuns is a map of PipelineRunTaskRunStatus with the taskRun name as the key.
        //
        // Deprecated: use ChildReferences instead. As of v0.45.0, this field is no
        // longer populated and is only included for backwards compatibility with
        // older server versions.
        // +optional
        TaskRuns map[string]*PipelineRunTaskRunStatus `json:"taskRuns,omitempty"`

        // Runs is a map of PipelineRunRunStatus with the run name as the key
        //
        // Deprecated: use ChildReferences instead. As of v0.45.0, this field is no
        // longer populated and is only included for backwards compatibility with
        // older server versions.
        // +optional
        Runs map[string]*PipelineRunRunStatus `json:"runs,omitempty"`

        // PipelineResults are the list of results written out by the pipeline task's containers
        // +optional
        // +listType=atomic
        PipelineResults []PipelineRunResult `json:"pipelineResults,omitempty"`

        // PipelineSpec contains the exact spec used to instantiate the run.
        // See Pipeline.spec (API version: tekton.dev/v1beta1)
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        PipelineSpec *PipelineSpec `json:"pipelineSpec,omitempty"`

        // list of tasks that were skipped due to when expressions evaluating to false
        // +optional
        // +listType=atomic
        SkippedTasks []SkippedTask `json:"skippedTasks,omitempty"`

        // list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.
        // +optional
        // +listType=atomic
        ChildReferences []ChildStatusReference `json:"childReferences,omitempty"`

        // FinallyStartTime is when all non-finally tasks have been completed and only finally tasks are being executed.
        // +optional
        FinallyStartTime *metav1.Time `json:"finallyStartTime,omitempty"`

        // Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
        // +optional
        Provenance *Provenance `json:"provenance,omitempty"`

        // SpanContext contains tracing span context fields
        SpanContext map[string]string `json:"spanContext,omitempty"`
}

// SkippedTask is used to describe the Tasks that were skipped due to their When Expressions
// evaluating to False. This is a struct because we are looking into including more details
// about the When Expressions that caused this Task to be skipped.
type SkippedTask struct {
        // Name is the Pipeline Task name
        Name string `json:"name"`
        // Reason is the cause of the PipelineTask being skipped.
        Reason SkippingReason `json:"reason"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// SkippingReason explains why a PipelineTask was skipped.
type SkippingReason string

const (
        // WhenExpressionsSkip means the task was skipped due to at least one of its when expressions evaluating to false
        WhenExpressionsSkip SkippingReason = "When Expressions evaluated to false"
        // ParentTasksSkip means the task was skipped because its parent was skipped
        ParentTasksSkip SkippingReason = "Parent Tasks were skipped"
        // StoppingSkip means the task was skipped because the pipeline run is stopping
        StoppingSkip SkippingReason = "PipelineRun was stopping"
        // GracefullyCancelledSkip means the task was skipped because the pipeline run has been gracefully cancelled
        GracefullyCancelledSkip SkippingReason = "PipelineRun was gracefully cancelled"
        // GracefullyStoppedSkip means the task was skipped because the pipeline run has been gracefully stopped
        GracefullyStoppedSkip SkippingReason = "PipelineRun was gracefully stopped"
        // MissingResultsSkip means the task was skipped because it's missing necessary results
        MissingResultsSkip SkippingReason = "Results were missing"
        // PipelineTimedOutSkip means the task was skipped because the PipelineRun has passed its overall timeout.
        PipelineTimedOutSkip SkippingReason = "PipelineRun timeout has been reached"
        // TasksTimedOutSkip means the task was skipped because the PipelineRun has passed its Timeouts.Tasks.
        TasksTimedOutSkip SkippingReason = "PipelineRun Tasks timeout has been reached"
        // FinallyTimedOutSkip means the task was skipped because the PipelineRun has passed its Timeouts.Finally.
        FinallyTimedOutSkip SkippingReason = "PipelineRun Finally timeout has been reached"
        // EmptyArrayInMatrixParams means the task was skipped because Matrix parameters contain empty array.
        EmptyArrayInMatrixParams SkippingReason = "Matrix Parameters have an empty array"
        // None means the task was not skipped
        None SkippingReason = "None"
)

// PipelineRunResult used to describe the results of a pipeline
type PipelineRunResult struct {
        // Name is the result's name as declared by the Pipeline
        Name string `json:"name"`

        // Value is the result returned from the execution of this PipelineRun
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// PipelineRunTaskRunStatus contains the name of the PipelineTask for this TaskRun and the TaskRun's Status
type PipelineRunTaskRunStatus struct {
        // PipelineTaskName is the name of the PipelineTask.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`
        // Status is the TaskRunStatus for the corresponding TaskRun
        // +optional
        Status *TaskRunStatus `json:"status,omitempty"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// PipelineRunRunStatus contains the name of the PipelineTask for this CustomRun or Run and the CustomRun or Run's Status
type PipelineRunRunStatus struct {
        // PipelineTaskName is the name of the PipelineTask.
        PipelineTaskName string `json:"pipelineTaskName,omitempty"`
        // Status is the CustomRunStatus for the corresponding CustomRun or Run
        // +optional
        Status *CustomRunStatus `json:"status,omitempty"`
        // WhenExpressions is the list of checks guarding the execution of the PipelineTask
        // +optional
        // +listType=atomic
        WhenExpressions []WhenExpression `json:"whenExpressions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// PipelineRunList contains a list of PipelineRun
type PipelineRunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []PipelineRun `json:"items,omitempty"`
}

// PipelineTaskRun reports the results of running a step in the Task. Each
// task has the potential to succeed or fail (based on the exit code)
// and produces logs.
type PipelineTaskRun struct {
        Name string `json:"name,omitempty"`
}

// PipelineTaskRunSpec  can be used to configure specific
// specs for a concrete Task
type PipelineTaskRunSpec struct {
        PipelineTaskName       string           `json:"pipelineTaskName,omitempty"`
        TaskServiceAccountName string           `json:"taskServiceAccountName,omitempty"`
        TaskPodTemplate        *pod.PodTemplate `json:"taskPodTemplate,omitempty"`
        // +listType=atomic
        StepOverrides []TaskRunStepOverride `json:"stepOverrides,omitempty"`
        // +listType=atomic
        SidecarOverrides []TaskRunSidecarOverride `json:"sidecarOverrides,omitempty"`

        // +optional
        Metadata *PipelineTaskMetadata `json:"metadata,omitempty"`

        // Compute resources to use for this TaskRun
        ComputeResources *corev1.ResourceRequirements `json:"computeResources,omitempty"`

        // Duration after which the TaskRun times out.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`
}

// GetTaskRunSpec returns the task specific spec for a given
// PipelineTask if configured, otherwise it returns the PipelineRun's default.
func (pr *PipelineRun) GetTaskRunSpec(pipelineTaskName string) PipelineTaskRunSpec <span class="cov8" title="1">{
        s := PipelineTaskRunSpec{
                PipelineTaskName:       pipelineTaskName,
                TaskServiceAccountName: pr.Spec.ServiceAccountName,
                TaskPodTemplate:        pr.Spec.PodTemplate,
        }
        for _, task := range pr.Spec.TaskRunSpecs </span><span class="cov8" title="1">{
                if task.PipelineTaskName == pipelineTaskName </span><span class="cov8" title="1">{
                        // merge podTemplates specified in pipelineRun.spec.taskRunSpecs[].podTemplate and pipelineRun.spec.podTemplate
                        // with taskRunSpecs taking higher precedence
                        s.TaskPodTemplate = pod.MergePodTemplateWithDefault(task.TaskPodTemplate, s.TaskPodTemplate)
                        if task.TaskServiceAccountName != "" </span><span class="cov8" title="1">{
                                s.TaskServiceAccountName = task.TaskServiceAccountName
                        }</span>
                        <span class="cov8" title="1">s.StepOverrides = task.StepOverrides
                        s.SidecarOverrides = task.SidecarOverrides
                        s.Metadata = task.Metadata
                        s.ComputeResources = task.ComputeResources
                        s.Timeout = task.Timeout</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable = (*PipelineRun)(nil)
        _ resourcesemantics.VerbLimited
)

// SupportedVerbs returns the operations that validation should be called for
func (pr *PipelineRun) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate pipelinerun
func (pr *PipelineRun) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">errs := validate.ObjectMetadata(pr.GetObjectMeta()).ViaField("metadata")

        if pr.IsPending() &amp;&amp; pr.HasStarted() </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("PipelineRun cannot be Pending after it is started", "spec.status"))
        }</span>

        <span class="cov8" title="1">return errs.Also(pr.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))</span>
}

// Validate pipelinerun spec
func (ps *PipelineRunSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate the spec changes
        errs = errs.Also(ps.ValidateUpdate(ctx))

        // Must have exactly one of pipelineRef and pipelineSpec.
        if ps.PipelineRef == nil &amp;&amp; ps.PipelineSpec == nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("pipelineRef", "pipelineSpec"))
        }</span>
        <span class="cov8" title="1">if ps.PipelineRef != nil &amp;&amp; ps.PipelineSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("pipelineRef", "pipelineSpec"))
        }</span>

        // Validate PipelineRef if it's present
        <span class="cov8" title="1">if ps.PipelineRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ps.PipelineRef.Validate(ctx).ViaField("pipelineRef"))
        }</span>

        // Validate PipelineSpec if it's present
        <span class="cov8" title="1">if ps.PipelineSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "pipelinerun") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("pipelineSpec"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(ps.PipelineSpec.Validate(ctx).ViaField("pipelineSpec"))</span>
        }

        // Validate PipelineRun parameters
        <span class="cov8" title="1">errs = errs.Also(ps.validatePipelineRunParameters(ctx))

        // Validate propagated parameters
        errs = errs.Also(ps.validateInlineParameters(ctx))
        // Validate propagated workspaces
        errs = errs.Also(ps.validatePropagatedWorkspaces(ctx))

        if ps.Timeout != nil </span><span class="cov8" title="1">{
                // timeout should be a valid duration of at least 0.
                if ps.Timeout.Duration &lt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(ps.Timeout.Duration.String()+" should be &gt;= 0", "timeout"))
                }</span>
        }

        <span class="cov8" title="1">if ps.Timeouts != nil </span><span class="cov8" title="1">{
                if ps.Timeout != nil </span><span class="cov8" title="1">{
                        // can't have both at the same time
                        errs = errs.Also(apis.ErrDisallowedFields("timeout", "timeouts"))
                }</span>

                // tasks timeout should be a valid duration of at least 0.
                <span class="cov8" title="1">errs = errs.Also(validateTimeoutDuration("tasks", ps.Timeouts.Tasks))

                // finally timeout should be a valid duration of at least 0.
                errs = errs.Also(validateTimeoutDuration("finally", ps.Timeouts.Finally))

                // pipeline timeout should be a valid duration of at least 0.
                errs = errs.Also(validateTimeoutDuration("pipeline", ps.Timeouts.Pipeline))

                if ps.Timeouts.Pipeline != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(ps.validatePipelineTimeout(ps.Timeouts.Pipeline.Duration, "should be &lt;= pipeline duration"))
                }</span> else<span class="cov8" title="1"> {
                        defaultTimeout := time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes)
                        errs = errs.Also(ps.validatePipelineTimeout(defaultTimeout, "should be &lt;= default timeout duration"))
                }</span>
        }

        <span class="cov8" title="1">errs = errs.Also(validateSpecStatus(ps.Status))

        if ps.Workspaces != nil </span><span class="cov8" title="1">{
                wsNames := make(map[string]int)
                for idx, ws := range ps.Workspaces </span><span class="cov8" title="1">{
                        errs = errs.Also(ws.Validate(ctx).ViaFieldIndex("workspaces", idx))
                        if prevIdx, alreadyExists := wsNames[ws.Name]; alreadyExists </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace %q provided by pipelinerun more than once, at index %d and %d", ws.Name, prevIdx, idx), "name").ViaFieldIndex("workspaces", idx))
                        }</span>
                        <span class="cov8" title="1">wsNames[ws.Name] = idx</span>
                }
        }
        <span class="cov8" title="1">for idx, trs := range ps.TaskRunSpecs </span><span class="cov8" title="1">{
                errs = errs.Also(validateTaskRunSpec(ctx, trs, ps.Timeouts).ViaIndex(idx).ViaField("taskRunSpecs"))
        }</span>
        <span class="cov8" title="1">if ps.PodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *ps.PodTemplate))
        }</span>
        <span class="cov8" title="1">if ps.Resources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("resources"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateUpdate validates the update of a PipelineRunSpec
func (ps *PipelineRunSpec) ValidateUpdate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">oldObj, ok := apis.GetBaseline(ctx).(*PipelineRun)
        if !ok || oldObj == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if oldObj.IsDone() </span><span class="cov8" title="1">{
                // try comparing without any copying first
                // this handles the common case where only finalizers changed
                if equality.Semantic.DeepEqual(&amp;oldObj.Spec, ps) </span><span class="cov8" title="1">{
                        return nil // Specs identical, allow update
                }</span>

                // Specs differ, this could be due to different defaults after upgrade
                // Apply current defaults to old spec to normalize
                <span class="cov8" title="1">oldCopy := oldObj.Spec.DeepCopy()
                oldCopy.SetDefaults(ctx)

                if equality.Semantic.DeepEqual(oldCopy, ps) </span><span class="cov0" title="0">{
                        return nil // Difference was only defaults, allow update
                }</span>

                // Real spec changes detected, reject update
                <span class="cov8" title="1">errs = errs.Also(apis.ErrInvalidValue("Once the PipelineRun is complete, no updates are allowed", ""))
                return errs</span>
        }

        // Handle started but not done case
        <span class="cov8" title="1">old := oldObj.Spec.DeepCopy()
        old.Status = ps.Status
        if !equality.Semantic.DeepEqual(old, ps) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("Once the PipelineRun has started, only status updates are allowed", ""))
        }</span>

        <span class="cov8" title="1">return</span>
}

func (ps *PipelineRunSpec) validatePipelineRunParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(ps.Params) == 0 </span><span class="cov8" title="1">{
                return errs
        }</span>

        // Validate parameter types and uniqueness
        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ps.Params).ViaField("params"))

        // Validate that task results aren't used in param values
        for _, param := range ps.Params </span><span class="cov8" title="1">{
                expressions, ok := GetVarSubstitutionExpressionsForParam(param)
                if ok </span><span class="cov8" title="1">{
                        if LooksLikeContainsResultRefs(expressions) </span><span class="cov8" title="1">{
                                expressions = filter(expressions, resultref.LooksLikeResultRef)
                                resultRefs := NewResultRefs(expressions)
                                if len(resultRefs) &gt; 0 </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("cannot use result expressions in %v as PipelineRun parameter values", expressions),
                                                "value").ViaFieldKey("params", param.Name))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// validatePropagatedWorkspaces validates workspaces that are propagated.
func (ps *PipelineRunSpec) validatePropagatedWorkspaces(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ps.PipelineSpec == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">workspaceNames := sets.NewString()
        for _, w := range ps.Workspaces </span><span class="cov8" title="1">{
                workspaceNames.Insert(w.Name)
        }</span>

        <span class="cov8" title="1">for _, w := range ps.PipelineSpec.Workspaces </span><span class="cov8" title="1">{
                workspaceNames.Insert(w.Name)
        }</span>

        <span class="cov8" title="1">for i, pt := range ps.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                for _, w := range pt.Workspaces </span><span class="cov8" title="1">{
                        workspaceNames.Insert(w.Name)
                }</span>
                <span class="cov8" title="1">errs = errs.Also(pt.validateWorkspaces(workspaceNames).ViaIndex(i))</span>
        }
        <span class="cov8" title="1">for i, pt := range ps.PipelineSpec.Finally </span><span class="cov8" title="1">{
                for _, w := range pt.Workspaces </span><span class="cov8" title="1">{
                        workspaceNames.Insert(w.Name)
                }</span>
                <span class="cov8" title="1">errs = errs.Also(pt.validateWorkspaces(workspaceNames).ViaIndex(i))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateInlineParameters validates parameters that are defined inline.
// This is crucial for propagated parameters since the parameters could
// be defined under pipelineRun and then called directly in the task steps.
// In this case, parameters cannot be validated by the underlying pipelineSpec
// or taskSpec since they may not have the parameters declared because of propagation.
func (ps *PipelineRunSpec) validateInlineParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ps.PipelineSpec == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">paramSpecForValidation := make(map[string]ParamSpec)
        for _, p := range ps.Params </span><span class="cov8" title="1">{
                paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
        }</span>
        <span class="cov8" title="1">for _, p := range ps.PipelineSpec.Params </span><span class="cov8" title="1">{
                var err *apis.FieldError
                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                if err != nil </span><span class="cov0" title="0">{
                        errs = errs.Also(err)
                }</span>
        }
        <span class="cov8" title="1">for _, pt := range ps.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                paramSpecForValidation = appendPipelineTaskParams(paramSpecForValidation, pt.Params)
                if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Params != nil </span><span class="cov8" title="1">{
                        for _, p := range pt.TaskSpec.Params </span><span class="cov8" title="1">{
                                var err *apis.FieldError
                                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = errs.Also(err)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">var paramSpec []ParamSpec
        for _, v := range paramSpecForValidation </span><span class="cov8" title="1">{
                paramSpec = append(paramSpec, v)
        }</span>
        <span class="cov8" title="1">if ps.PipelineSpec != nil &amp;&amp; ps.PipelineSpec.Tasks != nil </span><span class="cov8" title="1">{
                for _, pt := range ps.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                        if pt.TaskSpec != nil &amp;&amp; pt.TaskSpec.Steps != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(ValidateParameterTypes(ctx, paramSpec))
                                errs = errs.Also(ValidateParameterVariables(ctx, pt.TaskSpec.Steps, paramSpec))
                                errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, pt.TaskSpec.Steps, paramSpec))
                        }</span>
                }
                <span class="cov8" title="1">errs = errs.Also(ValidatePipelineParameterVariables(ctx, ps.PipelineSpec.Tasks, paramSpec))
                errs = errs.Also(validatePipelineTaskParameterUsage(ps.PipelineSpec.Tasks, paramSpec))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func appendPipelineTaskParams(paramSpecForValidation map[string]ParamSpec, params Params) map[string]ParamSpec <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                if pSpec, ok := paramSpecForValidation[p.Name]; ok </span><span class="cov8" title="1">{
                        if p.Value.ObjectVal != nil </span><span class="cov8" title="1">{
                                for k, v := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                                        pSpec.Default.ObjectVal[k] = v
                                        pSpec.Properties[k] = PropertySpec{Type: ParamTypeString}
                                }</span>
                        }
                        <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec</span>
                } else<span class="cov8" title="1"> {
                        paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
                }</span>
        }
        <span class="cov8" title="1">return paramSpecForValidation</span>
}

func validateSpecStatus(status PipelineRunSpecStatus) *apis.FieldError <span class="cov8" title="1">{
        switch status </span>{
        case "":<span class="cov8" title="1">
                return nil</span>
        case PipelineRunSpecStatusPending:<span class="cov8" title="1">
                return nil</span>
        case PipelineRunSpecStatusCancelled,
                PipelineRunSpecStatusCancelledRunFinally,
                PipelineRunSpecStatusStoppedRunFinally:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">return apis.ErrInvalidValue(fmt.Sprintf("%s should be %s, %s, %s or %s", status,
                PipelineRunSpecStatusCancelled,
                PipelineRunSpecStatusCancelledRunFinally,
                PipelineRunSpecStatusStoppedRunFinally,
                PipelineRunSpecStatusPending), "status")</span>
}

func validateTimeoutDuration(field string, d *metav1.Duration) (errs *apis.FieldError) <span class="cov8" title="1">{
        if d != nil &amp;&amp; d.Duration &lt; 0 </span><span class="cov8" title="1">{
                fieldPath := "timeouts." + field
                return errs.Also(apis.ErrInvalidValue(d.Duration.String()+" should be &gt;= 0", fieldPath))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ps *PipelineRunSpec) validatePipelineTimeout(timeout time.Duration, errorMsg string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ps.Timeouts.Tasks != nil </span><span class="cov8" title="1">{
                tasksTimeoutErr := false
                tasksTimeoutStr := ps.Timeouts.Tasks.Duration.String()
                if ps.Timeouts.Tasks.Duration &gt; timeout &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        tasksTimeoutErr = true
                }</span>
                <span class="cov8" title="1">if ps.Timeouts.Tasks.Duration == config.NoTimeoutDuration &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        tasksTimeoutErr = true
                        tasksTimeoutStr += " (no timeout)"
                }</span>
                <span class="cov8" title="1">if tasksTimeoutErr </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s %s", tasksTimeoutStr, errorMsg), "timeouts.tasks"))
                }</span>
        }

        <span class="cov8" title="1">if ps.Timeouts.Finally != nil </span><span class="cov8" title="1">{
                finallyTimeoutErr := false
                finallyTimeoutStr := ps.Timeouts.Finally.Duration.String()
                if ps.Timeouts.Finally.Duration &gt; timeout &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        finallyTimeoutErr = true
                }</span>
                <span class="cov8" title="1">if ps.Timeouts.Finally.Duration == config.NoTimeoutDuration &amp;&amp; timeout != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        finallyTimeoutErr = true
                        finallyTimeoutStr += " (no timeout)"
                }</span>
                <span class="cov8" title="1">if finallyTimeoutErr </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s %s", finallyTimeoutStr, errorMsg), "timeouts.finally"))
                }</span>
        }

        <span class="cov8" title="1">if ps.Timeouts.Tasks != nil &amp;&amp; ps.Timeouts.Finally != nil </span><span class="cov8" title="1">{
                if ps.Timeouts.Tasks.Duration+ps.Timeouts.Finally.Duration &gt; timeout </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s + %s %s", ps.Timeouts.Tasks.Duration.String(), ps.Timeouts.Finally.Duration.String(), errorMsg), "timeouts.tasks"))
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s + %s %s", ps.Timeouts.Tasks.Duration.String(), ps.Timeouts.Finally.Duration.String(), errorMsg), "timeouts.finally"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateTaskRunSpec(ctx context.Context, trs PipelineTaskRunSpec, pipelineTimeouts *TimeoutFields) (errs *apis.FieldError) <span class="cov8" title="1">{
        if trs.StepOverrides != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "stepOverrides", config.BetaAPIFields).ViaField("stepOverrides"))
                errs = errs.Also(validateStepOverrides(trs.StepOverrides).ViaField("stepOverrides"))
        }</span>
        <span class="cov8" title="1">if trs.SidecarOverrides != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecarOverrides", config.BetaAPIFields).ViaField("sidecarOverrides"))
                errs = errs.Also(validateSidecarOverrides(trs.SidecarOverrides).ViaField("sidecarOverrides"))
        }</span>
        <span class="cov8" title="1">if trs.ComputeResources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "computeResources", config.BetaAPIFields).ViaField("computeResources"))
                errs = errs.Also(validateTaskRunComputeResources(trs.ComputeResources, trs.StepOverrides))
        }</span>
        <span class="cov8" title="1">if trs.TaskPodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *trs.TaskPodTemplate))
        }</span>

        // Check taskRunSpec timeout against pipeline limits
        <span class="cov8" title="1">errs = errs.Also(validateTaskRunSpecTimeout(ctx, trs.Timeout, pipelineTimeouts))

        return errs</span>
}

// validateTaskRunSpecTimeout validates a TaskRunSpec's timeout against pipeline timeouts.
// This function works in isolation and doesn't rely on previous validation steps.
func validateTaskRunSpecTimeout(ctx context.Context, timeout *metav1.Duration, pipelineTimeouts *TimeoutFields) *apis.FieldError <span class="cov8" title="1">{
        if timeout == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)
        var errs *apis.FieldError

        // Validate basic timeout (negative values)
        _, err := validateTimeout(timeout, cfg.Defaults.DefaultTimeoutMinutes)
        if err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(err)
        }</span>

        // Validate timeout against effective pipeline timeout (explicit or default)
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                // Find applicable timeout limit: Tasks -&gt; Pipeline -&gt; Default (60min)
                var maxTimeout *metav1.Duration
                var timeoutSource string

                switch </span>{
                case pipelineTimeouts != nil &amp;&amp; pipelineTimeouts.Tasks != nil:<span class="cov8" title="1">
                        if validatedTimeout, err := validateTimeout(pipelineTimeouts.Tasks, cfg.Defaults.DefaultTimeoutMinutes); err != nil </span><span class="cov0" title="0">{
                                // Add error if Tasks timeout is invalid (prevents silent failures)
                                errs = errs.Also(err)
                        }</span> else<span class="cov8" title="1"> {
                                maxTimeout = validatedTimeout
                                timeoutSource = "pipeline tasks duration"
                        }</span>
                case pipelineTimeouts != nil &amp;&amp; pipelineTimeouts.Pipeline != nil:<span class="cov8" title="1">
                        if validatedTimeout, err := validateTimeout(pipelineTimeouts.Pipeline, cfg.Defaults.DefaultTimeoutMinutes); err != nil </span><span class="cov0" title="0">{
                                // Add error if Pipeline timeout is invalid (prevents silent failures)
                                errs = errs.Also(err)
                        }</span> else<span class="cov8" title="1"> {
                                maxTimeout = validatedTimeout
                                timeoutSource = "pipeline duration"
                        }</span>
                default:<span class="cov8" title="1">
                        maxTimeout = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
                        timeoutSource = "default pipeline duration"</span>
                }

                // Always check against max timeout if it's not "no timeout"
                <span class="cov8" title="1">if maxTimeout != nil &amp;&amp; maxTimeout.Duration != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        taskRunTimeout, _ := validateTimeout(timeout, cfg.Defaults.DefaultTimeoutMinutes) // We know this won't error from above
                        if taskRunTimeout.Duration &gt; maxTimeout.Duration </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(
                                        fmt.Sprintf("%s should be &lt;= %s %s", taskRunTimeout.Duration, timeoutSource, maxTimeout.Duration),
                                        "timeout"))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// validateTimeout validates a timeout field and returns the validated timeout with defaults applied.
// If timeout is nil, returns default timeout. If timeout is negative, returns an error.
func validateTimeout(timeout *metav1.Duration, defaultTimeoutMinutes int) (*metav1.Duration, *apis.FieldError) <span class="cov8" title="1">{
        if timeout == nil </span><span class="cov0" title="0">{
                return &amp;metav1.Duration{Duration: time.Duration(defaultTimeoutMinutes) * time.Minute}, nil
        }</span>
        <span class="cov8" title="1">if timeout.Duration &lt; 0 </span><span class="cov0" title="0">{
                return nil, apis.ErrInvalidValue(timeout.Duration.String()+" should be &gt;= 0", "timeout")
        }</span>
        <span class="cov8" title="1">return timeout, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (p Provenance) convertTo(ctx context.Context, sink *v1.Provenance) <span class="cov8" title="1">{
        if p.RefSource != nil </span><span class="cov8" title="1">{
                new := v1.RefSource{}
                p.RefSource.convertTo(ctx, &amp;new)
                sink.RefSource = &amp;new
        }</span>
        <span class="cov8" title="1">if p.FeatureFlags != nil </span><span class="cov8" title="1">{
                sink.FeatureFlags = p.FeatureFlags
        }</span>
}

func (p *Provenance) convertFrom(ctx context.Context, source v1.Provenance) <span class="cov8" title="1">{
        if source.RefSource != nil </span><span class="cov8" title="1">{
                new := RefSource{}
                new.convertFrom(ctx, *source.RefSource)
                p.RefSource = &amp;new
        }</span>
        <span class="cov8" title="1">if source.FeatureFlags != nil </span><span class="cov8" title="1">{
                p.FeatureFlags = source.FeatureFlags
        }</span>
}

func (cs RefSource) convertTo(ctx context.Context, sink *v1.RefSource) <span class="cov8" title="1">{
        sink.URI = cs.URI
        sink.Digest = cs.Digest
        sink.EntryPoint = cs.EntryPoint
}</span>

func (cs *RefSource) convertFrom(ctx context.Context, source v1.RefSource) <span class="cov8" title="1">{
        cs.URI = source.URI
        cs.Digest = source.Digest
        cs.EntryPoint = source.EntryPoint
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: pipeline.GroupName, Version: "v1beta1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;Task{},
                &amp;TaskList{},
                &amp;Pipeline{},
                &amp;PipelineList{},
                &amp;TaskRun{},
                &amp;TaskRunList{},
                &amp;PipelineRun{},
                &amp;PipelineRunList{},
                &amp;CustomRun{},
                &amp;CustomRunList{},
                &amp;StepAction{},
                &amp;StepActionList{},
        )
        // &amp;Condition{},
        // &amp;ConditionList{},

        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (rr ResolverRef) convertTo(ctx context.Context, sink *v1.ResolverRef) <span class="cov8" title="1">{
        sink.Resolver = v1.ResolverName(rr.Resolver)
        sink.Params = nil
        for _, r := range rr.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                r.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
}

func (rr *ResolverRef) convertFrom(ctx context.Context, source v1.ResolverRef) <span class="cov8" title="1">{
        rr.Resolver = ResolverName(source.Resolver)
        rr.Params = nil
        for _, r := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, r)
                rr.Params = append(rr.Params, new)
        }</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (r TaskResult) convertTo(ctx context.Context, sink *v1.TaskResult) <span class="cov8" title="1">{
        sink.Name = r.Name
        sink.Type = v1.ResultsType(r.Type)
        sink.Description = r.Description
        if r.Properties != nil </span><span class="cov8" title="1">{
                properties := make(map[string]v1.PropertySpec)
                for k, v := range r.Properties </span><span class="cov8" title="1">{
                        properties[k] = v1.PropertySpec{Type: v1.ParamType(v.Type)}
                }</span>
                <span class="cov8" title="1">sink.Properties = properties</span>
        }
        <span class="cov8" title="1">if r.Value != nil </span><span class="cov8" title="1">{
                sink.Value = &amp;v1.ParamValue{}
                r.Value.convertTo(ctx, sink.Value)
        }</span>
}

func (r *TaskResult) convertFrom(ctx context.Context, source v1.TaskResult) <span class="cov8" title="1">{
        r.Name = source.Name
        r.Type = ResultsType(source.Type)
        r.Description = source.Description
        if source.Properties != nil </span><span class="cov8" title="1">{
                properties := make(map[string]PropertySpec)
                for k, v := range source.Properties </span><span class="cov8" title="1">{
                        properties[k] = PropertySpec{Type: ParamType(v.Type)}
                }</span>
                <span class="cov8" title="1">r.Properties = properties</span>
        }
        <span class="cov8" title="1">if source.Value != nil </span><span class="cov8" title="1">{
                r.Value = &amp;ParamValue{}
                r.Value.convertFrom(ctx, *source.Value)
        }</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import "context"

// SetDefaults set the default type for TaskResult
func (tr *TaskResult) SetDefaults(context.Context) <span class="cov8" title="1">{
        if tr == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if tr.Type == "" </span><span class="cov8" title="1">{
                if tr.Properties != nil </span><span class="cov8" title="1">{
                        // Set type to object if `properties` is given
                        tr.Type = ResultsTypeObject
                }</span> else<span class="cov8" title="1"> {
                        // ResultsTypeString is the default value
                        tr.Type = ResultsTypeString
                }</span>
        }

        // Set default type of object values to string
        <span class="cov8" title="1">for key, propertySpec := range tr.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type == "" </span><span class="cov8" title="1">{
                        tr.Properties[key] = PropertySpec{Type: ParamType(ResultsTypeString)}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file116" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import "strings"

// TaskResult used to describe the results of a task
type TaskResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Properties is the JSON Schema properties to support key-value pairs results.
        // +optional
        Properties map[string]PropertySpec `json:"properties,omitempty"`

        // Description is a human-readable description of the result
        // +optional
        Description string `json:"description,omitempty"`

        // Value the expression used to retrieve the value of the result from an underlying Step.
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value *ResultValue `json:"value,omitempty"`
}

// TaskRunResult used to describe the results of a task
type TaskRunResult struct {
        // Name the given name
        Name string `json:"name"`

        // Type is the user-specified type of the result. The possible type
        // is currently "string" and will support "array" in following work.
        // +optional
        Type ResultsType `json:"type,omitempty"`

        // Value the given value of the result
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Value ResultValue `json:"value"`
}

// TaskRunStepResult is a type alias of TaskRunResult
type TaskRunStepResult = TaskRunResult

// ResultValue is a type alias of ParamValue
type ResultValue = ParamValue

// ResultsType indicates the type of a result;
// Used to distinguish between a single string and an array of strings.
// Note that there is ResultType used to find out whether a
// RunResult is from a task result or not, which is different from
// this ResultsType.
type ResultsType string

// Valid ResultsType:
const (
        ResultsTypeString ResultsType = "string"
        ResultsTypeArray  ResultsType = "array"
        ResultsTypeObject ResultsType = "object"
)

// AllResultsTypes can be used for ResultsTypes validation.
var AllResultsTypes = []ResultsType{ResultsTypeString, ResultsTypeArray, ResultsTypeObject}

// ResultsArrayReference returns the reference of the result. e.g. results.resultname from $(results.resultname[*])
func ResultsArrayReference(a string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimSuffix(strings.TrimPrefix(a, "$("), ")"), "[*]")
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// Validate implements apis.Validatable
func (tr TaskResult) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !resultNameFormatRegex.MatchString(tr.Name) </span><span class="cov8" title="1">{
                return apis.ErrInvalidKeyName(tr.Name, "name", fmt.Sprintf("Name must consist of alphanumeric characters, '-', '_', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my-name',  or 'my_name', regex used for validation is '%s')", ResultNameFormat))
        }</span>

        <span class="cov8" title="1">switch </span>{
        case tr.Type == ResultsTypeObject:<span class="cov8" title="1">
                errs = errs.Also(validateObjectResult(tr))</span>
        case tr.Type == ResultsTypeArray:<span class="cov8" title="1"></span>
        // Resources created before the result. Type was introduced may not have Type set
        // and should be considered valid
        case tr.Type == "":<span class="cov8" title="1"></span>
        // By default, the result type is string
        case tr.Type != ResultsTypeString:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrInvalidValue(tr.Type, "type", "type must be string"))</span>
        }
        <span class="cov8" title="1">return errs.Also(tr.validateValue(ctx))</span>
}

// validateObjectResult validates the object result and check if the Properties is missing
// for Properties values it will check if the type is string.
func validateObjectResult(tr TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ParamType(tr.Type) == ParamTypeObject &amp;&amp; tr.Properties == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(tr.Name + ".properties")
        }</span>

        <span class="cov8" title="1">invalidKeys := []string{}
        for key, propertySpec := range tr.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type != ParamTypeString </span><span class="cov8" title="1">{
                        invalidKeys = append(invalidKeys, key)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidKeys) != 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("The value type specified for these keys %v is invalid, the type must be string", invalidKeys),
                        Paths:   []string{tr.Name + ".properties"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateValue validates the value of the TaskResult.
// It requires the value is of type string
// and format $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;)
func (tr TaskResult) validateValue(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if tr.Value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if tr.Value.Type != ParamTypeString </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf(
                                "Invalid Type. Wanted string but got: \"%v\"", tr.Value.Type),
                        Paths: []string{
                                tr.Name + ".type",
                        },
                }
        }</span>
        <span class="cov8" title="1">if tr.Value.StringVal != "" </span><span class="cov8" title="1">{
                stepName, resultName, err := v1.ExtractStepResultName(tr.Value.StringVal)
                if err != nil </span><span class="cov8" title="1">{
                        return &amp;apis.FieldError{
                                Message: err.Error(),
                                Paths:   []string{tr.Name + ".value"},
                        }
                }</span>
                <span class="cov8" title="1">if e := validation.IsDNS1123Label(stepName); len(e) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid extracted step name %q", stepName),
                                Paths:   []string{tr.Name + ".value"},
                                Details: "stepName in $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;) must be a valid DNS Label, For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        })
                }</span>
                <span class="cov8" title="1">if !resultNameFormatRegex.MatchString(resultName) </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid extracted result name %q", resultName),
                                Paths:   []string{tr.Name + ".value"},
                                Details: fmt.Sprintf("resultName in $(steps.&lt;stepName&gt;.results.&lt;resultName&gt;) must consist of alphanumeric characters, '-', '_', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my-name',  or 'my_name', regex used for validation is '%s')", ResultNameFormat),
                        })
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "regexp"
        "strings"

        "github.com/tektoncd/pipeline/pkg/internal/resultref"
)

// ResultRef is a type that represents a reference to a task run result
type ResultRef struct {
        PipelineTask string `json:"pipelineTask"`
        Result       string `json:"result"`
        ResultsIndex *int   `json:"resultsIndex"`
        Property     string `json:"property"`
}

const (
        // ResultTaskPart Constant used to define the "tasks" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultTaskPart = resultref.ResultTaskPart
        // ResultFinallyPart Constant used to define the "finally" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultFinallyPart = resultref.ResultFinallyPart
        // ResultResultPart Constant used to define the "results" part of a pipeline result reference
        // retained because of backwards compatibility
        ResultResultPart = resultref.ResultResultPart
        // TODO(#2462) use one regex across all substitutions
        // variableSubstitutionFormat matches format like $result.resultname, $result.resultname[int] and $result.resultname[*]
        variableSubstitutionFormat = `\$\([_a-zA-Z0-9.-]+(\.[_a-zA-Z0-9.-]+)*(\[([0-9]+|\*)\])?\)`
        // exactVariableSubstitutionFormat matches strings that only contain a single reference to result or param variables, but nothing else
        // i.e. `$(result.resultname)` is a match, but `foo $(result.resultname)` is not.
        exactVariableSubstitutionFormat = `^\$\([_a-zA-Z0-9.-]+(\.[_a-zA-Z0-9.-]+)*(\[([0-9]+|\*)\])?\)$`
        // ResultNameFormat Constant used to define the regex Result.Name should follow
        ResultNameFormat = `^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$`
)

// VariableSubstitutionRegex is a regex to find all result matching substitutions
var VariableSubstitutionRegex = regexp.MustCompile(variableSubstitutionFormat)
var exactVariableSubstitutionRegex = regexp.MustCompile(exactVariableSubstitutionFormat)
var resultNameFormatRegex = regexp.MustCompile(ResultNameFormat)

// NewResultRefs extracts all ResultReferences from a param or a pipeline result.
// If the ResultReference can be extracted, they are returned. Expressions which are not
// results are ignored.
func NewResultRefs(expressions []string) []*ResultRef <span class="cov8" title="1">{
        var resultRefs []*ResultRef
        for _, expression := range expressions </span><span class="cov8" title="1">{
                pr, err := resultref.ParseTaskExpression(expression)
                // If the expression isn't a result but is some other expression,
                // parseExpression will return an error, in which case we just skip that expression,
                // since although it's not a result ref, it might be some other kind of reference
                if err == nil </span><span class="cov8" title="1">{
                        resultRefs = append(resultRefs, &amp;ResultRef{
                                PipelineTask: pr.ResourceName,
                                Result:       pr.ResultName,
                                ResultsIndex: pr.ArrayIdx,
                                Property:     pr.ObjectKey,
                        })
                }</span>
        }
        <span class="cov8" title="1">return resultRefs</span>
}

// LooksLikeContainsResultRefs attempts to check if param or a pipeline result looks like it contains any
// result references.
// This is useful if we want to make sure the param looks like a ResultReference before
// performing strict validation
func LooksLikeContainsResultRefs(expressions []string) bool <span class="cov8" title="1">{
        for _, expression := range expressions </span><span class="cov8" title="1">{
                if resultref.LooksLikeResultRef(expression) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetVarSubstitutionExpressionsForParam extracts all the value between "$(" and ")"" for a parameter
func GetVarSubstitutionExpressionsForParam(param Param) ([]string, bool) <span class="cov8" title="1">{
        var allExpressions []string
        switch param.Value.Type </span>{
        case ParamTypeArray:<span class="cov8" title="1">
                // array type
                for _, value := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                        allExpressions = append(allExpressions, validateString(value)...)
                }</span>
        case ParamTypeString:<span class="cov8" title="1">
                // string type
                allExpressions = append(allExpressions, validateString(param.Value.StringVal)...)</span>
        case ParamTypeObject:<span class="cov8" title="1">
                // object type
                for _, value := range param.Value.ObjectVal </span><span class="cov8" title="1">{
                        allExpressions = append(allExpressions, validateString(value)...)
                }</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}

// GetVarSubstitutionExpressionsForPipelineResult extracts all the value between "$(" and ")"" for a pipeline result
func GetVarSubstitutionExpressionsForPipelineResult(result PipelineResult) ([]string, bool) <span class="cov8" title="1">{
        allExpressions := validateString(result.Value.StringVal)
        for _, v := range result.Value.ArrayVal </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(v)...)
        }</span>
        <span class="cov8" title="1">for _, v := range result.Value.ObjectVal </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(v)...)
        }</span>
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}

func validateString(value string) []string <span class="cov8" title="1">{
        expressions := VariableSubstitutionRegex.FindAllString(value, -1)
        if expressions == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var result []string
        for _, expression := range expressions </span><span class="cov8" title="1">{
                result = append(result, stripVarSubExpression(expression))
        }</span>
        <span class="cov8" title="1">return result</span>
}

func stripVarSubExpression(expression string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimPrefix(expression, "$("), ")")
}</span>

// ParseResultName parse the input string to extract resultName and result index.
// Array indexing:
// Input:  anArrayResult[1]
// Output: anArrayResult, "1"
// Array star reference:
// Input:  anArrayResult[*]
// Output: anArrayResult, "*"
func ParseResultName(resultName string) (string, string) <span class="cov8" title="1">{
        return resultref.ParseResultName(resultName)
}</span>

// PipelineTaskResultRefs walks all the places a result reference can be used
// in a PipelineTask and returns a list of any references that are found.
func PipelineTaskResultRefs(pt *PipelineTask) []*ResultRef <span class="cov8" title="1">{
        refs := []*ResultRef{}
        for _, p := range pt.extractAllParams() </span><span class="cov8" title="1">{
                expressions, _ := GetVarSubstitutionExpressionsForParam(p)
                refs = append(refs, NewResultRefs(expressions)...)
        }</span>
        <span class="cov8" title="1">for _, whenExpression := range pt.WhenExpressions </span><span class="cov8" title="1">{
                expressions, _ := whenExpression.GetVarSubstitutionExpressions()
                refs = append(refs, NewResultRefs(expressions)...)
        }</span>
        <span class="cov8" title="1">return refs</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*StepAction)(nil)

// ConvertTo implements apis.Convertible
func (s *StepAction) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov0" title="0">{
        return nil
}</span>

// ConvertTo implements apis.Convertible
func (ss *StepActionSpec) ConvertTo(ctx context.Context, sink *StepActionSpec) error <span class="cov0" title="0">{
        return nil
}</span>

// ConvertFrom implements apis.Convertible
func (s *StepAction) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov0" title="0">{
        return nil
}</span>

// ConvertFrom implements apis.Convertible
func (ss *StepActionSpec) ConvertFrom(ctx context.Context, source *StepActionSpec) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*StepAction)(nil)

// SetDefaults implements apis.Defaultable
func (s *StepAction) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        s.Spec.SetDefaults(ctx)
}</span>

// SetDefaults set any defaults for the StepAction spec
func (ss *StepActionSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        for i := range ss.Params </span><span class="cov8" title="1">{
                ss.Params[i].SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">for i := range ss.Results </span><span class="cov8" title="1">{
                ss.Results[i].SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmeta"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// StepAction represents the actionable components of Step.
// The Step can only reference it from the cluster or using remote resolution.
//
// +k8s:openapi-gen=true
// +kubebuilder:storageversion
type StepAction struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the Step from the client
        // +optional
        Spec StepActionSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*StepAction)(nil)

// StepAction returns the step action's spec
func (s *StepAction) StepActionSpec() StepActionSpec <span class="cov0" title="0">{
        return s.Spec
}</span>

// StepActionMetadata returns the step action's ObjectMeta
func (s *StepAction) StepActionMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return s.ObjectMeta
}</span>

// Copy returns a deep copy of the stepaction
func (s *StepAction) Copy() StepActionObject <span class="cov0" title="0">{
        return s.DeepCopy()
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*StepAction) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("StepAction")
}</span>

// Checksum computes the sha256 checksum of the stepaction object.
// Prior to computing the checksum, it performs some preprocessing on the
// metadata of the object where it removes system provided annotations.
// Only the name, namespace, generateName, user-provided labels and annotations
// and the taskSpec are included for the checksum computation.
func (s *StepAction) Checksum() ([]byte, error) <span class="cov0" title="0">{
        objectMeta := checksum.PrepareObjectMeta(s)
        preprocessedStepaction := StepAction{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1beta1",
                        Kind:       "StepAction",
                },
                ObjectMeta: objectMeta,
                Spec:       s.Spec,
        }
        sha256Checksum, err := checksum.ComputeSha256Checksum(preprocessedStepaction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sha256Checksum, nil</span>
}

// StepActionList contains a list of StepActions
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type StepActionList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []StepAction `json:"items"`
}

// +listType=atomic
type Args []string

// StepActionSpec contains the actionable components of a step.
type StepActionSpec struct {
        // Description is a user-facing description of the stepaction that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`
        // Image reference name to run for this StepAction.
        // More info: https://kubernetes.io/docs/concepts/containers/images
        // +optional
        Image string `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
        // Entrypoint array. Not executed within a shell.
        // The image's ENTRYPOINT is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        // +listType=atomic
        Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
        // Arguments to the entrypoint.
        // The image's CMD is used if this is not provided.
        // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        // of whether the variable exists or not. Cannot be updated.
        // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        // +optional
        Args Args `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
        // List of environment variables to set in the container.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=name
        // +patchStrategy=merge
        // +listType=atomic
        Env []corev1.EnvVar `json:"env,omitempty" patchMergeKey:"name" patchStrategy:"merge" protobuf:"bytes,7,rep,name=env"`
        // Script is the contents of an executable file to execute.
        //
        // If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
        // +optional
        Script string `json:"script,omitempty"`
        // Step's working directory.
        // If not specified, the container runtime's default will be used, which
        // might be configured in the container image.
        // Cannot be updated.
        // +optional
        WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
        // Params is a list of input parameters required to run the stepAction.
        // Params must be supplied as inputs in Steps unless they declare a defaultvalue.
        // +optional
        Params v1.ParamSpecs `json:"params,omitempty"`
        // Results are values that this StepAction can output
        // +optional
        // +listType=atomic
        Results []v1.StepResult `json:"results,omitempty"`
        // SecurityContext defines the security options the Step should be run with.
        // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
        // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        // The value set in StepAction will take precedence over the value from Task.
        // +optional
        SecurityContext *corev1.SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`
        // Volumes to mount into the Step's filesystem.
        // Cannot be updated.
        // +optional
        // +patchMergeKey=mountPath
        // +patchStrategy=merge
        // +listType=atomic
        VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty" patchMergeKey:"mountPath" patchStrategy:"merge" protobuf:"bytes,9,rep,name=volumeMounts"`
}

// ToStep converts the StepActionSpec to a Step struct
func (ss *StepActionSpec) ToStep() *v1.Step <span class="cov0" title="0">{
        return &amp;v1.Step{
                Image:           ss.Image,
                Command:         ss.Command,
                Args:            ss.Args,
                WorkingDir:      ss.WorkingDir,
                Script:          ss.Script,
                Env:             ss.Env,
                VolumeMounts:    ss.VolumeMounts,
                SecurityContext: ss.SecurityContext,
                Results:         ss.Results,
        }
}</span>

// StepActionObject is implemented by StepAction
type StepActionObject interface {
        apis.Defaultable
        StepActionMetadata() metav1.ObjectMeta
        StepActionSpec() StepActionSpec
        Copy() StepActionObject
}
</pre>
		
		<pre class="file" id="file122" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/substitution"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*StepAction)(nil)
        _ resourcesemantics.VerbLimited = (*StepAction)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (s *StepAction) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate implements apis.Validatable
func (s *StepAction) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = validate.ObjectMetadata(s.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(s.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        return errs
}</span>

// Validate implements apis.Validatable
func (ss *StepActionSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ss.Image == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("Image"))
        }</span>

        <span class="cov8" title="1">if ss.Script != "" </span><span class="cov8" title="1">{
                if len(ss.Command) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "script cannot be used with command",
                                Paths:   []string{"script"},
                        })
                }</span>

                <span class="cov8" title="1">cleaned := strings.TrimSpace(ss.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "windows script support", config.AlphaAPIFields).ViaField("script"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(validateNoParamSubstitutionsInScript(ss.Script))</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateUsageOfDeclaredParameters(ctx, *ss))
        errs = errs.Also(v1.ValidateParameterTypes(ctx, ss.Params).ViaField("params"))
        errs = errs.Also(validateParameterVariables(ctx, *ss, ss.Params))
        errs = errs.Also(v1.ValidateStepResultsVariables(ctx, ss.Results, ss.Script))
        errs = errs.Also(v1.ValidateStepResults(ctx, ss.Results).ViaField("results"))
        errs = errs.Also(validateVolumeMounts(ss.VolumeMounts, ss.Params).ViaField("volumeMounts"))
        return errs</span>
}

// validateNoParamSubstitutionsInScript validates that param substitutions are not invoked in the script
func validateNoParamSubstitutionsInScript(script string) *apis.FieldError <span class="cov8" title="1">{
        _, present, errString := substitution.ExtractVariablesFromString(script, "params")
        if errString != "" || present </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: "param substitution in scripts is not allowed.",
                        Paths:   []string{"script"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateUsageOfDeclaredParameters validates that all parameters referenced in the Task are declared by the Task.
func validateUsageOfDeclaredParameters(ctx context.Context, sas StepActionSpec) *apis.FieldError <span class="cov8" title="1">{
        params := sas.Params
        var errs *apis.FieldError
        _, _, objectParams := params.SortByType()
        allParameterNames := sets.NewString(params.GetNames()...)
        errs = errs.Also(validateStepActionVariables(ctx, sas, "params", allParameterNames))
        errs = errs.Also(ValidateObjectUsage(ctx, sas, objectParams))
        errs = errs.Also(v1.ValidateObjectParamsHaveProperties(ctx, params))
        return errs
}</span>

func validateVolumeMounts(volumeMounts []corev1.VolumeMount, params v1.ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(volumeMounts) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">paramNames := sets.String{}
        for _, p := range params </span><span class="cov8" title="1">{
                paramNames.Insert(p.Name)
        }</span>
        <span class="cov8" title="1">for idx, v := range volumeMounts </span><span class="cov8" title="1">{
                matches, _ := substitution.ExtractVariableExpressions(v.Name, "params")
                if len(matches) != 1 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(v.Name, "name", "expect the Name to be a single param reference").ViaIndex(idx))
                        return errs
                }</span> else<span class="cov8" title="1"> if matches[0] != v.Name </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(v.Name, "name", "expect the Name to be a single param reference").ViaIndex(idx))
                        return errs
                }</span>
                <span class="cov8" title="1">errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.Name, "params", paramNames).ViaIndex(idx))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateParameterVariables validates all variables within a slice of ParamSpecs against a StepAction
func validateParameterVariables(ctx context.Context, sas StepActionSpec, params v1.ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        errs = errs.Also(params.ValidateNoDuplicateNames())
        stringParams, arrayParams, objectParams := params.SortByType()
        stringParameterNames := sets.NewString(stringParams.GetNames()...)
        arrayParameterNames := sets.NewString(arrayParams.GetNames()...)
        errs = errs.Also(v1.ValidateNameFormat(stringParameterNames.Insert(arrayParameterNames.List()...), objectParams))
        return errs.Also(validateStepActionArrayUsage(sas, "params", arrayParameterNames))
}</span>

// ValidateObjectUsage validates the usage of individual attributes of an object param and the usage of the entire object
func ValidateObjectUsage(ctx context.Context, sas StepActionSpec, params v1.ParamSpecs) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectParameterNames := sets.NewString()
        for _, p := range params </span><span class="cov8" title="1">{
                // collect all names of object type params
                objectParameterNames.Insert(p.Name)

                // collect all keys for this object param
                objectKeys := sets.NewString()
                for key := range p.Properties </span><span class="cov8" title="1">{
                        objectKeys.Insert(key)
                }</span>

                // check if the object's key names are referenced correctly i.e. param.objectParam.key1
                <span class="cov8" title="1">errs = errs.Also(validateStepActionVariables(ctx, sas, "params\\."+p.Name, objectKeys))</span>
        }

        <span class="cov8" title="1">return errs.Also(validateStepActionObjectUsageAsWhole(sas, "params", objectParameterNames))</span>
}

// validateStepActionObjectUsageAsWhole returns an error if the StepAction contains references to the entire input object params in fields where these references are prohibited
func validateStepActionObjectUsageAsWhole(sas StepActionSpec, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToEntireProhibitedVariables(sas.Image, prefix, vars).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(sas.Script, prefix, vars).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(vm.Name, prefix, vars).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepActionArrayUsage returns an error if the Step contains references to the input array params in fields where these references are prohibited
func validateStepActionArrayUsage(sas StepActionSpec, prefix string, arrayParamNames sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToProhibitedVariables(sas.Image, prefix, arrayParamNames).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(sas.Script, prefix, arrayParamNames).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(cmd, prefix, arrayParamNames).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(arg, prefix, arrayParamNames).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(env.Value, prefix, arrayParamNames).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(vm.Name, prefix, arrayParamNames).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepActionVariables returns an error if the StepAction contains references to any unknown variables
func validateStepActionVariables(ctx context.Context, sas StepActionSpec, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(sas.Image, prefix, vars).ViaField("image")
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(sas.Script, prefix, vars).ViaField("script"))
        for i, cmd := range sas.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range sas.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range sas.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, vm := range sas.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(vm.Name, prefix, vars).ViaFieldIndex("volumeMounts", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/version"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "knative.dev/pkg/apis"
)

// TaskDeprecationsAnnotationKey is the annotation key for all deprecated fields of (a) Task(s) that belong(s) to an object.
// For example: a v1beta1.Pipeline contains two tasks
//
// spec:
//
//         tasks:
//         - name: task-1
//           stepTemplate:
//                 name: deprecated-name-field # deprecated field
//         - name: task-2
//           steps:
//           - tty: true # deprecated field
//
// The annotation would be:
//
//        "tekton.dev/v1beta1.task-deprecations": `{
//           "task1":{
//              "deprecatedStepTemplates":{
//                 "name":"deprecated-name-field"
//               },
//            },
//           "task-2":{
//              "deprecatedSteps":[{"tty":true}],
//            },
//        }`
const (
        TaskDeprecationsAnnotationKey = "tekton.dev/v1beta1.task-deprecations"
        resourcesAnnotationKey        = "tekton.dev/v1beta1Resources"
)

var _ apis.Convertible = (*Task)(nil)

// ConvertTo implements apis.Convertible
func (t *Task) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := to.(type) </span>{
        case *v1.Task:<span class="cov8" title="1">
                sink.ObjectMeta = t.ObjectMeta
                if err := serializeResources(&amp;sink.ObjectMeta, &amp;t.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return t.Spec.ConvertTo(ctx, &amp;sink.Spec, &amp;sink.ObjectMeta, t.Name)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo implements apis.Convertible
func (ts *TaskSpec) ConvertTo(ctx context.Context, sink *v1.TaskSpec, meta *metav1.ObjectMeta, taskName string) error <span class="cov8" title="1">{
        if err := serializeTaskDeprecations(meta, ts, taskName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sink.Steps = nil
        for _, s := range ts.Steps </span><span class="cov8" title="1">{
                new := v1.Step{}
                s.convertTo(ctx, &amp;new)
                sink.Steps = append(sink.Steps, new)
        }</span>
        <span class="cov8" title="1">sink.Volumes = v1.Volumes(ts.Volumes)
        if ts.StepTemplate != nil </span><span class="cov8" title="1">{
                new := v1.StepTemplate{}
                ts.StepTemplate.convertTo(ctx, &amp;new)
                sink.StepTemplate = &amp;new
        }</span>
        <span class="cov8" title="1">sink.Sidecars = nil
        for _, s := range ts.Sidecars </span><span class="cov8" title="1">{
                new := v1.Sidecar{}
                s.convertTo(ctx, &amp;new)
                sink.Sidecars = append(sink.Sidecars, new)
        }</span>
        <span class="cov8" title="1">sink.Workspaces = nil
        for _, w := range ts.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspaceDeclaration{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
        <span class="cov8" title="1">sink.Results = nil
        for _, r := range ts.Results </span><span class="cov8" title="1">{
                new := v1.TaskResult{}
                r.convertTo(ctx, &amp;new)
                sink.Results = append(sink.Results, new)
        }</span>
        <span class="cov8" title="1">sink.Params = nil
        for _, p := range ts.Params </span><span class="cov8" title="1">{
                new := v1.ParamSpec{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.DisplayName = ts.DisplayName
        sink.Description = ts.Description
        return nil</span>
}

// ConvertFrom implements apis.Convertible
func (t *Task) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch source := from.(type) </span>{
        case *v1.Task:<span class="cov8" title="1">
                t.ObjectMeta = source.ObjectMeta
                if err := deserializeResources(&amp;t.ObjectMeta, &amp;t.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return t.Spec.ConvertFrom(ctx, &amp;source.Spec, &amp;t.ObjectMeta, t.Name)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", t)</span>
        }
}

// ConvertFrom implements apis.Convertible
func (ts *TaskSpec) ConvertFrom(ctx context.Context, source *v1.TaskSpec, meta *metav1.ObjectMeta, taskName string) error <span class="cov8" title="1">{
        ts.Steps = nil
        for _, s := range source.Steps </span><span class="cov8" title="1">{
                new := Step{}
                new.convertFrom(ctx, s)
                ts.Steps = append(ts.Steps, new)
        }</span>
        <span class="cov8" title="1">ts.Volumes = Volumes(source.Volumes)
        if source.StepTemplate != nil </span><span class="cov8" title="1">{
                new := StepTemplate{}
                new.convertFrom(ctx, source.StepTemplate)
                ts.StepTemplate = &amp;new
        }</span>
        <span class="cov8" title="1">if err := deserializeTaskDeprecations(meta, ts, taskName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ts.Sidecars = nil
        for _, s := range source.Sidecars </span><span class="cov8" title="1">{
                new := Sidecar{}
                new.convertFrom(ctx, s)
                ts.Sidecars = append(ts.Sidecars, new)
        }</span>
        <span class="cov8" title="1">ts.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspaceDeclaration{}
                new.convertFrom(ctx, w)
                ts.Workspaces = append(ts.Workspaces, new)
        }</span>
        <span class="cov8" title="1">ts.Results = nil
        for _, r := range source.Results </span><span class="cov8" title="1">{
                new := TaskResult{}
                new.convertFrom(ctx, r)
                ts.Results = append(ts.Results, new)
        }</span>
        <span class="cov8" title="1">ts.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := ParamSpec{}
                new.convertFrom(ctx, p)
                ts.Params = append(ts.Params, new)
        }</span>
        <span class="cov8" title="1">ts.DisplayName = source.DisplayName
        ts.Description = source.Description
        return nil</span>
}

// taskDeprecation contains deprecated fields of a Task
// +k8s:openapi-gen=false
type taskDeprecation struct {
        // DeprecatedSteps contains Steps of a Task that with deprecated fields defined.
        // +listType=atomic
        DeprecatedSteps []Step `json:"deprecatedSteps,omitempty"`
        // DeprecatedStepTemplate contains stepTemplate of a Task that with deprecated fields defined.
        DeprecatedStepTemplate *StepTemplate `json:"deprecatedStepTemplate,omitempty"`
}

// taskDeprecations contains deprecated fields of Tasks that belong to the same Pipeline or PipelineRun
// the key is Task name
// +k8s:openapi-gen=false
type taskDeprecations map[string]taskDeprecation

// serializeTaskDeprecations appends the current Task's deprecation info to annotation of the object.
// The object could be Task, TaskRun, Pipeline or PipelineRun
func serializeTaskDeprecations(meta *metav1.ObjectMeta, spec *TaskSpec, taskName string) error <span class="cov8" title="1">{
        var taskDeprecation *taskDeprecation
        if spec.HasDeprecatedFields() </span><span class="cov8" title="1">{
                taskDeprecation = retrieveTaskDeprecation(spec)
        }</span>
        <span class="cov8" title="1">existingDeprecations := taskDeprecations{}
        if str, ok := meta.Annotations[TaskDeprecationsAnnotationKey]; ok </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(str), &amp;existingDeprecations); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error serializing key %s from metadata: %w", TaskDeprecationsAnnotationKey, err)
                }</span>
        }
        <span class="cov8" title="1">if taskDeprecation != nil </span><span class="cov8" title="1">{
                existingDeprecations[taskName] = *taskDeprecation
                return version.SerializeToMetadata(meta, existingDeprecations, TaskDeprecationsAnnotationKey)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// deserializeTaskDeprecations retrieves deprecation info of the Task from object annotation.
// The object could be Task, TaskRun, Pipeline or PipelineRun.
func deserializeTaskDeprecations(meta *metav1.ObjectMeta, spec *TaskSpec, taskName string) error <span class="cov8" title="1">{
        existingDeprecations := taskDeprecations{}
        if meta == nil || meta.Annotations == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if str, ok := meta.Annotations[TaskDeprecationsAnnotationKey]; ok </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(str), &amp;existingDeprecations); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deserializing key %s from metadata: %w", TaskDeprecationsAnnotationKey, err)
                }</span>
        }
        <span class="cov8" title="1">if td, ok := existingDeprecations[taskName]; ok </span><span class="cov8" title="1">{
                if len(spec.Steps) != len(td.DeprecatedSteps) </span><span class="cov0" title="0">{
                        return errors.New("length of deserialized steps mismatch the length of target steps")
                }</span>
                <span class="cov8" title="1">for i := range len(spec.Steps) </span><span class="cov8" title="1">{
                        spec.Steps[i].DeprecatedPorts = td.DeprecatedSteps[i].DeprecatedPorts
                        spec.Steps[i].DeprecatedLivenessProbe = td.DeprecatedSteps[i].DeprecatedLivenessProbe
                        spec.Steps[i].DeprecatedReadinessProbe = td.DeprecatedSteps[i].DeprecatedReadinessProbe
                        spec.Steps[i].DeprecatedStartupProbe = td.DeprecatedSteps[i].DeprecatedStartupProbe
                        spec.Steps[i].DeprecatedLifecycle = td.DeprecatedSteps[i].DeprecatedLifecycle
                        spec.Steps[i].DeprecatedTerminationMessagePath = td.DeprecatedSteps[i].DeprecatedTerminationMessagePath
                        spec.Steps[i].DeprecatedTerminationMessagePolicy = td.DeprecatedSteps[i].DeprecatedTerminationMessagePolicy
                        spec.Steps[i].DeprecatedStdin = td.DeprecatedSteps[i].DeprecatedStdin
                        spec.Steps[i].DeprecatedStdinOnce = td.DeprecatedSteps[i].DeprecatedStdinOnce
                        spec.Steps[i].DeprecatedTTY = td.DeprecatedSteps[i].DeprecatedTTY
                }</span>
                <span class="cov8" title="1">if td.DeprecatedStepTemplate != nil </span><span class="cov8" title="1">{
                        if spec.StepTemplate == nil </span><span class="cov0" title="0">{
                                spec.StepTemplate = &amp;StepTemplate{}
                        }</span>
                        <span class="cov8" title="1">spec.StepTemplate.DeprecatedName = td.DeprecatedStepTemplate.DeprecatedName
                        spec.StepTemplate.DeprecatedPorts = td.DeprecatedStepTemplate.DeprecatedPorts
                        spec.StepTemplate.DeprecatedLivenessProbe = td.DeprecatedStepTemplate.DeprecatedLivenessProbe
                        spec.StepTemplate.DeprecatedReadinessProbe = td.DeprecatedStepTemplate.DeprecatedReadinessProbe
                        spec.StepTemplate.DeprecatedStartupProbe = td.DeprecatedStepTemplate.DeprecatedStartupProbe
                        spec.StepTemplate.DeprecatedLifecycle = td.DeprecatedStepTemplate.DeprecatedLifecycle
                        spec.StepTemplate.DeprecatedTerminationMessagePath = td.DeprecatedStepTemplate.DeprecatedTerminationMessagePath
                        spec.StepTemplate.DeprecatedTerminationMessagePolicy = td.DeprecatedStepTemplate.DeprecatedTerminationMessagePolicy
                        spec.StepTemplate.DeprecatedStdin = td.DeprecatedStepTemplate.DeprecatedStdin
                        spec.StepTemplate.DeprecatedStdinOnce = td.DeprecatedStepTemplate.DeprecatedStdinOnce
                        spec.StepTemplate.DeprecatedTTY = td.DeprecatedStepTemplate.DeprecatedTTY</span>
                }
                <span class="cov8" title="1">delete(existingDeprecations, taskName)
                if len(existingDeprecations) == 0 </span><span class="cov8" title="1">{
                        delete(meta.Annotations, TaskDeprecationsAnnotationKey)
                }</span> else<span class="cov8" title="1"> {
                        updatedDeprecations, err := json.Marshal(existingDeprecations)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">meta.Annotations[TaskDeprecationsAnnotationKey] = string(updatedDeprecations)</span>
                }
                <span class="cov8" title="1">if len(meta.Annotations) == 0 </span><span class="cov8" title="1">{
                        meta.Annotations = nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func retrieveTaskDeprecation(spec *TaskSpec) *taskDeprecation <span class="cov8" title="1">{
        if !spec.HasDeprecatedFields() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ds := []Step{}
        for _, s := range spec.Steps </span><span class="cov8" title="1">{
                ds = append(ds, Step{
                        DeprecatedPorts:                    s.DeprecatedPorts,
                        DeprecatedLivenessProbe:            s.DeprecatedLivenessProbe,
                        DeprecatedReadinessProbe:           s.DeprecatedReadinessProbe,
                        DeprecatedStartupProbe:             s.DeprecatedStartupProbe,
                        DeprecatedLifecycle:                s.DeprecatedLifecycle,
                        DeprecatedTerminationMessagePath:   s.DeprecatedTerminationMessagePath,
                        DeprecatedTerminationMessagePolicy: s.DeprecatedTerminationMessagePolicy,
                        DeprecatedStdin:                    s.DeprecatedStdin,
                        DeprecatedStdinOnce:                s.DeprecatedStdinOnce,
                        DeprecatedTTY:                      s.DeprecatedTTY,
                })
        }</span>
        <span class="cov8" title="1">var dst *StepTemplate
        if spec.StepTemplate != nil </span><span class="cov8" title="1">{
                dst = &amp;StepTemplate{
                        DeprecatedName:                     spec.StepTemplate.DeprecatedName,
                        DeprecatedPorts:                    spec.StepTemplate.DeprecatedPorts,
                        DeprecatedLivenessProbe:            spec.StepTemplate.DeprecatedLivenessProbe,
                        DeprecatedReadinessProbe:           spec.StepTemplate.DeprecatedReadinessProbe,
                        DeprecatedStartupProbe:             spec.StepTemplate.DeprecatedStartupProbe,
                        DeprecatedLifecycle:                spec.StepTemplate.DeprecatedLifecycle,
                        DeprecatedTerminationMessagePath:   spec.StepTemplate.DeprecatedTerminationMessagePath,
                        DeprecatedTerminationMessagePolicy: spec.StepTemplate.DeprecatedTerminationMessagePolicy,
                        DeprecatedStdin:                    spec.StepTemplate.DeprecatedStdin,
                        DeprecatedStdinOnce:                spec.StepTemplate.DeprecatedStdinOnce,
                        DeprecatedTTY:                      spec.StepTemplate.DeprecatedTTY,
                }
        }</span>
        <span class="cov8" title="1">return &amp;taskDeprecation{
                DeprecatedSteps:        ds,
                DeprecatedStepTemplate: dst,
        }</span>
}

func serializeResources(meta *metav1.ObjectMeta, spec *TaskSpec) error <span class="cov8" title="1">{
        if spec.Resources == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, spec.Resources, resourcesAnnotationKey)</span>
}

func deserializeResources(meta *metav1.ObjectMeta, spec *TaskSpec) error <span class="cov8" title="1">{
        resources := &amp;TaskResources{}
        err := version.DeserializeFromMetadata(meta, resources, resourcesAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if resources.Inputs != nil || resources.Outputs != nil </span><span class="cov8" title="1">{
                spec.Resources = resources
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "knative.dev/pkg/apis"
)

var _ apis.Defaultable = (*Task)(nil)

// SetDefaults implements apis.Defaultable
func (t *Task) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        t.Spec.SetDefaults(ctx)
}</span>

// SetDefaults set any defaults for the task spec
func (ts *TaskSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        for i := range ts.Params </span><span class="cov8" title="1">{
                ts.Params[i].SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">for i := range ts.Results </span><span class="cov8" title="1">{
                ts.Results[i].SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/internal/checksum"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/kmeta"
)

// +genclient
// +genclient:noStatus
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// Task represents a collection of sequential steps that are run as part of a
// Pipeline using a set of inputs and producing a set of outputs. Tasks execute
// when TaskRuns are created that provide the input parameters and resources and
// output resources the Task requires.
//
// Deprecated: Please use v1.Task instead.
type Task struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the Task from the client
        // +optional
        Spec TaskSpec `json:"spec"`
}

var _ kmeta.OwnerRefable = (*Task)(nil)

// TaskSpec returns the task's spec
func (t *Task) TaskSpec() TaskSpec <span class="cov0" title="0">{
        return t.Spec
}</span>

// TaskMetadata returns the task's ObjectMeta
func (t *Task) TaskMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return t.ObjectMeta
}</span>

// Copy returns a deep copy of the task
func (t *Task) Copy() TaskObject <span class="cov0" title="0">{
        return t.DeepCopy()
}</span>

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*Task) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.TaskControllerName)
}</span>

// Checksum computes the sha256 checksum of the task object.
// Prior to computing the checksum, it performs some preprocessing on the
// metadata of the object where it removes system provided annotations.
// Only the name, namespace, generateName, user-provided labels and annotations
// and the taskSpec are included for the checksum computation.
func (t *Task) Checksum() ([]byte, error) <span class="cov8" title="1">{
        objectMeta := checksum.PrepareObjectMeta(t)
        preprocessedTask := Task{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1beta1",
                        Kind:       "Task"},
                ObjectMeta: objectMeta,
                Spec:       t.Spec,
        }
        sha256Checksum, err := checksum.ComputeSha256Checksum(preprocessedTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sha256Checksum, nil</span>
}

// +listType=atomic
type Volumes []corev1.Volume

// TaskSpec defines the desired state of Task.
type TaskSpec struct {
        // Resources is a list input and output resource to run the task
        // Resources are represented in TaskRuns as bindings to instances of
        // PipelineResources.
        //
        // Deprecated: Unused, preserved only for backwards compatibility
        // +optional
        Resources *TaskResources `json:"resources,omitempty"`

        // Params is a list of input parameters required to run the task. Params
        // must be supplied as inputs in TaskRuns unless they declare a default
        // value.
        // +optional
        Params ParamSpecs `json:"params,omitempty"`

        // DisplayName is a user-facing name of the task that may be
        // used to populate a UI.
        // +optional
        DisplayName string `json:"displayName,omitempty"`

        // Description is a user-facing description of the task that may be
        // used to populate a UI.
        // +optional
        Description string `json:"description,omitempty"`

        // Steps are the steps of the build; each step is run sequentially with the
        // source mounted into /workspace.
        // +listType=atomic
        Steps []Step `json:"steps,omitempty"`

        // Volumes is a collection of volumes that are available to mount into the
        // steps of the build.
        // See Pod.spec.volumes (API version: v1)
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Volumes Volumes `json:"volumes,omitempty"`

        // StepTemplate can be used as the basis for all step containers within the
        // Task, so that the steps inherit settings on the base container.
        StepTemplate *StepTemplate `json:"stepTemplate,omitempty"`

        // Sidecars are run alongside the Task's step containers. They begin before
        // the steps start and end after the steps complete.
        // +listType=atomic
        Sidecars []Sidecar `json:"sidecars,omitempty"`

        // Workspaces are the volumes that this Task requires.
        // +listType=atomic
        Workspaces []WorkspaceDeclaration `json:"workspaces,omitempty"`

        // Results are values that this Task can output
        // +listType=atomic
        Results []TaskResult `json:"results,omitempty"`
}

// TaskList contains a list of Task
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TaskList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Task `json:"items"`
}

// HasDeprecatedFields returns true if the TaskSpec has deprecated field specified.
func (ts *TaskSpec) HasDeprecatedFields() bool <span class="cov8" title="1">{
        if ts == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len(ts.Steps) &gt; 0 </span><span class="cov8" title="1">{
                for _, s := range ts.Steps </span><span class="cov8" title="1">{
                        if len(s.DeprecatedPorts) &gt; 0 ||
                                s.DeprecatedLivenessProbe != nil ||
                                s.DeprecatedReadinessProbe != nil ||
                                s.DeprecatedStartupProbe != nil ||
                                s.DeprecatedLifecycle != nil ||
                                s.DeprecatedTerminationMessagePath != "" ||
                                s.DeprecatedTerminationMessagePolicy != "" ||
                                s.DeprecatedStdin ||
                                s.DeprecatedStdinOnce ||
                                s.DeprecatedTTY </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">if ts.StepTemplate != nil </span><span class="cov8" title="1">{
                if len(ts.StepTemplate.DeprecatedPorts) &gt; 0 ||
                        ts.StepTemplate.DeprecatedName != "" ||
                        ts.StepTemplate.DeprecatedReadinessProbe != nil ||
                        ts.StepTemplate.DeprecatedStartupProbe != nil ||
                        ts.StepTemplate.DeprecatedLifecycle != nil ||
                        ts.StepTemplate.DeprecatedTerminationMessagePath != "" ||
                        ts.StepTemplate.DeprecatedTerminationMessagePolicy != "" ||
                        ts.StepTemplate.DeprecatedStdin ||
                        ts.StepTemplate.DeprecatedStdinOnce ||
                        ts.StepTemplate.DeprecatedTTY </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "path/filepath"
        "regexp"
        "slices"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "github.com/tektoncd/pipeline/pkg/substitution"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

const (
        // stringAndArrayVariableNameFormat is the regex to validate if string/array variable name format follows the following rules.
        // - Must only contain alphanumeric characters, hyphens (-), underscores (_), and dots (.)
        // - Must begin with a letter or an underscore (_)
        stringAndArrayVariableNameFormat = "^[_a-zA-Z][_a-zA-Z0-9.-]*$"

        // objectVariableNameFormat is the regext used to validate object name and key names format
        // The difference with the array or string name format is that object variable names shouldn't contain dots.
        objectVariableNameFormat = "^[_a-zA-Z][_a-zA-Z0-9-]*$"
)

var (
        _ apis.Validatable              = (*Task)(nil)
        _ resourcesemantics.VerbLimited = (*Task)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (t *Task) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

var (
        stringAndArrayVariableNameFormatRegex = regexp.MustCompile(stringAndArrayVariableNameFormat)
        objectVariableNameFormatRegex         = regexp.MustCompile(objectVariableNameFormat)
)

// Validate implements apis.Validatable
func (t *Task) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        errs = errs.Also(t.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
        // When a Task is created directly, instead of declared inline in a TaskRun or PipelineRun,
        // we do not support propagated parameters. Validate that all params it uses are declared.
        return errs.Also(ValidateUsageOfDeclaredParameters(ctx, t.Spec.Steps, t.Spec.Params).ViaField("spec"))
}</span>

// Validate implements apis.Validatable
func (ts *TaskSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if len(ts.Steps) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("steps"))
        }</span>

        <span class="cov8" title="1">errs = errs.Also(ValidateVolumes(ts.Volumes).ViaField("volumes"))
        errs = errs.Also(validateDeclaredWorkspaces(ts.Workspaces, ts.Steps, ts.StepTemplate).ViaField("workspaces"))
        errs = errs.Also(validateWorkspaceUsages(ctx, ts))
        mergedSteps, err := MergeStepsWithStepTemplate(ts.StepTemplate, ts.Steps)
        if err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("error merging step template and steps: %s", err),
                        Paths:   []string{"stepTemplate"},
                        Details: err.Error(),
                })
        }</span>

        <span class="cov8" title="1">errs = errs.Also(validateSteps(ctx, mergedSteps).ViaField("steps"))
        errs = errs.Also(validateSidecarNames(ts.Sidecars))
        errs = errs.Also(ValidateParameterTypes(ctx, ts.Params).ViaField("params"))
        errs = errs.Also(ValidateParameterVariables(ctx, ts.Steps, ts.Params))
        errs = errs.Also(validateTaskContextVariables(ctx, ts.Steps))
        errs = errs.Also(validateTaskResultsVariables(ctx, ts.Steps, ts.Results))
        errs = errs.Also(validateResults(ctx, ts.Results).ViaField("results"))
        if ts.Resources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("resources"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateUsageOfDeclaredParameters validates that all parameters referenced in the Task are declared by the Task.
func ValidateUsageOfDeclaredParameters(ctx context.Context, steps []Step, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        _, _, objectParams := params.sortByType()
        allParameterNames := sets.NewString(params.getNames()...)
        errs = errs.Also(validateVariables(ctx, steps, "params", allParameterNames))
        errs = errs.Also(validateObjectUsage(ctx, steps, objectParams))
        errs = errs.Also(validateObjectParamsHaveProperties(ctx, params))
        return errs
}</span>

// validateObjectParamsHaveProperties returns an error if any declared object params are missing properties
func validateObjectParamsHaveProperties(ctx context.Context, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        for _, p := range params </span><span class="cov8" title="1">{
                if p.Type == ParamTypeObject &amp;&amp; p.Properties == nil </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrMissingField(p.Name + ".properties"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateSidecarNames(sidecars []Sidecar) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, sc := range sidecars </span><span class="cov8" title="1">{
                if sc.Name == pipeline.ReservedResultsSidecarName </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("Invalid: cannot use reserved sidecar name %v ", sc.Name),
                                Paths:   []string{"sidecars"},
                        })
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateResults(ctx context.Context, results []TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        for index, result := range results </span><span class="cov8" title="1">{
                errs = errs.Also(result.Validate(ctx).ViaIndex(index))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// a mount path which conflicts with any other declared workspaces, with the explicitly
// declared volume mounts, or with the stepTemplate. The names must also be unique.
func validateDeclaredWorkspaces(workspaces []WorkspaceDeclaration, steps []Step, stepTemplate *StepTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        mountPaths := sets.NewString()
        for _, step := range steps </span><span class="cov8" title="1">{
                for _, vm := range step.VolumeMounts </span><span class="cov8" title="1">{
                        mountPaths.Insert(filepath.Clean(vm.MountPath))
                }</span>
        }
        <span class="cov8" title="1">if stepTemplate != nil </span><span class="cov8" title="1">{
                for _, vm := range stepTemplate.VolumeMounts </span><span class="cov8" title="1">{
                        mountPaths.Insert(filepath.Clean(vm.MountPath))
                }</span>
        }

        <span class="cov8" title="1">wsNames := sets.NewString()
        for idx, w := range workspaces </span><span class="cov8" title="1">{
                // Workspace names must be unique
                if wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace name %q must be unique", w.Name), "name").ViaIndex(idx))
                }</span> else<span class="cov8" title="1"> {
                        wsNames.Insert(w.Name)
                }</span>
                // Workspaces must not try to use mount paths that are already used
                <span class="cov8" title="1">mountPath := filepath.Clean(w.GetMountPath())
                if _, ok := mountPaths[mountPath]; ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("workspace mount path %q must be unique", mountPath), "mountpath").ViaIndex(idx))
                }</span>
                <span class="cov8" title="1">mountPaths[mountPath] = struct{}{}</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// validateWorkspaceUsages checks that all WorkspaceUsage objects in Steps
// refer to workspaces that are defined in the Task.
//
// This is a beta feature and will fail validation if it's used by a step
// or sidecar when the enable-api-fields feature gate is anything but "beta".
//
// Note that this feature reached beta after the v1 API version has been released and
// consequently it is *not* implicitly enabled on the v1beta1 API to avoid suffering
// from the issues described in TEP-0138 https://github.com/tektoncd/community/pull/1034
func validateWorkspaceUsages(ctx context.Context, ts *TaskSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        workspaces := ts.Workspaces
        steps := ts.Steps
        sidecars := ts.Sidecars

        wsNames := sets.NewString()
        for _, w := range workspaces </span><span class="cov8" title="1">{
                wsNames.Insert(w.Name)
        }</span>

        <span class="cov8" title="1">for stepIdx, step := range steps </span><span class="cov8" title="1">{
                if len(step.Workspaces) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step workspaces", config.BetaAPIFields).ViaIndex(stepIdx).ViaField("steps"))
                }</span>
                <span class="cov8" title="1">for workspaceIdx, w := range step.Workspaces </span><span class="cov8" title="1">{
                        if !wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("undefined workspace %q", w.Name), "name").ViaIndex(workspaceIdx).ViaField("workspaces").ViaIndex(stepIdx).ViaField("steps"))
                        }</span>
                }
        }

        <span class="cov8" title="1">for sidecarIdx, sidecar := range sidecars </span><span class="cov8" title="1">{
                if len(sidecar.Workspaces) != 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecar workspaces", config.BetaAPIFields).ViaIndex(sidecarIdx).ViaField("sidecars"))
                }</span>
                <span class="cov8" title="1">for workspaceIdx, w := range sidecar.Workspaces </span><span class="cov8" title="1">{
                        if !wsNames.Has(w.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("undefined workspace %q", w.Name), "name").ViaIndex(workspaceIdx).ViaField("workspaces").ViaIndex(sidecarIdx).ViaField("sidecars"))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// ValidateVolumes validates a slice of volumes to make sure there are no dupilcate names
func ValidateVolumes(volumes []corev1.Volume) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Task must not have duplicate volume names.
        vols := sets.NewString()
        for idx, v := range volumes </span><span class="cov8" title="1">{
                if vols.Has(v.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("multiple volumes with same name %q", v.Name), "name").ViaIndex(idx))
                }</span> else<span class="cov8" title="1"> {
                        vols.Insert(v.Name)
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func validateSteps(ctx context.Context, steps []Step) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Task must not have duplicate step names.
        names := sets.NewString()
        for idx, s := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStep(ctx, s, names).ViaIndex(idx))
                if s.Results != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(v1.ValidateStepResultsVariables(ctx, s.Results, s.Script).ViaIndex(idx))
                        errs = errs.Also(v1.ValidateStepResults(ctx, s.Results).ViaIndex(idx).ViaField("results"))
                }</span>
                <span class="cov8" title="1">if len(s.When) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(s.When.validate(ctx).ViaIndex(idx))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func errorIfStepResultReferenceinField(value, fieldName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        matches := resultref.StepResultRegex.FindAllStringSubmatch(value, -1)
        if len(matches) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "stepResult substitutions are only allowed in env, command and args. Found usage in",
                        Paths:   []string{fieldName},
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func stepArtifactReferenceExists(src string) bool <span class="cov8" title="1">{
        return len(artifactref.StepArtifactRegex.FindAllStringSubmatch(src, -1)) &gt; 0 || strings.Contains(src, "$("+artifactref.StepArtifactPathPattern+")")
}</span>

func taskArtifactReferenceExists(src string) bool <span class="cov8" title="1">{
        return len(artifactref.TaskArtifactRegex.FindAllStringSubmatch(src, -1)) &gt; 0 || strings.Contains(src, "$("+artifactref.TaskArtifactPathPattern+")")
}</span>

func errorIfStepArtifactReferencedInField(value, fieldName string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if stepArtifactReferenceExists(value) </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "stepArtifact substitutions are only allowed in env, command, args and script. Found usage in",
                        Paths:   []string{fieldName},
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateStepArtifactsReference(s Step) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.Name, "name"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.Image, "image"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(string(s.ImagePullPolicy), "imagePullPolicy"))
        errs = errs.Also(errorIfStepArtifactReferencedInField(s.WorkingDir, "workingDir"))
        for _, e := range s.EnvFrom </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(e.Prefix, "envFrom.prefix"))
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepArtifactReferencedInField(e.ConfigMapRef.LocalObjectReference.Name, "envFrom.configMapRef"))
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepArtifactReferencedInField(e.SecretRef.LocalObjectReference.Name, "envFrom.secretRef"))
                }</span>
        }
        <span class="cov8" title="1">for _, v := range s.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.Name, "volumeMounts.name"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.MountPath, "volumeMounts.mountPath"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.SubPath, "volumeMounts.subPath"))
        }</span>
        <span class="cov8" title="1">for _, v := range s.VolumeDevices </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.Name, "volumeDevices.name"))
                errs = errs.Also(errorIfStepArtifactReferencedInField(v.DevicePath, "volumeDevices.devicePath"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateStepResultReference(s Step) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(errorIfStepResultReferenceinField(s.Name, "name"))
        errs = errs.Also(errorIfStepResultReferenceinField(s.Image, "image"))
        errs = errs.Also(errorIfStepResultReferenceinField(s.Script, "script"))
        errs = errs.Also(errorIfStepResultReferenceinField(string(s.ImagePullPolicy), "imagePullPolicy"))
        errs = errs.Also(errorIfStepResultReferenceinField(s.WorkingDir, "workingDir"))
        for _, e := range s.EnvFrom </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferenceinField(e.Prefix, "envFrom.prefix"))
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepResultReferenceinField(e.ConfigMapRef.LocalObjectReference.Name, "envFrom.configMapRef"))
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(errorIfStepResultReferenceinField(e.SecretRef.LocalObjectReference.Name, "envFrom.secretRef"))
                }</span>
        }
        <span class="cov8" title="1">for _, v := range s.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferenceinField(v.Name, "volumeMounts.name"))
                errs = errs.Also(errorIfStepResultReferenceinField(v.MountPath, "volumeMounts.mountPath"))
                errs = errs.Also(errorIfStepResultReferenceinField(v.SubPath, "volumeMounts.subPath"))
        }</span>
        <span class="cov8" title="1">for _, v := range s.VolumeDevices </span><span class="cov8" title="1">{
                errs = errs.Also(errorIfStepResultReferenceinField(v.Name, "volumeDevices.name"))
                errs = errs.Also(errorIfStepResultReferenceinField(v.DevicePath, "volumeDevices.devicePath"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateStep(ctx context.Context, s Step, names sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        if err := validateArtifactsReferencesInStep(ctx, s); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if s.Ref != nil </span><span class="cov8" title="1">{
                errs = errs.Also(s.Ref.Validate(ctx))
                if s.Image != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "image cannot be used with Ref",
                                Paths:   []string{"image"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "command cannot be used with Ref",
                                Paths:   []string{"command"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Args) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "args cannot be used with Ref",
                                Paths:   []string{"args"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "script cannot be used with Ref",
                                Paths:   []string{"script"},
                        })
                }</span>
                <span class="cov8" title="1">if s.WorkingDir != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "working dir cannot be used with Ref",
                                Paths:   []string{"workingDir"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Env != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "env cannot be used with Ref",
                                Paths:   []string{"env"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.VolumeMounts) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "volumeMounts cannot be used with Ref",
                                Paths:   []string{"volumeMounts"},
                        })
                }</span>
                <span class="cov8" title="1">if len(s.Results) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "results cannot be used with Ref",
                                Paths:   []string{"results"},
                        })
                }</span>
        } else<span class="cov8" title="1"> {
                if len(s.Params) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: "params cannot be used without Ref",
                                Paths:   []string{"params"},
                        })
                }</span>
                <span class="cov8" title="1">if s.Image == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("Image"))
                }</span>

                <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                        if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(&amp;apis.FieldError{
                                        Message: "script cannot be used with command",
                                        Paths:   []string{"script"},
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">if s.Name != "" </span><span class="cov8" title="1">{
                if names.Has(s.Name) </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(s.Name, "name"))
                }</span>
                <span class="cov8" title="1">if e := validation.IsDNS1123Label(s.Name); len(e) &gt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid value %q", s.Name),
                                Paths:   []string{"name"},
                                Details: "Task step name must be a valid DNS Label, For more info refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        })
                }</span>
                <span class="cov8" title="1">names.Insert(s.Name)</span>
        }

        <span class="cov8" title="1">if s.Timeout != nil </span><span class="cov8" title="1">{
                if s.Timeout.Duration &lt; time.Duration(0) </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(s.Timeout.Duration, "negative timeout")
                }</span>
        }

        <span class="cov8" title="1">for j, vm := range s.VolumeMounts </span><span class="cov8" title="1">{
                if strings.HasPrefix(vm.MountPath, "/tekton/") &amp;&amp;
                        !strings.HasPrefix(vm.MountPath, "/tekton/home") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("volumeMount cannot be mounted under /tekton/ (volumeMount %q mounted at %q)", vm.Name, vm.MountPath), "mountPath").ViaFieldIndex("volumeMounts", j))
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(vm.Name, "tekton-internal-") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf(`volumeMount name %q cannot start with "tekton-internal-"`, vm.Name), "name").ViaFieldIndex("volumeMounts", j))
                }</span>
        }

        <span class="cov8" title="1">if s.OnError != "" </span><span class="cov8" title="1">{
                if !isParamRefs(string(s.OnError)) &amp;&amp; s.OnError != Continue &amp;&amp; s.OnError != StopAndFail </span><span class="cov8" title="1">{
                        errs = errs.Also(&amp;apis.FieldError{
                                Message: fmt.Sprintf("invalid value: \"%v\"", s.OnError),
                                Paths:   []string{"onError"},
                                Details: "Task step onError must be either \"continue\" or \"stopAndFail\"",
                        })
                }</span>
        }

        <span class="cov8" title="1">if s.Script != "" </span><span class="cov8" title="1">{
                cleaned := strings.TrimSpace(s.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "windows script support", config.AlphaAPIFields).ViaField("script"))
                }</span>
        }

        // StdoutConfig is an alpha feature and will fail validation if it's used in a task spec
        // when the enable-api-fields feature gate is not "alpha".
        <span class="cov8" title="1">if s.StdoutConfig != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step stdout stream support", config.AlphaAPIFields).ViaField("stdoutconfig"))
        }</span>
        // StderrConfig is an alpha feature and will fail validation if it's used in a task spec
        // when the enable-api-fields feature gate is not "alpha".
        <span class="cov8" title="1">if s.StderrConfig != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "step stderr stream support", config.AlphaAPIFields).ViaField("stderrconfig"))
        }</span>

        // Validate usage of step result reference.
        // Referencing previous step's results are only allowed in `env`, `command` and `args`.
        <span class="cov8" title="1">errs = errs.Also(validateStepResultReference(s))

        // Validate usage of step artifacts output reference
        // Referencing previous step's results are only allowed in `env`, `command` and `args`, `script`.
        errs = errs.Also(validateStepArtifactsReference(s))

        return errs</span>
}

func validateArtifactsReferencesInStep(ctx context.Context, s Step) *apis.FieldError <span class="cov8" title="1">{
        if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableArtifacts </span><span class="cov8" title="1">{
                var t []string
                t = append(t, s.Script)
                t = append(t, s.Command...)
                t = append(t, s.Args...)
                for _, e := range s.Env </span><span class="cov8" title="1">{
                        t = append(t, e.Value)
                }</span>
                <span class="cov8" title="1">if slices.ContainsFunc(t, stepArtifactReferenceExists) || slices.ContainsFunc(t, taskArtifactReferenceExists) </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use artifacts feature.", config.EnableArtifacts), "")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateParameterTypes validates all the types within a slice of ParamSpecs
func ValidateParameterTypes(ctx context.Context, params []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                errs = errs.Also(p.ValidateType(ctx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateType checks that the type of a ParamSpec is allowed and its default value matches that type
func (p ParamSpec) ValidateType(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Ensure param has a valid type.
        validType := false
        for _, allowedType := range AllParamTypes </span><span class="cov8" title="1">{
                if p.Type == allowedType </span><span class="cov8" title="1">{
                        validType = true
                }</span>
        }
        <span class="cov8" title="1">if !validType </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue(p.Type, p.Name+".type")
        }</span>

        // If a default value is provided, ensure its type matches param's declared type.
        <span class="cov8" title="1">if (p.Default != nil) &amp;&amp; (p.Default.Type != p.Type) </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf(
                                "\"%v\" type does not match default value's type: \"%v\"", p.Type, p.Default.Type),
                        Paths: []string{
                                p.Name + ".type",
                                p.Name + ".default.type",
                        },
                }
        }</span>

        // Check object type and its PropertySpec type
        <span class="cov8" title="1">return p.ValidateObjectType(ctx)</span>
}

// ValidateObjectType checks that object type parameter does not miss the
// definition of `properties` section and the type of a PropertySpec is allowed.
// (Currently, only string is allowed)
func (p ParamSpec) ValidateObjectType(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        invalidKeys := []string{}
        for key, propertySpec := range p.Properties </span><span class="cov8" title="1">{
                if propertySpec.Type != ParamTypeString </span><span class="cov8" title="1">{
                        invalidKeys = append(invalidKeys, key)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidKeys) != 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("The value type specified for these keys %v is invalid", invalidKeys),
                        Paths:   []string{p.Name + ".properties"},
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateParameterVariables validates all variables within a slice of ParamSpecs against a slice of Steps
func ValidateParameterVariables(ctx context.Context, steps []Step, params ParamSpecs) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        errs = errs.Also(params.validateNoDuplicateNames())
        errs = errs.Also(params.validateParamEnums(ctx).ViaField("params"))
        stringParams, arrayParams, objectParams := params.sortByType()
        stringParameterNames := sets.NewString(stringParams.getNames()...)
        arrayParameterNames := sets.NewString(arrayParams.getNames()...)
        errs = errs.Also(validateNameFormat(stringParameterNames.Insert(arrayParameterNames.List()...), objectParams))
        return errs.Also(validateArrayUsage(steps, "params", arrayParameterNames))
}</span>

// validateTaskContextVariables returns an error if any Steps reference context variables that don't exist.
func validateTaskContextVariables(ctx context.Context, steps []Step) *apis.FieldError <span class="cov8" title="1">{
        taskRunContextNames := sets.NewString().Insert(
                "name",
                "namespace",
                "uid",
        )
        taskContextNames := sets.NewString().Insert(
                "name",
                "retry-count",
        )
        errs := validateVariables(ctx, steps, "context\\.taskRun", taskRunContextNames)
        return errs.Also(validateVariables(ctx, steps, "context\\.task", taskContextNames))
}</span>

// validateTaskResultsVariables validates if the results referenced in step script are defined in task results
func validateTaskResultsVariables(ctx context.Context, steps []Step, results []TaskResult) (errs *apis.FieldError) <span class="cov8" title="1">{
        resultsNames := sets.NewString()
        for _, r := range results </span><span class="cov8" title="1">{
                resultsNames.Insert(r.Name)
        }</span>
        <span class="cov8" title="1">for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariablesWithDetail(step.Script, "results", resultsNames).ViaField("script").ViaFieldIndex("steps", idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateObjectUsage validates the usage of individual attributes of an object param and the usage of the entire object
func validateObjectUsage(ctx context.Context, steps []Step, params []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        objectParameterNames := sets.NewString()
        for _, p := range params </span><span class="cov8" title="1">{
                // collect all names of object type params
                objectParameterNames.Insert(p.Name)

                // collect all keys for this object param
                objectKeys := sets.NewString()
                for key := range p.Properties </span><span class="cov8" title="1">{
                        objectKeys.Insert(key)
                }</span>

                // check if the object's key names are referenced correctly i.e. param.objectParam.key1
                <span class="cov8" title="1">errs = errs.Also(validateVariables(ctx, steps, "params\\."+p.Name, objectKeys))</span>
        }

        <span class="cov8" title="1">return errs.Also(validateObjectUsageAsWhole(steps, "params", objectParameterNames))</span>
}

// validateObjectUsageAsWhole returns an error if the Steps contain references to the entire input object params in fields where these references are prohibited
func validateObjectUsageAsWhole(steps []Step, prefix string, vars sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepObjectUsageAsWhole(step, prefix, vars)).ViaFieldIndex("steps", idx)
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepObjectUsageAsWhole returns an error if the Step contains references to the entire input object params in fields where these references are prohibited
func validateStepObjectUsageAsWhole(step Step, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Name, prefix, vars).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Image, prefix, vars).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.WorkingDir, prefix, vars).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(step.Script, prefix, vars).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov0" title="0">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.Name, prefix, vars).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.MountPath, prefix, vars).ViaField("mountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(v.SubPath, prefix, vars).ViaField("subPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateArrayUsage returns an error if the Steps contain references to the input array params in fields where these references are prohibited
func validateArrayUsage(steps []Step, prefix string, arrayParamNames sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepArrayUsage(step, prefix, arrayParamNames)).ViaFieldIndex("steps", idx)
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateStepArrayUsage returns an error if the Step contains references to the input array params in fields where these references are prohibited
func validateStepArrayUsage(step Step, prefix string, arrayParamNames sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToProhibitedVariables(step.Name, prefix, arrayParamNames).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.Image, prefix, arrayParamNames).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.WorkingDir, prefix, arrayParamNames).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(step.Script, prefix, arrayParamNames).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(cmd, prefix, arrayParamNames).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateVariableReferenceIsIsolated(arg, prefix, arrayParamNames).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(env.Value, prefix, arrayParamNames).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.Name, prefix, arrayParamNames).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.MountPath, prefix, arrayParamNames).ViaField("mountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(v.SubPath, prefix, arrayParamNames).ViaField("subPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateVariables returns an error if the Steps contain references to any unknown variables
func validateVariables(ctx context.Context, steps []Step, prefix string, vars sets.String) (errs *apis.FieldError) <span class="cov8" title="1">{
        // We've checked param name format. Now, we want to check if param names are referenced correctly in each step
        for idx, step := range steps </span><span class="cov8" title="1">{
                errs = errs.Also(validateStepVariables(ctx, step, prefix, vars).ViaFieldIndex("steps", idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// validateNameFormat validates that the name format of all param types follows the rules
func validateNameFormat(stringAndArrayParams sets.String, objectParams []ParamSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        // checking string or array name format
        // ----
        invalidStringAndArrayNames := []string{}
        // Converting to sorted list here rather than just looping map keys
        // because we want the order of items in vars to be deterministic for purpose of unit testing
        for _, name := range stringAndArrayParams.List() </span><span class="cov8" title="1">{
                if !stringAndArrayVariableNameFormatRegex.MatchString(name) </span><span class="cov8" title="1">{
                        invalidStringAndArrayNames = append(invalidStringAndArrayNames, name)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidStringAndArrayNames) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("The format of following array and string variable names is invalid: %s", invalidStringAndArrayNames),
                        Paths:   []string{"params"},
                        Details: "String/Array Names: \nMust only contain alphanumeric characters, hyphens (-), underscores (_), and dots (.)\nMust begin with a letter or an underscore (_)",
                })
        }</span>

        // checking object name and key name format
        // -----
        <span class="cov8" title="1">invalidObjectNames := map[string][]string{}
        for _, obj := range objectParams </span><span class="cov8" title="1">{
                // check object param name
                if !objectVariableNameFormatRegex.MatchString(obj.Name) </span><span class="cov8" title="1">{
                        invalidObjectNames[obj.Name] = []string{}
                }</span>

                // check key names
                <span class="cov8" title="1">for k := range obj.Properties </span><span class="cov8" title="1">{
                        if !objectVariableNameFormatRegex.MatchString(k) </span><span class="cov8" title="1">{
                                invalidObjectNames[obj.Name] = append(invalidObjectNames[obj.Name], k)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(invalidObjectNames) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: fmt.Sprintf("Object param name and key name format is invalid: %s", invalidObjectNames),
                        Paths:   []string{"params"},
                        Details: "Object Names: \nMust only contain alphanumeric characters, hyphens (-), underscores (_) \nMust begin with a letter or an underscore (_)",
                })
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// validateStepVariables returns an error if the Step contains references to any unknown variables
func validateStepVariables(ctx context.Context, step Step, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        errs := substitution.ValidateNoReferencesToUnknownVariables(step.Name, prefix, vars).ViaField("name")
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.Image, prefix, vars).ViaField("image"))
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(step.WorkingDir, prefix, vars).ViaField("workingDir"))
        errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariablesWithDetail(step.Script, prefix, vars).ViaField("script"))
        for i, cmd := range step.Command </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(cmd, prefix, vars).ViaFieldIndex("command", i))
        }</span>
        <span class="cov8" title="1">for i, arg := range step.Args </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(arg, prefix, vars).ViaFieldIndex("args", i))
        }</span>
        <span class="cov8" title="1">for _, env := range step.Env </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(env.Value, prefix, vars).ViaFieldKey("env", env.Name))
        }</span>
        <span class="cov8" title="1">for i, v := range step.VolumeMounts </span><span class="cov8" title="1">{
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.Name, prefix, vars).ViaField("name").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.MountPath, prefix, vars).ViaField("MountPath").ViaFieldIndex("volumeMount", i))
                errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(v.SubPath, prefix, vars).ViaField("SubPath").ViaFieldIndex("volumeMount", i))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(string(step.OnError), prefix, vars).ViaField("onError"))
        return errs</span>
}

// isParamRefs attempts to check if a specified string looks like it contains any parameter reference
// This is useful to make sure the specified value looks like a Parameter Reference before performing any strict validation
func isParamRefs(s string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(s, "$("+ParamsPrefix)
}</span>

// GetIndexingReferencesToArrayParams returns all strings referencing indices of TaskRun array parameters
// from parameters, workspaces, and when expressions defined in the Task.
// For example, if a Task has a parameter with a value "$(params.array-param-name[1])",
// this would be one of the strings returned.
func (ts *TaskSpec) GetIndexingReferencesToArrayParams() sets.String <span class="cov8" title="1">{
        // collect all the possible places to use param references
        paramsRefs := []string{}
        paramsRefs = append(paramsRefs, extractParamRefsFromSteps(ts.Steps)...)
        paramsRefs = append(paramsRefs, extractParamRefsFromStepTemplate(ts.StepTemplate)...)
        paramsRefs = append(paramsRefs, extractParamRefsFromVolumes(ts.Volumes)...)
        for _, v := range ts.Workspaces </span><span class="cov8" title="1">{
                paramsRefs = append(paramsRefs, v.MountPath)
        }</span>
        <span class="cov8" title="1">paramsRefs = append(paramsRefs, extractParamRefsFromSidecars(ts.Sidecars)...)
        // extract all array indexing references, for example []{"$(params.array-params[1])"}
        arrayIndexParamRefs := []string{}
        for _, p := range paramsRefs </span><span class="cov8" title="1">{
                arrayIndexParamRefs = append(arrayIndexParamRefs, extractArrayIndexingParamRefs(p)...)
        }</span>
        <span class="cov8" title="1">return sets.NewString(arrayIndexParamRefs...)</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (tr TaskRef) convertTo(ctx context.Context, sink *v1.TaskRef) <span class="cov8" title="1">{
        sink.Name = tr.Name
        sink.Kind = v1.TaskKind(tr.Kind)
        sink.APIVersion = tr.APIVersion
        new := v1.ResolverRef{}
        tr.ResolverRef.convertTo(ctx, &amp;new)
        sink.ResolverRef = new
}</span>

// ConvertFrom converts v1beta1 TaskRef from v1 TaskRef
func (tr *TaskRef) ConvertFrom(ctx context.Context, source v1.TaskRef) <span class="cov8" title="1">{
        tr.Name = source.Name
        tr.Kind = TaskKind(source.Kind)
        tr.APIVersion = source.APIVersion
        new := ResolverRef{}
        new.convertFrom(ctx, source.ResolverRef)
        tr.ResolverRef = new
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// TaskRef can be used to refer to a specific instance of a task.
type TaskRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // TaskKind indicates the Kind of the Task:
        // 1. Namespaced Task when Kind is set to "Task". If Kind is "", it defaults to "Task".
        // 2. Custom Task when Kind is non-empty and APIVersion is non-empty
        Kind TaskKind `json:"kind,omitempty"`
        // API version of the referent
        // Note: A Task with non-empty APIVersion and Kind is considered a Custom Task
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`
        // Bundle url reference to a Tekton Bundle.
        //
        // Deprecated: Please use ResolverRef with the bundles resolver instead.
        // The field is staying there for go client backward compatibility, but is not used/allowed anymore.
        // +optional
        Bundle string `json:"bundle,omitempty"`

        // ResolverRef allows referencing a Task in a remote location
        // like a git repo. This field is only supported when the alpha
        // feature gate is enabled.
        // +optional
        ResolverRef `json:",omitempty"`
}

// Check that Pipeline may be validated and defaulted.

// TaskKind defines the type of Task used by the pipeline.
type TaskKind string

const (
        // NamespacedTaskKind indicates that the task type has a namespaced scope.
        NamespacedTaskKind TaskKind = "Task"
)

// IsCustomTask checks whether the reference is to a Custom Task
func (tr *TaskRef) IsCustomTask() bool <span class="cov8" title="1">{
        // Note that if `apiVersion` is set to `"tekton.dev/v1beta1"` and `kind` is set to `"Task"`,
        // the reference will be considered a Custom Task - https://github.com/tektoncd/pipeline/issues/6457
        return tr != nil &amp;&amp; tr.APIVersion != "" &amp;&amp; tr.Kind != ""
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// Validate ensures that a supplied TaskRef field is populated
// correctly. No errors are returned for a nil TaskRef.
func (ref *TaskRef) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">if apis.IsInCreate(ctx) &amp;&amp; ref.Bundle != "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("bundle"))
        }</span>
        <span class="cov8" title="1">switch </span>{
        case ref.Resolver != "" || ref.Params != nil:<span class="cov8" title="1">
                if ref.Params != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver params", config.BetaAPIFields).ViaField("params"))
                        if ref.Name != "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name", "params"))
                        }</span>
                        <span class="cov8" title="1">if ref.Resolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ref.Params))</span>
                }
                <span class="cov8" title="1">if ref.Resolver != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "resolver", config.BetaAPIFields).ViaField("resolver"))
                        if ref.Name != "" </span><span class="cov8" title="1">{
                                // make sure that the name is url-like.
                                err := RefNameLikeUrl(ref.Name)
                                if err == nil &amp;&amp; !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                        // If name is url-like then concise resolver syntax must be enabled
                                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(err, "name"))
                                }</span>
                        }
                }
        case ref.Name != "":<span class="cov8" title="1">
                // ref name can be a Url-like format.
                if err := RefNameLikeUrl(ref.Name); err == nil </span><span class="cov8" title="1">{
                        // If name is url-like then concise resolver syntax must be enabled
                        if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableConciseResolverSyntax </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use concise resolver syntax", config.EnableConciseResolverSyntax), ""))
                        }</span>
                        // In stage1 of concise remote resolvers syntax, this is a required field.
                        // TODO: remove this check when implementing stage 2 where this is optional.
                        <span class="cov8" title="1">if ref.Resolver == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("resolver"))
                        }</span>
                        // Or, it must be a valid k8s name
                } else<span class="cov8" title="1"> {
                        // ref name must be a valid k8s name
                        if errSlice := validation.IsQualifiedName(ref.Name); len(errSlice) != 0 </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(strings.Join(errSlice, ","), "name"))
                        }</span>
                }
        default:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("name"))</span>
        }
        <span class="cov8" title="1">return</span> //nolint:nakedret
}
</pre>
		
		<pre class="file" id="file130" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/version"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

const (
        cloudEventsAnnotationKey     = "tekton.dev/v1beta1CloudEvents"
        resourcesResultAnnotationKey = "tekton.dev/v1beta1ResourcesResult"
        resourcesStatusAnnotationKey = "tekton.dev/v1beta1ResourcesStatus"
)

var _ apis.Convertible = (*TaskRun)(nil)

// ConvertTo implements apis.Convertible
func (tr *TaskRun) ConvertTo(ctx context.Context, to apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := to.(type) </span>{
        case *v1.TaskRun:<span class="cov8" title="1">
                sink.ObjectMeta = tr.ObjectMeta
                if err := serializeTaskRunResources(&amp;sink.ObjectMeta, &amp;tr.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := serializeTaskRunCloudEvents(&amp;sink.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := serializeTaskRunResourcesResult(&amp;sink.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := serializeTaskRunResourcesStatus(&amp;sink.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := tr.Status.ConvertTo(ctx, &amp;sink.Status, &amp;sink.ObjectMeta); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return tr.Spec.ConvertTo(ctx, &amp;sink.Spec, &amp;sink.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo implements apis.Convertible
func (trs *TaskRunSpec) ConvertTo(ctx context.Context, sink *v1.TaskRunSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        if trs.Debug != nil </span><span class="cov8" title="1">{
                sink.Debug = &amp;v1.TaskRunDebug{}
                trs.Debug.convertTo(ctx, sink.Debug)
        }</span>
        <span class="cov8" title="1">sink.Params = nil
        for _, p := range trs.Params </span><span class="cov8" title="1">{
                new := v1.Param{}
                p.convertTo(ctx, &amp;new)
                sink.Params = append(sink.Params, new)
        }</span>
        <span class="cov8" title="1">sink.ServiceAccountName = trs.ServiceAccountName
        if trs.TaskRef != nil </span><span class="cov8" title="1">{
                sink.TaskRef = &amp;v1.TaskRef{}
                trs.TaskRef.convertTo(ctx, sink.TaskRef)
        }</span>
        <span class="cov8" title="1">if trs.TaskSpec != nil </span><span class="cov8" title="1">{
                sink.TaskSpec = &amp;v1.TaskSpec{}
                err := trs.TaskSpec.ConvertTo(ctx, sink.TaskSpec, meta, meta.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">sink.Status = v1.TaskRunSpecStatus(trs.Status)
        sink.StatusMessage = v1.TaskRunSpecStatusMessage(trs.StatusMessage)
        sink.Retries = trs.Retries
        sink.Timeout = trs.Timeout
        sink.PodTemplate = trs.PodTemplate
        sink.Workspaces = nil
        for _, w := range trs.Workspaces </span><span class="cov8" title="1">{
                new := v1.WorkspaceBinding{}
                w.convertTo(ctx, &amp;new)
                sink.Workspaces = append(sink.Workspaces, new)
        }</span>
        <span class="cov8" title="1">sink.StepSpecs = nil
        for _, so := range trs.StepOverrides </span><span class="cov8" title="1">{
                new := v1.TaskRunStepSpec{}
                so.convertTo(ctx, &amp;new)
                sink.StepSpecs = append(sink.StepSpecs, new)
        }</span>
        <span class="cov8" title="1">sink.SidecarSpecs = nil
        for _, so := range trs.SidecarOverrides </span><span class="cov8" title="1">{
                new := v1.TaskRunSidecarSpec{}
                so.convertTo(ctx, &amp;new)
                sink.SidecarSpecs = append(sink.SidecarSpecs, new)
        }</span>
        <span class="cov8" title="1">sink.ComputeResources = trs.ComputeResources
        return nil</span>
}

// ConvertFrom implements apis.Convertible
func (tr *TaskRun) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch source := from.(type) </span>{
        case *v1.TaskRun:<span class="cov8" title="1">
                tr.ObjectMeta = source.ObjectMeta
                if err := deserializeTaskRunResources(&amp;tr.ObjectMeta, &amp;tr.Spec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := deserializeTaskRunCloudEvents(&amp;tr.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := deserializeTaskRunResourcesResult(&amp;tr.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := tr.Status.ConvertFrom(ctx, source.Status, &amp;tr.ObjectMeta); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := deserializeTaskRunResourcesStatus(&amp;tr.ObjectMeta, &amp;tr.Status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return tr.Spec.ConvertFrom(ctx, &amp;source.Spec, &amp;tr.ObjectMeta)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", tr)</span>
        }
}

// ConvertFrom implements apis.Convertible
func (trs *TaskRunSpec) ConvertFrom(ctx context.Context, source *v1.TaskRunSpec, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        if source.Debug != nil </span><span class="cov8" title="1">{
                newDebug := TaskRunDebug{}
                newDebug.convertFrom(ctx, *source.Debug)
                trs.Debug = &amp;newDebug
        }</span>
        <span class="cov8" title="1">trs.Params = nil
        for _, p := range source.Params </span><span class="cov8" title="1">{
                new := Param{}
                new.ConvertFrom(ctx, p)
                trs.Params = append(trs.Params, new)
        }</span>
        <span class="cov8" title="1">trs.ServiceAccountName = source.ServiceAccountName
        if source.TaskRef != nil </span><span class="cov8" title="1">{
                newTaskRef := TaskRef{}
                newTaskRef.ConvertFrom(ctx, *source.TaskRef)
                trs.TaskRef = &amp;newTaskRef
        }</span>
        <span class="cov8" title="1">if source.TaskSpec != nil </span><span class="cov8" title="1">{
                newTaskSpec := TaskSpec{}
                err := newTaskSpec.ConvertFrom(ctx, source.TaskSpec, meta, meta.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">trs.TaskSpec = &amp;newTaskSpec</span>
        }
        <span class="cov8" title="1">trs.Status = TaskRunSpecStatus(source.Status)
        trs.StatusMessage = TaskRunSpecStatusMessage(source.StatusMessage)
        trs.Retries = source.Retries
        trs.Timeout = source.Timeout
        trs.PodTemplate = source.PodTemplate
        trs.Workspaces = nil
        for _, w := range source.Workspaces </span><span class="cov8" title="1">{
                new := WorkspaceBinding{}
                new.ConvertFrom(ctx, w)
                trs.Workspaces = append(trs.Workspaces, new)
        }</span>
        <span class="cov8" title="1">trs.StepOverrides = nil
        for _, so := range source.StepSpecs </span><span class="cov8" title="1">{
                new := TaskRunStepOverride{}
                new.convertFrom(ctx, so)
                trs.StepOverrides = append(trs.StepOverrides, new)
        }</span>
        <span class="cov8" title="1">trs.SidecarOverrides = nil
        for _, so := range source.SidecarSpecs </span><span class="cov8" title="1">{
                new := TaskRunSidecarOverride{}
                new.convertFrom(ctx, so)
                trs.SidecarOverrides = append(trs.SidecarOverrides, new)
        }</span>
        <span class="cov8" title="1">trs.ComputeResources = source.ComputeResources
        return nil</span>
}

func (trd TaskRunDebug) convertTo(ctx context.Context, sink *v1.TaskRunDebug) <span class="cov8" title="1">{
        if trd.Breakpoints != nil </span><span class="cov8" title="1">{
                sink.Breakpoints = &amp;v1.TaskBreakpoints{}
                trd.Breakpoints.convertTo(ctx, sink.Breakpoints)
        }</span>
}

func (trd *TaskRunDebug) convertFrom(ctx context.Context, source v1.TaskRunDebug) <span class="cov8" title="1">{
        if source.Breakpoints != nil </span><span class="cov8" title="1">{
                newBreakpoints := TaskBreakpoints{}
                newBreakpoints.convertFrom(ctx, *source.Breakpoints)
                trd.Breakpoints = &amp;newBreakpoints
        }</span>
}

func (tbp TaskBreakpoints) convertTo(ctx context.Context, sink *v1.TaskBreakpoints) <span class="cov8" title="1">{
        sink.OnFailure = tbp.OnFailure
        if len(tbp.BeforeSteps) &gt; 0 </span><span class="cov8" title="1">{
                sink.BeforeSteps = make([]string, 0)
                sink.BeforeSteps = append(sink.BeforeSteps, tbp.BeforeSteps...)
        }</span>
}

func (tbp *TaskBreakpoints) convertFrom(ctx context.Context, source v1.TaskBreakpoints) <span class="cov8" title="1">{
        tbp.OnFailure = source.OnFailure
        if len(source.BeforeSteps) &gt; 0 </span><span class="cov8" title="1">{
                tbp.BeforeSteps = make([]string, 0)
                tbp.BeforeSteps = append(tbp.BeforeSteps, source.BeforeSteps...)
        }</span>
}

func (trso TaskRunStepOverride) convertTo(ctx context.Context, sink *v1.TaskRunStepSpec) <span class="cov8" title="1">{
        sink.Name = trso.Name
        sink.ComputeResources = trso.Resources
}</span>

func (trso *TaskRunStepOverride) convertFrom(ctx context.Context, source v1.TaskRunStepSpec) <span class="cov8" title="1">{
        trso.Name = source.Name
        trso.Resources = source.ComputeResources
}</span>

func (trso TaskRunSidecarOverride) convertTo(ctx context.Context, sink *v1.TaskRunSidecarSpec) <span class="cov8" title="1">{
        sink.Name = trso.Name
        sink.ComputeResources = trso.Resources
}</span>

func (trso *TaskRunSidecarOverride) convertFrom(ctx context.Context, source v1.TaskRunSidecarSpec) <span class="cov8" title="1">{
        trso.Name = source.Name
        trso.Resources = source.ComputeResources
}</span>

// ConvertTo implements apis.Convertible
func (trs *TaskRunStatus) ConvertTo(ctx context.Context, sink *v1.TaskRunStatus, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        sink.Status = trs.Status
        sink.PodName = trs.PodName
        sink.StartTime = trs.StartTime
        sink.CompletionTime = trs.CompletionTime
        sink.Steps = nil
        for _, ss := range trs.Steps </span><span class="cov8" title="1">{
                new := v1.StepState{}
                ss.convertTo(ctx, &amp;new)
                sink.Steps = append(sink.Steps, new)
        }</span>
        <span class="cov8" title="1">sink.RetriesStatus = nil
        for _, rr := range trs.RetriesStatus </span><span class="cov8" title="1">{
                new := v1.TaskRunStatus{}
                err := rr.ConvertTo(ctx, &amp;new, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sink.RetriesStatus = append(sink.RetriesStatus, new)</span>
        }
        <span class="cov8" title="1">sink.Results = nil
        for _, trr := range trs.TaskRunResults </span><span class="cov8" title="1">{
                new := v1.TaskRunResult{}
                trr.convertTo(ctx, &amp;new)
                sink.Results = append(sink.Results, new)
        }</span>
        <span class="cov8" title="1">sink.Sidecars = nil
        for _, sc := range trs.Sidecars </span><span class="cov8" title="1">{
                new := v1.SidecarState{}
                sc.convertTo(ctx, &amp;new)
                sink.Sidecars = append(sink.Sidecars, new)
        }</span>

        <span class="cov8" title="1">if trs.TaskSpec != nil </span><span class="cov8" title="1">{
                sink.TaskSpec = &amp;v1.TaskSpec{}
                err := trs.TaskSpec.ConvertTo(ctx, sink.TaskSpec, meta, meta.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if trs.Provenance != nil </span><span class="cov8" title="1">{
                new := v1.Provenance{}
                trs.Provenance.convertTo(ctx, &amp;new)
                sink.Provenance = &amp;new
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom implements apis.Convertible
func (trs *TaskRunStatus) ConvertFrom(ctx context.Context, source v1.TaskRunStatus, meta *metav1.ObjectMeta) error <span class="cov8" title="1">{
        trs.Status = source.Status
        trs.PodName = source.PodName
        trs.StartTime = source.StartTime
        trs.CompletionTime = source.CompletionTime
        trs.Steps = nil
        for _, ss := range source.Steps </span><span class="cov8" title="1">{
                new := StepState{}
                new.convertFrom(ctx, ss)
                trs.Steps = append(trs.Steps, new)
        }</span>
        <span class="cov8" title="1">trs.RetriesStatus = nil
        for _, rr := range source.RetriesStatus </span><span class="cov8" title="1">{
                new := TaskRunStatus{}
                err := new.ConvertFrom(ctx, rr, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">trs.RetriesStatus = append(trs.RetriesStatus, new)</span>
        }
        <span class="cov8" title="1">trs.TaskRunResults = nil
        for _, trr := range source.Results </span><span class="cov8" title="1">{
                new := TaskRunResult{}
                new.convertFrom(ctx, trr)
                trs.TaskRunResults = append(trs.TaskRunResults, new)
        }</span>
        <span class="cov8" title="1">trs.Sidecars = nil
        for _, sc := range source.Sidecars </span><span class="cov8" title="1">{
                new := SidecarState{}
                new.convertFrom(ctx, sc)
                trs.Sidecars = append(trs.Sidecars, new)
        }</span>

        <span class="cov8" title="1">if source.TaskSpec != nil </span><span class="cov8" title="1">{
                trs.TaskSpec = &amp;TaskSpec{}
                err := trs.TaskSpec.ConvertFrom(ctx, source.TaskSpec, meta, meta.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if source.Provenance != nil </span><span class="cov8" title="1">{
                new := Provenance{}
                new.convertFrom(ctx, *source.Provenance)
                trs.Provenance = &amp;new
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ss StepState) convertTo(ctx context.Context, sink *v1.StepState) <span class="cov8" title="1">{
        sink.ContainerState = ss.ContainerState
        sink.Name = ss.Name
        sink.Container = ss.ContainerName
        sink.ImageID = ss.ImageID
        sink.Results = nil

        if ss.Provenance != nil </span><span class="cov8" title="1">{
                new := v1.Provenance{}
                ss.Provenance.convertTo(ctx, &amp;new)
                sink.Provenance = &amp;new
        }</span>

        <span class="cov8" title="1">if ss.ContainerState.Terminated != nil </span><span class="cov8" title="1">{
                sink.TerminationReason = ss.ContainerState.Terminated.Reason
        }</span>

        <span class="cov8" title="1">for _, o := range ss.Outputs </span><span class="cov8" title="1">{
                new := v1.TaskRunStepArtifact{}
                o.convertTo(ctx, &amp;new)
                sink.Outputs = append(sink.Outputs, new)
        }</span>

        <span class="cov8" title="1">for _, o := range ss.Inputs </span><span class="cov8" title="1">{
                new := v1.TaskRunStepArtifact{}
                o.convertTo(ctx, &amp;new)
                sink.Inputs = append(sink.Inputs, new)
        }</span>

        <span class="cov8" title="1">for _, r := range ss.Results </span><span class="cov8" title="1">{
                new := v1.TaskRunStepResult{}
                r.convertTo(ctx, &amp;new)
                sink.Results = append(sink.Results, new)
        }</span>
}

func (ss *StepState) convertFrom(ctx context.Context, source v1.StepState) <span class="cov8" title="1">{
        ss.ContainerState = source.ContainerState
        ss.Name = source.Name
        ss.ContainerName = source.Container
        ss.ImageID = source.ImageID
        ss.Results = nil
        for _, r := range source.Results </span><span class="cov8" title="1">{
                new := TaskRunStepResult{}
                new.convertFrom(ctx, r)
                ss.Results = append(ss.Results, new)
        }</span>
        <span class="cov8" title="1">if source.Provenance != nil </span><span class="cov8" title="1">{
                new := Provenance{}
                new.convertFrom(ctx, *source.Provenance)
                ss.Provenance = &amp;new
        }</span>
        <span class="cov8" title="1">for _, o := range source.Outputs </span><span class="cov8" title="1">{
                new := TaskRunStepArtifact{}
                new.convertFrom(ctx, o)
                ss.Outputs = append(ss.Outputs, new)
        }</span>
        <span class="cov8" title="1">for _, o := range source.Inputs </span><span class="cov8" title="1">{
                new := TaskRunStepArtifact{}
                new.convertFrom(ctx, o)
                ss.Inputs = append(ss.Inputs, new)
        }</span>
}

func (trr TaskRunResult) convertTo(ctx context.Context, sink *v1.TaskRunResult) <span class="cov8" title="1">{
        sink.Name = trr.Name
        sink.Type = v1.ResultsType(trr.Type)
        newValue := v1.ParamValue{}
        trr.Value.convertTo(ctx, &amp;newValue)
        sink.Value = newValue
}</span>

func (trr *TaskRunResult) convertFrom(ctx context.Context, source v1.TaskRunResult) <span class="cov8" title="1">{
        trr.Name = source.Name
        trr.Type = ResultsType(source.Type)
        newValue := ParamValue{}
        newValue.convertFrom(ctx, source.Value)
        trr.Value = newValue
}</span>

func (t *TaskRunStepArtifact) convertFrom(ctx context.Context, source v1.TaskRunStepArtifact) <span class="cov8" title="1">{
        t.Name = source.Name
        for _, v := range source.Values </span><span class="cov8" title="1">{
                new := ArtifactValue{}
                new.convertFrom(ctx, v)
                t.Values = append(t.Values, new)
        }</span>
}

func (t TaskRunStepArtifact) convertTo(ctx context.Context, sink *v1.TaskRunStepArtifact) <span class="cov8" title="1">{
        sink.Name = t.Name
        for _, v := range t.Values </span><span class="cov8" title="1">{
                new := v1.ArtifactValue{}
                v.convertTo(ctx, &amp;new)
                sink.Values = append(sink.Values, new)
        }</span>
}

func (t *ArtifactValue) convertFrom(ctx context.Context, source v1.ArtifactValue) <span class="cov8" title="1">{
        t.Uri = source.Uri
        if source.Digest != nil </span><span class="cov8" title="1">{
                t.Digest = map[Algorithm]string{}
                for i, a := range source.Digest </span><span class="cov8" title="1">{
                        t.Digest[Algorithm(i)] = a
                }</span>
        }
}
func (t ArtifactValue) convertTo(ctx context.Context, sink *v1.ArtifactValue) <span class="cov8" title="1">{
        sink.Uri = t.Uri
        if t.Digest != nil </span><span class="cov8" title="1">{
                sink.Digest = map[v1.Algorithm]string{}
                for i, a := range t.Digest </span><span class="cov8" title="1">{
                        sink.Digest[v1.Algorithm(i)] = a
                }</span>
        }
}

func (ss SidecarState) convertTo(ctx context.Context, sink *v1.SidecarState) <span class="cov8" title="1">{
        sink.ContainerState = ss.ContainerState
        sink.Name = ss.Name
        sink.Container = ss.ContainerName
        sink.ImageID = ss.ImageID
}</span>

func (ss *SidecarState) convertFrom(ctx context.Context, source v1.SidecarState) <span class="cov8" title="1">{
        ss.ContainerState = source.ContainerState
        ss.Name = source.Name
        ss.ContainerName = source.Container
        ss.ImageID = source.ImageID
}</span>

func serializeTaskRunResources(meta *metav1.ObjectMeta, spec *TaskRunSpec) error <span class="cov8" title="1">{
        if spec.Resources == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, spec.Resources, resourcesAnnotationKey)</span>
}

func deserializeTaskRunResources(meta *metav1.ObjectMeta, spec *TaskRunSpec) error <span class="cov8" title="1">{
        resources := &amp;TaskRunResources{}
        err := version.DeserializeFromMetadata(meta, resources, resourcesAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if resources.Inputs != nil || resources.Outputs != nil </span><span class="cov8" title="1">{
                spec.Resources = resources
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func serializeTaskRunCloudEvents(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        if status.CloudEvents == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, status.CloudEvents, cloudEventsAnnotationKey)</span>
}

func deserializeTaskRunCloudEvents(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        cloudEvents := []CloudEventDelivery{}
        err := version.DeserializeFromMetadata(meta, &amp;cloudEvents, cloudEventsAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(cloudEvents) != 0 </span><span class="cov8" title="1">{
                status.CloudEvents = cloudEvents
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func serializeTaskRunResourcesResult(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        if status.ResourcesResult == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, status.ResourcesResult, resourcesResultAnnotationKey)</span>
}

func deserializeTaskRunResourcesResult(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        resourcesResult := []RunResult{}
        err := version.DeserializeFromMetadata(meta, &amp;resourcesResult, resourcesResultAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(resourcesResult) != 0 </span><span class="cov8" title="1">{
                status.ResourcesResult = resourcesResult
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func serializeTaskRunResourcesStatus(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        if status.TaskSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if status.TaskSpec.Resources == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return version.SerializeToMetadata(meta, status.TaskSpec.Resources, resourcesStatusAnnotationKey)</span>
}

func deserializeTaskRunResourcesStatus(meta *metav1.ObjectMeta, status *TaskRunStatus) error <span class="cov8" title="1">{
        resourcesStatus := &amp;TaskResources{}
        err := version.DeserializeFromMetadata(meta, resourcesStatus, resourcesStatusAnnotationKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if resourcesStatus.Inputs != nil || resourcesStatus.Outputs != nil </span><span class="cov8" title="1">{
                if status.TaskRunStatusFields.TaskSpec == nil </span><span class="cov0" title="0">{
                        status.TaskSpec = &amp;TaskSpec{}
                }</span>
                <span class="cov8" title="1">status.TaskSpec.Resources = resourcesStatus</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmap"
)

var _ apis.Defaultable = (*TaskRun)(nil)

// ManagedByLabelKey is the label key used to mark what is managing this resource
const ManagedByLabelKey = "app.kubernetes.io/managed-by"

// SetDefaults implements apis.Defaultable
func (tr *TaskRun) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        ctx = apis.WithinParent(ctx, tr.ObjectMeta)
        tr.Spec.SetDefaults(ctx)

        // Silently filtering out Tekton Reserved annotations at creation
        if apis.IsInCreate(ctx) </span><span class="cov8" title="1">{
                tr.ObjectMeta.Annotations = kmap.Filter(tr.ObjectMeta.Annotations, func(s string) bool </span><span class="cov8" title="1">{
                        return filterReservedAnnotationRegexp.MatchString(s)
                }</span>)
        }

        // If the TaskRun doesn't have a managed-by label, apply the default
        // specified in the config.
        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)
        if tr.ObjectMeta.Labels == nil </span><span class="cov8" title="1">{
                tr.ObjectMeta.Labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">if _, found := tr.ObjectMeta.Labels[ManagedByLabelKey]; !found </span><span class="cov8" title="1">{
                tr.ObjectMeta.Labels[ManagedByLabelKey] = cfg.Defaults.DefaultManagedByLabelValue
        }</span>
}

// SetDefaults implements apis.Defaultable
func (trs *TaskRunSpec) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if trs.TaskRef != nil </span><span class="cov8" title="1">{
                if trs.TaskRef.Name == "" &amp;&amp; trs.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        trs.TaskRef.Resolver = ResolverName(cfg.Defaults.DefaultResolverType)
                }</span>
                <span class="cov8" title="1">if trs.TaskRef.Kind == "" &amp;&amp; trs.TaskRef.Resolver == "" </span><span class="cov8" title="1">{
                        trs.TaskRef.Kind = NamespacedTaskKind
                }</span>
        }

        <span class="cov8" title="1">if trs.Timeout == nil </span><span class="cov8" title="1">{
                trs.Timeout = &amp;metav1.Duration{Duration: time.Duration(cfg.Defaults.DefaultTimeoutMinutes) * time.Minute}
        }</span>

        <span class="cov8" title="1">defaultSA := cfg.Defaults.DefaultServiceAccount
        if trs.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                trs.ServiceAccountName = defaultSA
        }</span>

        <span class="cov8" title="1">defaultPodTemplate := cfg.Defaults.DefaultPodTemplate
        trs.PodTemplate = pod.MergePodTemplateWithDefault(trs.PodTemplate, defaultPodTemplate)

        // If this taskrun has an embedded task, apply the usual task defaults
        if trs.TaskSpec != nil </span><span class="cov8" title="1">{
                trs.TaskSpec.SetDefaults(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        apisconfig "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TaskRunSpec defines the desired state of TaskRun
type TaskRunSpec struct {
        // +optional
        Debug *TaskRunDebug `json:"debug,omitempty"`
        // +optional
        Params Params `json:"params,omitempty"`
        // Deprecated: Unused, preserved only for backwards compatibility
        // +optional
        Resources *TaskRunResources `json:"resources,omitempty"`
        // +optional
        ServiceAccountName string `json:"serviceAccountName"`
        // no more than one of the TaskRef and TaskSpec may be specified.
        // +optional
        TaskRef *TaskRef `json:"taskRef,omitempty"`
        // Specifying TaskSpec can be disabled by setting
        // `disable-inline-spec` feature flag.
        // See Task.spec (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        TaskSpec *TaskSpec `json:"taskSpec,omitempty"`
        // Used for cancelling a TaskRun (and maybe more later on)
        // +optional
        Status TaskRunSpecStatus `json:"status,omitempty"`
        // Status message for cancellation.
        // +optional
        StatusMessage TaskRunSpecStatusMessage `json:"statusMessage,omitempty"`
        // Retries represents how many times this TaskRun should be retried in the event of Task failure.
        // +optional
        Retries int `json:"retries,omitempty"`
        // Time after which one retry attempt times out. Defaults to 1 hour.
        // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
        // +optional
        Timeout *metav1.Duration `json:"timeout,omitempty"`
        // PodTemplate holds pod specific configuration
        PodTemplate *pod.PodTemplate `json:"podTemplate,omitempty"`
        // Workspaces is a list of WorkspaceBindings from volumes to workspaces.
        // +optional
        // +listType=atomic
        Workspaces []WorkspaceBinding `json:"workspaces,omitempty"`
        // Overrides to apply to Steps in this TaskRun.
        // If a field is specified in both a Step and a StepOverride,
        // the value from the StepOverride will be used.
        // This field is only supported when the alpha feature gate is enabled.
        // +optional
        // +listType=atomic
        StepOverrides []TaskRunStepOverride `json:"stepOverrides,omitempty"`
        // Overrides to apply to Sidecars in this TaskRun.
        // If a field is specified in both a Sidecar and a SidecarOverride,
        // the value from the SidecarOverride will be used.
        // This field is only supported when the alpha feature gate is enabled.
        // +optional
        // +listType=atomic
        SidecarOverrides []TaskRunSidecarOverride `json:"sidecarOverrides,omitempty"`
        // Compute resources to use for this TaskRun
        ComputeResources *corev1.ResourceRequirements `json:"computeResources,omitempty"`
}

// TaskRunSpecStatus defines the TaskRun spec status the user can provide
type TaskRunSpecStatus string

const (
        // TaskRunSpecStatusCancelled indicates that the user wants to cancel the task,
        // if not already cancelled or terminated
        TaskRunSpecStatusCancelled = "TaskRunCancelled"
)

// TaskRunSpecStatusMessage defines human readable status messages for the TaskRun.
type TaskRunSpecStatusMessage string

const (
        // TaskRunCancelledByPipelineMsg indicates that the PipelineRun of which this
        // TaskRun was a part of has been cancelled.
        TaskRunCancelledByPipelineMsg TaskRunSpecStatusMessage = "TaskRun cancelled as the PipelineRun it belongs to has been cancelled."
        // TaskRunCancelledByPipelineTimeoutMsg indicates that the TaskRun was cancelled because the PipelineRun running it timed out.
        TaskRunCancelledByPipelineTimeoutMsg TaskRunSpecStatusMessage = "TaskRun cancelled as the PipelineRun it belongs to has timed out."
)

const (
        // EnabledOnFailureBreakpoint is the value for TaskRunDebug.Breakpoints.OnFailure that means the breakpoint onFailure is enabled
        EnabledOnFailureBreakpoint = "enabled"
)

// TaskRunDebug defines the breakpoint config for a particular TaskRun
type TaskRunDebug struct {
        // +optional
        Breakpoints *TaskBreakpoints `json:"breakpoints,omitempty"`
}

// TaskBreakpoints defines the breakpoint config for a particular Task
type TaskBreakpoints struct {
        // if enabled, pause TaskRun on failure of a step
        // failed step will not exit
        // +optional
        OnFailure string `json:"onFailure,omitempty"`
        // +optional
        // +listType=atomic
        BeforeSteps []string `json:"beforeSteps,omitempty"`
}

// NeedsDebugOnFailure return true if the TaskRun is configured to debug on failure
func (trd *TaskRunDebug) NeedsDebugOnFailure() bool <span class="cov8" title="1">{
        if trd.Breakpoints == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return trd.Breakpoints.OnFailure == EnabledOnFailureBreakpoint</span>
}

// NeedsDebugBeforeStep return true if the step is configured to debug before execution
func (trd *TaskRunDebug) NeedsDebugBeforeStep(stepName string) bool <span class="cov8" title="1">{
        if trd.Breakpoints == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">beforeStepSets := sets.NewString(trd.Breakpoints.BeforeSteps...)
        return beforeStepSets.Has(stepName)</span>
}

// StepNeedsDebug return true if the step is configured to debug
func (trd *TaskRunDebug) StepNeedsDebug(stepName string) bool <span class="cov8" title="1">{
        return trd.NeedsDebugOnFailure() || trd.NeedsDebugBeforeStep(stepName)
}</span>

// HaveBeforeSteps return true if have any before steps
func (trd *TaskRunDebug) HaveBeforeSteps() bool <span class="cov8" title="1">{
        return trd.Breakpoints != nil &amp;&amp; len(trd.Breakpoints.BeforeSteps) &gt; 0
}</span>

// NeedsDebug return true if defined onfailure or have any before, after steps
func (trd *TaskRunDebug) NeedsDebug() bool <span class="cov8" title="1">{
        return trd.NeedsDebugOnFailure() || trd.HaveBeforeSteps()
}</span>

var taskRunCondSet = apis.NewBatchConditionSet()

// TaskRunStatus defines the observed state of TaskRun
type TaskRunStatus struct {
        duckv1.Status `json:",inline"`

        // TaskRunStatusFields inlines the status fields.
        TaskRunStatusFields `json:",inline"`
}

// TaskRunConditionType is an enum used to store TaskRun custom
// conditions such as one used in spire results verification
type TaskRunConditionType string

const (
        // TaskRunConditionResultsVerified is a Condition Type that indicates that the results were verified by spire
        TaskRunConditionResultsVerified TaskRunConditionType = "SignedResultsVerified"
)

func (t TaskRunConditionType) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

// TaskRunReason is an enum used to store all TaskRun reason for
// the Succeeded condition that are controlled by the TaskRun itself. Failure
// reasons that emerge from underlying resources are not included here
type TaskRunReason string

const (
        // TaskRunReasonStarted is the reason set when the TaskRun has just started
        TaskRunReasonStarted TaskRunReason = "Started"
        // TaskRunReasonRunning is the reason set when the TaskRun is running
        TaskRunReasonRunning TaskRunReason = "Running"
        // TaskRunReasonSuccessful is the reason set when the TaskRun completed successfully
        TaskRunReasonSuccessful TaskRunReason = "Succeeded"
        // TaskRunReasonFailed is the reason set when the TaskRun completed with a failure
        TaskRunReasonFailed TaskRunReason = "Failed"
        // TaskRunReasonToBeRetried is the reason set when the last TaskRun execution failed, and will be retried
        TaskRunReasonToBeRetried TaskRunReason = "ToBeRetried"
        // TaskRunReasonCancelled is the reason set when the TaskRun is cancelled by the user
        TaskRunReasonCancelled TaskRunReason = "TaskRunCancelled"
        // TaskRunReasonTimedOut is the reason set when one TaskRun execution has timed out
        TaskRunReasonTimedOut TaskRunReason = "TaskRunTimeout"
        // TaskRunReasonResolvingTaskRef indicates that the TaskRun is waiting for
        // its taskRef to be asynchronously resolved.
        TaskRunReasonResolvingTaskRef = "ResolvingTaskRef"
        // TaskRunReasonImagePullFailed is the reason set when the step of a task fails due to image not being pulled
        TaskRunReasonImagePullFailed TaskRunReason = "TaskRunImagePullFailed"
        // TaskRunReasonResultsVerified is the reason set when the TaskRun results are verified by spire
        TaskRunReasonResultsVerified TaskRunReason = "TaskRunResultsVerified"
        // TaskRunReasonsResultsVerificationFailed is the reason set when the TaskRun results are failed to verify by spire
        TaskRunReasonsResultsVerificationFailed TaskRunReason = "TaskRunResultsVerificationFailed"
        // AwaitingTaskRunResults is the reason set when waiting upon `TaskRun` results and signatures to verify
        AwaitingTaskRunResults TaskRunReason = "AwaitingTaskRunResults"
        // TaskRunReasonResultLargerThanAllowedLimit is the reason set when one of the results exceeds its maximum allowed limit of 1 KB
        TaskRunReasonResultLargerThanAllowedLimit TaskRunReason = "TaskRunResultLargerThanAllowedLimit"
        // TaskRunReasonStopSidecarFailed indicates that the sidecar is not properly stopped.
        TaskRunReasonStopSidecarFailed = "TaskRunStopSidecarFailed"
)

func (t TaskRunReason) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

// GetStartedReason returns the reason set to the "Succeeded" condition when
// InitializeConditions is invoked
func (trs *TaskRunStatus) GetStartedReason() string <span class="cov0" title="0">{
        return TaskRunReasonStarted.String()
}</span>

// GetRunningReason returns the reason set to the "Succeeded" condition when
// the TaskRun starts running. This is used indicate that the resource
// could be validated is starting to perform its job.
func (trs *TaskRunStatus) GetRunningReason() string <span class="cov0" title="0">{
        return TaskRunReasonRunning.String()
}</span>

// MarkResourceOngoing sets the ConditionSucceeded condition to ConditionUnknown
// with the reason and message.
func (trs *TaskRunStatus) MarkResourceOngoing(reason TaskRunReason, message string) <span class="cov0" title="0">{
        taskRunCondSet.Manage(trs).SetCondition(apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionUnknown,
                Reason:  reason.String(),
                Message: message,
        })
}</span>

// MarkResourceFailed sets the ConditionSucceeded condition to ConditionFalse
// based on an error that occurred and a reason
func (trs *TaskRunStatus) MarkResourceFailed(reason TaskRunReason, err error) <span class="cov0" title="0">{
        taskRunCondSet.Manage(trs).SetCondition(apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionFalse,
                Reason:  reason.String(),
                Message: err.Error(),
        })
        succeeded := trs.GetCondition(apis.ConditionSucceeded)
        trs.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// +listType=atomic
type RetriesStatus []TaskRunStatus

// TaskRunStatusFields holds the fields of TaskRun's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type TaskRunStatusFields struct {
        // PodName is the name of the pod responsible for executing this task's steps.
        PodName string `json:"podName"`

        // StartTime is the time the build is actually started.
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the build completed.
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // Steps describes the state of each build step container.
        // +optional
        // +listType=atomic
        Steps []StepState `json:"steps,omitempty"`

        // CloudEvents describe the state of each cloud event requested via a
        // CloudEventResource.
        //
        // Deprecated: Removed in v0.44.0.
        //
        // +optional
        // +listType=atomic
        CloudEvents []CloudEventDelivery `json:"cloudEvents,omitempty"`

        // RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures.
        // All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.
        // See TaskRun.status (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        RetriesStatus RetriesStatus `json:"retriesStatus,omitempty"`

        // Results from Resources built during the TaskRun.
        // This is tomb-stoned along with the removal of pipelineResources
        // Deprecated: this field is not populated and is preserved only for backwards compatibility
        // +optional
        // +listType=atomic
        ResourcesResult []PipelineResourceResult `json:"resourcesResult,omitempty"`

        // TaskRunResults are the list of results written out by the task's containers
        // +optional
        // +listType=atomic
        TaskRunResults []TaskRunResult `json:"taskResults,omitempty"`

        // The list has one entry per sidecar in the manifest. Each entry is
        // represents the imageid of the corresponding sidecar.
        // +listType=atomic
        Sidecars []SidecarState `json:"sidecars,omitempty"`

        // TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun.
        // See Task.spec (API version tekton.dev/v1beta1)
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        TaskSpec *TaskSpec `json:"taskSpec,omitempty"`

        // Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
        // +optional
        Provenance *Provenance `json:"provenance,omitempty"`

        // SpanContext contains tracing span context fields
        SpanContext map[string]string `json:"spanContext,omitempty"`
}

// TaskRunStepOverride is used to override the values of a Step in the corresponding Task.
type TaskRunStepOverride struct {
        // The name of the Step to override.
        Name string `json:"name"`
        // The resource requirements to apply to the Step.
        Resources corev1.ResourceRequirements `json:"resources"`
}

// TaskRunSidecarOverride is used to override the values of a Sidecar in the corresponding Task.
type TaskRunSidecarOverride struct {
        // The name of the Sidecar to override.
        Name string `json:"name"`
        // The resource requirements to apply to the Sidecar.
        Resources corev1.ResourceRequirements `json:"resources"`
}

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*TaskRun) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(pipeline.TaskRunControllerName)
}</span>

// GetStatusCondition returns the task run status as a ConditionAccessor
func (tr *TaskRun) GetStatusCondition() apis.ConditionAccessor <span class="cov0" title="0">{
        return &amp;tr.Status
}</span>

// GetCondition returns the Condition matching the given type.
func (trs *TaskRunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return taskRunCondSet.Manage(trs).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in taskRunCondSet to unknown for the TaskRun
// and set the started time to the current time
func (trs *TaskRunStatus) InitializeConditions() <span class="cov8" title="1">{
        started := false
        if trs.StartTime.IsZero() </span><span class="cov8" title="1">{
                trs.StartTime = &amp;metav1.Time{Time: time.Now()}
                started = true
        }</span>
        <span class="cov8" title="1">conditionManager := taskRunCondSet.Manage(trs)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov8" title="1">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = TaskRunReasonStarted.String()
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (trs *TaskRunStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                taskRunCondSet.Manage(trs).SetCondition(*newCond)
        }</span>
}

// StepState reports the results of running a step in a Task.
type StepState struct {
        corev1.ContainerState `json:",inline"`
        Name                  string                `json:"name,omitempty"`
        ContainerName         string                `json:"container,omitempty"`
        ImageID               string                `json:"imageID,omitempty"`
        Results               []TaskRunStepResult   `json:"results,omitempty"`
        Provenance            *Provenance           `json:"provenance,omitempty"`
        Inputs                []TaskRunStepArtifact `json:"inputs,omitempty"`
        Outputs               []TaskRunStepArtifact `json:"outputs,omitempty"`
}

// SidecarState reports the results of running a sidecar in a Task.
type SidecarState struct {
        corev1.ContainerState `json:",inline"`
        Name                  string `json:"name,omitempty"`
        ContainerName         string `json:"container,omitempty"`
        ImageID               string `json:"imageID,omitempty"`
}

// CloudEventDelivery is the target of a cloud event along with the state of
// delivery.
type CloudEventDelivery struct {
        // Target points to an addressable
        Target string                  `json:"target,omitempty"`
        Status CloudEventDeliveryState `json:"status,omitempty"`
}

// CloudEventCondition is a string that represents the condition of the event.
type CloudEventCondition string

const (
        // CloudEventConditionUnknown means that the condition for the event to be
        // triggered was not met yet, or we don't know the state yet.
        CloudEventConditionUnknown CloudEventCondition = "Unknown"
        // CloudEventConditionSent means that the event was sent successfully
        CloudEventConditionSent CloudEventCondition = "Sent"
        // CloudEventConditionFailed means that there was one or more attempts to
        // send the event, and none was successful so far.
        CloudEventConditionFailed CloudEventCondition = "Failed"
)

// CloudEventDeliveryState reports the state of a cloud event to be sent.
type CloudEventDeliveryState struct {
        // Current status
        Condition CloudEventCondition `json:"condition,omitempty"`
        // SentAt is the time at which the last attempt to send the event was made
        // +optional
        SentAt *metav1.Time `json:"sentAt,omitempty"`
        // Error is the text of error (if any)
        Error string `json:"message"`
        // RetryCount is the number of attempts of sending the cloud event
        RetryCount int32 `json:"retryCount"`
}

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// TaskRun represents a single execution of a Task. TaskRuns are how the steps
// specified in a Task are executed; they specify the parameters and resources
// used to run the steps in a Task.
//
// Deprecated: Please use v1.TaskRun instead.
type TaskRun struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // +optional
        Spec TaskRunSpec `json:"spec,omitempty"`
        // +optional
        Status TaskRunStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TaskRunList contains a list of TaskRun
type TaskRunList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TaskRun `json:"items"`
}

// GetPipelineRunPVCName for TaskRun gets pipelinerun
func (tr *TaskRun) GetPipelineRunPVCName() string <span class="cov8" title="1">{
        if tr == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, ref := range tr.GetOwnerReferences() </span><span class="cov8" title="1">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov8" title="1">{
                        return ref.Name + "-pvc"
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// HasPipelineRunOwnerReference returns true of TaskRun has
// owner reference of type PipelineRun
func (tr *TaskRun) HasPipelineRunOwnerReference() bool <span class="cov8" title="1">{
        for _, ref := range tr.GetOwnerReferences() </span><span class="cov8" title="1">{
                if ref.Kind == pipeline.PipelineRunControllerName </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsDone returns true if the TaskRun's status indicates that it is done.
func (tr *TaskRun) IsDone() bool <span class="cov8" title="1">{
        return !tr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// HasStarted function check whether TaskRun has valid start time set in its status
func (tr *TaskRun) HasStarted() bool <span class="cov8" title="1">{
        return tr.Status.StartTime != nil &amp;&amp; !tr.Status.StartTime.IsZero()
}</span>

// IsSuccessful returns true if the TaskRun's status indicates that it has succeeded.
func (tr *TaskRun) IsSuccessful() bool <span class="cov8" title="1">{
        return tr != nil &amp;&amp; tr.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
}</span>

// IsFailure returns true if the TaskRun's status indicates that it has failed.
func (tr *TaskRun) IsFailure() bool <span class="cov8" title="1">{
        return tr != nil &amp;&amp; tr.Status.GetCondition(apis.ConditionSucceeded).IsFalse()
}</span>

// IsCancelled returns true if the TaskRun's spec status is set to Cancelled state
func (tr *TaskRun) IsCancelled() bool <span class="cov8" title="1">{
        return tr.Spec.Status == TaskRunSpecStatusCancelled
}</span>

// IsTaskRunResultVerified returns true if the TaskRun's results have been validated by spire.
func (tr *TaskRun) IsTaskRunResultVerified() bool <span class="cov8" title="1">{
        return tr.Status.GetCondition(apis.ConditionType(TaskRunConditionResultsVerified.String())).IsTrue()
}</span>

// IsTaskRunResultDone returns true if the TaskRun's results are available for verification
func (tr *TaskRun) IsTaskRunResultDone() bool <span class="cov8" title="1">{
        return !tr.Status.GetCondition(apis.ConditionType(TaskRunConditionResultsVerified.String())).IsUnknown()
}</span>

// IsRetriable returns true if the TaskRun's Retries is not exhausted.
func (tr *TaskRun) IsRetriable() bool <span class="cov8" title="1">{
        return len(tr.Status.RetriesStatus) &lt; tr.Spec.Retries
}</span>

// HasTimedOut returns true if the TaskRun runtime is beyond the allowed timeout
func (tr *TaskRun) HasTimedOut(ctx context.Context, c clock.PassiveClock) bool <span class="cov8" title="1">{
        if tr.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeout := tr.GetTimeout(ctx)
        // If timeout is set to 0 or defaulted to 0, there is no timeout.
        if timeout == apisconfig.NoTimeoutDuration </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">runtime := c.Since(tr.Status.StartTime.Time)
        return runtime &gt; timeout</span>
}

// GetTimeout returns the timeout for the TaskRun, or the default if not specified
func (tr *TaskRun) GetTimeout(ctx context.Context) time.Duration <span class="cov8" title="1">{
        // Use the platform default is no timeout is set
        if tr.Spec.Timeout == nil </span><span class="cov0" title="0">{
                defaultTimeout := time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes)
                return defaultTimeout * time.Minute //nolint:durationcheck
        }</span>
        <span class="cov8" title="1">return tr.Spec.Timeout.Duration</span>
}

// GetNamespacedName returns a k8s namespaced name that identifies this TaskRun
func (tr *TaskRun) GetNamespacedName() types.NamespacedName <span class="cov8" title="1">{
        return types.NamespacedName{Namespace: tr.Namespace, Name: tr.Name}
}</span>

// HasVolumeClaimTemplate returns true if TaskRun contains volumeClaimTemplates that is
// used for creating PersistentVolumeClaims with an OwnerReference for each run
func (tr *TaskRun) HasVolumeClaimTemplate() bool <span class="cov8" title="1">{
        for _, ws := range tr.Spec.Workspaces </span><span class="cov8" title="1">{
                if ws.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        pod "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*TaskRun)(nil)
        _ resourcesemantics.VerbLimited = (*TaskRun)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (tr *TaskRun) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate taskrun
func (tr *TaskRun) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(tr.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tr.Spec.Validate(apis.WithinSpec(ctx)).ViaField("spec"))
}</span>

// Validate taskrun spec
func (ts *TaskRunSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Validate the spec changes
        errs = errs.Also(ts.ValidateUpdate(ctx))

        // Must have exactly one of taskRef and taskSpec.
        if ts.TaskRef == nil &amp;&amp; ts.TaskSpec == nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("taskRef", "taskSpec"))
        }</span>
        <span class="cov8" title="1">if ts.TaskRef != nil &amp;&amp; ts.TaskSpec != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("taskRef", "taskSpec"))
        }</span>
        // Validate TaskRef if it's present.
        <span class="cov8" title="1">if ts.TaskRef != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ts.TaskRef.Validate(ctx).ViaField("taskRef"))
        }</span>
        // Validate TaskSpec if it's present.
        <span class="cov8" title="1">if ts.TaskSpec != nil </span><span class="cov8" title="1">{
                if slices.Contains(strings.Split(
                        config.FromContextOrDefaults(ctx).FeatureFlags.DisableInlineSpec, ","), "taskrun") </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrDisallowedFields("taskSpec"))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(ts.TaskSpec.Validate(ctx).ViaField("taskSpec"))</span>
        }

        <span class="cov8" title="1">errs = errs.Also(ValidateParameters(ctx, ts.Params).ViaField("params"))

        // Validate propagated parameters
        errs = errs.Also(ts.validateInlineParameters(ctx))
        errs = errs.Also(ValidateWorkspaceBindings(ctx, ts.Workspaces).ViaField("workspaces"))
        if ts.Debug != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "debug", config.AlphaAPIFields).ViaField("debug"))
                errs = errs.Also(validateDebug(ts.Debug).ViaField("debug"))
        }</span>
        <span class="cov8" title="1">if ts.StepOverrides != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "stepOverrides", config.BetaAPIFields).ViaField("stepOverrides"))
                errs = errs.Also(validateStepOverrides(ts.StepOverrides).ViaField("stepOverrides"))
        }</span>
        <span class="cov8" title="1">if ts.SidecarOverrides != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "sidecarOverrides", config.BetaAPIFields).ViaField("sidecarOverrides"))
                errs = errs.Also(validateSidecarOverrides(ts.SidecarOverrides).ViaField("sidecarOverrides"))
        }</span>
        <span class="cov8" title="1">if ts.ComputeResources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(config.ValidateEnabledAPIFields(ctx, "computeResources", config.BetaAPIFields).ViaField("computeResources"))
                errs = errs.Also(validateTaskRunComputeResources(ts.ComputeResources, ts.StepOverrides))
        }</span>

        <span class="cov8" title="1">if ts.Status != "" </span><span class="cov8" title="1">{
                if ts.Status != TaskRunSpecStatusCancelled </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("%s should be %s", ts.Status, TaskRunSpecStatusCancelled), "status"))
                }</span>
        }
        <span class="cov8" title="1">if ts.Status == "" </span><span class="cov8" title="1">{
                if ts.StatusMessage != "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("statusMessage should not be set if status is not set, but it is currently set to %s", ts.StatusMessage), "statusMessage"))
                }</span>
        }

        <span class="cov8" title="1">if ts.PodTemplate != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validatePodTemplateEnv(ctx, *ts.PodTemplate))
        }</span>

        <span class="cov8" title="1">if ts.Timeout != nil &amp;&amp; ts.Timeout.Duration &lt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(ts.Timeout.Duration.String()+" should be &gt;= 0", "timeout"))
        }</span>

        <span class="cov8" title="1">if ts.Resources != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrDisallowedFields("resources"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// ValidateUpdate validates the update of a TaskRunSpec
func (ts *TaskRunSpec) ValidateUpdate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if !apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">oldObj, ok := apis.GetBaseline(ctx).(*TaskRun)
        if !ok || oldObj == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if oldObj.IsDone() </span><span class="cov8" title="1">{
                // try comparing without any copying first
                // this handles the common case where only finalizers changed
                if equality.Semantic.DeepEqual(&amp;oldObj.Spec, ts) </span><span class="cov8" title="1">{
                        return nil // Specs identical, allow update
                }</span>

                // Specs differ, this could be due to different defaults after upgrade
                // Apply current defaults to old spec to normalize
                <span class="cov8" title="1">oldCopy := oldObj.Spec.DeepCopy()
                oldCopy.SetDefaults(ctx)

                if equality.Semantic.DeepEqual(oldCopy, ts) </span><span class="cov0" title="0">{
                        return nil // Difference was only defaults, allow update
                }</span>

                // Real spec changes detected, reject update
                <span class="cov8" title="1">errs = errs.Also(apis.ErrInvalidValue("Once the TaskRun is complete, no updates are allowed", ""))
                return errs</span>
        }

        // Handle started but not done case
        <span class="cov8" title="1">old := oldObj.Spec.DeepCopy()
        old.Status = ts.Status
        old.StatusMessage = ts.StatusMessage
        if !equality.Semantic.DeepEqual(old, ts) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("Once the TaskRun has started, only status and statusMessage updates are allowed", ""))
        }</span>

        <span class="cov8" title="1">return</span>
}

// validateInlineParameters validates that any parameters called in the
// Task spec are declared in the TaskRun.
// This is crucial for propagated parameters because the parameters could
// be defined under taskRun and then called directly in the task steps.
// In this case, parameters cannot be validated by the underlying taskSpec
// since they may not have the parameters declared because of propagation.
func (ts *TaskRunSpec) validateInlineParameters(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if ts.TaskSpec == nil </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">paramSpecForValidation := make(map[string]ParamSpec)
        for _, p := range ts.Params </span><span class="cov8" title="1">{
                paramSpecForValidation = createParamSpecFromParam(p, paramSpecForValidation)
        }</span>

        <span class="cov8" title="1">for _, p := range ts.TaskSpec.Params </span><span class="cov8" title="1">{
                var err *apis.FieldError
                paramSpecForValidation, err = combineParamSpec(p, paramSpecForValidation)
                if err != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(err)
                }</span>
        }
        <span class="cov8" title="1">var paramSpec []ParamSpec
        for _, v := range paramSpecForValidation </span><span class="cov8" title="1">{
                paramSpec = append(paramSpec, v)
        }</span>
        <span class="cov8" title="1">if ts.TaskSpec != nil &amp;&amp; ts.TaskSpec.Steps != nil </span><span class="cov8" title="1">{
                errs = errs.Also(ValidateParameterTypes(ctx, paramSpec))
                errs = errs.Also(ValidateParameterVariables(ctx, ts.TaskSpec.Steps, paramSpec))
                errs = errs.Also(ValidateUsageOfDeclaredParameters(ctx, ts.TaskSpec.Steps, paramSpec))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validatePodTemplateEnv(ctx context.Context, podTemplate pod.Template) (errs *apis.FieldError) <span class="cov8" title="1">{
        forbiddenEnvsConfigured := config.FromContextOrDefaults(ctx).Defaults.DefaultForbiddenEnv
        if len(forbiddenEnvsConfigured) == 0 </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">for _, pEnv := range podTemplate.Env </span><span class="cov8" title="1">{
                if slices.Contains(forbiddenEnvsConfigured, pEnv.Name) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue("PodTemplate cannot update a forbidden env: "+pEnv.Name, "PodTemplate.Env"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func createParamSpecFromParam(p Param, paramSpecForValidation map[string]ParamSpec) map[string]ParamSpec <span class="cov8" title="1">{
        value := p.Value
        pSpec := ParamSpec{
                Name:    p.Name,
                Default: &amp;value,
                Type:    p.Value.Type,
        }
        if p.Value.ObjectVal != nil </span><span class="cov8" title="1">{
                pSpec.Properties = make(map[string]PropertySpec)
                prop := make(map[string]PropertySpec)
                for k := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                        prop[k] = PropertySpec{Type: ParamTypeString}
                }</span>
                <span class="cov8" title="1">pSpec.Properties = prop</span>
        }
        <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec
        return paramSpecForValidation</span>
}

func combineParamSpec(p ParamSpec, paramSpecForValidation map[string]ParamSpec) (map[string]ParamSpec, *apis.FieldError) <span class="cov8" title="1">{
        if pSpec, ok := paramSpecForValidation[p.Name]; ok </span><span class="cov8" title="1">{
                // Merge defaults with provided values in the taskrun.
                if p.Default != nil &amp;&amp; p.Default.ObjectVal != nil </span><span class="cov8" title="1">{
                        for k, v := range p.Default.ObjectVal </span><span class="cov8" title="1">{
                                if pSpec.Default.ObjectVal == nil </span><span class="cov8" title="1">{
                                        pSpec.Default.ObjectVal = map[string]string{k: v}
                                }</span> else<span class="cov8" title="1"> {
                                        pSpec.Default.ObjectVal[k] = v
                                }</span>
                        }
                        // If Default values of object type are provided then Properties must also be fully declared.
                        <span class="cov8" title="1">if p.Properties == nil </span><span class="cov8" title="1">{
                                return paramSpecForValidation, apis.ErrMissingField(p.Name + ".properties")
                        }</span>
                }

                // Properties must be defined if paramSpec is of object Type
                <span class="cov8" title="1">if pSpec.Type == ParamTypeObject </span><span class="cov8" title="1">{
                        if p.Properties == nil </span><span class="cov0" title="0">{
                                return paramSpecForValidation, apis.ErrMissingField(p.Name + ".properties")
                        }</span>
                        // Expect Properties to be complete
                        <span class="cov8" title="1">pSpec.Properties = p.Properties</span>
                }
                <span class="cov8" title="1">paramSpecForValidation[p.Name] = pSpec</span>
        } else<span class="cov8" title="1"> {
                // No values provided by task run but found a paramSpec declaration.
                // Expect it to be fully speced out.
                paramSpecForValidation[p.Name] = p
        }</span>
        <span class="cov8" title="1">return paramSpecForValidation, nil</span>
}

// validateDebug validates the debug section of the TaskRun.
// if set, onFailure breakpoint must be "enabled"
func validateDebug(db *TaskRunDebug) (errs *apis.FieldError) <span class="cov8" title="1">{
        if db == nil || db.Breakpoints == nil </span><span class="cov0" title="0">{
                return errs
        }</span>

        <span class="cov8" title="1">if db.Breakpoints.OnFailure == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue("onFailure breakpoint is empty, it is only allowed to be set as enabled", "breakpoints.onFailure"))
        }</span>

        <span class="cov8" title="1">if db.Breakpoints.OnFailure != "" &amp;&amp; db.Breakpoints.OnFailure != EnabledOnFailureBreakpoint </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(db.Breakpoints.OnFailure+" is not a valid onFailure breakpoint value, onFailure breakpoint is only allowed to be set as enabled", "breakpoints.onFailure"))
        }</span>
        <span class="cov8" title="1">beforeSteps := sets.NewString()
        for i, step := range db.Breakpoints.BeforeSteps </span><span class="cov8" title="1">{
                if beforeSteps.Has(step) </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("before step must be unique, the same step: %s is defined multiple times at", step), fmt.Sprintf("breakpoints.beforeSteps[%d]", i)))
                }</span>
                <span class="cov8" title="1">beforeSteps.Insert(step)</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// ValidateWorkspaceBindings makes sure the volumes provided for the Task's declared workspaces make sense.
func ValidateWorkspaceBindings(ctx context.Context, wb []WorkspaceBinding) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for idx, w := range wb </span><span class="cov8" title="1">{
                names = append(names, w.Name)
                errs = errs.Also(w.Validate(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// ValidateParameters makes sure the params for the Task are valid.
func ValidateParameters(ctx context.Context, params Params) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for _, p := range params </span><span class="cov8" title="1">{
                names = append(names, p.Name)
        }</span>
        <span class="cov8" title="1">return errs.Also(validateNoDuplicateNames(names, false))</span>
}

func validateStepOverrides(overrides []TaskRunStepOverride) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for i, o := range overrides </span><span class="cov8" title="1">{
                if o.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("name").ViaIndex(i))
                }</span> else<span class="cov8" title="1"> {
                        names = append(names, o.Name)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// validateTaskRunComputeResources ensures that compute resources are not configured at both the step level and the task level
func validateTaskRunComputeResources(computeResources *corev1.ResourceRequirements, overrides []TaskRunStepOverride) (errs *apis.FieldError) <span class="cov8" title="1">{
        for _, override := range overrides </span><span class="cov8" title="1">{
                if override.Resources.Size() != 0 &amp;&amp; computeResources != nil </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(
                                "stepOverrides.resources",
                                "computeResources",
                        )
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateSidecarOverrides(overrides []TaskRunSidecarOverride) (errs *apis.FieldError) <span class="cov8" title="1">{
        var names []string
        for i, o := range overrides </span><span class="cov8" title="1">{
                if o.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("name").ViaIndex(i))
                }</span> else<span class="cov8" title="1"> {
                        names = append(names, o.Name)
                }</span>
        }
        <span class="cov8" title="1">errs = errs.Also(validateNoDuplicateNames(names, true))
        return errs</span>
}

// validateNoDuplicateNames returns an error for each name that is repeated in names.
// Case insensitive.
// If byIndex is true, the error will be reported by index instead of by key.
func validateNoDuplicateNames(names []string, byIndex bool) (errs *apis.FieldError) <span class="cov8" title="1">{
        seen := sets.NewString()
        for i, n := range names </span><span class="cov8" title="1">{
                if seen.Has(strings.ToLower(n)) </span><span class="cov8" title="1">{
                        if byIndex </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMultipleOneOf("name").ViaIndex(i))
                        }</span> else<span class="cov8" title="1"> {
                                errs = errs.Also(apis.ErrMultipleOneOf("name").ViaKey(n))
                        }</span>
                }
                <span class="cov8" title="1">seen.Insert(strings.ToLower(n))</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"

        "github.com/tektoncd/pipeline/pkg/substitution"
        "k8s.io/apimachinery/pkg/selection"
)

// WhenExpression allows a PipelineTask to declare expressions to be evaluated before the Task is run
// to determine whether the Task should be executed or skipped
type WhenExpression struct {
        // Input is the string for guard checking which can be a static input or an output from a parent Task
        Input string `json:"input,omitempty"`

        // Operator that represents an Input's relationship to the values
        Operator selection.Operator `json:"operator,omitempty"`

        // Values is an array of strings, which is compared against the input, for guard checking
        // It must be non-empty
        // +listType=atomic
        Values []string `json:"values,omitempty"`

        // CEL is a string of Common Language Expression, which can be used to conditionally execute
        // the task based on the result of the expression evaluation
        // More info about CEL syntax: https://github.com/google/cel-spec/blob/master/doc/langdef.md
        // +optional
        CEL string `json:"cel,omitempty"`
}

func (we *WhenExpression) isInputInValues() bool <span class="cov8" title="1">{
        for i := range we.Values </span><span class="cov8" title="1">{
                if we.Values[i] == we.Input </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (we *WhenExpression) isTrue() bool <span class="cov8" title="1">{
        if we.Operator == selection.In </span><span class="cov8" title="1">{
                return we.isInputInValues()
        }</span>
        // selection.NotIn
        <span class="cov8" title="1">return !we.isInputInValues()</span>
}

func (we *WhenExpression) applyReplacements(replacements map[string]string, arrayReplacements map[string][]string) WhenExpression <span class="cov8" title="1">{
        replacedInput := substitution.ApplyReplacements(we.Input, replacements)
        replacedCEL := substitution.ApplyReplacements(we.CEL, replacements)

        var replacedValues []string
        for _, val := range we.Values </span><span class="cov8" title="1">{
                // arrayReplacements holds a list of array parameters with a pattern - params.arrayParam1
                // array params are referenced using $(params.arrayParam1[*])
                // array results are referenced using $(results.resultname[*])
                // check if the param exist in the arrayReplacements to replace it with a list of values
                if _, ok := arrayReplacements[fmt.Sprintf("%s.%s", ParamsPrefix, ArrayReference(val))]; ok </span><span class="cov8" title="1">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov8" title="1"> if _, ok := arrayReplacements[ResultsArrayReference(val)]; ok </span><span class="cov8" title="1">{
                        replacedValues = append(replacedValues, substitution.ApplyArrayReplacements(val, replacements, arrayReplacements)...)
                }</span> else<span class="cov8" title="1"> {
                        replacedValues = append(replacedValues, substitution.ApplyReplacements(val, replacements))
                }</span>
        }

        <span class="cov8" title="1">return WhenExpression{Input: replacedInput, Operator: we.Operator, Values: replacedValues, CEL: replacedCEL}</span>
}

// GetVarSubstitutionExpressions extracts all the values between "$(" and ")" in a When Expression
func (we *WhenExpression) GetVarSubstitutionExpressions() ([]string, bool) <span class="cov8" title="1">{
        var allExpressions []string
        allExpressions = append(allExpressions, validateString(we.Input)...)
        allExpressions = append(allExpressions, validateString(we.CEL)...)
        for _, value := range we.Values </span><span class="cov8" title="1">{
                allExpressions = append(allExpressions, validateString(value)...)
        }</span>
        <span class="cov8" title="1">return allExpressions, len(allExpressions) != 0</span>
}

// WhenExpressions are used to specify whether a Task should be executed or skipped
// All of them need to evaluate to True for a guarded Task to be executed.
type WhenExpressions []WhenExpression

type StepWhenExpressions = WhenExpressions

// AllowsExecution evaluates an Input's relationship to an array of Values, based on the Operator,
// to determine whether all the When Expressions are True. If they are all True, the guarded Task is
// executed, otherwise it is skipped.
// If CEL expression exists, AllowsExecution will get the evaluated results from evaluatedCEL and determine
// if the Task should be skipped.
func (wes WhenExpressions) AllowsExecution(evaluatedCEL map[string]bool) bool <span class="cov8" title="1">{
        for _, we := range wes </span><span class="cov8" title="1">{
                if !we.isTrue() || (we.CEL != "" &amp;&amp; !evaluatedCEL[we.CEL]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ReplaceVariables interpolates variables, such as Parameters and Results, in
// the Input and Values.
func (wes WhenExpressions) ReplaceVariables(replacements map[string]string, arrayReplacements map[string][]string) WhenExpressions <span class="cov8" title="1">{
        replaced := wes
        for i := range wes </span><span class="cov8" title="1">{
                replaced[i] = wes[i].applyReplacements(replacements, arrayReplacements)
        }</span>
        <span class="cov8" title="1">return replaced</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/selection"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var validWhenOperators = []string{
        string(selection.In),
        string(selection.NotIn),
}

func (wes WhenExpressions) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        return wes.validateWhenExpressionsFields(ctx).ViaField("when")
}</span>

func (wes WhenExpressions) validateWhenExpressionsFields(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, we := range wes </span><span class="cov8" title="1">{
                errs = errs.Also(we.validateWhenExpressionFields(ctx).ViaIndex(idx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (we *WhenExpression) validateWhenExpressionFields(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if we.CEL != "" </span><span class="cov8" title="1">{
                if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableCELInWhenExpression </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("feature flag %s should be set to true to use CEL: %s in WhenExpression", config.EnableCELInWhenExpression, we.CEL), "")
                }</span>
                <span class="cov8" title="1">if we.Input != "" || we.Operator != "" || len(we.Values) != 0 </span><span class="cov8" title="1">{
                        return apis.ErrGeneric(fmt.Sprintf("cel and input+operator+values cannot be set in one WhenExpression: %v", we))
                }</span>
                // We need to compile the CEL expression and check if it is a valid expression
                // note that at the validation webhook, Tekton's variables are not substituted,
                // so they need to be wrapped with single quotes.
                // e.g.  This is a valid CEL expression: '$(params.foo)' == 'foo';
                //       But this is not a valid expression since CEL cannot recognize: $(params.foo) == 'foo';
                //       This is not valid since we don't pass params to CEL's environment: params.foo == 'foo';
                <span class="cov8" title="1">env, _ := cel.NewEnv()
                _, iss := env.Compile(we.CEL)
                if iss.Err() != nil </span><span class="cov8" title="1">{
                        return apis.ErrGeneric("invalid cel expression: %s with err: %s", we.CEL, iss.Err().Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if equality.Semantic.DeepEqual(we, &amp;WhenExpression{}) || we == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(apis.CurrentField)
        }</span>
        <span class="cov8" title="1">if !sets.NewString(validWhenOperators...).Has(string(we.Operator)) </span><span class="cov8" title="1">{
                message := fmt.Sprintf("operator %q is not recognized. valid operators: %s", we.Operator, strings.Join(validWhenOperators, ","))
                return apis.ErrInvalidValue(message, apis.CurrentField)
        }</span>
        <span class="cov8" title="1">if len(we.Values) == 0 </span><span class="cov8" title="1">{
                return apis.ErrInvalidValue("expecting non-empty values field", apis.CurrentField)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (wes WhenExpressions) validatePipelineParametersVariables(prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) <span class="cov8" title="1">{
        for idx, we := range wes </span><span class="cov8" title="1">{
                errs = errs.Also(validateStringVariable(we.Input, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("input").ViaFieldIndex("when", idx))
                for _, val := range we.Values </span><span class="cov8" title="1">{
                        // one of the values could be a reference to an array param, such as, $(params.foo[*])
                        // extract the variable name from the pattern $(params.foo[*]), if the variable name matches with one of the array params
                        // validate the param as an array variable otherwise, validate it as a string variable
                        if arrayParamNames.Has(ArrayReference(val)) </span><span class="cov8" title="1">{
                                errs = errs.Also(validateArrayVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("values").ViaFieldIndex("when", idx))
                        }</span> else<span class="cov8" title="1"> {
                                errs = errs.Also(validateStringVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaField("values").ViaFieldIndex("when", idx))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func (w WorkspaceDeclaration) convertTo(ctx context.Context, sink *v1.WorkspaceDeclaration) <span class="cov8" title="1">{
        sink.Name = w.Name
        sink.Description = w.Description
        sink.MountPath = w.MountPath
        sink.ReadOnly = w.ReadOnly
        sink.Optional = w.Optional
}</span>

func (w *WorkspaceDeclaration) convertFrom(ctx context.Context, source v1.WorkspaceDeclaration) <span class="cov8" title="1">{
        w.Name = source.Name
        w.Description = source.Description
        w.MountPath = source.MountPath
        w.ReadOnly = source.ReadOnly
        w.Optional = source.Optional
}</span>

func (w WorkspaceUsage) convertTo(ctx context.Context, sink *v1.WorkspaceUsage) <span class="cov8" title="1">{
        sink.Name = w.Name
        sink.MountPath = w.MountPath
}</span>

func (w *WorkspaceUsage) convertFrom(ctx context.Context, source v1.WorkspaceUsage) <span class="cov8" title="1">{
        w.Name = source.Name
        w.MountPath = source.MountPath
}</span>

func (w PipelineWorkspaceDeclaration) convertTo(ctx context.Context, sink *v1.PipelineWorkspaceDeclaration) <span class="cov8" title="1">{
        sink.Name = w.Name
        sink.Description = w.Description
        sink.Optional = w.Optional
}</span>

func (w *PipelineWorkspaceDeclaration) convertFrom(ctx context.Context, source v1.PipelineWorkspaceDeclaration) <span class="cov8" title="1">{
        w.Name = source.Name
        w.Description = source.Description
        w.Optional = source.Optional
}</span>

func (w WorkspacePipelineTaskBinding) convertTo(ctx context.Context, sink *v1.WorkspacePipelineTaskBinding) <span class="cov8" title="1">{
        sink.Name = w.Name
        sink.Workspace = w.Workspace
        sink.SubPath = w.SubPath
}</span>

func (w *WorkspacePipelineTaskBinding) convertFrom(ctx context.Context, source v1.WorkspacePipelineTaskBinding) <span class="cov8" title="1">{
        w.Name = source.Name
        w.Workspace = source.Workspace
        w.SubPath = source.SubPath
}</span>

func (w WorkspaceBinding) convertTo(ctx context.Context, sink *v1.WorkspaceBinding) <span class="cov8" title="1">{
        sink.Name = w.Name
        sink.SubPath = w.SubPath
        sink.VolumeClaimTemplate = w.VolumeClaimTemplate
        sink.PersistentVolumeClaim = w.PersistentVolumeClaim
        sink.EmptyDir = w.EmptyDir
        sink.ConfigMap = w.ConfigMap
        sink.Secret = w.Secret
        sink.Projected = w.Projected
        sink.CSI = w.CSI
}</span>

// ConvertFrom converts v1beta1 Param from v1 Param
func (w *WorkspaceBinding) ConvertFrom(ctx context.Context, source v1.WorkspaceBinding) <span class="cov8" title="1">{
        w.Name = source.Name
        w.SubPath = source.SubPath
        w.VolumeClaimTemplate = source.VolumeClaimTemplate
        w.PersistentVolumeClaim = source.PersistentVolumeClaim
        w.EmptyDir = source.EmptyDir
        w.ConfigMap = source.ConfigMap
        w.Secret = source.Secret
        w.Projected = source.Projected
        w.CSI = source.CSI
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "path/filepath"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        corev1 "k8s.io/api/core/v1"
)

// WorkspaceDeclaration is a declaration of a volume that a Task requires.
type WorkspaceDeclaration struct {
        // Name is the name by which you can bind the volume at runtime.
        Name string `json:"name"`
        // Description is an optional human readable description of this volume.
        // +optional
        Description string `json:"description,omitempty"`
        // MountPath overrides the directory that the volume will be made available at.
        // +optional
        MountPath string `json:"mountPath,omitempty"`
        // ReadOnly dictates whether a mounted volume is writable. By default this
        // field is false and so mounted volumes are writable.
        ReadOnly bool `json:"readOnly,omitempty"`
        // Optional marks a Workspace as not being required in TaskRuns. By default
        // this field is false and so declared workspaces are required.
        Optional bool `json:"optional,omitempty"`
}

// GetMountPath returns the mountPath for w which is the MountPath if provided or the
// default if not.
func (w *WorkspaceDeclaration) GetMountPath() string <span class="cov8" title="1">{
        if w.MountPath != "" </span><span class="cov8" title="1">{
                return w.MountPath
        }</span>
        <span class="cov8" title="1">return filepath.Join(pipeline.WorkspaceDir, w.Name)</span>
}

// WorkspaceBinding maps a Task's declared workspace to a Volume.
type WorkspaceBinding struct {
        // Name is the name of the workspace populated by the volume.
        Name string `json:"name"`
        // SubPath is optionally a directory on the volume which should be used
        // for this binding (i.e. the volume will be mounted at this sub directory).
        // +optional
        SubPath string `json:"subPath,omitempty"`
        // VolumeClaimTemplate is a template for a claim that will be created in the same namespace.
        // The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.
        // See PersistentVolumeClaim (API version: v1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        VolumeClaimTemplate *corev1.PersistentVolumeClaim `json:"volumeClaimTemplate,omitempty"`
        // PersistentVolumeClaimVolumeSource represents a reference to a
        // PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.
        // +optional
        PersistentVolumeClaim *corev1.PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`
        // EmptyDir represents a temporary directory that shares a Task's lifetime.
        // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        // Either this OR PersistentVolumeClaim can be used.
        // +optional
        EmptyDir *corev1.EmptyDirVolumeSource `json:"emptyDir,omitempty"`
        // ConfigMap represents a configMap that should populate this workspace.
        // +optional
        ConfigMap *corev1.ConfigMapVolumeSource `json:"configMap,omitempty"`
        // Secret represents a secret that should populate this workspace.
        // +optional
        Secret *corev1.SecretVolumeSource `json:"secret,omitempty"`
        // Projected represents a projected volume that should populate this workspace.
        // +optional
        Projected *corev1.ProjectedVolumeSource `json:"projected,omitempty"`
        // CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
        // +optional
        CSI *corev1.CSIVolumeSource `json:"csi,omitempty"`
}

// WorkspacePipelineDeclaration creates a named slot in a Pipeline that a PipelineRun
// is expected to populate with a workspace binding.
//
// Deprecated: use PipelineWorkspaceDeclaration type instead
type WorkspacePipelineDeclaration = PipelineWorkspaceDeclaration

// PipelineWorkspaceDeclaration creates a named slot in a Pipeline that a PipelineRun
// is expected to populate with a workspace binding.
type PipelineWorkspaceDeclaration struct {
        // Name is the name of a workspace to be provided by a PipelineRun.
        Name string `json:"name"`
        // Description is a human readable string describing how the workspace will be
        // used in the Pipeline. It can be useful to include a bit of detail about which
        // tasks are intended to have access to the data on the workspace.
        // +optional
        Description string `json:"description,omitempty"`
        // Optional marks a Workspace as not being required in PipelineRuns. By default
        // this field is false and so declared workspaces are required.
        Optional bool `json:"optional,omitempty"`
}

// WorkspacePipelineTaskBinding describes how a workspace passed into the pipeline should be
// mapped to a task's declared workspace.
type WorkspacePipelineTaskBinding struct {
        // Name is the name of the workspace as declared by the task
        Name string `json:"name"`
        // Workspace is the name of the workspace declared by the pipeline
        // +optional
        Workspace string `json:"workspace,omitempty"`
        // SubPath is optionally a directory on the volume which should be used
        // for this binding (i.e. the volume will be mounted at this sub directory).
        // +optional
        SubPath string `json:"subPath,omitempty"`
}

// WorkspaceUsage is used by a Step or Sidecar to declare that it wants isolated access
// to a Workspace defined in a Task.
type WorkspaceUsage struct {
        // Name is the name of the workspace this Step or Sidecar wants access to.
        Name string `json:"name"`
        // MountPath is the path that the workspace should be mounted to inside the Step or Sidecar,
        // overriding any MountPath specified in the Task's WorkspaceDeclaration.
        MountPath string `json:"mountPath"`
}
</pre>
		
		<pre class="file" id="file138" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "k8s.io/apimachinery/pkg/api/equality"
        "knative.dev/pkg/apis"
)

// allVolumeSourceFields is a list of all the volume source field paths that a
// WorkspaceBinding may include.
var allVolumeSourceFields = []string{
        "persistentvolumeclaim",
        "volumeclaimtemplate",
        "emptydir",
        "configmap",
        "secret",
}

// Validate looks at the Volume provided in wb and makes sure that it is valid.
// This means that only one VolumeSource can be specified, and also that the
// supported VolumeSource is itself valid.
func (b *WorkspaceBinding) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(b, &amp;WorkspaceBinding{}) || b == nil </span><span class="cov8" title="1">{
                return apis.ErrMissingField(apis.CurrentField)
        }</span>

        <span class="cov8" title="1">numSources := b.numSources()

        if numSources &gt; 1 </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf(allVolumeSourceFields...)
        }</span>

        <span class="cov8" title="1">if numSources == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf(allVolumeSourceFields...)
        }</span>

        // For a PersistentVolumeClaim to work, you must at least provide the name of the PVC to use.
        <span class="cov8" title="1">if b.PersistentVolumeClaim != nil &amp;&amp; b.PersistentVolumeClaim.ClaimName == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("persistentvolumeclaim.claimname")
        }</span>

        // For a ConfigMap to work, you must provide the name of the ConfigMap to use.
        <span class="cov8" title="1">if b.ConfigMap != nil &amp;&amp; b.ConfigMap.LocalObjectReference.Name == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("configmap.name")
        }</span>

        // For a Secret to work, you must provide the name of the Secret to use.
        <span class="cov8" title="1">if b.Secret != nil &amp;&amp; b.Secret.SecretName == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("secret.secretName")
        }</span>

        // For a Projected volume to work, you must provide at least one source.
        <span class="cov8" title="1">if b.Projected != nil &amp;&amp; len(b.Projected.Sources) == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingField("projected.sources")
        }</span>

        // For a CSI to work, you must provide and have installed the driver to use.
        <span class="cov8" title="1">if b.CSI != nil &amp;&amp; b.CSI.Driver == "" </span><span class="cov8" title="1">{
                return apis.ErrMissingField("csi.driver")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// numSources returns the total number of volume sources that this WorkspaceBinding
// has been configured with.
func (b *WorkspaceBinding) numSources() int <span class="cov8" title="1">{
        n := 0
        if b.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.EmptyDir != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.ConfigMap != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.Secret != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.Projected != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">if b.CSI != nil </span><span class="cov8" title="1">{
                n++
        }</span>
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/tektoncd/pipeline/pkg/apis/resolution"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: resolution.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        // SchemeBuilder builds a scheme with the types known to the package.
        SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
        // AddToScheme adds the types known to this package to an existing schema.
        AddToScheme = SchemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ResolutionRequest{},
                &amp;ResolutionRequestList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*ResolutionRequest)(nil)

// ConvertTo implements apis.Convertible
func (rr *ResolutionRequest) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch sink := sink.(type) </span>{
        case *v1beta1.ResolutionRequest:<span class="cov8" title="1">
                sink.ObjectMeta = rr.ObjectMeta
                rr.Status.convertTo(ctx, &amp;sink.Status)
                return rr.Spec.ConvertTo(ctx, &amp;sink.Spec)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", sink)</span>
        }
}

// ConvertTo converts a v1alpha1.ResolutionRequestSpec to a v1beta1.ResolutionRequestSpec
func (rrs *ResolutionRequestSpec) ConvertTo(ctx context.Context, sink *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        for k, v := range rrs.Parameters </span><span class="cov8" title="1">{
                sink.Params = append(sink.Params, pipelinev1.Param{
                        Name: k,
                        Value: pipelinev1.ParamValue{
                                Type:      pipelinev1.ParamTypeString,
                                StringVal: v,
                        },
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// convertTo converts a v1alpha1.ResolutionRequestStatus to a v1beta1.ResolutionRequestStatus
func (rrs *ResolutionRequestStatus) convertTo(ctx context.Context, sink *v1beta1.ResolutionRequestStatus) <span class="cov8" title="1">{
        sink.Data = rrs.Data
        if rrs.RefSource != nil </span><span class="cov0" title="0">{
                refSource := pipelinev1.RefSource{}
                refSource.URI = rrs.RefSource.URI
                refSource.EntryPoint = rrs.RefSource.EntryPoint
                digest := make(map[string]string)
                for k, v := range rrs.RefSource.Digest </span><span class="cov0" title="0">{
                        digest[k] = v
                }</span>
                <span class="cov0" title="0">refSource.Digest = digest
                sink.RefSource = &amp;refSource</span>
        }
}

// ConvertFrom implements apis.Convertible
func (rr *ResolutionRequest) ConvertFrom(ctx context.Context, from apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch from := from.(type) </span>{
        case *v1beta1.ResolutionRequest:<span class="cov8" title="1">
                rr.ObjectMeta = from.ObjectMeta
                rr.Status.convertFrom(ctx, &amp;from.Status)
                return rr.Spec.ConvertFrom(ctx, &amp;from.Spec)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown version, got: %T", from)</span>
        }
}

// ConvertFrom converts a v1beta1.ResolutionRequestSpec to a v1alpha1.ResolutionRequestSpec
func (rrs *ResolutionRequestSpec) ConvertFrom(ctx context.Context, from *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        var nonStringParams []string

        for _, p := range from.Params </span><span class="cov8" title="1">{
                if p.Value.Type != pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                        nonStringParams = append(nonStringParams, p.Name)
                }</span> else<span class="cov8" title="1"> {
                        if rrs.Parameters == nil </span><span class="cov8" title="1">{
                                rrs.Parameters = make(map[string]string)
                        }</span>
                        <span class="cov8" title="1">rrs.Parameters[p.Name] = p.Value.StringVal</span>
                }
        }

        <span class="cov8" title="1">if len(nonStringParams) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot convert v1beta1 to v1alpha, non-string type parameter(s) found: %s", strings.Join(nonStringParams, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// convertFrom converts a v1alpha1.ResolutionRequestStatus to a v1beta1.ResolutionRequestStatus
func (rrs *ResolutionRequestStatus) convertFrom(ctx context.Context, from *v1beta1.ResolutionRequestStatus) <span class="cov8" title="1">{
        rrs.Data = from.Data

        if from.RefSource != nil </span><span class="cov0" title="0">{
                refSource := pipelinev1.RefSource{}
                refSource.URI = from.RefSource.URI
                refSource.EntryPoint = from.RefSource.EntryPoint
                digest := make(map[string]string)
                for k, v := range from.RefSource.Digest </span><span class="cov0" title="0">{
                        digest[k] = v
                }</span>
                <span class="cov0" title="0">refSource.Digest = digest
                rrs.RefSource = &amp;refSource</span>
        } else<span class="cov8" title="1"> if from.Source != nil </span><span class="cov0" title="0">{
                refSource := pipelinev1.RefSource{}
                refSource.URI = from.Source.URI
                refSource.EntryPoint = from.Source.EntryPoint
                digest := make(map[string]string)
                for k, v := range from.Source.Digest </span><span class="cov0" title="0">{
                        digest[k] = v
                }</span>
                <span class="cov0" title="0">refSource.Digest = digest
                rrs.RefSource = &amp;refSource</span>
        }
}
</pre>
		
		<pre class="file" id="file141" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import "context"

// ManagedByLabelKey is the label key used to mark what is managing this resource
const ManagedByLabelKey = "app.kubernetes.io/managed-by"

// SetDefaults walks a ResolutionRequest object and sets any default
// values that are required to be set before a reconciler sees it.
func (rr *ResolutionRequest) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if rr.TypeMeta.Kind == "" </span><span class="cov0" title="0">{
                rr.TypeMeta.Kind = "ResolutionRequest"
        }</span>
        <span class="cov0" title="0">if rr.TypeMeta.APIVersion == "" </span><span class="cov0" title="0">{
                rr.TypeMeta.APIVersion = "resolution.tekton.dev/v1alpha1"
        }</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

// ResolutionRequests only have apis.ConditionSucceeded for now.
var resolutionRequestCondSet = apis.NewBatchConditionSet()

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*ResolutionRequest) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("ResolutionRequest")
}</span>

// GetConditionSet implements KRShaped.
func (*ResolutionRequest) GetConditionSet() apis.ConditionSet <span class="cov0" title="0">{
        return resolutionRequestCondSet
}</span>

// HasStarted returns whether a ResolutionRequests Status is considered to
// be in-progress.
func (rr *ResolutionRequest) HasStarted() bool <span class="cov0" title="0">{
        return rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// IsDone returns whether a ResolutionRequests Status is considered to be
// in a completed state, independent of success/failure.
func (rr *ResolutionRequest) IsDone() bool <span class="cov0" title="0">{
        finalStateIsUnknown := rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
        return !finalStateIsUnknown
}</span>

// InitializeConditions set ths initial values of the conditions.
func (s *ResolutionRequestStatus) InitializeConditions() <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).InitializeConditions()
}</span>

// MarkFailed sets the Succeeded condition to False with an accompanying
// error message.
func (s *ResolutionRequestStatus) MarkFailed(reason, message string) <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkFalse(apis.ConditionSucceeded, reason, message)
}</span>

// MarkSucceeded sets the Succeeded condition to True.
func (s *ResolutionRequestStatus) MarkSucceeded() <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkTrue(apis.ConditionSucceeded)
}</span>

// MarkInProgress updates the Succeeded condition to Unknown with an
// accompanying message.
func (s *ResolutionRequestStatus) MarkInProgress(message string) <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkUnknown(apis.ConditionSucceeded, resolutioncommon.ReasonResolutionInProgress, message)
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ResolutionRequest is an object for requesting the content of
// a Tekton resource like a pipeline.yaml.
//
// +genclient
// +genreconciler
type ResolutionRequest struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the information for the request part of the resource request.
        // +optional
        Spec ResolutionRequestSpec `json:"spec,omitempty"`

        // Status communicates the state of the request and, ultimately,
        // the content of the resolved resource.
        // +optional
        Status ResolutionRequestStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ResolutionRequestList is a list of ResolutionRequests.
type ResolutionRequestList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata"`
        Items           []ResolutionRequest `json:"items"`
}

// ResolutionRequestSpec are all the fields in the spec of the
// ResolutionRequest CRD.
type ResolutionRequestSpec struct {
        // Parameters are the runtime attributes passed to
        // the resolver to help it figure out how to resolve the
        // resource being requested. For example: repo URL, commit SHA,
        // path to file, the kind of authentication to leverage, etc.
        // +optional
        Parameters map[string]string `json:"params,omitempty"`
}

// ResolutionRequestStatus are all the fields in a ResolutionRequest's
// status subresource.
type ResolutionRequestStatus struct {
        duckv1.Status                 `json:",inline"`
        ResolutionRequestStatusFields `json:",inline"`
}

// ResolutionRequestStatusFields are the ResolutionRequest-specific fields
// for the status subresource.
type ResolutionRequestStatusFields struct {
        // Data is a string representation of the resolved content
        // of the requested resource in-lined into the ResolutionRequest
        // object.
        Data string `json:"data"`
        // RefSource is the source reference of the remote data that records where the remote
        // file came from including the url, digest and the entrypoint.
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        RefSource *pipelinev1.RefSource `json:"refSource"`
}

// GetStatus implements KRShaped.
func (rr *ResolutionRequest) GetStatus() *duckv1.Status <span class="cov0" title="0">{
        return &amp;rr.Status.Status
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/resolution/common"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*ResolutionRequest)(nil)
        _ resourcesemantics.VerbLimited = (*ResolutionRequest)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (rr *ResolutionRequest) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate checks that a submitted ResolutionRequest is structurally
// sound before the controller receives it.
func (rr *ResolutionRequest) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov0" title="0">{
        errs = errs.Also(validateTypeLabel(rr))
        return errs.Also(rr.Spec.Validate(ctx).ViaField("spec"))
}</span>

// Validate checks the spec field of a ResolutionRequest is valid.
func (rs *ResolutionRequestSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov0" title="0">{
        return nil
}</span>

func validateTypeLabel(rr *ResolutionRequest) *apis.FieldError <span class="cov0" title="0">{
        typeLabel := getTypeLabel(rr.ObjectMeta.Labels)
        if typeLabel == "" </span><span class="cov0" title="0">{
                return apis.ErrMissingField(common.LabelKeyResolverType).ViaField("labels").ViaField("meta")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getTypeLabel(labels map[string]string) string <span class="cov0" title="0">{
        if labels == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return labels[common.LabelKeyResolverType]</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/resolution"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: resolution.GroupName, Version: "v1beta1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        // SchemeBuilder builds a scheme with the types known to the package.
        SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
        // AddToScheme adds the types known to this package to an existing schema.
        AddToScheme = SchemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ResolutionRequest{},
                &amp;ResolutionRequestList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

*/

package v1beta1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

var _ apis.Convertible = (*ResolutionRequest)(nil)

// ConvertTo implements apis.Convertible
func (rr *ResolutionRequest) ConvertTo(ctx context.Context, sink apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1beta1 is the highest known version, got: %T", sink)</span>
}

// ConvertFrom implements apis.Convertible
func (rr *ResolutionRequest) ConvertFrom(ctx context.Context, source apis.Convertible) error <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("v1beta1 is the highest known version, got: %T", source)</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import "context"

// ManagedByLabelKey is the label key used to mark what is managing this resource
const ManagedByLabelKey = "app.kubernetes.io/managed-by"

// SetDefaults walks a ResolutionRequest object and sets any default
// values that are required to be set before a reconciler sees it.
func (rr *ResolutionRequest) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if rr.TypeMeta.Kind == "" </span><span class="cov0" title="0">{
                rr.TypeMeta.Kind = "ResolutionRequest"
        }</span>
        <span class="cov0" title="0">if rr.TypeMeta.APIVersion == "" </span><span class="cov0" title="0">{
                rr.TypeMeta.APIVersion = "resolution.tekton.dev/v1beta1"
        }</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

// ResolutionRequests only have apis.ConditionSucceeded for now.
var resolutionRequestCondSet = apis.NewBatchConditionSet()

// GetGroupVersionKind implements kmeta.OwnerRefable.
func (*ResolutionRequest) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("ResolutionRequest")
}</span>

// GetConditionSet implements KRShaped.
func (*ResolutionRequest) GetConditionSet() apis.ConditionSet <span class="cov0" title="0">{
        return resolutionRequestCondSet
}</span>

// HasStarted returns whether a ResolutionRequests Status is considered to
// be in-progress.
func (rr *ResolutionRequest) HasStarted() bool <span class="cov0" title="0">{
        return rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// IsDone returns whether a ResolutionRequests Status is considered to be
// in a completed state, independent of success/failure.
func (rr *ResolutionRequest) IsDone() bool <span class="cov0" title="0">{
        finalStateIsUnknown := rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
        return !finalStateIsUnknown
}</span>

// InitializeConditions set ths initial values of the conditions.
func (s *ResolutionRequestStatus) InitializeConditions() <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).InitializeConditions()
}</span>

// MarkFailed sets the Succeeded condition to False with an accompanying
// error message.
func (s *ResolutionRequestStatus) MarkFailed(reason, message string) <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkFalse(apis.ConditionSucceeded, reason, message)
}</span>

// MarkSucceeded sets the Succeeded condition to True.
func (s *ResolutionRequestStatus) MarkSucceeded() <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkTrue(apis.ConditionSucceeded)
}</span>

// MarkInProgress updates the Succeeded condition to Unknown with an
// accompanying message.
func (s *ResolutionRequestStatus) MarkInProgress(message string) <span class="cov0" title="0">{
        resolutionRequestCondSet.Manage(s).MarkUnknown(apis.ConditionSucceeded, resolutioncommon.ReasonResolutionInProgress, message)
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ResolutionRequest is an object for requesting the content of
// a Tekton resource like a pipeline.yaml.
//
// +genclient
// +genreconciler
// +kubebuilder:storageversion
type ResolutionRequest struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the information for the request part of the resource request.
        // +optional
        Spec ResolutionRequestSpec `json:"spec,omitempty"`

        // Status communicates the state of the request and, ultimately,
        // the content of the resolved resource.
        // +optional
        Status ResolutionRequestStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ResolutionRequestList is a list of ResolutionRequests.
type ResolutionRequestList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata"`
        Items           []ResolutionRequest `json:"items"`
}

// ResolutionRequestSpec are all the fields in the spec of the
// ResolutionRequest CRD.
type ResolutionRequestSpec struct {
        // Parameters are the runtime attributes passed to
        // the resolver to help it figure out how to resolve the
        // resource being requested. For example: repo URL, commit SHA,
        // path to file, the kind of authentication to leverage, etc.
        // +optional
        // +listType=atomic
        Params []pipelinev1.Param `json:"params,omitempty"`
        // URL is the runtime url passed to the resolver
        // to help it figure out how to resolver the resource being
        // requested.
        // This is currently at an ALPHA stability level and subject to
        // alpha API compatibility policies.
        // +optional
        URL string `json:"url,omitempty"`
}

// ResolutionRequestStatus are all the fields in a ResolutionRequest's
// status subresource.
type ResolutionRequestStatus struct {
        duckv1.Status                 `json:",inline"`
        ResolutionRequestStatusFields `json:",inline"`
}

// ResolutionRequestStatusFields are the ResolutionRequest-specific fields
// for the status subresource.
type ResolutionRequestStatusFields struct {
        // Data is a string representation of the resolved content
        // of the requested resource in-lined into the ResolutionRequest
        // object.
        Data string `json:"data"`
        // Deprecated: Use RefSource instead
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        Source *pipelinev1.RefSource `json:"source"`

        // RefSource is the source reference of the remote data that records the url, digest
        // and the entrypoint.
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        RefSource *pipelinev1.RefSource `json:"refSource"`
}

// GetStatus implements KRShaped.
func (rr *ResolutionRequest) GetStatus() *duckv1.Status <span class="cov0" title="0">{
        return &amp;rr.Status.Status
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/resolution/common"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        _ apis.Validatable              = (*ResolutionRequest)(nil)
        _ resourcesemantics.VerbLimited = (*ResolutionRequest)(nil)
)

// SupportedVerbs returns the operations that validation should be called for
func (rr *ResolutionRequest) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate checks that a submitted ResolutionRequest is structurally
// sound before the controller receives it.
func (rr *ResolutionRequest) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov0" title="0">{
        errs = errs.Also(validateTypeLabel(rr))
        return errs.Also(rr.Spec.Validate(ctx).ViaField("spec"))
}</span>

// Validate checks the spec field of a ResolutionRequest is valid.
func (rs *ResolutionRequestSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov0" title="0">{
        return nil
}</span>

func validateTypeLabel(rr *ResolutionRequest) *apis.FieldError <span class="cov0" title="0">{
        typeLabel := getTypeLabel(rr.ObjectMeta.Labels)
        if typeLabel == "" </span><span class="cov0" title="0">{
                return apis.ErrMissingField(common.LabelKeyResolverType).ViaField("labels").ViaField("meta")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getTypeLabel(labels map[string]string) string <span class="cov0" title="0">{
        if labels == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return labels[common.LabelKeyResolverType]</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">/*
Copyright 2019 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: pipeline.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;PipelineResource{},
                &amp;PipelineResourceList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// This package exists to avoid an import cycle between v1alpha1 and v1beta1.
// It contains common definitions needed by v1alpha1.Run and v1beta1.PipelineRun.

// +k8s:deepcopy-gen=true

// RunStatus defines the observed state of Run
type RunStatus struct {
        duckv1.Status `json:",inline"`

        // RunStatusFields inlines the status fields.
        RunStatusFields `json:",inline"`
}

// +k8s:deepcopy-gen=true

// RunStatusFields holds the fields of Run's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type RunStatusFields struct {
        // StartTime is the time the build is actually started.
        // +optional
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the build completed.
        // +optional
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // Results reports any output result values to be consumed by later
        // tasks in a pipeline.
        // +optional
        Results []RunResult `json:"results,omitempty"`

        // RetriesStatus contains the history of RunStatus, in case of a retry.
        // +optional
        RetriesStatus []RunStatus `json:"retriesStatus,omitempty"`

        // ExtraFields holds arbitrary fields provided by the custom task
        // controller.
        ExtraFields runtime.RawExtension `json:"extraFields,omitempty"`
}

// RunResult used to describe the results of a task
type RunResult struct {
        // Name the given name
        Name string `json:"name"`
        // Value the given value of the result
        Value string `json:"value"`
}

var runCondSet = apis.NewBatchConditionSet()

// GetCondition returns the Condition matching the given type.
func (r *RunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov0" title="0">{
        return runCondSet.Manage(r).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in runCondSet to unknown for the PipelineRun
// and set the started time to the current time
func (r *RunStatus) InitializeConditions() <span class="cov0" title="0">{
        started := false
        if r.StartTime.IsZero() </span><span class="cov0" title="0">{
                r.StartTime = &amp;metav1.Time{Time: time.Now()}
                started = true
        }</span>
        <span class="cov0" title="0">conditionManager := runCondSet.Manage(r)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov0" title="0">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = "Started"
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (r *RunStatus) SetCondition(newCond *apis.Condition) <span class="cov0" title="0">{
        if newCond != nil </span><span class="cov0" title="0">{
                runCondSet.Manage(r).SetCondition(*newCond)
        }</span>
}

// MarkRunSucceeded changes the Succeeded condition to True with the provided reason and message.
func (r *RunStatus) MarkRunSucceeded(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        runCondSet.Manage(r).MarkTrueWithReason(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := r.GetCondition(apis.ConditionSucceeded)
        r.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkRunFailed changes the Succeeded condition to False with the provided reason and message.
func (r *RunStatus) MarkRunFailed(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        runCondSet.Manage(r).MarkFalse(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := r.GetCondition(apis.ConditionSucceeded)
        r.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkRunRunning changes the Succeeded condition to Unknown with the provided reason and message.
func (r *RunStatus) MarkRunRunning(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        runCondSet.Manage(r).MarkUnknown(apis.ConditionSucceeded, reason, messageFormat, messageA...)
}</span>

// DecodeExtraFields deserializes the extra fields in the Run status.
func (r *RunStatus) DecodeExtraFields(into interface{}) error <span class="cov0" title="0">{
        if len(r.ExtraFields.Raw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(r.ExtraFields.Raw, into)</span>
}

// EncodeExtraFields serializes the extra fields in the Run status.
func (r *RunStatus) EncodeExtraFields(from interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(from)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.ExtraFields = runtime.RawExtension{
                Raw: data,
        }
        return nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/json"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/run/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// This package contains common definitions needed by v1beta1.CustomRun and v1beta1.PipelineRun.

// +k8s:deepcopy-gen=true

// CustomRunStatus defines the observed state of CustomRun
type CustomRunStatus struct {
        duckv1.Status `json:",inline"`

        // CustomRunStatusFields inlines the status fields.
        CustomRunStatusFields `json:",inline"`
}

// +k8s:deepcopy-gen=true

// CustomRunStatusFields holds the fields of CustomRun's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
type CustomRunStatusFields struct {
        // StartTime is the time the build is actually started.
        // +optional
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the build completed.
        // +optional
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // Results reports any output result values to be consumed by later
        // tasks in a pipeline.
        // +optional
        Results []CustomRunResult `json:"results,omitempty"`

        // RetriesStatus contains the history of CustomRunStatus, in case of a retry.
        // See CustomRun.status (API version: tekton.dev/v1beta1)
        // +optional
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        RetriesStatus []CustomRunStatus `json:"retriesStatus,omitempty"`

        // ExtraFields holds arbitrary fields provided by the custom task
        // controller.
        // +kubebuilder:pruning:PreserveUnknownFields
        // +kubebuilder:validation:Schemaless
        ExtraFields runtime.RawExtension `json:"extraFields,omitempty"`
}

// CustomRunResult used to describe the results of a task
type CustomRunResult struct {
        // Name the given name
        Name string `json:"name"`
        // Value the given value of the result
        Value string `json:"value"`
}

var customRunCondSet = apis.NewBatchConditionSet()

// GetCondition returns the Condition matching the given type.
func (r *CustomRunStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov0" title="0">{
        return customRunCondSet.Manage(r).GetCondition(t)
}</span>

// InitializeConditions will set all conditions in customRunCondSet to unknown
// and set the started time to the current time
func (r *CustomRunStatus) InitializeConditions() <span class="cov0" title="0">{
        started := false
        if r.StartTime.IsZero() </span><span class="cov0" title="0">{
                r.StartTime = &amp;metav1.Time{Time: time.Now()}
                started = true
        }</span>
        <span class="cov0" title="0">conditionManager := customRunCondSet.Manage(r)
        conditionManager.InitializeConditions()
        // Ensure the started reason is set for the "Succeeded" condition
        if started </span><span class="cov0" title="0">{
                initialCondition := conditionManager.GetCondition(apis.ConditionSucceeded)
                initialCondition.Reason = "Started"
                conditionManager.SetCondition(*initialCondition)
        }</span>
}

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary.
func (r *CustomRunStatus) SetCondition(newCond *apis.Condition) <span class="cov0" title="0">{
        if newCond != nil </span><span class="cov0" title="0">{
                customRunCondSet.Manage(r).SetCondition(*newCond)
        }</span>
}

// MarkCustomRunSucceeded changes the Succeeded condition to True with the provided reason and message.
func (r *CustomRunStatus) MarkCustomRunSucceeded(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        customRunCondSet.Manage(r).MarkTrueWithReason(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := r.GetCondition(apis.ConditionSucceeded)
        r.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkCustomRunFailed changes the Succeeded condition to False with the provided reason and message.
func (r *CustomRunStatus) MarkCustomRunFailed(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        customRunCondSet.Manage(r).MarkFalse(apis.ConditionSucceeded, reason, messageFormat, messageA...)
        succeeded := r.GetCondition(apis.ConditionSucceeded)
        r.CompletionTime = &amp;succeeded.LastTransitionTime.Inner
}</span>

// MarkCustomRunRunning changes the Succeeded condition to Unknown with the provided reason and message.
func (r *CustomRunStatus) MarkCustomRunRunning(reason, messageFormat string, messageA ...interface{}) <span class="cov0" title="0">{
        customRunCondSet.Manage(r).MarkUnknown(apis.ConditionSucceeded, reason, messageFormat, messageA...)
}</span>

// DecodeExtraFields deserializes the extra fields in the CustomRun status.
func (r *CustomRunStatus) DecodeExtraFields(into interface{}) error <span class="cov0" title="0">{
        if len(r.ExtraFields.Raw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(r.ExtraFields.Raw, into)</span>
}

// EncodeExtraFields serializes the extra fields in the CustomRun status.
func (r *CustomRunStatus) EncodeExtraFields(from interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(from)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.ExtraFields = runtime.RawExtension{
                Raw: data,
        }
        return nil</span>
}

// FromRunStatus converts a v1alpha1.RunStatus into a corresponding v1beta1.CustomRunStatus
func FromRunStatus(orig v1alpha1.RunStatus) CustomRunStatus <span class="cov8" title="1">{
        crs := CustomRunStatus{
                Status: orig.Status,
                CustomRunStatusFields: CustomRunStatusFields{
                        StartTime:      orig.StartTime,
                        CompletionTime: orig.CompletionTime,
                        ExtraFields:    orig.ExtraFields,
                },
        }

        for _, origRes := range orig.Results </span><span class="cov8" title="1">{
                crs.Results = append(crs.Results, CustomRunResult{
                        Name:  origRes.Name,
                        Value: origRes.Value,
                })
        }</span>

        <span class="cov8" title="1">for _, origRetryStatus := range orig.RetriesStatus </span><span class="cov8" title="1">{
                crs.RetriesStatus = append(crs.RetriesStatus, FromRunStatus(origRetryStatus))
        }</span>

        <span class="cov8" title="1">return crs</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package validate

import (
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
)

// MaxLength is the maximum length that an object's name can be
const MaxLength = validation.DNS1123LabelMaxLength

// ObjectMetadata validates that the given object's name is a valid DNS name and isn't longer than the max length
func ObjectMetadata(meta metav1.Object) *apis.FieldError <span class="cov8" title="1">{
        name := meta.GetName()

        if err := validation.IsDNS1123Subdomain(name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid resource name %q: must be a valid DNS label", name),
                        Paths:   []string{"name"},
                }
        }</span>

        <span class="cov8" title="1">if len(name) &gt; MaxLength </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: "Invalid resource name: length must be no more than 63 characters",
                        Paths:   []string{"name"},
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package version

import (
        "encoding/json"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// SerializeToMetadata serializes the input field and adds it as an annotation to
// the metadata under the input key.
func SerializeToMetadata(meta *metav1.ObjectMeta, field interface{}, key string) error <span class="cov8" title="1">{
        bytes, err := json.Marshal(field)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error serializing field: %w", err)
        }</span>
        <span class="cov8" title="1">if meta.Annotations == nil </span><span class="cov8" title="1">{
                meta.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">meta.Annotations[key] = string(bytes)
        return nil</span>
}

// DeserializeFromMetadata takes the value of the input key from the metadata's annotations,
// deserializes it into "to", and removes the key from the metadata's annotations.
// Returns nil if the key is not present in the annotations.
func DeserializeFromMetadata(meta *metav1.ObjectMeta, to interface{}, key string) error <span class="cov8" title="1">{
        if meta == nil || meta.Annotations == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if str, ok := meta.Annotations[key]; ok </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(str), to); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deserializing key %s from metadata: %w", key, err)
                }</span>
                <span class="cov8" title="1">delete(meta.Annotations, key)
                if len(meta.Annotations) == 0 </span><span class="cov8" title="1">{
                        meta.Annotations = nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        fmt "fmt"
        http "net/http"

        tektonv1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface
        TektonV1beta1() tektonv1beta1.TektonV1beta1Interface
        TektonV1() tektonv1.TektonV1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        tektonV1alpha1 *tektonv1alpha1.TektonV1alpha1Client
        tektonV1beta1  *tektonv1beta1.TektonV1beta1Client
        tektonV1       *tektonv1.TektonV1Client
}

// TektonV1alpha1 retrieves the TektonV1alpha1Client
func (c *Clientset) TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface <span class="cov0" title="0">{
        return c.tektonV1alpha1
}</span>

// TektonV1beta1 retrieves the TektonV1beta1Client
func (c *Clientset) TektonV1beta1() tektonv1beta1.TektonV1beta1Interface <span class="cov0" title="0">{
        return c.tektonV1beta1
}</span>

// TektonV1 retrieves the TektonV1Client
func (c *Clientset) TektonV1() tektonv1.TektonV1Interface <span class="cov0" title="0">{
        return c.tektonV1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.tektonV1alpha1, err = tektonv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cs.tektonV1beta1, err = tektonv1beta1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cs.tektonV1, err = tektonv1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.tektonV1alpha1 = tektonv1alpha1.New(c)
        cs.tektonV1beta1 = tektonv1beta1.New(c)
        cs.tektonV1 = tektonv1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        tektonv1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        faketektonv1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1/fake"
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        faketektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1/fake"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        faketektonv1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// TektonV1alpha1 retrieves the TektonV1alpha1Client
func (c *Clientset) TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface <span class="cov0" title="0">{
        return &amp;faketektonv1alpha1.FakeTektonV1alpha1{Fake: &amp;c.Fake}
}</span>

// TektonV1beta1 retrieves the TektonV1beta1Client
func (c *Clientset) TektonV1beta1() tektonv1beta1.TektonV1beta1Interface <span class="cov0" title="0">{
        return &amp;faketektonv1beta1.FakeTektonV1beta1{Fake: &amp;c.Fake}
}</span>

// TektonV1 retrieves the TektonV1Client
func (c *Clientset) TektonV1() tektonv1.TektonV1Interface <span class="cov0" title="0">{
        return &amp;faketektonv1.FakeTektonV1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        tektonv1alpha1.AddToScheme,
        tektonv1beta1.AddToScheme,
        tektonv1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        tektonv1alpha1.AddToScheme,
        tektonv1beta1.AddToScheme,
        tektonv1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file160" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        gentype "k8s.io/client-go/gentype"
)

// fakePipelines implements PipelineInterface
type fakePipelines struct {
        *gentype.FakeClientWithList[*v1.Pipeline, *v1.PipelineList]
        Fake *FakeTektonV1
}

func newFakePipelines(fake *FakeTektonV1, namespace string) pipelinev1.PipelineInterface <span class="cov0" title="0">{
        return &amp;fakePipelines{
                gentype.NewFakeClientWithList[*v1.Pipeline, *v1.PipelineList](
                        fake.Fake,
                        namespace,
                        v1.SchemeGroupVersion.WithResource("pipelines"),
                        v1.SchemeGroupVersion.WithKind("Pipeline"),
                        func() *v1.Pipeline </span><span class="cov0" title="0">{ return &amp;v1.Pipeline{} }</span>,
                        func() *v1.PipelineList <span class="cov0" title="0">{ return &amp;v1.PipelineList{} }</span>,
                        func(dst, src *v1.PipelineList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1.PipelineList) []*v1.Pipeline <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1.PipelineList, items []*v1.Pipeline) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file161" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTektonV1 struct {
        *testing.Fake
}

func (c *FakeTektonV1) Pipelines(namespace string) v1.PipelineInterface <span class="cov0" title="0">{
        return newFakePipelines(c, namespace)
}</span>

func (c *FakeTektonV1) PipelineRuns(namespace string) v1.PipelineRunInterface <span class="cov0" title="0">{
        return newFakePipelineRuns(c, namespace)
}</span>

func (c *FakeTektonV1) Tasks(namespace string) v1.TaskInterface <span class="cov0" title="0">{
        return newFakeTasks(c, namespace)
}</span>

func (c *FakeTektonV1) TaskRuns(namespace string) v1.TaskRunInterface <span class="cov0" title="0">{
        return newFakeTaskRuns(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTektonV1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        gentype "k8s.io/client-go/gentype"
)

// fakePipelineRuns implements PipelineRunInterface
type fakePipelineRuns struct {
        *gentype.FakeClientWithList[*v1.PipelineRun, *v1.PipelineRunList]
        Fake *FakeTektonV1
}

func newFakePipelineRuns(fake *FakeTektonV1, namespace string) pipelinev1.PipelineRunInterface <span class="cov0" title="0">{
        return &amp;fakePipelineRuns{
                gentype.NewFakeClientWithList[*v1.PipelineRun, *v1.PipelineRunList](
                        fake.Fake,
                        namespace,
                        v1.SchemeGroupVersion.WithResource("pipelineruns"),
                        v1.SchemeGroupVersion.WithKind("PipelineRun"),
                        func() *v1.PipelineRun </span><span class="cov0" title="0">{ return &amp;v1.PipelineRun{} }</span>,
                        func() *v1.PipelineRunList <span class="cov0" title="0">{ return &amp;v1.PipelineRunList{} }</span>,
                        func(dst, src *v1.PipelineRunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1.PipelineRunList) []*v1.PipelineRun <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1.PipelineRunList, items []*v1.PipelineRun) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file163" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTasks implements TaskInterface
type fakeTasks struct {
        *gentype.FakeClientWithList[*v1.Task, *v1.TaskList]
        Fake *FakeTektonV1
}

func newFakeTasks(fake *FakeTektonV1, namespace string) pipelinev1.TaskInterface <span class="cov0" title="0">{
        return &amp;fakeTasks{
                gentype.NewFakeClientWithList[*v1.Task, *v1.TaskList](
                        fake.Fake,
                        namespace,
                        v1.SchemeGroupVersion.WithResource("tasks"),
                        v1.SchemeGroupVersion.WithKind("Task"),
                        func() *v1.Task </span><span class="cov0" title="0">{ return &amp;v1.Task{} }</span>,
                        func() *v1.TaskList <span class="cov0" title="0">{ return &amp;v1.TaskList{} }</span>,
                        func(dst, src *v1.TaskList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1.TaskList) []*v1.Task <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1.TaskList, items []*v1.Task) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file164" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTaskRuns implements TaskRunInterface
type fakeTaskRuns struct {
        *gentype.FakeClientWithList[*v1.TaskRun, *v1.TaskRunList]
        Fake *FakeTektonV1
}

func newFakeTaskRuns(fake *FakeTektonV1, namespace string) pipelinev1.TaskRunInterface <span class="cov0" title="0">{
        return &amp;fakeTaskRuns{
                gentype.NewFakeClientWithList[*v1.TaskRun, *v1.TaskRunList](
                        fake.Fake,
                        namespace,
                        v1.SchemeGroupVersion.WithResource("taskruns"),
                        v1.SchemeGroupVersion.WithKind("TaskRun"),
                        func() *v1.TaskRun </span><span class="cov0" title="0">{ return &amp;v1.TaskRun{} }</span>,
                        func() *v1.TaskRunList <span class="cov0" title="0">{ return &amp;v1.TaskRunList{} }</span>,
                        func(dst, src *v1.TaskRunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1.TaskRunList) []*v1.TaskRun <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1.TaskRunList, items []*v1.TaskRun) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file165" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1

import (
        context "context"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// PipelinesGetter has a method to return a PipelineInterface.
// A group's client should implement this interface.
type PipelinesGetter interface {
        Pipelines(namespace string) PipelineInterface
}

// PipelineInterface has methods to work with Pipeline resources.
type PipelineInterface interface {
        Create(ctx context.Context, pipeline *pipelinev1.Pipeline, opts metav1.CreateOptions) (*pipelinev1.Pipeline, error)
        Update(ctx context.Context, pipeline *pipelinev1.Pipeline, opts metav1.UpdateOptions) (*pipelinev1.Pipeline, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*pipelinev1.Pipeline, error)
        List(ctx context.Context, opts metav1.ListOptions) (*pipelinev1.PipelineList, error)
        Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *pipelinev1.Pipeline, err error)
        PipelineExpansion
}

// pipelines implements PipelineInterface
type pipelines struct {
        *gentype.ClientWithList[*pipelinev1.Pipeline, *pipelinev1.PipelineList]
}

// newPipelines returns a Pipelines
func newPipelines(c *TektonV1Client, namespace string) *pipelines <span class="cov0" title="0">{
        return &amp;pipelines{
                gentype.NewClientWithList[*pipelinev1.Pipeline, *pipelinev1.PipelineList](
                        "pipelines",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1.Pipeline </span><span class="cov0" title="0">{ return &amp;pipelinev1.Pipeline{} }</span>,
                        func() *pipelinev1.PipelineList <span class="cov0" title="0">{ return &amp;pipelinev1.PipelineList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file166" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1

import (
        http "net/http"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TektonV1Interface interface {
        RESTClient() rest.Interface
        PipelinesGetter
        PipelineRunsGetter
        TasksGetter
        TaskRunsGetter
}

// TektonV1Client is used to interact with features provided by the tekton.dev group.
type TektonV1Client struct {
        restClient rest.Interface
}

func (c *TektonV1Client) Pipelines(namespace string) PipelineInterface <span class="cov0" title="0">{
        return newPipelines(c, namespace)
}</span>

func (c *TektonV1Client) PipelineRuns(namespace string) PipelineRunInterface <span class="cov0" title="0">{
        return newPipelineRuns(c, namespace)
}</span>

func (c *TektonV1Client) Tasks(namespace string) TaskInterface <span class="cov0" title="0">{
        return newTasks(c, namespace)
}</span>

func (c *TektonV1Client) TaskRuns(namespace string) TaskRunInterface <span class="cov0" title="0">{
        return newTaskRuns(c, namespace)
}</span>

// NewForConfig creates a new TektonV1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TektonV1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TektonV1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TektonV1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TektonV1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TektonV1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TektonV1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TektonV1Client for the given RESTClient.
func New(c rest.Interface) *TektonV1Client <span class="cov0" title="0">{
        return &amp;TektonV1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := pipelinev1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TektonV1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1

import (
        context "context"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// PipelineRunsGetter has a method to return a PipelineRunInterface.
// A group's client should implement this interface.
type PipelineRunsGetter interface {
        PipelineRuns(namespace string) PipelineRunInterface
}

// PipelineRunInterface has methods to work with PipelineRun resources.
type PipelineRunInterface interface {
        Create(ctx context.Context, pipelineRun *pipelinev1.PipelineRun, opts metav1.CreateOptions) (*pipelinev1.PipelineRun, error)
        Update(ctx context.Context, pipelineRun *pipelinev1.PipelineRun, opts metav1.UpdateOptions) (*pipelinev1.PipelineRun, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, pipelineRun *pipelinev1.PipelineRun, opts metav1.UpdateOptions) (*pipelinev1.PipelineRun, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*pipelinev1.PipelineRun, error)
        List(ctx context.Context, opts metav1.ListOptions) (*pipelinev1.PipelineRunList, error)
        Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *pipelinev1.PipelineRun, err error)
        PipelineRunExpansion
}

// pipelineRuns implements PipelineRunInterface
type pipelineRuns struct {
        *gentype.ClientWithList[*pipelinev1.PipelineRun, *pipelinev1.PipelineRunList]
}

// newPipelineRuns returns a PipelineRuns
func newPipelineRuns(c *TektonV1Client, namespace string) *pipelineRuns <span class="cov0" title="0">{
        return &amp;pipelineRuns{
                gentype.NewClientWithList[*pipelinev1.PipelineRun, *pipelinev1.PipelineRunList](
                        "pipelineruns",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1.PipelineRun </span><span class="cov0" title="0">{ return &amp;pipelinev1.PipelineRun{} }</span>,
                        func() *pipelinev1.PipelineRunList <span class="cov0" title="0">{ return &amp;pipelinev1.PipelineRunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file168" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1

import (
        context "context"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TasksGetter has a method to return a TaskInterface.
// A group's client should implement this interface.
type TasksGetter interface {
        Tasks(namespace string) TaskInterface
}

// TaskInterface has methods to work with Task resources.
type TaskInterface interface {
        Create(ctx context.Context, task *pipelinev1.Task, opts metav1.CreateOptions) (*pipelinev1.Task, error)
        Update(ctx context.Context, task *pipelinev1.Task, opts metav1.UpdateOptions) (*pipelinev1.Task, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*pipelinev1.Task, error)
        List(ctx context.Context, opts metav1.ListOptions) (*pipelinev1.TaskList, error)
        Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *pipelinev1.Task, err error)
        TaskExpansion
}

// tasks implements TaskInterface
type tasks struct {
        *gentype.ClientWithList[*pipelinev1.Task, *pipelinev1.TaskList]
}

// newTasks returns a Tasks
func newTasks(c *TektonV1Client, namespace string) *tasks <span class="cov0" title="0">{
        return &amp;tasks{
                gentype.NewClientWithList[*pipelinev1.Task, *pipelinev1.TaskList](
                        "tasks",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1.Task </span><span class="cov0" title="0">{ return &amp;pipelinev1.Task{} }</span>,
                        func() *pipelinev1.TaskList <span class="cov0" title="0">{ return &amp;pipelinev1.TaskList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file169" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1

import (
        context "context"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TaskRunsGetter has a method to return a TaskRunInterface.
// A group's client should implement this interface.
type TaskRunsGetter interface {
        TaskRuns(namespace string) TaskRunInterface
}

// TaskRunInterface has methods to work with TaskRun resources.
type TaskRunInterface interface {
        Create(ctx context.Context, taskRun *pipelinev1.TaskRun, opts metav1.CreateOptions) (*pipelinev1.TaskRun, error)
        Update(ctx context.Context, taskRun *pipelinev1.TaskRun, opts metav1.UpdateOptions) (*pipelinev1.TaskRun, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, taskRun *pipelinev1.TaskRun, opts metav1.UpdateOptions) (*pipelinev1.TaskRun, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*pipelinev1.TaskRun, error)
        List(ctx context.Context, opts metav1.ListOptions) (*pipelinev1.TaskRunList, error)
        Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *pipelinev1.TaskRun, err error)
        TaskRunExpansion
}

// taskRuns implements TaskRunInterface
type taskRuns struct {
        *gentype.ClientWithList[*pipelinev1.TaskRun, *pipelinev1.TaskRunList]
}

// newTaskRuns returns a TaskRuns
func newTaskRuns(c *TektonV1Client, namespace string) *taskRuns <span class="cov0" title="0">{
        return &amp;taskRuns{
                gentype.NewClientWithList[*pipelinev1.TaskRun, *pipelinev1.TaskRunList](
                        "taskruns",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1.TaskRun </span><span class="cov0" title="0">{ return &amp;pipelinev1.TaskRun{} }</span>,
                        func() *pipelinev1.TaskRunList <span class="cov0" title="0">{ return &amp;pipelinev1.TaskRunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file170" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTektonV1alpha1 struct {
        *testing.Fake
}

func (c *FakeTektonV1alpha1) Runs(namespace string) v1alpha1.RunInterface <span class="cov0" title="0">{
        return newFakeRuns(c, namespace)
}</span>

func (c *FakeTektonV1alpha1) StepActions(namespace string) v1alpha1.StepActionInterface <span class="cov0" title="0">{
        return newFakeStepActions(c, namespace)
}</span>

func (c *FakeTektonV1alpha1) VerificationPolicies(namespace string) v1alpha1.VerificationPolicyInterface <span class="cov0" title="0">{
        return newFakeVerificationPolicies(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTektonV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeRuns implements RunInterface
type fakeRuns struct {
        *gentype.FakeClientWithList[*v1alpha1.Run, *v1alpha1.RunList]
        Fake *FakeTektonV1alpha1
}

func newFakeRuns(fake *FakeTektonV1alpha1, namespace string) pipelinev1alpha1.RunInterface <span class="cov0" title="0">{
        return &amp;fakeRuns{
                gentype.NewFakeClientWithList[*v1alpha1.Run, *v1alpha1.RunList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("runs"),
                        v1alpha1.SchemeGroupVersion.WithKind("Run"),
                        func() *v1alpha1.Run </span><span class="cov0" title="0">{ return &amp;v1alpha1.Run{} }</span>,
                        func() *v1alpha1.RunList <span class="cov0" title="0">{ return &amp;v1alpha1.RunList{} }</span>,
                        func(dst, src *v1alpha1.RunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.RunList) []*v1alpha1.Run <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1alpha1.RunList, items []*v1alpha1.Run) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file172" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeStepActions implements StepActionInterface
type fakeStepActions struct {
        *gentype.FakeClientWithList[*v1alpha1.StepAction, *v1alpha1.StepActionList]
        Fake *FakeTektonV1alpha1
}

func newFakeStepActions(fake *FakeTektonV1alpha1, namespace string) pipelinev1alpha1.StepActionInterface <span class="cov0" title="0">{
        return &amp;fakeStepActions{
                gentype.NewFakeClientWithList[*v1alpha1.StepAction, *v1alpha1.StepActionList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("stepactions"),
                        v1alpha1.SchemeGroupVersion.WithKind("StepAction"),
                        func() *v1alpha1.StepAction </span><span class="cov0" title="0">{ return &amp;v1alpha1.StepAction{} }</span>,
                        func() *v1alpha1.StepActionList <span class="cov0" title="0">{ return &amp;v1alpha1.StepActionList{} }</span>,
                        func(dst, src *v1alpha1.StepActionList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.StepActionList) []*v1alpha1.StepAction <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1alpha1.StepActionList, items []*v1alpha1.StepAction) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file173" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeVerificationPolicies implements VerificationPolicyInterface
type fakeVerificationPolicies struct {
        *gentype.FakeClientWithList[*v1alpha1.VerificationPolicy, *v1alpha1.VerificationPolicyList]
        Fake *FakeTektonV1alpha1
}

func newFakeVerificationPolicies(fake *FakeTektonV1alpha1, namespace string) pipelinev1alpha1.VerificationPolicyInterface <span class="cov0" title="0">{
        return &amp;fakeVerificationPolicies{
                gentype.NewFakeClientWithList[*v1alpha1.VerificationPolicy, *v1alpha1.VerificationPolicyList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("verificationpolicies"),
                        v1alpha1.SchemeGroupVersion.WithKind("VerificationPolicy"),
                        func() *v1alpha1.VerificationPolicy </span><span class="cov0" title="0">{ return &amp;v1alpha1.VerificationPolicy{} }</span>,
                        func() *v1alpha1.VerificationPolicyList <span class="cov0" title="0">{ return &amp;v1alpha1.VerificationPolicyList{} }</span>,
                        func(dst, src *v1alpha1.VerificationPolicyList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.VerificationPolicyList) []*v1alpha1.VerificationPolicy <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.VerificationPolicyList, items []*v1alpha1.VerificationPolicy) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file174" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        http "net/http"

        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TektonV1alpha1Interface interface {
        RESTClient() rest.Interface
        RunsGetter
        StepActionsGetter
        VerificationPoliciesGetter
}

// TektonV1alpha1Client is used to interact with features provided by the tekton.dev group.
type TektonV1alpha1Client struct {
        restClient rest.Interface
}

func (c *TektonV1alpha1Client) Runs(namespace string) RunInterface <span class="cov0" title="0">{
        return newRuns(c, namespace)
}</span>

func (c *TektonV1alpha1Client) StepActions(namespace string) StepActionInterface <span class="cov0" title="0">{
        return newStepActions(c, namespace)
}</span>

func (c *TektonV1alpha1Client) VerificationPolicies(namespace string) VerificationPolicyInterface <span class="cov0" title="0">{
        return newVerificationPolicies(c, namespace)
}</span>

// NewForConfig creates a new TektonV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TektonV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TektonV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TektonV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TektonV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TektonV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TektonV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TektonV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *TektonV1alpha1Client <span class="cov0" title="0">{
        return &amp;TektonV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := pipelinev1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TektonV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// RunsGetter has a method to return a RunInterface.
// A group's client should implement this interface.
type RunsGetter interface {
        Runs(namespace string) RunInterface
}

// RunInterface has methods to work with Run resources.
type RunInterface interface {
        Create(ctx context.Context, run *pipelinev1alpha1.Run, opts v1.CreateOptions) (*pipelinev1alpha1.Run, error)
        Update(ctx context.Context, run *pipelinev1alpha1.Run, opts v1.UpdateOptions) (*pipelinev1alpha1.Run, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, run *pipelinev1alpha1.Run, opts v1.UpdateOptions) (*pipelinev1alpha1.Run, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1alpha1.Run, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1alpha1.RunList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1alpha1.Run, err error)
        RunExpansion
}

// runs implements RunInterface
type runs struct {
        *gentype.ClientWithList[*pipelinev1alpha1.Run, *pipelinev1alpha1.RunList]
}

// newRuns returns a Runs
func newRuns(c *TektonV1alpha1Client, namespace string) *runs <span class="cov0" title="0">{
        return &amp;runs{
                gentype.NewClientWithList[*pipelinev1alpha1.Run, *pipelinev1alpha1.RunList](
                        "runs",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1alpha1.Run </span><span class="cov0" title="0">{ return &amp;pipelinev1alpha1.Run{} }</span>,
                        func() *pipelinev1alpha1.RunList <span class="cov0" title="0">{ return &amp;pipelinev1alpha1.RunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file176" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// StepActionsGetter has a method to return a StepActionInterface.
// A group's client should implement this interface.
type StepActionsGetter interface {
        StepActions(namespace string) StepActionInterface
}

// StepActionInterface has methods to work with StepAction resources.
type StepActionInterface interface {
        Create(ctx context.Context, stepAction *pipelinev1alpha1.StepAction, opts v1.CreateOptions) (*pipelinev1alpha1.StepAction, error)
        Update(ctx context.Context, stepAction *pipelinev1alpha1.StepAction, opts v1.UpdateOptions) (*pipelinev1alpha1.StepAction, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1alpha1.StepAction, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1alpha1.StepActionList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1alpha1.StepAction, err error)
        StepActionExpansion
}

// stepActions implements StepActionInterface
type stepActions struct {
        *gentype.ClientWithList[*pipelinev1alpha1.StepAction, *pipelinev1alpha1.StepActionList]
}

// newStepActions returns a StepActions
func newStepActions(c *TektonV1alpha1Client, namespace string) *stepActions <span class="cov0" title="0">{
        return &amp;stepActions{
                gentype.NewClientWithList[*pipelinev1alpha1.StepAction, *pipelinev1alpha1.StepActionList](
                        "stepactions",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1alpha1.StepAction </span><span class="cov0" title="0">{ return &amp;pipelinev1alpha1.StepAction{} }</span>,
                        func() *pipelinev1alpha1.StepActionList <span class="cov0" title="0">{ return &amp;pipelinev1alpha1.StepActionList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file177" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// VerificationPoliciesGetter has a method to return a VerificationPolicyInterface.
// A group's client should implement this interface.
type VerificationPoliciesGetter interface {
        VerificationPolicies(namespace string) VerificationPolicyInterface
}

// VerificationPolicyInterface has methods to work with VerificationPolicy resources.
type VerificationPolicyInterface interface {
        Create(ctx context.Context, verificationPolicy *pipelinev1alpha1.VerificationPolicy, opts v1.CreateOptions) (*pipelinev1alpha1.VerificationPolicy, error)
        Update(ctx context.Context, verificationPolicy *pipelinev1alpha1.VerificationPolicy, opts v1.UpdateOptions) (*pipelinev1alpha1.VerificationPolicy, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1alpha1.VerificationPolicy, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1alpha1.VerificationPolicyList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1alpha1.VerificationPolicy, err error)
        VerificationPolicyExpansion
}

// verificationPolicies implements VerificationPolicyInterface
type verificationPolicies struct {
        *gentype.ClientWithList[*pipelinev1alpha1.VerificationPolicy, *pipelinev1alpha1.VerificationPolicyList]
}

// newVerificationPolicies returns a VerificationPolicies
func newVerificationPolicies(c *TektonV1alpha1Client, namespace string) *verificationPolicies <span class="cov0" title="0">{
        return &amp;verificationPolicies{
                gentype.NewClientWithList[*pipelinev1alpha1.VerificationPolicy, *pipelinev1alpha1.VerificationPolicyList](
                        "verificationpolicies",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1alpha1.VerificationPolicy </span><span class="cov0" title="0">{ return &amp;pipelinev1alpha1.VerificationPolicy{} }</span>,
                        func() *pipelinev1alpha1.VerificationPolicyList <span class="cov0" title="0">{ return &amp;pipelinev1alpha1.VerificationPolicyList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file178" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// CustomRunsGetter has a method to return a CustomRunInterface.
// A group's client should implement this interface.
type CustomRunsGetter interface {
        CustomRuns(namespace string) CustomRunInterface
}

// CustomRunInterface has methods to work with CustomRun resources.
type CustomRunInterface interface {
        Create(ctx context.Context, customRun *pipelinev1beta1.CustomRun, opts v1.CreateOptions) (*pipelinev1beta1.CustomRun, error)
        Update(ctx context.Context, customRun *pipelinev1beta1.CustomRun, opts v1.UpdateOptions) (*pipelinev1beta1.CustomRun, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, customRun *pipelinev1beta1.CustomRun, opts v1.UpdateOptions) (*pipelinev1beta1.CustomRun, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.CustomRun, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.CustomRunList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.CustomRun, err error)
        CustomRunExpansion
}

// customRuns implements CustomRunInterface
type customRuns struct {
        *gentype.ClientWithList[*pipelinev1beta1.CustomRun, *pipelinev1beta1.CustomRunList]
}

// newCustomRuns returns a CustomRuns
func newCustomRuns(c *TektonV1beta1Client, namespace string) *customRuns <span class="cov0" title="0">{
        return &amp;customRuns{
                gentype.NewClientWithList[*pipelinev1beta1.CustomRun, *pipelinev1beta1.CustomRunList](
                        "customruns",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.CustomRun </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.CustomRun{} }</span>,
                        func() *pipelinev1beta1.CustomRunList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.CustomRunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file179" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeCustomRuns implements CustomRunInterface
type fakeCustomRuns struct {
        *gentype.FakeClientWithList[*v1beta1.CustomRun, *v1beta1.CustomRunList]
        Fake *FakeTektonV1beta1
}

func newFakeCustomRuns(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.CustomRunInterface <span class="cov0" title="0">{
        return &amp;fakeCustomRuns{
                gentype.NewFakeClientWithList[*v1beta1.CustomRun, *v1beta1.CustomRunList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("customruns"),
                        v1beta1.SchemeGroupVersion.WithKind("CustomRun"),
                        func() *v1beta1.CustomRun </span><span class="cov0" title="0">{ return &amp;v1beta1.CustomRun{} }</span>,
                        func() *v1beta1.CustomRunList <span class="cov0" title="0">{ return &amp;v1beta1.CustomRunList{} }</span>,
                        func(dst, src *v1beta1.CustomRunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.CustomRunList) []*v1beta1.CustomRun <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.CustomRunList, items []*v1beta1.CustomRun) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file180" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakePipelines implements PipelineInterface
type fakePipelines struct {
        *gentype.FakeClientWithList[*v1beta1.Pipeline, *v1beta1.PipelineList]
        Fake *FakeTektonV1beta1
}

func newFakePipelines(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.PipelineInterface <span class="cov0" title="0">{
        return &amp;fakePipelines{
                gentype.NewFakeClientWithList[*v1beta1.Pipeline, *v1beta1.PipelineList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("pipelines"),
                        v1beta1.SchemeGroupVersion.WithKind("Pipeline"),
                        func() *v1beta1.Pipeline </span><span class="cov0" title="0">{ return &amp;v1beta1.Pipeline{} }</span>,
                        func() *v1beta1.PipelineList <span class="cov0" title="0">{ return &amp;v1beta1.PipelineList{} }</span>,
                        func(dst, src *v1beta1.PipelineList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.PipelineList) []*v1beta1.Pipeline <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.PipelineList, items []*v1beta1.Pipeline) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file181" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTektonV1beta1 struct {
        *testing.Fake
}

func (c *FakeTektonV1beta1) CustomRuns(namespace string) v1beta1.CustomRunInterface <span class="cov0" title="0">{
        return newFakeCustomRuns(c, namespace)
}</span>

func (c *FakeTektonV1beta1) Pipelines(namespace string) v1beta1.PipelineInterface <span class="cov0" title="0">{
        return newFakePipelines(c, namespace)
}</span>

func (c *FakeTektonV1beta1) PipelineRuns(namespace string) v1beta1.PipelineRunInterface <span class="cov0" title="0">{
        return newFakePipelineRuns(c, namespace)
}</span>

func (c *FakeTektonV1beta1) StepActions(namespace string) v1beta1.StepActionInterface <span class="cov0" title="0">{
        return newFakeStepActions(c, namespace)
}</span>

func (c *FakeTektonV1beta1) Tasks(namespace string) v1beta1.TaskInterface <span class="cov0" title="0">{
        return newFakeTasks(c, namespace)
}</span>

func (c *FakeTektonV1beta1) TaskRuns(namespace string) v1beta1.TaskRunInterface <span class="cov0" title="0">{
        return newFakeTaskRuns(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTektonV1beta1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakePipelineRuns implements PipelineRunInterface
type fakePipelineRuns struct {
        *gentype.FakeClientWithList[*v1beta1.PipelineRun, *v1beta1.PipelineRunList]
        Fake *FakeTektonV1beta1
}

func newFakePipelineRuns(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.PipelineRunInterface <span class="cov0" title="0">{
        return &amp;fakePipelineRuns{
                gentype.NewFakeClientWithList[*v1beta1.PipelineRun, *v1beta1.PipelineRunList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("pipelineruns"),
                        v1beta1.SchemeGroupVersion.WithKind("PipelineRun"),
                        func() *v1beta1.PipelineRun </span><span class="cov0" title="0">{ return &amp;v1beta1.PipelineRun{} }</span>,
                        func() *v1beta1.PipelineRunList <span class="cov0" title="0">{ return &amp;v1beta1.PipelineRunList{} }</span>,
                        func(dst, src *v1beta1.PipelineRunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.PipelineRunList) []*v1beta1.PipelineRun <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.PipelineRunList, items []*v1beta1.PipelineRun) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file183" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeStepActions implements StepActionInterface
type fakeStepActions struct {
        *gentype.FakeClientWithList[*v1beta1.StepAction, *v1beta1.StepActionList]
        Fake *FakeTektonV1beta1
}

func newFakeStepActions(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.StepActionInterface <span class="cov0" title="0">{
        return &amp;fakeStepActions{
                gentype.NewFakeClientWithList[*v1beta1.StepAction, *v1beta1.StepActionList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("stepactions"),
                        v1beta1.SchemeGroupVersion.WithKind("StepAction"),
                        func() *v1beta1.StepAction </span><span class="cov0" title="0">{ return &amp;v1beta1.StepAction{} }</span>,
                        func() *v1beta1.StepActionList <span class="cov0" title="0">{ return &amp;v1beta1.StepActionList{} }</span>,
                        func(dst, src *v1beta1.StepActionList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.StepActionList) []*v1beta1.StepAction <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.StepActionList, items []*v1beta1.StepAction) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file184" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTasks implements TaskInterface
type fakeTasks struct {
        *gentype.FakeClientWithList[*v1beta1.Task, *v1beta1.TaskList]
        Fake *FakeTektonV1beta1
}

func newFakeTasks(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.TaskInterface <span class="cov0" title="0">{
        return &amp;fakeTasks{
                gentype.NewFakeClientWithList[*v1beta1.Task, *v1beta1.TaskList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("tasks"),
                        v1beta1.SchemeGroupVersion.WithKind("Task"),
                        func() *v1beta1.Task </span><span class="cov0" title="0">{ return &amp;v1beta1.Task{} }</span>,
                        func() *v1beta1.TaskList <span class="cov0" title="0">{ return &amp;v1beta1.TaskList{} }</span>,
                        func(dst, src *v1beta1.TaskList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.TaskList) []*v1beta1.Task <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.TaskList, items []*v1beta1.Task) <span class="cov0" title="0">{ list.Items = gentype.FromPointerSlice(items) }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file185" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTaskRuns implements TaskRunInterface
type fakeTaskRuns struct {
        *gentype.FakeClientWithList[*v1beta1.TaskRun, *v1beta1.TaskRunList]
        Fake *FakeTektonV1beta1
}

func newFakeTaskRuns(fake *FakeTektonV1beta1, namespace string) pipelinev1beta1.TaskRunInterface <span class="cov0" title="0">{
        return &amp;fakeTaskRuns{
                gentype.NewFakeClientWithList[*v1beta1.TaskRun, *v1beta1.TaskRunList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("taskruns"),
                        v1beta1.SchemeGroupVersion.WithKind("TaskRun"),
                        func() *v1beta1.TaskRun </span><span class="cov0" title="0">{ return &amp;v1beta1.TaskRun{} }</span>,
                        func() *v1beta1.TaskRunList <span class="cov0" title="0">{ return &amp;v1beta1.TaskRunList{} }</span>,
                        func(dst, src *v1beta1.TaskRunList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.TaskRunList) []*v1beta1.TaskRun <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.TaskRunList, items []*v1beta1.TaskRun) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file186" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// PipelinesGetter has a method to return a PipelineInterface.
// A group's client should implement this interface.
type PipelinesGetter interface {
        Pipelines(namespace string) PipelineInterface
}

// PipelineInterface has methods to work with Pipeline resources.
type PipelineInterface interface {
        Create(ctx context.Context, pipeline *pipelinev1beta1.Pipeline, opts v1.CreateOptions) (*pipelinev1beta1.Pipeline, error)
        Update(ctx context.Context, pipeline *pipelinev1beta1.Pipeline, opts v1.UpdateOptions) (*pipelinev1beta1.Pipeline, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.Pipeline, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.PipelineList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.Pipeline, err error)
        PipelineExpansion
}

// pipelines implements PipelineInterface
type pipelines struct {
        *gentype.ClientWithList[*pipelinev1beta1.Pipeline, *pipelinev1beta1.PipelineList]
}

// newPipelines returns a Pipelines
func newPipelines(c *TektonV1beta1Client, namespace string) *pipelines <span class="cov0" title="0">{
        return &amp;pipelines{
                gentype.NewClientWithList[*pipelinev1beta1.Pipeline, *pipelinev1beta1.PipelineList](
                        "pipelines",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.Pipeline </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.Pipeline{} }</span>,
                        func() *pipelinev1beta1.PipelineList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.PipelineList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file187" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        http "net/http"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TektonV1beta1Interface interface {
        RESTClient() rest.Interface
        CustomRunsGetter
        PipelinesGetter
        PipelineRunsGetter
        StepActionsGetter
        TasksGetter
        TaskRunsGetter
}

// TektonV1beta1Client is used to interact with features provided by the tekton.dev group.
type TektonV1beta1Client struct {
        restClient rest.Interface
}

func (c *TektonV1beta1Client) CustomRuns(namespace string) CustomRunInterface <span class="cov0" title="0">{
        return newCustomRuns(c, namespace)
}</span>

func (c *TektonV1beta1Client) Pipelines(namespace string) PipelineInterface <span class="cov0" title="0">{
        return newPipelines(c, namespace)
}</span>

func (c *TektonV1beta1Client) PipelineRuns(namespace string) PipelineRunInterface <span class="cov0" title="0">{
        return newPipelineRuns(c, namespace)
}</span>

func (c *TektonV1beta1Client) StepActions(namespace string) StepActionInterface <span class="cov0" title="0">{
        return newStepActions(c, namespace)
}</span>

func (c *TektonV1beta1Client) Tasks(namespace string) TaskInterface <span class="cov0" title="0">{
        return newTasks(c, namespace)
}</span>

func (c *TektonV1beta1Client) TaskRuns(namespace string) TaskRunInterface <span class="cov0" title="0">{
        return newTaskRuns(c, namespace)
}</span>

// NewForConfig creates a new TektonV1beta1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TektonV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TektonV1beta1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TektonV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TektonV1beta1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TektonV1beta1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TektonV1beta1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TektonV1beta1Client for the given RESTClient.
func New(c rest.Interface) *TektonV1beta1Client <span class="cov0" title="0">{
        return &amp;TektonV1beta1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := pipelinev1beta1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TektonV1beta1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// PipelineRunsGetter has a method to return a PipelineRunInterface.
// A group's client should implement this interface.
type PipelineRunsGetter interface {
        PipelineRuns(namespace string) PipelineRunInterface
}

// PipelineRunInterface has methods to work with PipelineRun resources.
type PipelineRunInterface interface {
        Create(ctx context.Context, pipelineRun *pipelinev1beta1.PipelineRun, opts v1.CreateOptions) (*pipelinev1beta1.PipelineRun, error)
        Update(ctx context.Context, pipelineRun *pipelinev1beta1.PipelineRun, opts v1.UpdateOptions) (*pipelinev1beta1.PipelineRun, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, pipelineRun *pipelinev1beta1.PipelineRun, opts v1.UpdateOptions) (*pipelinev1beta1.PipelineRun, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.PipelineRun, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.PipelineRunList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.PipelineRun, err error)
        PipelineRunExpansion
}

// pipelineRuns implements PipelineRunInterface
type pipelineRuns struct {
        *gentype.ClientWithList[*pipelinev1beta1.PipelineRun, *pipelinev1beta1.PipelineRunList]
}

// newPipelineRuns returns a PipelineRuns
func newPipelineRuns(c *TektonV1beta1Client, namespace string) *pipelineRuns <span class="cov0" title="0">{
        return &amp;pipelineRuns{
                gentype.NewClientWithList[*pipelinev1beta1.PipelineRun, *pipelinev1beta1.PipelineRunList](
                        "pipelineruns",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.PipelineRun </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.PipelineRun{} }</span>,
                        func() *pipelinev1beta1.PipelineRunList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.PipelineRunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file189" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// StepActionsGetter has a method to return a StepActionInterface.
// A group's client should implement this interface.
type StepActionsGetter interface {
        StepActions(namespace string) StepActionInterface
}

// StepActionInterface has methods to work with StepAction resources.
type StepActionInterface interface {
        Create(ctx context.Context, stepAction *pipelinev1beta1.StepAction, opts v1.CreateOptions) (*pipelinev1beta1.StepAction, error)
        Update(ctx context.Context, stepAction *pipelinev1beta1.StepAction, opts v1.UpdateOptions) (*pipelinev1beta1.StepAction, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.StepAction, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.StepActionList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.StepAction, err error)
        StepActionExpansion
}

// stepActions implements StepActionInterface
type stepActions struct {
        *gentype.ClientWithList[*pipelinev1beta1.StepAction, *pipelinev1beta1.StepActionList]
}

// newStepActions returns a StepActions
func newStepActions(c *TektonV1beta1Client, namespace string) *stepActions <span class="cov0" title="0">{
        return &amp;stepActions{
                gentype.NewClientWithList[*pipelinev1beta1.StepAction, *pipelinev1beta1.StepActionList](
                        "stepactions",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.StepAction </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.StepAction{} }</span>,
                        func() *pipelinev1beta1.StepActionList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.StepActionList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file190" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TasksGetter has a method to return a TaskInterface.
// A group's client should implement this interface.
type TasksGetter interface {
        Tasks(namespace string) TaskInterface
}

// TaskInterface has methods to work with Task resources.
type TaskInterface interface {
        Create(ctx context.Context, task *pipelinev1beta1.Task, opts v1.CreateOptions) (*pipelinev1beta1.Task, error)
        Update(ctx context.Context, task *pipelinev1beta1.Task, opts v1.UpdateOptions) (*pipelinev1beta1.Task, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.Task, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.TaskList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.Task, err error)
        TaskExpansion
}

// tasks implements TaskInterface
type tasks struct {
        *gentype.ClientWithList[*pipelinev1beta1.Task, *pipelinev1beta1.TaskList]
}

// newTasks returns a Tasks
func newTasks(c *TektonV1beta1Client, namespace string) *tasks <span class="cov0" title="0">{
        return &amp;tasks{
                gentype.NewClientWithList[*pipelinev1beta1.Task, *pipelinev1beta1.TaskList](
                        "tasks",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.Task </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.Task{} }</span>,
                        func() *pipelinev1beta1.TaskList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.TaskList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file191" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TaskRunsGetter has a method to return a TaskRunInterface.
// A group's client should implement this interface.
type TaskRunsGetter interface {
        TaskRuns(namespace string) TaskRunInterface
}

// TaskRunInterface has methods to work with TaskRun resources.
type TaskRunInterface interface {
        Create(ctx context.Context, taskRun *pipelinev1beta1.TaskRun, opts v1.CreateOptions) (*pipelinev1beta1.TaskRun, error)
        Update(ctx context.Context, taskRun *pipelinev1beta1.TaskRun, opts v1.UpdateOptions) (*pipelinev1beta1.TaskRun, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, taskRun *pipelinev1beta1.TaskRun, opts v1.UpdateOptions) (*pipelinev1beta1.TaskRun, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*pipelinev1beta1.TaskRun, error)
        List(ctx context.Context, opts v1.ListOptions) (*pipelinev1beta1.TaskRunList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *pipelinev1beta1.TaskRun, err error)
        TaskRunExpansion
}

// taskRuns implements TaskRunInterface
type taskRuns struct {
        *gentype.ClientWithList[*pipelinev1beta1.TaskRun, *pipelinev1beta1.TaskRunList]
}

// newTaskRuns returns a TaskRuns
func newTaskRuns(c *TektonV1beta1Client, namespace string) *taskRuns <span class="cov0" title="0">{
        return &amp;taskRuns{
                gentype.NewClientWithList[*pipelinev1beta1.TaskRun, *pipelinev1beta1.TaskRunList](
                        "taskruns",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *pipelinev1beta1.TaskRun </span><span class="cov0" title="0">{ return &amp;pipelinev1beta1.TaskRun{} }</span>,
                        func() *pipelinev1beta1.TaskRunList <span class="cov0" title="0">{ return &amp;pipelinev1beta1.TaskRunList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file192" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipeline "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Tekton() pipeline.Interface
}

func (f *sharedInformerFactory) Tekton() pipeline.Interface <span class="cov0" title="0">{
        return pipeline.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file193" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=tekton.dev, Version=v1
        case v1.SchemeGroupVersion.WithResource("pipelines"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1().Pipelines().Informer()}, nil</span>
        case v1.SchemeGroupVersion.WithResource("pipelineruns"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1().PipelineRuns().Informer()}, nil</span>
        case v1.SchemeGroupVersion.WithResource("tasks"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1().Tasks().Informer()}, nil</span>
        case v1.SchemeGroupVersion.WithResource("taskruns"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1().TaskRuns().Informer()}, nil</span>

                // Group=tekton.dev, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("runs"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1alpha1().Runs().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("stepactions"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1alpha1().StepActions().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("verificationpolicies"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1alpha1().VerificationPolicies().Informer()}, nil</span>

                // Group=tekton.dev, Version=v1beta1
        case v1beta1.SchemeGroupVersion.WithResource("customruns"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().CustomRuns().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("pipelines"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().Pipelines().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("pipelineruns"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().PipelineRuns().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("stepactions"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().StepActions().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("tasks"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().Tasks().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("taskruns"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1beta1().TaskRuns().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package pipeline

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1 provides access to shared informers for resources in V1.
        V1() v1.Interface
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
        // V1beta1 provides access to shared informers for resources in V1beta1.
        V1beta1() v1beta1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1 returns a new v1.Interface.
func (g *group) V1() v1.Interface <span class="cov0" title="0">{
        return v1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>

// V1beta1 returns a new v1beta1.Interface.
func (g *group) V1beta1() v1beta1.Interface <span class="cov0" title="0">{
        return v1beta1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // Pipelines returns a PipelineInformer.
        Pipelines() PipelineInformer
        // PipelineRuns returns a PipelineRunInformer.
        PipelineRuns() PipelineRunInformer
        // Tasks returns a TaskInformer.
        Tasks() TaskInformer
        // TaskRuns returns a TaskRunInformer.
        TaskRuns() TaskRunInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// Pipelines returns a PipelineInformer.
func (v *version) Pipelines() PipelineInformer <span class="cov0" title="0">{
        return &amp;pipelineInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// PipelineRuns returns a PipelineRunInformer.
func (v *version) PipelineRuns() PipelineRunInformer <span class="cov0" title="0">{
        return &amp;pipelineRunInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Tasks returns a TaskInformer.
func (v *version) Tasks() TaskInformer <span class="cov0" title="0">{
        return &amp;taskInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TaskRuns returns a TaskRunInformer.
func (v *version) TaskRuns() TaskRunInformer <span class="cov0" title="0">{
        return &amp;taskRunInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1

import (
        context "context"
        time "time"

        apispipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineInformer provides access to a shared informer and lister for
// Pipelines.
type PipelineInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1.PipelineLister
}

type pipelineInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewPipelineInformer constructs a new informer for Pipeline type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewPipelineInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredPipelineInformer constructs a new informer for Pipeline type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredPipelineInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().Pipelines(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().Pipelines(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1.Pipeline{},
                resyncPeriod,
                indexers,
        )
}

func (f *pipelineInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *pipelineInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1.Pipeline{}, f.defaultInformer)
}</span>

func (f *pipelineInformer) Lister() pipelinev1.PipelineLister <span class="cov0" title="0">{
        return pipelinev1.NewPipelineLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file197" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1

import (
        context "context"
        time "time"

        apispipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineRunInformer provides access to a shared informer and lister for
// PipelineRuns.
type PipelineRunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1.PipelineRunLister
}

type pipelineRunInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewPipelineRunInformer constructs a new informer for PipelineRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewPipelineRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredPipelineRunInformer constructs a new informer for PipelineRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredPipelineRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().PipelineRuns(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().PipelineRuns(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1.PipelineRun{},
                resyncPeriod,
                indexers,
        )
}

func (f *pipelineRunInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *pipelineRunInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1.PipelineRun{}, f.defaultInformer)
}</span>

func (f *pipelineRunInformer) Lister() pipelinev1.PipelineRunLister <span class="cov0" title="0">{
        return pipelinev1.NewPipelineRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file198" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1

import (
        context "context"
        time "time"

        apispipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TaskInformer provides access to a shared informer and lister for
// Tasks.
type TaskInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1.TaskLister
}

type taskInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTaskInformer constructs a new informer for Task type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTaskInformer constructs a new informer for Task type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().Tasks(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().Tasks(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1.Task{},
                resyncPeriod,
                indexers,
        )
}

func (f *taskInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *taskInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1.Task{}, f.defaultInformer)
}</span>

func (f *taskInformer) Lister() pipelinev1.TaskLister <span class="cov0" title="0">{
        return pipelinev1.NewTaskLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1

import (
        context "context"
        time "time"

        apispipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TaskRunInformer provides access to a shared informer and lister for
// TaskRuns.
type TaskRunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1.TaskRunLister
}

type taskRunInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTaskRunInformer constructs a new informer for TaskRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTaskRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTaskRunInformer constructs a new informer for TaskRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTaskRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().TaskRuns(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1().TaskRuns(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1.TaskRun{},
                resyncPeriod,
                indexers,
        )
}

func (f *taskRunInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *taskRunInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1.TaskRun{}, f.defaultInformer)
}</span>

func (f *taskRunInformer) Lister() pipelinev1.TaskRunLister <span class="cov0" title="0">{
        return pipelinev1.NewTaskRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file200" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // Runs returns a RunInformer.
        Runs() RunInformer
        // StepActions returns a StepActionInformer.
        StepActions() StepActionInformer
        // VerificationPolicies returns a VerificationPolicyInformer.
        VerificationPolicies() VerificationPolicyInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// Runs returns a RunInformer.
func (v *version) Runs() RunInformer <span class="cov0" title="0">{
        return &amp;runInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// StepActions returns a StepActionInformer.
func (v *version) StepActions() StepActionInformer <span class="cov0" title="0">{
        return &amp;stepActionInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// VerificationPolicies returns a VerificationPolicyInformer.
func (v *version) VerificationPolicies() VerificationPolicyInformer <span class="cov0" title="0">{
        return &amp;verificationPolicyInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file201" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apispipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// RunInformer provides access to a shared informer and lister for
// Runs.
type RunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1alpha1.RunLister
}

type runInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewRunInformer constructs a new informer for Run type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredRunInformer constructs a new informer for Run type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().Runs(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().Runs(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1alpha1.Run{},
                resyncPeriod,
                indexers,
        )
}

func (f *runInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *runInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1alpha1.Run{}, f.defaultInformer)
}</span>

func (f *runInformer) Lister() pipelinev1alpha1.RunLister <span class="cov0" title="0">{
        return pipelinev1alpha1.NewRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apispipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// StepActionInformer provides access to a shared informer and lister for
// StepActions.
type StepActionInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1alpha1.StepActionLister
}

type stepActionInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewStepActionInformer constructs a new informer for StepAction type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewStepActionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredStepActionInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredStepActionInformer constructs a new informer for StepAction type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredStepActionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().StepActions(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().StepActions(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1alpha1.StepAction{},
                resyncPeriod,
                indexers,
        )
}

func (f *stepActionInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredStepActionInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *stepActionInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1alpha1.StepAction{}, f.defaultInformer)
}</span>

func (f *stepActionInformer) Lister() pipelinev1alpha1.StepActionLister <span class="cov0" title="0">{
        return pipelinev1alpha1.NewStepActionLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file203" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apispipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// VerificationPolicyInformer provides access to a shared informer and lister for
// VerificationPolicies.
type VerificationPolicyInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1alpha1.VerificationPolicyLister
}

type verificationPolicyInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewVerificationPolicyInformer constructs a new informer for VerificationPolicy type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewVerificationPolicyInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredVerificationPolicyInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredVerificationPolicyInformer constructs a new informer for VerificationPolicy type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredVerificationPolicyInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().VerificationPolicies(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().VerificationPolicies(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1alpha1.VerificationPolicy{},
                resyncPeriod,
                indexers,
        )
}

func (f *verificationPolicyInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredVerificationPolicyInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *verificationPolicyInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1alpha1.VerificationPolicy{}, f.defaultInformer)
}</span>

func (f *verificationPolicyInformer) Lister() pipelinev1alpha1.VerificationPolicyLister <span class="cov0" title="0">{
        return pipelinev1alpha1.NewVerificationPolicyLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file204" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// CustomRunInformer provides access to a shared informer and lister for
// CustomRuns.
type CustomRunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.CustomRunLister
}

type customRunInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewCustomRunInformer constructs a new informer for CustomRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewCustomRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredCustomRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredCustomRunInformer constructs a new informer for CustomRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredCustomRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().CustomRuns(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().CustomRuns(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.CustomRun{},
                resyncPeriod,
                indexers,
        )
}

func (f *customRunInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredCustomRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *customRunInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.CustomRun{}, f.defaultInformer)
}</span>

func (f *customRunInformer) Lister() pipelinev1beta1.CustomRunLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewCustomRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file205" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // CustomRuns returns a CustomRunInformer.
        CustomRuns() CustomRunInformer
        // Pipelines returns a PipelineInformer.
        Pipelines() PipelineInformer
        // PipelineRuns returns a PipelineRunInformer.
        PipelineRuns() PipelineRunInformer
        // StepActions returns a StepActionInformer.
        StepActions() StepActionInformer
        // Tasks returns a TaskInformer.
        Tasks() TaskInformer
        // TaskRuns returns a TaskRunInformer.
        TaskRuns() TaskRunInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// CustomRuns returns a CustomRunInformer.
func (v *version) CustomRuns() CustomRunInformer <span class="cov0" title="0">{
        return &amp;customRunInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Pipelines returns a PipelineInformer.
func (v *version) Pipelines() PipelineInformer <span class="cov0" title="0">{
        return &amp;pipelineInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// PipelineRuns returns a PipelineRunInformer.
func (v *version) PipelineRuns() PipelineRunInformer <span class="cov0" title="0">{
        return &amp;pipelineRunInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// StepActions returns a StepActionInformer.
func (v *version) StepActions() StepActionInformer <span class="cov0" title="0">{
        return &amp;stepActionInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Tasks returns a TaskInformer.
func (v *version) Tasks() TaskInformer <span class="cov0" title="0">{
        return &amp;taskInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TaskRuns returns a TaskRunInformer.
func (v *version) TaskRuns() TaskRunInformer <span class="cov0" title="0">{
        return &amp;taskRunInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineInformer provides access to a shared informer and lister for
// Pipelines.
type PipelineInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.PipelineLister
}

type pipelineInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewPipelineInformer constructs a new informer for Pipeline type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewPipelineInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredPipelineInformer constructs a new informer for Pipeline type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredPipelineInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().Pipelines(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().Pipelines(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.Pipeline{},
                resyncPeriod,
                indexers,
        )
}

func (f *pipelineInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *pipelineInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.Pipeline{}, f.defaultInformer)
}</span>

func (f *pipelineInformer) Lister() pipelinev1beta1.PipelineLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewPipelineLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file207" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineRunInformer provides access to a shared informer and lister for
// PipelineRuns.
type PipelineRunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.PipelineRunLister
}

type pipelineRunInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewPipelineRunInformer constructs a new informer for PipelineRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewPipelineRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredPipelineRunInformer constructs a new informer for PipelineRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredPipelineRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().PipelineRuns(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().PipelineRuns(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.PipelineRun{},
                resyncPeriod,
                indexers,
        )
}

func (f *pipelineRunInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *pipelineRunInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.PipelineRun{}, f.defaultInformer)
}</span>

func (f *pipelineRunInformer) Lister() pipelinev1beta1.PipelineRunLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewPipelineRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// StepActionInformer provides access to a shared informer and lister for
// StepActions.
type StepActionInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.StepActionLister
}

type stepActionInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewStepActionInformer constructs a new informer for StepAction type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewStepActionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredStepActionInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredStepActionInformer constructs a new informer for StepAction type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredStepActionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().StepActions(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().StepActions(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.StepAction{},
                resyncPeriod,
                indexers,
        )
}

func (f *stepActionInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredStepActionInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *stepActionInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.StepAction{}, f.defaultInformer)
}</span>

func (f *stepActionInformer) Lister() pipelinev1beta1.StepActionLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewStepActionLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file209" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TaskInformer provides access to a shared informer and lister for
// Tasks.
type TaskInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.TaskLister
}

type taskInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTaskInformer constructs a new informer for Task type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTaskInformer constructs a new informer for Task type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().Tasks(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().Tasks(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.Task{},
                resyncPeriod,
                indexers,
        )
}

func (f *taskInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *taskInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.Task{}, f.defaultInformer)
}</span>

func (f *taskInformer) Lister() pipelinev1beta1.TaskLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewTaskLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apispipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/internalinterfaces"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TaskRunInformer provides access to a shared informer and lister for
// TaskRuns.
type TaskRunInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() pipelinev1beta1.TaskRunLister
}

type taskRunInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTaskRunInformer constructs a new informer for TaskRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTaskRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskRunInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTaskRunInformer constructs a new informer for TaskRun type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTaskRunInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().TaskRuns(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1beta1().TaskRuns(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apispipelinev1beta1.TaskRun{},
                resyncPeriod,
                indexers,
        )
}

func (f *taskRunInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTaskRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *taskRunInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apispipelinev1beta1.TaskRun{}, f.defaultInformer)
}</span>

func (f *taskRunInformer) Lister() pipelinev1beta1.TaskRunLister <span class="cov0" title="0">{
        return pipelinev1beta1.NewTaskRunLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file211" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
        context "context"

        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterClient(withClientFromConfig)
        injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}</span>

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                if injection.GetConfig(ctx) == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
                }</span> else<span class="cov0" title="0"> {
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/clientset/versioned.Interface from context.")
                }</span>
        }
        <span class="cov0" title="0">return untyped.(versioned.Interface)</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/fake"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        runtime "k8s.io/apimachinery/pkg/runtime"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(withClient)
        injection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

func withClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        ctx, _ = With(ctx)
        return ctx
}</span>

func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) <span class="cov0" title="0">{
        cs := fake.NewSimpleClientset(objects...)
        return context.WithValue(ctx, client.Key{}, cs), cs
}</span>

// Get extracts the Kubernetes client from the context.
func Get(ctx context.Context) *fake.Clientset <span class="cov0" title="0">{
        untyped := ctx.Value(client.Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/clientset/versioned/fake.Clientset from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*fake.Clientset)</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package factory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions.SharedInformerFactory from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/injection/client/fake"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = factory.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, factory.Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}
</pre>
		
		<pre class="file" id="file215" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fakeFilteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/injection/client/fake"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, filtered.Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file216" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct {
        Selector string
}

type LabelKey struct{}

func WithSelectors(ctx context.Context, selector ...string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LabelKey{}, selector)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        untyped := ctx.Value(LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions.SharedInformerFactory with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        pipeline "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = pipeline.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1().Pipelines()
        return context.WithValue(ctx, pipeline.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1().Pipelines()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1().Pipelines()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1.PipelineInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.PipelineInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1.PipelineInformer)</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1().Pipelines()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1.PipelineInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.PipelineInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1.PipelineInformer)</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        pipelinerun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = pipelinerun.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1().PipelineRuns()
        return context.WithValue(ctx, pipelinerun.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file222" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1().PipelineRuns()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1().PipelineRuns()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1.PipelineRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.PipelineRunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1.PipelineRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file224" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1().PipelineRuns()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1.PipelineRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.PipelineRunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1.PipelineRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file225" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        task "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = task.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1().Tasks()
        return context.WithValue(ctx, task.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file226" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1().Tasks()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file227" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1().Tasks()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1.TaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.TaskInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1.TaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1().Tasks()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1.TaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.TaskInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1.TaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        taskrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = taskrun.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1().TaskRuns()
        return context.WithValue(ctx, taskrun.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file230" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1().TaskRuns()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file231" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1().TaskRuns()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1.TaskRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.TaskRunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1.TaskRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"

        v1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1().TaskRuns()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1.TaskRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1.TaskRunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1.TaskRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        run "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = run.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1alpha1().Runs()
        return context.WithValue(ctx, run.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file234" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().Runs()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file235" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().Runs()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.RunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.RunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.RunInformer)</span>
}
</pre>
		
		<pre class="file" id="file236" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package run

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1alpha1().Runs()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.RunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.RunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.RunInformer)</span>
}
</pre>
		
		<pre class="file" id="file237" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        stepaction "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = stepaction.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1alpha1().StepActions()
        return context.WithValue(ctx, stepaction.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file238" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().StepActions()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().StepActions()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.StepActionInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.StepActionInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.StepActionInformer)</span>
}
</pre>
		
		<pre class="file" id="file240" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1alpha1().StepActions()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.StepActionInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.StepActionInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.StepActionInformer)</span>
}
</pre>
		
		<pre class="file" id="file241" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        verificationpolicy "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = verificationpolicy.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1alpha1().VerificationPolicies()
        return context.WithValue(ctx, verificationpolicy.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file242" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().VerificationPolicies()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file243" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().VerificationPolicies()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.VerificationPolicyInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.VerificationPolicyInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.VerificationPolicyInformer)</span>
}
</pre>
		
		<pre class="file" id="file244" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package verificationpolicy

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1alpha1().VerificationPolicies()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.VerificationPolicyInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1.VerificationPolicyInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.VerificationPolicyInformer)</span>
}
</pre>
		
		<pre class="file" id="file245" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package customrun

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().CustomRuns()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.CustomRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.CustomRunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.CustomRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        customrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = customrun.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().CustomRuns()
        return context.WithValue(ctx, customrun.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file247" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().CustomRuns()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.CustomRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.CustomRunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.CustomRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().CustomRuns()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file249" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        pipeline "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = pipeline.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().Pipelines()
        return context.WithValue(ctx, pipeline.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file250" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().Pipelines()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file251" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().Pipelines()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.PipelineInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.PipelineInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.PipelineInformer)</span>
}
</pre>
		
		<pre class="file" id="file252" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().Pipelines()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.PipelineInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.PipelineInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.PipelineInformer)</span>
}
</pre>
		
		<pre class="file" id="file253" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        pipelinerun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = pipelinerun.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().PipelineRuns()
        return context.WithValue(ctx, pipelinerun.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file254" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().PipelineRuns()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file255" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().PipelineRuns()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.PipelineRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.PipelineRunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.PipelineRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file256" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().PipelineRuns()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.PipelineRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.PipelineRunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.PipelineRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file257" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        stepaction "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = stepaction.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().StepActions()
        return context.WithValue(ctx, stepaction.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file258" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().StepActions()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file259" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().StepActions()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.StepActionInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.StepActionInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.StepActionInformer)</span>
}
</pre>
		
		<pre class="file" id="file260" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().StepActions()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.StepActionInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.StepActionInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.StepActionInformer)</span>
}
</pre>
		
		<pre class="file" id="file261" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        task "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = task.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().Tasks()
        return context.WithValue(ctx, task.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file262" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().Tasks()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file263" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().Tasks()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.TaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.TaskInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file264" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().Tasks()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.TaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.TaskInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/fake"
        taskrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = taskrun.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1beta1().TaskRuns()
        return context.WithValue(ctx, taskrun.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file266" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().TaskRuns()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file267" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1beta1().TaskRuns()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.TaskRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.TaskRunInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TaskRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file268" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1beta1().TaskRuns()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.TaskRunInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1.TaskRunInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TaskRunInformer)</span>
}
</pre>
		
		<pre class="file" id="file269" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipeline "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "pipeline-controller"
        defaultFinalizerName       = "pipelines.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">pipelineInformer := pipeline.Get(ctx)

        lister := pipelineInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.Pipeline"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file270" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.Pipeline.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1.Pipeline. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1.Pipeline) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1.Pipeline.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1.Pipeline. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1.Pipeline) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.Pipeline if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1.Pipeline.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1.Pipeline) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1.Pipeline) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1.Pipeline resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1.PipelineLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1.PipelineLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Pipelines(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, corev1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1.Pipeline, desiredFinalizers sets.Set[string]) (*v1.Pipeline, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1().Pipelines(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, corev1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1.Pipeline) (*v1.Pipeline, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1.Pipeline, reconcileEvent reconciler.Event) (*v1.Pipeline, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == corev1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file271" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1.Pipeline) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file272" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelinerun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "pipelinerun-controller"
        defaultFinalizerName       = "pipelineruns.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">pipelinerunInformer := pipelinerun.Get(ctx)

        lister := pipelinerunInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.PipelineRun"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file273" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        corev1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.PipelineRun.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1.PipelineRun. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1.PipelineRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1.PipelineRun.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1.PipelineRun. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1.PipelineRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.PipelineRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1.PipelineRun.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1.PipelineRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1.PipelineRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1.PipelineRun resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1.PipelineRunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1.PipelineRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.PipelineRuns(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, corev1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, corev1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1.PipelineRun, desired *v1.PipelineRun) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1().PipelineRuns(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1().PipelineRuns(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1.PipelineRun, desiredFinalizers sets.Set[string]) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1().PipelineRuns(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, corev1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1.PipelineRun) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1.PipelineRun, reconcileEvent reconciler.Event) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == corev1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file274" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1.PipelineRun) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file275" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        task "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "task-controller"
        defaultFinalizerName       = "tasks.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">taskInformer := task.Get(ctx)

        lister := taskInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.Task"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file276" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.Task.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1.Task. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1.Task) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1.Task.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1.Task. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1.Task) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.Task if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1.Task.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1.Task) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1.Task) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1.Task resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1.TaskLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1.TaskLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Tasks(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, corev1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1.Task, desiredFinalizers sets.Set[string]) (*v1.Task, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1().Tasks(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, corev1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1.Task) (*v1.Task, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1.Task, reconcileEvent reconciler.Event) (*v1.Task, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == corev1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file277" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1.Task) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file278" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "taskrun-controller"
        defaultFinalizerName       = "taskruns.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">taskrunInformer := taskrun.Get(ctx)

        lister := taskrunInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.TaskRun"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file279" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        corev1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.TaskRun.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1.TaskRun. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1.TaskRun.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1.TaskRun. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.TaskRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1.TaskRun.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1.TaskRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1.TaskRun resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1.TaskRunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1.TaskRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.TaskRuns(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, corev1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, corev1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1.TaskRun, desired *v1.TaskRun) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1().TaskRuns(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1().TaskRuns(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1.TaskRun, desiredFinalizers sets.Set[string]) (*v1.TaskRun, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1().TaskRuns(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, corev1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1.TaskRun, reconcileEvent reconciler.Event) (*v1.TaskRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == corev1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file280" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        fmt "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1.TaskRun) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file281" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package run

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        run "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/run"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "run-controller"
        defaultFinalizerName       = "runs.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">runInformer := run.Get(ctx)

        lister := runInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.Run"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file282" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package run

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.Run.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.Run. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.Run) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.Run.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.Run. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.Run) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.Run if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.Run.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.Run) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.Run) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.Run resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1alpha1.RunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1alpha1.RunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Runs(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                <span class="cov0" title="0">if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PreProcessReconcile(ctx, resource)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)

                if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PostProcessReconcile(ctx, resource, original)
                }</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.Run, desired *v1alpha1.Run) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1alpha1().Runs(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1alpha1().Runs(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.Run, desiredFinalizers sets.Set[string]) (*v1alpha1.Run, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1alpha1().Runs(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.Run) (*v1alpha1.Run, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.Run, reconcileEvent reconciler.Event) (*v1alpha1.Run, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file283" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package run

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.Run) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file284" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        stepaction "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/stepaction"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "stepaction-controller"
        defaultFinalizerName       = "stepactions.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">stepactionInformer := stepaction.Get(ctx)

        lister := stepactionInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.StepAction"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file285" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        zap "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.StepAction.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.StepAction. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.StepAction) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.StepAction.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.StepAction. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.StepAction) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.StepAction if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.StepAction.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.StepAction) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.StepAction) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.StepAction resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1alpha1.StepActionLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1alpha1.StepActionLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.StepActions(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.StepAction, desiredFinalizers sets.Set[string]) (*v1alpha1.StepAction, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1alpha1().StepActions(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.StepAction) (*v1alpha1.StepAction, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.StepAction, reconcileEvent reconciler.Event) (*v1alpha1.StepAction, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file286" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.StepAction) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file287" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package verificationpolicy

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        verificationpolicy "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "verificationpolicy-controller"
        defaultFinalizerName       = "verificationpolicies.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">verificationpolicyInformer := verificationpolicy.Get(ctx)

        lister := verificationpolicyInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.VerificationPolicy"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file288" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package verificationpolicy

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        zap "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.VerificationPolicy.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.VerificationPolicy. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.VerificationPolicy) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.VerificationPolicy.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.VerificationPolicy. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.VerificationPolicy) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.VerificationPolicy if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.VerificationPolicy.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.VerificationPolicy) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.VerificationPolicy) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.VerificationPolicy resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1alpha1.VerificationPolicyLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1alpha1.VerificationPolicyLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.VerificationPolicies(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.VerificationPolicy, desiredFinalizers sets.Set[string]) (*v1alpha1.VerificationPolicy, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1alpha1().VerificationPolicies(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.VerificationPolicy) (*v1alpha1.VerificationPolicy, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.VerificationPolicy, reconcileEvent reconciler.Event) (*v1alpha1.VerificationPolicy, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file289" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package verificationpolicy

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.VerificationPolicy) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file290" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package customrun

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        customrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "customrun-controller"
        defaultFinalizerName       = "customruns.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">customrunInformer := customrun.Get(ctx)

        lister := customrunInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.CustomRun"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file291" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package customrun

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.CustomRun.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.CustomRun. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.CustomRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.CustomRun.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.CustomRun. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.CustomRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.CustomRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.CustomRun.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.CustomRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.CustomRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.CustomRun resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.CustomRunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.CustomRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.CustomRuns(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                <span class="cov0" title="0">if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PreProcessReconcile(ctx, resource)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)

                if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PostProcessReconcile(ctx, resource, original)
                }</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1beta1.CustomRun, desired *v1beta1.CustomRun) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1beta1().CustomRuns(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1beta1().CustomRuns(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.CustomRun, desiredFinalizers sets.Set[string]) (*v1beta1.CustomRun, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().CustomRuns(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.CustomRun) (*v1beta1.CustomRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.CustomRun, reconcileEvent reconciler.Event) (*v1beta1.CustomRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file292" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package customrun

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.CustomRun) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file293" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipeline "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipeline"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "pipeline-controller"
        defaultFinalizerName       = "pipelines.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">pipelineInformer := pipeline.Get(ctx)

        lister := pipelineInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.Pipeline"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file294" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.Pipeline.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.Pipeline. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.Pipeline) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.Pipeline.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.Pipeline. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.Pipeline) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.Pipeline if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.Pipeline.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.Pipeline) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.Pipeline) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.Pipeline resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.PipelineLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.PipelineLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Pipelines(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.Pipeline, desiredFinalizers sets.Set[string]) (*v1beta1.Pipeline, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().Pipelines(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.Pipeline) (*v1beta1.Pipeline, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.Pipeline, reconcileEvent reconciler.Event) (*v1beta1.Pipeline, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file295" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipeline

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.Pipeline) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file296" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelinerun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/pipelinerun"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "pipelinerun-controller"
        defaultFinalizerName       = "pipelineruns.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">pipelinerunInformer := pipelinerun.Get(ctx)

        lister := pipelinerunInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.PipelineRun"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file297" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.PipelineRun.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.PipelineRun. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.PipelineRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.PipelineRun.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.PipelineRun. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.PipelineRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.PipelineRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.PipelineRun.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.PipelineRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.PipelineRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.PipelineRun resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.PipelineRunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.PipelineRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.PipelineRuns(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1beta1.PipelineRun, desired *v1beta1.PipelineRun) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1beta1().PipelineRuns(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1beta1().PipelineRuns(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.PipelineRun, desiredFinalizers sets.Set[string]) (*v1beta1.PipelineRun, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().PipelineRuns(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.PipelineRun) (*v1beta1.PipelineRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.PipelineRun, reconcileEvent reconciler.Event) (*v1beta1.PipelineRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file298" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelinerun

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.PipelineRun) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file299" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        stepaction "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "stepaction-controller"
        defaultFinalizerName       = "stepactions.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">stepactionInformer := stepaction.Get(ctx)

        lister := stepactionInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.StepAction"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file300" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.StepAction.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.StepAction. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.StepAction) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.StepAction.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.StepAction. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.StepAction) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.StepAction if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.StepAction.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.StepAction) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.StepAction) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.StepAction resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.StepActionLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.StepActionLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.StepActions(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.StepAction, desiredFinalizers sets.Set[string]) (*v1beta1.StepAction, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().StepActions(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.StepAction) (*v1beta1.StepAction, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.StepAction, reconcileEvent reconciler.Event) (*v1beta1.StepAction, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file301" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package stepaction

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.StepAction) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file302" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        task "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/task"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "task-controller"
        defaultFinalizerName       = "tasks.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">taskInformer := task.Get(ctx)

        lister := taskInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.Task"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file303" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.Task.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.Task. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.Task) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.Task.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.Task. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.Task) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.Task if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.Task.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.Task) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.Task) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.Task resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.TaskLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.TaskLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Tasks(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.Task, desiredFinalizers sets.Set[string]) (*v1beta1.Task, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().Tasks(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.Task) (*v1beta1.Task, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.Task, reconcileEvent reconciler.Event) (*v1beta1.Task, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file304" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package task

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.Task) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file305" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskrun "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/taskrun"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "taskrun-controller"
        defaultFinalizerName       = "taskruns.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">taskrunInformer := taskrun.Get(ctx)

        lister := taskrunInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "tekton.dev.TaskRun"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file306" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.TaskRun.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.TaskRun. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.TaskRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.TaskRun.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.TaskRun. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.TaskRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.TaskRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.TaskRun.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.TaskRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.TaskRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.TaskRun resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister pipelinev1beta1.TaskRunLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1beta1.TaskRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.TaskRuns(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1beta1.TaskRun, desired *v1beta1.TaskRun) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TektonV1beta1().TaskRuns(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TektonV1beta1().TaskRuns(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.TaskRun, desiredFinalizers sets.Set[string]) (*v1beta1.TaskRun, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TektonV1beta1().TaskRuns(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.TaskRun) (*v1beta1.TaskRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.TaskRun, reconcileEvent reconciler.Event) (*v1beta1.TaskRun, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file307" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.TaskRun) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file308" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineLister helps list Pipelines.
// All objects returned here must be treated as read-only.
type PipelineLister interface {
        // List lists all Pipelines in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.Pipeline, err error)
        // Pipelines returns an object that can list and get Pipelines.
        Pipelines(namespace string) PipelineNamespaceLister
        PipelineListerExpansion
}

// pipelineLister implements the PipelineLister interface.
type pipelineLister struct {
        listers.ResourceIndexer[*pipelinev1.Pipeline]
}

// NewPipelineLister returns a new PipelineLister.
func NewPipelineLister(indexer cache.Indexer) PipelineLister <span class="cov0" title="0">{
        return &amp;pipelineLister{listers.New[*pipelinev1.Pipeline](indexer, pipelinev1.Resource("pipeline"))}
}</span>

// Pipelines returns an object that can list and get Pipelines.
func (s *pipelineLister) Pipelines(namespace string) PipelineNamespaceLister <span class="cov0" title="0">{
        return pipelineNamespaceLister{listers.NewNamespaced[*pipelinev1.Pipeline](s.ResourceIndexer, namespace)}
}</span>

// PipelineNamespaceLister helps list and get Pipelines.
// All objects returned here must be treated as read-only.
type PipelineNamespaceLister interface {
        // List lists all Pipelines in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.Pipeline, err error)
        // Get retrieves the Pipeline from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1.Pipeline, error)
        PipelineNamespaceListerExpansion
}

// pipelineNamespaceLister implements the PipelineNamespaceLister
// interface.
type pipelineNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1.Pipeline]
}
</pre>
		
		<pre class="file" id="file309" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineRunLister helps list PipelineRuns.
// All objects returned here must be treated as read-only.
type PipelineRunLister interface {
        // List lists all PipelineRuns in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.PipelineRun, err error)
        // PipelineRuns returns an object that can list and get PipelineRuns.
        PipelineRuns(namespace string) PipelineRunNamespaceLister
        PipelineRunListerExpansion
}

// pipelineRunLister implements the PipelineRunLister interface.
type pipelineRunLister struct {
        listers.ResourceIndexer[*pipelinev1.PipelineRun]
}

// NewPipelineRunLister returns a new PipelineRunLister.
func NewPipelineRunLister(indexer cache.Indexer) PipelineRunLister <span class="cov0" title="0">{
        return &amp;pipelineRunLister{listers.New[*pipelinev1.PipelineRun](indexer, pipelinev1.Resource("pipelinerun"))}
}</span>

// PipelineRuns returns an object that can list and get PipelineRuns.
func (s *pipelineRunLister) PipelineRuns(namespace string) PipelineRunNamespaceLister <span class="cov0" title="0">{
        return pipelineRunNamespaceLister{listers.NewNamespaced[*pipelinev1.PipelineRun](s.ResourceIndexer, namespace)}
}</span>

// PipelineRunNamespaceLister helps list and get PipelineRuns.
// All objects returned here must be treated as read-only.
type PipelineRunNamespaceLister interface {
        // List lists all PipelineRuns in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.PipelineRun, err error)
        // Get retrieves the PipelineRun from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1.PipelineRun, error)
        PipelineRunNamespaceListerExpansion
}

// pipelineRunNamespaceLister implements the PipelineRunNamespaceLister
// interface.
type pipelineRunNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1.PipelineRun]
}
</pre>
		
		<pre class="file" id="file310" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TaskLister helps list Tasks.
// All objects returned here must be treated as read-only.
type TaskLister interface {
        // List lists all Tasks in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.Task, err error)
        // Tasks returns an object that can list and get Tasks.
        Tasks(namespace string) TaskNamespaceLister
        TaskListerExpansion
}

// taskLister implements the TaskLister interface.
type taskLister struct {
        listers.ResourceIndexer[*pipelinev1.Task]
}

// NewTaskLister returns a new TaskLister.
func NewTaskLister(indexer cache.Indexer) TaskLister <span class="cov0" title="0">{
        return &amp;taskLister{listers.New[*pipelinev1.Task](indexer, pipelinev1.Resource("task"))}
}</span>

// Tasks returns an object that can list and get Tasks.
func (s *taskLister) Tasks(namespace string) TaskNamespaceLister <span class="cov0" title="0">{
        return taskNamespaceLister{listers.NewNamespaced[*pipelinev1.Task](s.ResourceIndexer, namespace)}
}</span>

// TaskNamespaceLister helps list and get Tasks.
// All objects returned here must be treated as read-only.
type TaskNamespaceLister interface {
        // List lists all Tasks in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.Task, err error)
        // Get retrieves the Task from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1.Task, error)
        TaskNamespaceListerExpansion
}

// taskNamespaceLister implements the TaskNamespaceLister
// interface.
type taskNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1.Task]
}
</pre>
		
		<pre class="file" id="file311" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1

import (
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TaskRunLister helps list TaskRuns.
// All objects returned here must be treated as read-only.
type TaskRunLister interface {
        // List lists all TaskRuns in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.TaskRun, err error)
        // TaskRuns returns an object that can list and get TaskRuns.
        TaskRuns(namespace string) TaskRunNamespaceLister
        TaskRunListerExpansion
}

// taskRunLister implements the TaskRunLister interface.
type taskRunLister struct {
        listers.ResourceIndexer[*pipelinev1.TaskRun]
}

// NewTaskRunLister returns a new TaskRunLister.
func NewTaskRunLister(indexer cache.Indexer) TaskRunLister <span class="cov0" title="0">{
        return &amp;taskRunLister{listers.New[*pipelinev1.TaskRun](indexer, pipelinev1.Resource("taskrun"))}
}</span>

// TaskRuns returns an object that can list and get TaskRuns.
func (s *taskRunLister) TaskRuns(namespace string) TaskRunNamespaceLister <span class="cov0" title="0">{
        return taskRunNamespaceLister{listers.NewNamespaced[*pipelinev1.TaskRun](s.ResourceIndexer, namespace)}
}</span>

// TaskRunNamespaceLister helps list and get TaskRuns.
// All objects returned here must be treated as read-only.
type TaskRunNamespaceLister interface {
        // List lists all TaskRuns in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1.TaskRun, err error)
        // Get retrieves the TaskRun from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1.TaskRun, error)
        TaskRunNamespaceListerExpansion
}

// taskRunNamespaceLister implements the TaskRunNamespaceLister
// interface.
type taskRunNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1.TaskRun]
}
</pre>
		
		<pre class="file" id="file312" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// RunLister helps list Runs.
// All objects returned here must be treated as read-only.
type RunLister interface {
        // List lists all Runs in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.Run, err error)
        // Runs returns an object that can list and get Runs.
        Runs(namespace string) RunNamespaceLister
        RunListerExpansion
}

// runLister implements the RunLister interface.
type runLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.Run]
}

// NewRunLister returns a new RunLister.
func NewRunLister(indexer cache.Indexer) RunLister <span class="cov0" title="0">{
        return &amp;runLister{listers.New[*pipelinev1alpha1.Run](indexer, pipelinev1alpha1.Resource("run"))}
}</span>

// Runs returns an object that can list and get Runs.
func (s *runLister) Runs(namespace string) RunNamespaceLister <span class="cov0" title="0">{
        return runNamespaceLister{listers.NewNamespaced[*pipelinev1alpha1.Run](s.ResourceIndexer, namespace)}
}</span>

// RunNamespaceLister helps list and get Runs.
// All objects returned here must be treated as read-only.
type RunNamespaceLister interface {
        // List lists all Runs in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.Run, err error)
        // Get retrieves the Run from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1alpha1.Run, error)
        RunNamespaceListerExpansion
}

// runNamespaceLister implements the RunNamespaceLister
// interface.
type runNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.Run]
}
</pre>
		
		<pre class="file" id="file313" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// StepActionLister helps list StepActions.
// All objects returned here must be treated as read-only.
type StepActionLister interface {
        // List lists all StepActions in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.StepAction, err error)
        // StepActions returns an object that can list and get StepActions.
        StepActions(namespace string) StepActionNamespaceLister
        StepActionListerExpansion
}

// stepActionLister implements the StepActionLister interface.
type stepActionLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.StepAction]
}

// NewStepActionLister returns a new StepActionLister.
func NewStepActionLister(indexer cache.Indexer) StepActionLister <span class="cov0" title="0">{
        return &amp;stepActionLister{listers.New[*pipelinev1alpha1.StepAction](indexer, pipelinev1alpha1.Resource("stepaction"))}
}</span>

// StepActions returns an object that can list and get StepActions.
func (s *stepActionLister) StepActions(namespace string) StepActionNamespaceLister <span class="cov0" title="0">{
        return stepActionNamespaceLister{listers.NewNamespaced[*pipelinev1alpha1.StepAction](s.ResourceIndexer, namespace)}
}</span>

// StepActionNamespaceLister helps list and get StepActions.
// All objects returned here must be treated as read-only.
type StepActionNamespaceLister interface {
        // List lists all StepActions in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.StepAction, err error)
        // Get retrieves the StepAction from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1alpha1.StepAction, error)
        StepActionNamespaceListerExpansion
}

// stepActionNamespaceLister implements the StepActionNamespaceLister
// interface.
type stepActionNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.StepAction]
}
</pre>
		
		<pre class="file" id="file314" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        pipelinev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// VerificationPolicyLister helps list VerificationPolicies.
// All objects returned here must be treated as read-only.
type VerificationPolicyLister interface {
        // List lists all VerificationPolicies in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.VerificationPolicy, err error)
        // VerificationPolicies returns an object that can list and get VerificationPolicies.
        VerificationPolicies(namespace string) VerificationPolicyNamespaceLister
        VerificationPolicyListerExpansion
}

// verificationPolicyLister implements the VerificationPolicyLister interface.
type verificationPolicyLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.VerificationPolicy]
}

// NewVerificationPolicyLister returns a new VerificationPolicyLister.
func NewVerificationPolicyLister(indexer cache.Indexer) VerificationPolicyLister <span class="cov0" title="0">{
        return &amp;verificationPolicyLister{listers.New[*pipelinev1alpha1.VerificationPolicy](indexer, pipelinev1alpha1.Resource("verificationpolicy"))}
}</span>

// VerificationPolicies returns an object that can list and get VerificationPolicies.
func (s *verificationPolicyLister) VerificationPolicies(namespace string) VerificationPolicyNamespaceLister <span class="cov0" title="0">{
        return verificationPolicyNamespaceLister{listers.NewNamespaced[*pipelinev1alpha1.VerificationPolicy](s.ResourceIndexer, namespace)}
}</span>

// VerificationPolicyNamespaceLister helps list and get VerificationPolicies.
// All objects returned here must be treated as read-only.
type VerificationPolicyNamespaceLister interface {
        // List lists all VerificationPolicies in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1alpha1.VerificationPolicy, err error)
        // Get retrieves the VerificationPolicy from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1alpha1.VerificationPolicy, error)
        VerificationPolicyNamespaceListerExpansion
}

// verificationPolicyNamespaceLister implements the VerificationPolicyNamespaceLister
// interface.
type verificationPolicyNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1alpha1.VerificationPolicy]
}
</pre>
		
		<pre class="file" id="file315" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// CustomRunLister helps list CustomRuns.
// All objects returned here must be treated as read-only.
type CustomRunLister interface {
        // List lists all CustomRuns in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.CustomRun, err error)
        // CustomRuns returns an object that can list and get CustomRuns.
        CustomRuns(namespace string) CustomRunNamespaceLister
        CustomRunListerExpansion
}

// customRunLister implements the CustomRunLister interface.
type customRunLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.CustomRun]
}

// NewCustomRunLister returns a new CustomRunLister.
func NewCustomRunLister(indexer cache.Indexer) CustomRunLister <span class="cov0" title="0">{
        return &amp;customRunLister{listers.New[*pipelinev1beta1.CustomRun](indexer, pipelinev1beta1.Resource("customrun"))}
}</span>

// CustomRuns returns an object that can list and get CustomRuns.
func (s *customRunLister) CustomRuns(namespace string) CustomRunNamespaceLister <span class="cov0" title="0">{
        return customRunNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.CustomRun](s.ResourceIndexer, namespace)}
}</span>

// CustomRunNamespaceLister helps list and get CustomRuns.
// All objects returned here must be treated as read-only.
type CustomRunNamespaceLister interface {
        // List lists all CustomRuns in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.CustomRun, err error)
        // Get retrieves the CustomRun from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.CustomRun, error)
        CustomRunNamespaceListerExpansion
}

// customRunNamespaceLister implements the CustomRunNamespaceLister
// interface.
type customRunNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.CustomRun]
}
</pre>
		
		<pre class="file" id="file316" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineLister helps list Pipelines.
// All objects returned here must be treated as read-only.
type PipelineLister interface {
        // List lists all Pipelines in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.Pipeline, err error)
        // Pipelines returns an object that can list and get Pipelines.
        Pipelines(namespace string) PipelineNamespaceLister
        PipelineListerExpansion
}

// pipelineLister implements the PipelineLister interface.
type pipelineLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.Pipeline]
}

// NewPipelineLister returns a new PipelineLister.
func NewPipelineLister(indexer cache.Indexer) PipelineLister <span class="cov0" title="0">{
        return &amp;pipelineLister{listers.New[*pipelinev1beta1.Pipeline](indexer, pipelinev1beta1.Resource("pipeline"))}
}</span>

// Pipelines returns an object that can list and get Pipelines.
func (s *pipelineLister) Pipelines(namespace string) PipelineNamespaceLister <span class="cov0" title="0">{
        return pipelineNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.Pipeline](s.ResourceIndexer, namespace)}
}</span>

// PipelineNamespaceLister helps list and get Pipelines.
// All objects returned here must be treated as read-only.
type PipelineNamespaceLister interface {
        // List lists all Pipelines in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.Pipeline, err error)
        // Get retrieves the Pipeline from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.Pipeline, error)
        PipelineNamespaceListerExpansion
}

// pipelineNamespaceLister implements the PipelineNamespaceLister
// interface.
type pipelineNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.Pipeline]
}
</pre>
		
		<pre class="file" id="file317" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineRunLister helps list PipelineRuns.
// All objects returned here must be treated as read-only.
type PipelineRunLister interface {
        // List lists all PipelineRuns in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.PipelineRun, err error)
        // PipelineRuns returns an object that can list and get PipelineRuns.
        PipelineRuns(namespace string) PipelineRunNamespaceLister
        PipelineRunListerExpansion
}

// pipelineRunLister implements the PipelineRunLister interface.
type pipelineRunLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.PipelineRun]
}

// NewPipelineRunLister returns a new PipelineRunLister.
func NewPipelineRunLister(indexer cache.Indexer) PipelineRunLister <span class="cov0" title="0">{
        return &amp;pipelineRunLister{listers.New[*pipelinev1beta1.PipelineRun](indexer, pipelinev1beta1.Resource("pipelinerun"))}
}</span>

// PipelineRuns returns an object that can list and get PipelineRuns.
func (s *pipelineRunLister) PipelineRuns(namespace string) PipelineRunNamespaceLister <span class="cov0" title="0">{
        return pipelineRunNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.PipelineRun](s.ResourceIndexer, namespace)}
}</span>

// PipelineRunNamespaceLister helps list and get PipelineRuns.
// All objects returned here must be treated as read-only.
type PipelineRunNamespaceLister interface {
        // List lists all PipelineRuns in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.PipelineRun, err error)
        // Get retrieves the PipelineRun from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.PipelineRun, error)
        PipelineRunNamespaceListerExpansion
}

// pipelineRunNamespaceLister implements the PipelineRunNamespaceLister
// interface.
type pipelineRunNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.PipelineRun]
}
</pre>
		
		<pre class="file" id="file318" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// StepActionLister helps list StepActions.
// All objects returned here must be treated as read-only.
type StepActionLister interface {
        // List lists all StepActions in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.StepAction, err error)
        // StepActions returns an object that can list and get StepActions.
        StepActions(namespace string) StepActionNamespaceLister
        StepActionListerExpansion
}

// stepActionLister implements the StepActionLister interface.
type stepActionLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.StepAction]
}

// NewStepActionLister returns a new StepActionLister.
func NewStepActionLister(indexer cache.Indexer) StepActionLister <span class="cov0" title="0">{
        return &amp;stepActionLister{listers.New[*pipelinev1beta1.StepAction](indexer, pipelinev1beta1.Resource("stepaction"))}
}</span>

// StepActions returns an object that can list and get StepActions.
func (s *stepActionLister) StepActions(namespace string) StepActionNamespaceLister <span class="cov0" title="0">{
        return stepActionNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.StepAction](s.ResourceIndexer, namespace)}
}</span>

// StepActionNamespaceLister helps list and get StepActions.
// All objects returned here must be treated as read-only.
type StepActionNamespaceLister interface {
        // List lists all StepActions in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.StepAction, err error)
        // Get retrieves the StepAction from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.StepAction, error)
        StepActionNamespaceListerExpansion
}

// stepActionNamespaceLister implements the StepActionNamespaceLister
// interface.
type stepActionNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.StepAction]
}
</pre>
		
		<pre class="file" id="file319" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TaskLister helps list Tasks.
// All objects returned here must be treated as read-only.
type TaskLister interface {
        // List lists all Tasks in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.Task, err error)
        // Tasks returns an object that can list and get Tasks.
        Tasks(namespace string) TaskNamespaceLister
        TaskListerExpansion
}

// taskLister implements the TaskLister interface.
type taskLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.Task]
}

// NewTaskLister returns a new TaskLister.
func NewTaskLister(indexer cache.Indexer) TaskLister <span class="cov0" title="0">{
        return &amp;taskLister{listers.New[*pipelinev1beta1.Task](indexer, pipelinev1beta1.Resource("task"))}
}</span>

// Tasks returns an object that can list and get Tasks.
func (s *taskLister) Tasks(namespace string) TaskNamespaceLister <span class="cov0" title="0">{
        return taskNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.Task](s.ResourceIndexer, namespace)}
}</span>

// TaskNamespaceLister helps list and get Tasks.
// All objects returned here must be treated as read-only.
type TaskNamespaceLister interface {
        // List lists all Tasks in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.Task, err error)
        // Get retrieves the Task from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.Task, error)
        TaskNamespaceListerExpansion
}

// taskNamespaceLister implements the TaskNamespaceLister
// interface.
type taskNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.Task]
}
</pre>
		
		<pre class="file" id="file320" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TaskRunLister helps list TaskRuns.
// All objects returned here must be treated as read-only.
type TaskRunLister interface {
        // List lists all TaskRuns in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.TaskRun, err error)
        // TaskRuns returns an object that can list and get TaskRuns.
        TaskRuns(namespace string) TaskRunNamespaceLister
        TaskRunListerExpansion
}

// taskRunLister implements the TaskRunLister interface.
type taskRunLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.TaskRun]
}

// NewTaskRunLister returns a new TaskRunLister.
func NewTaskRunLister(indexer cache.Indexer) TaskRunLister <span class="cov0" title="0">{
        return &amp;taskRunLister{listers.New[*pipelinev1beta1.TaskRun](indexer, pipelinev1beta1.Resource("taskrun"))}
}</span>

// TaskRuns returns an object that can list and get TaskRuns.
func (s *taskRunLister) TaskRuns(namespace string) TaskRunNamespaceLister <span class="cov0" title="0">{
        return taskRunNamespaceLister{listers.NewNamespaced[*pipelinev1beta1.TaskRun](s.ResourceIndexer, namespace)}
}</span>

// TaskRunNamespaceLister helps list and get TaskRuns.
// All objects returned here must be treated as read-only.
type TaskRunNamespaceLister interface {
        // List lists all TaskRuns in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*pipelinev1beta1.TaskRun, err error)
        // Get retrieves the TaskRun from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*pipelinev1beta1.TaskRun, error)
        TaskRunNamespaceListerExpansion
}

// taskRunNamespaceLister implements the TaskRunNamespaceLister
// interface.
type taskRunNamespaceLister struct {
        listers.ResourceIndexer[*pipelinev1beta1.TaskRun]
}
</pre>
		
		<pre class="file" id="file321" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        fmt "fmt"
        http "net/http"

        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        ResolutionV1alpha1() resolutionv1alpha1.ResolutionV1alpha1Interface
        ResolutionV1beta1() resolutionv1beta1.ResolutionV1beta1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        resolutionV1alpha1 *resolutionv1alpha1.ResolutionV1alpha1Client
        resolutionV1beta1  *resolutionv1beta1.ResolutionV1beta1Client
}

// ResolutionV1alpha1 retrieves the ResolutionV1alpha1Client
func (c *Clientset) ResolutionV1alpha1() resolutionv1alpha1.ResolutionV1alpha1Interface <span class="cov0" title="0">{
        return c.resolutionV1alpha1
}</span>

// ResolutionV1beta1 retrieves the ResolutionV1beta1Client
func (c *Clientset) ResolutionV1beta1() resolutionv1beta1.ResolutionV1beta1Interface <span class="cov0" title="0">{
        return c.resolutionV1beta1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.resolutionV1alpha1, err = resolutionv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cs.resolutionV1beta1, err = resolutionv1beta1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.resolutionV1alpha1 = resolutionv1alpha1.New(c)
        cs.resolutionV1beta1 = resolutionv1beta1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file322" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        clientset "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1"
        fakeresolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1/fake"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1"
        fakeresolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// ResolutionV1alpha1 retrieves the ResolutionV1alpha1Client
func (c *Clientset) ResolutionV1alpha1() resolutionv1alpha1.ResolutionV1alpha1Interface <span class="cov0" title="0">{
        return &amp;fakeresolutionv1alpha1.FakeResolutionV1alpha1{Fake: &amp;c.Fake}
}</span>

// ResolutionV1beta1 retrieves the ResolutionV1beta1Client
func (c *Clientset) ResolutionV1beta1() resolutionv1beta1.ResolutionV1beta1Interface <span class="cov0" title="0">{
        return &amp;fakeresolutionv1beta1.FakeResolutionV1beta1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file323" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        resolutionv1alpha1.AddToScheme,
        resolutionv1beta1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file324" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        resolutionv1alpha1.AddToScheme,
        resolutionv1beta1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file325" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeResolutionV1alpha1 struct {
        *testing.Fake
}

func (c *FakeResolutionV1alpha1) ResolutionRequests(namespace string) v1alpha1.ResolutionRequestInterface <span class="cov0" title="0">{
        return newFakeResolutionRequests(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeResolutionV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file326" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeResolutionRequests implements ResolutionRequestInterface
type fakeResolutionRequests struct {
        *gentype.FakeClientWithList[*v1alpha1.ResolutionRequest, *v1alpha1.ResolutionRequestList]
        Fake *FakeResolutionV1alpha1
}

func newFakeResolutionRequests(fake *FakeResolutionV1alpha1, namespace string) resolutionv1alpha1.ResolutionRequestInterface <span class="cov0" title="0">{
        return &amp;fakeResolutionRequests{
                gentype.NewFakeClientWithList[*v1alpha1.ResolutionRequest, *v1alpha1.ResolutionRequestList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("resolutionrequests"),
                        v1alpha1.SchemeGroupVersion.WithKind("ResolutionRequest"),
                        func() *v1alpha1.ResolutionRequest </span><span class="cov0" title="0">{ return &amp;v1alpha1.ResolutionRequest{} }</span>,
                        func() *v1alpha1.ResolutionRequestList <span class="cov0" title="0">{ return &amp;v1alpha1.ResolutionRequestList{} }</span>,
                        func(dst, src *v1alpha1.ResolutionRequestList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.ResolutionRequestList) []*v1alpha1.ResolutionRequest <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.ResolutionRequestList, items []*v1alpha1.ResolutionRequest) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file327" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        http "net/http"

        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type ResolutionV1alpha1Interface interface {
        RESTClient() rest.Interface
        ResolutionRequestsGetter
}

// ResolutionV1alpha1Client is used to interact with features provided by the resolution.tekton.dev group.
type ResolutionV1alpha1Client struct {
        restClient rest.Interface
}

func (c *ResolutionV1alpha1Client) ResolutionRequests(namespace string) ResolutionRequestInterface <span class="cov0" title="0">{
        return newResolutionRequests(c, namespace)
}</span>

// NewForConfig creates a new ResolutionV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*ResolutionV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new ResolutionV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*ResolutionV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ResolutionV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new ResolutionV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *ResolutionV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new ResolutionV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *ResolutionV1alpha1Client <span class="cov0" title="0">{
        return &amp;ResolutionV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := resolutionv1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *ResolutionV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file328" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ResolutionRequestsGetter has a method to return a ResolutionRequestInterface.
// A group's client should implement this interface.
type ResolutionRequestsGetter interface {
        ResolutionRequests(namespace string) ResolutionRequestInterface
}

// ResolutionRequestInterface has methods to work with ResolutionRequest resources.
type ResolutionRequestInterface interface {
        Create(ctx context.Context, resolutionRequest *resolutionv1alpha1.ResolutionRequest, opts v1.CreateOptions) (*resolutionv1alpha1.ResolutionRequest, error)
        Update(ctx context.Context, resolutionRequest *resolutionv1alpha1.ResolutionRequest, opts v1.UpdateOptions) (*resolutionv1alpha1.ResolutionRequest, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, resolutionRequest *resolutionv1alpha1.ResolutionRequest, opts v1.UpdateOptions) (*resolutionv1alpha1.ResolutionRequest, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*resolutionv1alpha1.ResolutionRequest, error)
        List(ctx context.Context, opts v1.ListOptions) (*resolutionv1alpha1.ResolutionRequestList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *resolutionv1alpha1.ResolutionRequest, err error)
        ResolutionRequestExpansion
}

// resolutionRequests implements ResolutionRequestInterface
type resolutionRequests struct {
        *gentype.ClientWithList[*resolutionv1alpha1.ResolutionRequest, *resolutionv1alpha1.ResolutionRequestList]
}

// newResolutionRequests returns a ResolutionRequests
func newResolutionRequests(c *ResolutionV1alpha1Client, namespace string) *resolutionRequests <span class="cov0" title="0">{
        return &amp;resolutionRequests{
                gentype.NewClientWithList[*resolutionv1alpha1.ResolutionRequest, *resolutionv1alpha1.ResolutionRequestList](
                        "resolutionrequests",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *resolutionv1alpha1.ResolutionRequest </span><span class="cov0" title="0">{ return &amp;resolutionv1alpha1.ResolutionRequest{} }</span>,
                        func() *resolutionv1alpha1.ResolutionRequestList <span class="cov0" title="0">{ return &amp;resolutionv1alpha1.ResolutionRequestList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file329" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeResolutionV1beta1 struct {
        *testing.Fake
}

func (c *FakeResolutionV1beta1) ResolutionRequests(namespace string) v1beta1.ResolutionRequestInterface <span class="cov0" title="0">{
        return newFakeResolutionRequests(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeResolutionV1beta1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file330" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeResolutionRequests implements ResolutionRequestInterface
type fakeResolutionRequests struct {
        *gentype.FakeClientWithList[*v1beta1.ResolutionRequest, *v1beta1.ResolutionRequestList]
        Fake *FakeResolutionV1beta1
}

func newFakeResolutionRequests(fake *FakeResolutionV1beta1, namespace string) resolutionv1beta1.ResolutionRequestInterface <span class="cov0" title="0">{
        return &amp;fakeResolutionRequests{
                gentype.NewFakeClientWithList[*v1beta1.ResolutionRequest, *v1beta1.ResolutionRequestList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("resolutionrequests"),
                        v1beta1.SchemeGroupVersion.WithKind("ResolutionRequest"),
                        func() *v1beta1.ResolutionRequest </span><span class="cov0" title="0">{ return &amp;v1beta1.ResolutionRequest{} }</span>,
                        func() *v1beta1.ResolutionRequestList <span class="cov0" title="0">{ return &amp;v1beta1.ResolutionRequestList{} }</span>,
                        func(dst, src *v1beta1.ResolutionRequestList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.ResolutionRequestList) []*v1beta1.ResolutionRequest <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1beta1.ResolutionRequestList, items []*v1beta1.ResolutionRequest) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file331" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        http "net/http"

        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type ResolutionV1beta1Interface interface {
        RESTClient() rest.Interface
        ResolutionRequestsGetter
}

// ResolutionV1beta1Client is used to interact with features provided by the resolution.tekton.dev group.
type ResolutionV1beta1Client struct {
        restClient rest.Interface
}

func (c *ResolutionV1beta1Client) ResolutionRequests(namespace string) ResolutionRequestInterface <span class="cov0" title="0">{
        return newResolutionRequests(c, namespace)
}</span>

// NewForConfig creates a new ResolutionV1beta1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*ResolutionV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new ResolutionV1beta1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*ResolutionV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ResolutionV1beta1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new ResolutionV1beta1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *ResolutionV1beta1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new ResolutionV1beta1Client for the given RESTClient.
func New(c rest.Interface) *ResolutionV1beta1Client <span class="cov0" title="0">{
        return &amp;ResolutionV1beta1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := resolutionv1beta1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *ResolutionV1beta1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file332" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ResolutionRequestsGetter has a method to return a ResolutionRequestInterface.
// A group's client should implement this interface.
type ResolutionRequestsGetter interface {
        ResolutionRequests(namespace string) ResolutionRequestInterface
}

// ResolutionRequestInterface has methods to work with ResolutionRequest resources.
type ResolutionRequestInterface interface {
        Create(ctx context.Context, resolutionRequest *resolutionv1beta1.ResolutionRequest, opts v1.CreateOptions) (*resolutionv1beta1.ResolutionRequest, error)
        Update(ctx context.Context, resolutionRequest *resolutionv1beta1.ResolutionRequest, opts v1.UpdateOptions) (*resolutionv1beta1.ResolutionRequest, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, resolutionRequest *resolutionv1beta1.ResolutionRequest, opts v1.UpdateOptions) (*resolutionv1beta1.ResolutionRequest, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*resolutionv1beta1.ResolutionRequest, error)
        List(ctx context.Context, opts v1.ListOptions) (*resolutionv1beta1.ResolutionRequestList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *resolutionv1beta1.ResolutionRequest, err error)
        ResolutionRequestExpansion
}

// resolutionRequests implements ResolutionRequestInterface
type resolutionRequests struct {
        *gentype.ClientWithList[*resolutionv1beta1.ResolutionRequest, *resolutionv1beta1.ResolutionRequestList]
}

// newResolutionRequests returns a ResolutionRequests
func newResolutionRequests(c *ResolutionV1beta1Client, namespace string) *resolutionRequests <span class="cov0" title="0">{
        return &amp;resolutionRequests{
                gentype.NewClientWithList[*resolutionv1beta1.ResolutionRequest, *resolutionv1beta1.ResolutionRequestList](
                        "resolutionrequests",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *resolutionv1beta1.ResolutionRequest </span><span class="cov0" title="0">{ return &amp;resolutionv1beta1.ResolutionRequest{} }</span>,
                        func() *resolutionv1beta1.ResolutionRequestList <span class="cov0" title="0">{ return &amp;resolutionv1beta1.ResolutionRequestList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file333" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
        resolution "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Resolution() resolution.Interface
}

func (f *sharedInformerFactory) Resolution() resolution.Interface <span class="cov0" title="0">{
        return resolution.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file334" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=resolution.tekton.dev, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("resolutionrequests"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Resolution().V1alpha1().ResolutionRequests().Informer()}, nil</span>

                // Group=resolution.tekton.dev, Version=v1beta1
        case v1beta1.SchemeGroupVersion.WithResource("resolutionrequests"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Resolution().V1beta1().ResolutionRequests().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file335" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package resolution

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1"
        v1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
        // V1beta1 provides access to shared informers for resources in V1beta1.
        V1beta1() v1beta1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>

// V1beta1 returns a new v1beta1.Interface.
func (g *group) V1beta1() v1beta1.Interface <span class="cov0" title="0">{
        return v1beta1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file336" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // ResolutionRequests returns a ResolutionRequestInformer.
        ResolutionRequests() ResolutionRequestInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// ResolutionRequests returns a ResolutionRequestInformer.
func (v *version) ResolutionRequests() ResolutionRequestInformer <span class="cov0" title="0">{
        return &amp;resolutionRequestInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file337" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apisresolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ResolutionRequestInformer provides access to a shared informer and lister for
// ResolutionRequests.
type ResolutionRequestInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() resolutionv1alpha1.ResolutionRequestLister
}

type resolutionRequestInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewResolutionRequestInformer constructs a new informer for ResolutionRequest type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewResolutionRequestInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredResolutionRequestInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredResolutionRequestInformer constructs a new informer for ResolutionRequest type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredResolutionRequestInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.ResolutionV1alpha1().ResolutionRequests(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.ResolutionV1alpha1().ResolutionRequests(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apisresolutionv1alpha1.ResolutionRequest{},
                resyncPeriod,
                indexers,
        )
}

func (f *resolutionRequestInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredResolutionRequestInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *resolutionRequestInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apisresolutionv1alpha1.ResolutionRequest{}, f.defaultInformer)
}</span>

func (f *resolutionRequestInformer) Lister() resolutionv1alpha1.ResolutionRequestLister <span class="cov0" title="0">{
        return resolutionv1alpha1.NewResolutionRequestLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file338" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // ResolutionRequests returns a ResolutionRequestInformer.
        ResolutionRequests() ResolutionRequestInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// ResolutionRequests returns a ResolutionRequestInformer.
func (v *version) ResolutionRequests() ResolutionRequestInformer <span class="cov0" title="0">{
        return &amp;resolutionRequestInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file339" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apisresolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/internalinterfaces"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ResolutionRequestInformer provides access to a shared informer and lister for
// ResolutionRequests.
type ResolutionRequestInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() resolutionv1beta1.ResolutionRequestLister
}

type resolutionRequestInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewResolutionRequestInformer constructs a new informer for ResolutionRequest type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewResolutionRequestInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredResolutionRequestInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredResolutionRequestInformer constructs a new informer for ResolutionRequest type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredResolutionRequestInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.ResolutionV1beta1().ResolutionRequests(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.ResolutionV1beta1().ResolutionRequests(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apisresolutionv1beta1.ResolutionRequest{},
                resyncPeriod,
                indexers,
        )
}

func (f *resolutionRequestInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredResolutionRequestInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *resolutionRequestInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apisresolutionv1beta1.ResolutionRequest{}, f.defaultInformer)
}</span>

func (f *resolutionRequestInformer) Lister() resolutionv1beta1.ResolutionRequestLister <span class="cov0" title="0">{
        return resolutionv1beta1.NewResolutionRequestLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file340" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
        context "context"

        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterClient(withClientFromConfig)
        injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}</span>

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                if injection.GetConfig(ctx) == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
                }</span> else<span class="cov0" title="0"> {
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned.Interface from context.")
                }</span>
        }
        <span class="cov0" title="0">return untyped.(versioned.Interface)</span>
}
</pre>
		
		<pre class="file" id="file341" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/fake"
        client "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        runtime "k8s.io/apimachinery/pkg/runtime"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(withClient)
        injection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

func withClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        ctx, _ = With(ctx)
        return ctx
}</span>

func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) <span class="cov0" title="0">{
        cs := fake.NewSimpleClientset(objects...)
        return context.WithValue(ctx, client.Key{}, cs), cs
}</span>

// Get extracts the Kubernetes client from the context.
func Get(ctx context.Context) *fake.Clientset <span class="cov0" title="0">{
        untyped := ctx.Value(client.Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/fake.Clientset from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*fake.Clientset)</span>
}
</pre>
		
		<pre class="file" id="file342" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package factory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions.SharedInformerFactory from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file343" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client/fake"
        factory "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = factory.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, factory.Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}
</pre>
		
		<pre class="file" id="file344" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fakeFilteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client/fake"
        filtered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, filtered.Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file345" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct {
        Selector string
}

type LabelKey struct{}

func WithSelectors(ctx context.Context, selector ...string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LabelKey{}, selector)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        untyped := ctx.Value(LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions.SharedInformerFactory with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file346" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/fake"
        resolutionrequest "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = resolutionrequest.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Resolution().V1alpha1().ResolutionRequests()
        return context.WithValue(ctx, resolutionrequest.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file347" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Resolution().V1alpha1().ResolutionRequests()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file348" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1"
        filtered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Resolution().V1alpha1().ResolutionRequests()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.ResolutionRequestInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1.ResolutionRequestInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ResolutionRequestInformer)</span>
}
</pre>
		
		<pre class="file" id="file349" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1"
        factory "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Resolution().V1alpha1().ResolutionRequests()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.ResolutionRequestInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1alpha1.ResolutionRequestInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ResolutionRequestInformer)</span>
}
</pre>
		
		<pre class="file" id="file350" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/fake"
        resolutionrequest "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = resolutionrequest.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Resolution().V1beta1().ResolutionRequests()
        return context.WithValue(ctx, resolutionrequest.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file351" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Resolution().V1beta1().ResolutionRequests()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file352" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1"
        filtered "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Resolution().V1beta1().ResolutionRequests()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.ResolutionRequestInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1.ResolutionRequestInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.ResolutionRequestInformer)</span>
}
</pre>
		
		<pre class="file" id="file353" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"

        v1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1"
        factory "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Resolution().V1beta1().ResolutionRequests()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.ResolutionRequestInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1.ResolutionRequestInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.ResolutionRequestInformer)</span>
}
</pre>
		
		<pre class="file" id="file354" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        resolutionrequest "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1alpha1/resolutionrequest"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "resolutionrequest-controller"
        defaultFinalizerName       = "resolutionrequests.resolution.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">resolutionrequestInformer := resolutionrequest.Get(ctx)

        lister := resolutionrequestInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "resolution.tekton.dev.ResolutionRequest"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file355" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1alpha1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.ResolutionRequest.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.ResolutionRequest. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.ResolutionRequest) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.ResolutionRequest.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.ResolutionRequest. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.ResolutionRequest) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.ResolutionRequest if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.ResolutionRequest.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.ResolutionRequest) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.ResolutionRequest) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.ResolutionRequest resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister resolutionv1alpha1.ResolutionRequestLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister resolutionv1alpha1.ResolutionRequestLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.ResolutionRequests(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                <span class="cov0" title="0">if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PreProcessReconcile(ctx, resource)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)

                if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PostProcessReconcile(ctx, resource, original)
                }</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.ResolutionRequest, desired *v1alpha1.ResolutionRequest) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.ResolutionV1alpha1().ResolutionRequests(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.ResolutionV1alpha1().ResolutionRequests(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.ResolutionRequest, desiredFinalizers sets.Set[string]) (*v1alpha1.ResolutionRequest, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.ResolutionV1alpha1().ResolutionRequests(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.ResolutionRequest) (*v1alpha1.ResolutionRequest, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.ResolutionRequest, reconcileEvent reconciler.Event) (*v1alpha1.ResolutionRequest, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file356" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.ResolutionRequest) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file357" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/scheme"
        client "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        resolutionrequest "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "resolutionrequest-controller"
        defaultFinalizerName       = "resolutionrequests.resolution.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">resolutionrequestInformer := resolutionrequest.Get(ctx)

        lister := resolutionrequestInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "resolution.tekton.dev.ResolutionRequest"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file358" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        versioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.ResolutionRequest.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.ResolutionRequest. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.ResolutionRequest) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.ResolutionRequest.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.ResolutionRequest. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.ResolutionRequest) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.ResolutionRequest if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.ResolutionRequest.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.ResolutionRequest) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.ResolutionRequest) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.ResolutionRequest resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister resolutionv1beta1.ResolutionRequestLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister resolutionv1beta1.ResolutionRequestLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.ResolutionRequests(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                <span class="cov0" title="0">if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PreProcessReconcile(ctx, resource)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)

                if !r.skipStatusUpdates </span><span class="cov0" title="0">{
                        reconciler.PostProcessReconcile(ctx, resource, original)
                }</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1beta1.ResolutionRequest, desired *v1beta1.ResolutionRequest) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.ResolutionV1beta1().ResolutionRequests(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.ResolutionV1beta1().ResolutionRequests(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.ResolutionRequest, desiredFinalizers sets.Set[string]) (*v1beta1.ResolutionRequest, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.ResolutionV1beta1().ResolutionRequests(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.ResolutionRequest) (*v1beta1.ResolutionRequest, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.ResolutionRequest, reconcileEvent reconciler.Event) (*v1beta1.ResolutionRequest, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file359" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package resolutionrequest

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.ResolutionRequest) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file360" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ResolutionRequestLister helps list ResolutionRequests.
// All objects returned here must be treated as read-only.
type ResolutionRequestLister interface {
        // List lists all ResolutionRequests in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resolutionv1alpha1.ResolutionRequest, err error)
        // ResolutionRequests returns an object that can list and get ResolutionRequests.
        ResolutionRequests(namespace string) ResolutionRequestNamespaceLister
        ResolutionRequestListerExpansion
}

// resolutionRequestLister implements the ResolutionRequestLister interface.
type resolutionRequestLister struct {
        listers.ResourceIndexer[*resolutionv1alpha1.ResolutionRequest]
}

// NewResolutionRequestLister returns a new ResolutionRequestLister.
func NewResolutionRequestLister(indexer cache.Indexer) ResolutionRequestLister <span class="cov0" title="0">{
        return &amp;resolutionRequestLister{listers.New[*resolutionv1alpha1.ResolutionRequest](indexer, resolutionv1alpha1.Resource("resolutionrequest"))}
}</span>

// ResolutionRequests returns an object that can list and get ResolutionRequests.
func (s *resolutionRequestLister) ResolutionRequests(namespace string) ResolutionRequestNamespaceLister <span class="cov0" title="0">{
        return resolutionRequestNamespaceLister{listers.NewNamespaced[*resolutionv1alpha1.ResolutionRequest](s.ResourceIndexer, namespace)}
}</span>

// ResolutionRequestNamespaceLister helps list and get ResolutionRequests.
// All objects returned here must be treated as read-only.
type ResolutionRequestNamespaceLister interface {
        // List lists all ResolutionRequests in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resolutionv1alpha1.ResolutionRequest, err error)
        // Get retrieves the ResolutionRequest from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*resolutionv1alpha1.ResolutionRequest, error)
        ResolutionRequestNamespaceListerExpansion
}

// resolutionRequestNamespaceLister implements the ResolutionRequestNamespaceLister
// interface.
type resolutionRequestNamespaceLister struct {
        listers.ResourceIndexer[*resolutionv1alpha1.ResolutionRequest]
}
</pre>
		
		<pre class="file" id="file361" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        resolutionv1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ResolutionRequestLister helps list ResolutionRequests.
// All objects returned here must be treated as read-only.
type ResolutionRequestLister interface {
        // List lists all ResolutionRequests in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resolutionv1beta1.ResolutionRequest, err error)
        // ResolutionRequests returns an object that can list and get ResolutionRequests.
        ResolutionRequests(namespace string) ResolutionRequestNamespaceLister
        ResolutionRequestListerExpansion
}

// resolutionRequestLister implements the ResolutionRequestLister interface.
type resolutionRequestLister struct {
        listers.ResourceIndexer[*resolutionv1beta1.ResolutionRequest]
}

// NewResolutionRequestLister returns a new ResolutionRequestLister.
func NewResolutionRequestLister(indexer cache.Indexer) ResolutionRequestLister <span class="cov0" title="0">{
        return &amp;resolutionRequestLister{listers.New[*resolutionv1beta1.ResolutionRequest](indexer, resolutionv1beta1.Resource("resolutionrequest"))}
}</span>

// ResolutionRequests returns an object that can list and get ResolutionRequests.
func (s *resolutionRequestLister) ResolutionRequests(namespace string) ResolutionRequestNamespaceLister <span class="cov0" title="0">{
        return resolutionRequestNamespaceLister{listers.NewNamespaced[*resolutionv1beta1.ResolutionRequest](s.ResourceIndexer, namespace)}
}</span>

// ResolutionRequestNamespaceLister helps list and get ResolutionRequests.
// All objects returned here must be treated as read-only.
type ResolutionRequestNamespaceLister interface {
        // List lists all ResolutionRequests in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resolutionv1beta1.ResolutionRequest, err error)
        // Get retrieves the ResolutionRequest from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*resolutionv1beta1.ResolutionRequest, error)
        ResolutionRequestNamespaceListerExpansion
}

// resolutionRequestNamespaceLister implements the ResolutionRequestNamespaceLister
// interface.
type resolutionRequestNamespaceLister struct {
        listers.ResourceIndexer[*resolutionv1beta1.ResolutionRequest]
}
</pre>
		
		<pre class="file" id="file362" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        fmt "fmt"
        http "net/http"

        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        tektonV1alpha1 *tektonv1alpha1.TektonV1alpha1Client
}

// TektonV1alpha1 retrieves the TektonV1alpha1Client
func (c *Clientset) TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface <span class="cov0" title="0">{
        return c.tektonV1alpha1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.tektonV1alpha1, err = tektonv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.tektonV1alpha1 = tektonv1alpha1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file363" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        clientset "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned"
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1"
        faketektonv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// TektonV1alpha1 retrieves the TektonV1alpha1Client
func (c *Clientset) TektonV1alpha1() tektonv1alpha1.TektonV1alpha1Interface <span class="cov0" title="0">{
        return &amp;faketektonv1alpha1.FakeTektonV1alpha1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file364" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        tektonv1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file365" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        tektonv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        tektonv1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file366" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        resourcev1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakePipelineResources implements PipelineResourceInterface
type fakePipelineResources struct {
        *gentype.FakeClientWithList[*v1alpha1.PipelineResource, *v1alpha1.PipelineResourceList]
        Fake *FakeTektonV1alpha1
}

func newFakePipelineResources(fake *FakeTektonV1alpha1, namespace string) resourcev1alpha1.PipelineResourceInterface <span class="cov0" title="0">{
        return &amp;fakePipelineResources{
                gentype.NewFakeClientWithList[*v1alpha1.PipelineResource, *v1alpha1.PipelineResourceList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("pipelineresources"),
                        v1alpha1.SchemeGroupVersion.WithKind("PipelineResource"),
                        func() *v1alpha1.PipelineResource </span><span class="cov0" title="0">{ return &amp;v1alpha1.PipelineResource{} }</span>,
                        func() *v1alpha1.PipelineResourceList <span class="cov0" title="0">{ return &amp;v1alpha1.PipelineResourceList{} }</span>,
                        func(dst, src *v1alpha1.PipelineResourceList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.PipelineResourceList) []*v1alpha1.PipelineResource <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.PipelineResourceList, items []*v1alpha1.PipelineResource) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file367" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/typed/resource/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTektonV1alpha1 struct {
        *testing.Fake
}

func (c *FakeTektonV1alpha1) PipelineResources(namespace string) v1alpha1.PipelineResourceInterface <span class="cov0" title="0">{
        return newFakePipelineResources(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTektonV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file368" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        resourcev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// PipelineResourcesGetter has a method to return a PipelineResourceInterface.
// A group's client should implement this interface.
type PipelineResourcesGetter interface {
        PipelineResources(namespace string) PipelineResourceInterface
}

// PipelineResourceInterface has methods to work with PipelineResource resources.
type PipelineResourceInterface interface {
        Create(ctx context.Context, pipelineResource *resourcev1alpha1.PipelineResource, opts v1.CreateOptions) (*resourcev1alpha1.PipelineResource, error)
        Update(ctx context.Context, pipelineResource *resourcev1alpha1.PipelineResource, opts v1.UpdateOptions) (*resourcev1alpha1.PipelineResource, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*resourcev1alpha1.PipelineResource, error)
        List(ctx context.Context, opts v1.ListOptions) (*resourcev1alpha1.PipelineResourceList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *resourcev1alpha1.PipelineResource, err error)
        PipelineResourceExpansion
}

// pipelineResources implements PipelineResourceInterface
type pipelineResources struct {
        *gentype.ClientWithList[*resourcev1alpha1.PipelineResource, *resourcev1alpha1.PipelineResourceList]
}

// newPipelineResources returns a PipelineResources
func newPipelineResources(c *TektonV1alpha1Client, namespace string) *pipelineResources <span class="cov0" title="0">{
        return &amp;pipelineResources{
                gentype.NewClientWithList[*resourcev1alpha1.PipelineResource, *resourcev1alpha1.PipelineResourceList](
                        "pipelineresources",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *resourcev1alpha1.PipelineResource </span><span class="cov0" title="0">{ return &amp;resourcev1alpha1.PipelineResource{} }</span>,
                        func() *resourcev1alpha1.PipelineResourceList <span class="cov0" title="0">{ return &amp;resourcev1alpha1.PipelineResourceList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file369" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        http "net/http"

        resourcev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        scheme "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TektonV1alpha1Interface interface {
        RESTClient() rest.Interface
        PipelineResourcesGetter
}

// TektonV1alpha1Client is used to interact with features provided by the tekton.dev group.
type TektonV1alpha1Client struct {
        restClient rest.Interface
}

func (c *TektonV1alpha1Client) PipelineResources(namespace string) PipelineResourceInterface <span class="cov0" title="0">{
        return newPipelineResources(c, namespace)
}</span>

// NewForConfig creates a new TektonV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TektonV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TektonV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TektonV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TektonV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TektonV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TektonV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TektonV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *TektonV1alpha1Client <span class="cov0" title="0">{
        return &amp;TektonV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := resourcev1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TektonV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file370" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/internalinterfaces"
        resource "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Tekton() resource.Interface
}

func (f *sharedInformerFactory) Tekton() resource.Interface <span class="cov0" title="0">{
        return resource.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file371" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=tekton.dev, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("pipelineresources"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Tekton().V1alpha1().PipelineResources().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file372" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package resource

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/internalinterfaces"
        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file373" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // PipelineResources returns a PipelineResourceInformer.
        PipelineResources() PipelineResourceInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// PipelineResources returns a PipelineResourceInformer.
func (v *version) PipelineResources() PipelineResourceInformer <span class="cov0" title="0">{
        return &amp;pipelineResourceInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file374" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apisresourcev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        versioned "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned"
        internalinterfaces "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/internalinterfaces"
        resourcev1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/listers/resource/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineResourceInformer provides access to a shared informer and lister for
// PipelineResources.
type PipelineResourceInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() resourcev1alpha1.PipelineResourceLister
}

type pipelineResourceInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewPipelineResourceInformer constructs a new informer for PipelineResource type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewPipelineResourceInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineResourceInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredPipelineResourceInformer constructs a new informer for PipelineResource type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredPipelineResourceInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().PipelineResources(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TektonV1alpha1().PipelineResources(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apisresourcev1alpha1.PipelineResource{},
                resyncPeriod,
                indexers,
        )
}

func (f *pipelineResourceInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredPipelineResourceInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *pipelineResourceInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apisresourcev1alpha1.PipelineResource{}, f.defaultInformer)
}</span>

func (f *pipelineResourceInformer) Lister() resourcev1alpha1.PipelineResourceLister <span class="cov0" title="0">{
        return resourcev1alpha1.NewPipelineResourceLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file375" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
        context "context"

        versioned "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterClient(withClientFromConfig)
        injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}</span>

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                if injection.GetConfig(ctx) == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
                }</span> else<span class="cov0" title="0"> {
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned.Interface from context.")
                }</span>
        }
        <span class="cov0" title="0">return untyped.(versioned.Interface)</span>
}
</pre>
		
		<pre class="file" id="file376" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/fake"
        client "github.com/tektoncd/pipeline/pkg/client/resource/injection/client"
        runtime "k8s.io/apimachinery/pkg/runtime"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(withClient)
        injection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

func withClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        ctx, _ = With(ctx)
        return ctx
}</span>

func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) <span class="cov0" title="0">{
        cs := fake.NewSimpleClientset(objects...)
        return context.WithValue(ctx, client.Key{}, cs), cs
}</span>

// Get extracts the Kubernetes client from the context.
func Get(ctx context.Context) *fake.Clientset <span class="cov0" title="0">{
        untyped := ctx.Value(client.Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/clientset/versioned/fake.Clientset from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*fake.Clientset)</span>
}
</pre>
		
		<pre class="file" id="file377" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package factory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/resource/injection/client"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions.SharedInformerFactory from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file378" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/resource/injection/client/fake"
        factory "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = factory.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, factory.Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}
</pre>
		
		<pre class="file" id="file379" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fakeFilteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions"
        fake "github.com/tektoncd/pipeline/pkg/client/resource/injection/client/fake"
        filtered "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/filtered"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, filtered.Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file380" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions"
        client "github.com/tektoncd/pipeline/pkg/client/resource/injection/client"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct {
        Selector string
}

type LabelKey struct{}

func WithSelectors(ctx context.Context, selector ...string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LabelKey{}, selector)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        untyped := ctx.Value(LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions.SharedInformerFactory with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file381" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/fake"
        pipelineresource "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = pipelineresource.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Tekton().V1alpha1().PipelineResources()
        return context.WithValue(ctx, pipelineresource.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file382" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/resource/v1alpha1/pipelineresource/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().PipelineResources()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file383" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1"
        filtered "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Tekton().V1alpha1().PipelineResources()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.PipelineResourceInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1.PipelineResourceInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.PipelineResourceInformer)</span>
}
</pre>
		
		<pre class="file" id="file384" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package pipelineresource

import (
        context "context"

        v1alpha1 "github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1"
        factory "github.com/tektoncd/pipeline/pkg/client/resource/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Tekton().V1alpha1().PipelineResources()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.PipelineResourceInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/pipeline/pkg/client/resource/informers/externalversions/resource/v1alpha1.PipelineResourceInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.PipelineResourceInformer)</span>
}
</pre>
		
		<pre class="file" id="file385" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        resourcev1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resource/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// PipelineResourceLister helps list PipelineResources.
// All objects returned here must be treated as read-only.
type PipelineResourceLister interface {
        // List lists all PipelineResources in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resourcev1alpha1.PipelineResource, err error)
        // PipelineResources returns an object that can list and get PipelineResources.
        PipelineResources(namespace string) PipelineResourceNamespaceLister
        PipelineResourceListerExpansion
}

// pipelineResourceLister implements the PipelineResourceLister interface.
type pipelineResourceLister struct {
        listers.ResourceIndexer[*resourcev1alpha1.PipelineResource]
}

// NewPipelineResourceLister returns a new PipelineResourceLister.
func NewPipelineResourceLister(indexer cache.Indexer) PipelineResourceLister <span class="cov0" title="0">{
        return &amp;pipelineResourceLister{listers.New[*resourcev1alpha1.PipelineResource](indexer, resourcev1alpha1.Resource("pipelineresource"))}
}</span>

// PipelineResources returns an object that can list and get PipelineResources.
func (s *pipelineResourceLister) PipelineResources(namespace string) PipelineResourceNamespaceLister <span class="cov0" title="0">{
        return pipelineResourceNamespaceLister{listers.NewNamespaced[*resourcev1alpha1.PipelineResource](s.ResourceIndexer, namespace)}
}</span>

// PipelineResourceNamespaceLister helps list and get PipelineResources.
// All objects returned here must be treated as read-only.
type PipelineResourceNamespaceLister interface {
        // List lists all PipelineResources in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*resourcev1alpha1.PipelineResource, err error)
        // Get retrieves the PipelineResource from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*resourcev1alpha1.PipelineResource, error)
        PipelineResourceNamespaceListerExpansion
}

// pipelineResourceNamespaceLister implements the PipelineResourceNamespaceLister
// interface.
type pipelineResourceNamespaceLister struct {
        listers.ResourceIndexer[*resourcev1alpha1.PipelineResource]
}
</pre>
		
		<pre class="file" id="file386" style="display: none">/*
 Copyright 2019 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package container

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/substitution"
        corev1 "k8s.io/api/core/v1"
)

// applyStepReplacements returns a StepContainer with variable interpolation applied.
func applyStepReplacements(step *v1.Step, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov8" title="1">{
        c := step.ToK8sContainer()
        applyContainerReplacements(c, stringReplacements, arrayReplacements)
        step.SetContainerFields(*c)
}</span>

// applySidecarReplacements returns a SidecarContainer with variable interpolation applied.
func applySidecarReplacements(sidecar *v1.Sidecar, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov8" title="1">{
        c := sidecar.ToK8sContainer()
        applyContainerReplacements(c, stringReplacements, arrayReplacements)
        sidecar.SetContainerFields(*c)
}</span>

func applyContainerReplacements(c *corev1.Container, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov8" title="1">{
        c.Name = substitution.ApplyReplacements(c.Name, stringReplacements)
        c.Image = substitution.ApplyReplacements(c.Image, stringReplacements)
        c.ImagePullPolicy = corev1.PullPolicy(substitution.ApplyReplacements(string(c.ImagePullPolicy), stringReplacements))

        // Use ApplyArrayReplacements here, as additional args may be added via an array parameter.
        var newArgs []string
        for _, a := range c.Args </span><span class="cov8" title="1">{
                newArgs = append(newArgs, substitution.ApplyArrayReplacements(a, stringReplacements, arrayReplacements)...)
        }</span>
        <span class="cov8" title="1">c.Args = newArgs

        for ie, e := range c.Env </span><span class="cov8" title="1">{
                c.Env[ie].Value = substitution.ApplyReplacements(e.Value, stringReplacements)
                if c.Env[ie].ValueFrom != nil </span><span class="cov8" title="1">{
                        if e.ValueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                                c.Env[ie].ValueFrom.SecretKeyRef.LocalObjectReference.Name = substitution.ApplyReplacements(e.ValueFrom.SecretKeyRef.LocalObjectReference.Name, stringReplacements)
                                c.Env[ie].ValueFrom.SecretKeyRef.Key = substitution.ApplyReplacements(e.ValueFrom.SecretKeyRef.Key, stringReplacements)
                        }</span>
                        <span class="cov8" title="1">if e.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                                c.Env[ie].ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name = substitution.ApplyReplacements(e.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name, stringReplacements)
                                c.Env[ie].ValueFrom.ConfigMapKeyRef.Key = substitution.ApplyReplacements(e.ValueFrom.ConfigMapKeyRef.Key, stringReplacements)
                        }</span>
                }
        }

        <span class="cov8" title="1">for ie, e := range c.EnvFrom </span><span class="cov8" title="1">{
                c.EnvFrom[ie].Prefix = substitution.ApplyReplacements(e.Prefix, stringReplacements)
                if e.ConfigMapRef != nil </span><span class="cov8" title="1">{
                        c.EnvFrom[ie].ConfigMapRef.LocalObjectReference.Name = substitution.ApplyReplacements(e.ConfigMapRef.LocalObjectReference.Name, stringReplacements)
                }</span>
                <span class="cov8" title="1">if e.SecretRef != nil </span><span class="cov8" title="1">{
                        c.EnvFrom[ie].SecretRef.LocalObjectReference.Name = substitution.ApplyReplacements(e.SecretRef.LocalObjectReference.Name, stringReplacements)
                }</span>
        }
        <span class="cov8" title="1">c.WorkingDir = substitution.ApplyReplacements(c.WorkingDir, stringReplacements)

        // Use ApplyArrayReplacements here, as additional commands may be added via an array parameter.
        var newCommand []string
        for _, c := range c.Command </span><span class="cov8" title="1">{
                newCommand = append(newCommand, substitution.ApplyArrayReplacements(c, stringReplacements, arrayReplacements)...)
        }</span>
        <span class="cov8" title="1">c.Command = newCommand

        for iv, v := range c.VolumeMounts </span><span class="cov8" title="1">{
                c.VolumeMounts[iv].Name = substitution.ApplyReplacements(v.Name, stringReplacements)
                c.VolumeMounts[iv].MountPath = substitution.ApplyReplacements(v.MountPath, stringReplacements)
                c.VolumeMounts[iv].SubPath = substitution.ApplyReplacements(v.SubPath, stringReplacements)
        }</span>
}
</pre>
		
		<pre class="file" id="file387" style="display: none">/*
 Copyright 2020 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package container

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/substitution"
)

// ApplySidecarReplacements applies variable interpolation on a Sidecar.
func ApplySidecarReplacements(sidecar *v1.Sidecar, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov8" title="1">{
        sidecar.Script = substitution.ApplyReplacements(sidecar.Script, stringReplacements)
        applySidecarReplacements(sidecar, stringReplacements, arrayReplacements)
}</span>
</pre>
		
		<pre class="file" id="file388" style="display: none">/*
 Copyright 2019 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package container

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/substitution"
)

// ApplyStepReplacements applies variable interpolation on a Step.
func ApplyStepReplacements(step *v1.Step, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov8" title="1">{
        step.Script = substitution.ApplyReplacements(step.Script, stringReplacements)
        step.OnError = (v1.OnErrorType)(substitution.ApplyReplacements(string(step.OnError), stringReplacements))
        if step.StdoutConfig != nil </span><span class="cov8" title="1">{
                step.StdoutConfig.Path = substitution.ApplyReplacements(step.StdoutConfig.Path, stringReplacements)
        }</span>
        <span class="cov8" title="1">if step.StderrConfig != nil </span><span class="cov8" title="1">{
                step.StderrConfig.Path = substitution.ApplyReplacements(step.StderrConfig.Path, stringReplacements)
        }</span>
        <span class="cov8" title="1">step.When = step.When.ReplaceVariables(stringReplacements, arrayReplacements)
        applyStepReplacements(step, stringReplacements, arrayReplacements)</span>
}

// ApplyStepTemplateReplacements applies variable interpolation on a StepTemplate (aka a container)
func ApplyStepTemplateReplacements(stepTemplate *v1.StepTemplate, stringReplacements map[string]string, arrayReplacements map[string][]string) <span class="cov0" title="0">{
        container := stepTemplate.ToK8sContainer()
        applyContainerReplacements(container, stringReplacements, arrayReplacements)
        stepTemplate.SetContainerFields(*container)
}</span>
</pre>
		
		<pre class="file" id="file389" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package controller provides helper methods for external controllers for
// Custom Task types.
package controller

import (
        "errors"
        "net/http"
        "strings"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
)

// IsWebhookTimeout checks if the error is due to a mutating admission webhook timeout.
// This function is used to determine if an error should trigger exponential backoff retry logic.
func IsWebhookTimeout(err error) bool <span class="cov8" title="1">{
        var statusErr *apierrors.StatusError
        if errors.As(err, &amp;statusErr) </span><span class="cov8" title="1">{
                return statusErr.ErrStatus.Code == http.StatusInternalServerError &amp;&amp;
                        strings.Contains(statusErr.ErrStatus.Message, "timeout")
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file390" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package controller provides helper methods for external controllers for
// Custom Task types.
package controller

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        listersbeta "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// FilterCustomRunRef returns a filter that can be passed to a CustomRun Informer, which
// filters out CustomRuns for apiVersion and kinds that a controller doesn't care
// about.
//
// For example, a controller impl that wants to be notified of updates to CustomRuns
// which reference a Task with apiVersion "example.dev/v0" and kind "Example":
//
//        customruninformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
//          FilterFunc: FilterCustomRunRef("example.dev/v0", "Example"),
//          Handler:    controller.HandleAll(impl.Enqueue),
//        })
func FilterCustomRunRef(apiVersion, kind string) func(interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov8" title="1">{
                r, ok := obj.(*v1beta1.CustomRun)
                if !ok </span><span class="cov8" title="1">{
                        // Somehow got informed of a non-CustomRun object.
                        // Ignore.
                        return false
                }</span>
                <span class="cov8" title="1">if r == nil || (r.Spec.CustomRef == nil &amp;&amp; r.Spec.CustomSpec == nil) </span><span class="cov8" title="1">{
                        // These are invalid, but just in case they get
                        // created somehow, don't panic.
                        return false
                }</span>
                <span class="cov8" title="1">result := false
                if r.Spec.CustomRef != nil </span><span class="cov8" title="1">{
                        result = r.Spec.CustomRef.APIVersion == apiVersion &amp;&amp; r.Spec.CustomRef.Kind == v1beta1.TaskKind(kind)
                }</span> else<span class="cov8" title="1"> if r.Spec.CustomSpec != nil </span><span class="cov8" title="1">{
                        result = r.Spec.CustomSpec.APIVersion == apiVersion &amp;&amp; r.Spec.CustomSpec.Kind == kind
                }</span>
                <span class="cov8" title="1">return result</span>
        }
}

// FilterOwnerCustomRunRef returns a filter that can be passed to an Informer for any runtime object, which
// filters out objects that aren't controlled by a CustomRun that references a particular apiVersion and kind.
//
// For example, a controller impl that wants to be notified of updates to TaskRuns that are controlled by
// a CustomRun which references a custom task with apiVersion "example.dev/v0" and kind "Example":
//
//        taskruninformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
//          FilterFunc: FilterOwnerCustomRunRef("example.dev/v0", "Example"),
//          Handler:    controller.HandleAll(impl.Enqueue),
//        })
func FilterOwnerCustomRunRef(customRunLister listersbeta.CustomRunLister, apiVersion, kind string) func(interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov8" title="1">{
                object, ok := obj.(metav1.Object)
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">owner := metav1.GetControllerOf(object)
                if owner == nil </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">if owner.APIVersion != v1beta1.SchemeGroupVersion.String() || owner.Kind != pipeline.CustomRunControllerName </span><span class="cov8" title="1">{
                        // Not owned by a CustomRun
                        return false
                }</span>
                <span class="cov8" title="1">run, err := customRunLister.CustomRuns(object.GetNamespace()).Get(owner.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if run.Spec.CustomRef == nil &amp;&amp; run.Spec.CustomSpec == nil </span><span class="cov8" title="1">{
                        // These are invalid, but just in case they get created somehow, don't panic.
                        return false
                }</span>
                <span class="cov8" title="1">if run.Spec.CustomRef != nil &amp;&amp; run.Spec.CustomSpec != nil </span><span class="cov8" title="1">{
                        // These are invalid.
                        return false
                }</span>
                <span class="cov8" title="1">result := false
                if run.Spec.CustomRef != nil </span><span class="cov8" title="1">{
                        result = run.Spec.CustomRef.APIVersion == apiVersion &amp;&amp; run.Spec.CustomRef.Kind == v1beta1.TaskKind(kind)
                }</span> else<span class="cov8" title="1"> if run.Spec.CustomSpec != nil </span><span class="cov8" title="1">{
                        result = run.Spec.CustomSpec.APIVersion == apiVersion &amp;&amp; run.Spec.CustomSpec.Kind == kind
                }</span>
                <span class="cov8" title="1">return result</span>
        }
}
</pre>
		
		<pre class="file" id="file391" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dockercreds

import (
        "encoding/base64"
        "encoding/json"
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/tektoncd/pipeline/pkg/credentials/common"
        credmatcher "github.com/tektoncd/pipeline/pkg/credentials/matcher"
        credwriter "github.com/tektoncd/pipeline/pkg/credentials/writer"
)

const annotationPrefix = "tekton.dev/docker-"

var (
        config       basicDocker
        dockerConfig arrayArg
        dockerCfg    arrayArg
)

// AddFlags adds CLI flags that dockercreds supports to a given flag.FlagSet.
func AddFlags(flagSet *flag.FlagSet) <span class="cov8" title="1">{
        flags(flagSet)
}</span>

func flags(fs *flag.FlagSet) <span class="cov8" title="1">{
        config = basicDocker{make(map[string]entry)}
        dockerConfig = arrayArg{[]string{}}
        dockerCfg = arrayArg{[]string{}}
        fs.Var(&amp;config, "basic-docker", "List of secret=url pairs.")
        fs.Var(&amp;dockerConfig, "docker-config", "Docker config.json secret file.")
        fs.Var(&amp;dockerCfg, "docker-cfg", "Docker .dockercfg secret file.")
}</span>

// As the flag is read, this status is populated.
// basicDocker implements flag.Value
type basicDocker struct {
        Entries map[string]entry `json:"auths"`
}

func (dc *basicDocker) String() string <span class="cov8" title="1">{
        if dc == nil </span><span class="cov0" title="0">{
                // According to flag.Value this can happen.
                return ""
        }</span>
        <span class="cov8" title="1">var urls []string
        for k, v := range dc.Entries </span><span class="cov0" title="0">{
                urls = append(urls, fmt.Sprintf("%s=%s", v.Secret, k))
        }</span>
        <span class="cov8" title="1">return strings.Join(urls, ",")</span>
}

// Set sets a secret for a URL from a value in the format of "secret=url"
func (dc *basicDocker) Set(value string) error <span class="cov8" title="1">{
        parts := strings.Split(value, "=")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("expect entries of the form secret=url, got: %v", value)
        }</span>
        <span class="cov8" title="1">secret := parts[0]
        url := parts[1]

        if _, ok := dc.Entries[url]; ok </span><span class="cov8" title="1">{
                return fmt.Errorf("multiple entries for url: %v", url)
        }</span>

        <span class="cov8" title="1">e, err := newEntry(secret)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dc.Entries[url] = *e
        return nil</span>
}

type arrayArg struct {
        Values []string
}

// Set adds a value to the arrayArg's value slice
func (aa *arrayArg) Set(value string) error <span class="cov8" title="1">{
        aa.Values = append(aa.Values, value)
        return nil
}</span>

func (aa *arrayArg) String() string <span class="cov8" title="1">{
        return strings.Join(aa.Values, ",")
}</span>

type configFile struct {
        Auth map[string]entry `json:"auths"`
}

type entry struct {
        Secret   string `json:"-"`
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`
        Auth     string `json:"auth"`
        Email    string `json:"email,omitempty"`
}

func newEntry(secret string) (*entry, error) <span class="cov8" title="1">{
        secretPath := credmatcher.VolumeName(secret)

        ub, err := os.ReadFile(filepath.Join(secretPath, common.BasicAuthUsernameKey))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">username := string(ub)

        pb, err := os.ReadFile(filepath.Join(secretPath, common.BasicAuthPasswordKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">password := string(pb)

        return &amp;entry{
                Secret:   secret,
                Username: username,
                Password: password,
                Auth:     base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password))),
                Email:    "not@val.id",
        }, nil</span>
}

type basicDockerBuilder struct{}

// NewBuilder returns a new builder for Docker credentials.
func NewBuilder() interface {
        credmatcher.Matcher
        credwriter.Writer
} <span class="cov8" title="1">{
        return &amp;basicDockerBuilder{}
}</span>

// MatchingAnnotations extracts flags for the credential helper
// from the supplied secret and returns a slice (of length 0 or
// greater) of applicable domains.
func (*basicDockerBuilder) MatchingAnnotations(secret credmatcher.Secret) []string <span class="cov8" title="1">{
        var flags []string
        switch credmatcher.GetSecretType(secret) </span>{
        case common.SecretTypeBasicAuth:<span class="cov8" title="1">
                for _, v := range credwriter.SortAnnotations(secret.GetAnnotations(), annotationPrefix) </span><span class="cov8" title="1">{
                        flags = append(flags, fmt.Sprintf("-basic-docker=%s=%s", secret.GetName(), v))
                }</span>
        case common.SecretTypeDockerConfigJson:<span class="cov8" title="1">
                flags = append(flags, "-docker-config="+secret.GetName())</span>
        case common.SecretTypeDockercfg:<span class="cov8" title="1">
                flags = append(flags, "-docker-cfg="+secret.GetName())</span>

        case common.SecretTypeOpaque, common.SecretTypeServiceAccountToken, common.SecretTypeSSHAuth, common.SecretTypeTLS, common.SecretTypeBootstrapToken:<span class="cov8" title="1">
                fallthrough</span>

        default:<span class="cov8" title="1">
                return flags</span>
        }

        <span class="cov8" title="1">return flags</span>
}

// Write builds a .docker/config.json file from a combination
// of kubernetes docker registry secrets and tekton docker
// secret entries and writes it to the given directory. If
// no entries exist then nothing will be written to disk.
func (*basicDockerBuilder) Write(directory string) error <span class="cov8" title="1">{
        dockerDir := filepath.Join(directory, ".docker")
        basicDocker := filepath.Join(dockerDir, "config.json")
        cf := configFile{Auth: config.Entries}
        auth := map[string]entry{}

        for _, secretName := range dockerCfg.Values </span><span class="cov8" title="1">{
                dockerConfigAuthMap, err := authsFromDockerCfg(secretName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range dockerConfigAuthMap </span><span class="cov8" title="1">{
                        auth[k] = v
                }</span>
        }

        <span class="cov8" title="1">for _, secretName := range dockerConfig.Values </span><span class="cov8" title="1">{
                dockerConfigAuthMap, err := authsFromDockerConfig(secretName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range dockerConfigAuthMap </span><span class="cov8" title="1">{
                        auth[k] = v
                }</span>
        }
        <span class="cov8" title="1">for k, v := range config.Entries </span><span class="cov8" title="1">{
                auth[k] = v
        }</span>
        <span class="cov8" title="1">if len(auth) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(dockerDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cf.Auth = auth
        content, err := json.Marshal(cf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(basicDocker, content, 0o600)</span>
}

func authsFromDockerCfg(secret string) (map[string]entry, error) <span class="cov8" title="1">{
        secretPath := credmatcher.VolumeName(secret)
        m := make(map[string]entry)
        data, err := os.ReadFile(filepath.Join(secretPath, common.DockerConfigKey))
        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;m)
        return m, err</span>
}

func authsFromDockerConfig(secret string) (map[string]entry, error) <span class="cov8" title="1">{
        secretPath := credmatcher.VolumeName(secret)
        m := make(map[string]entry)
        c := configFile{}
        data, err := os.ReadFile(filepath.Join(secretPath, common.DockerConfigJsonKey))
        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;c); err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov8" title="1">for k, v := range c.Auth </span><span class="cov8" title="1">{
                m[k] = v
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file392" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitcreds

import (
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "github.com/tektoncd/pipeline/pkg/credentials/common"
        credmatcher "github.com/tektoncd/pipeline/pkg/credentials/matcher"
)

// As the flag is read, this status is populated.
// basicGitConfig implements flag.Value
type basicGitConfig struct {
        entries map[string]basicEntry
        // The order we see things, for iterating over the above.
        order []string
}

func (dc *basicGitConfig) String() string <span class="cov8" title="1">{
        if dc == nil </span><span class="cov0" title="0">{
                // According to flag.Value this can happen.
                return ""
        }</span>
        <span class="cov8" title="1">var urls []string
        for _, k := range dc.order </span><span class="cov0" title="0">{
                v := dc.entries[k]
                urls = append(urls, fmt.Sprintf("%s=%s", v.secret, k))
        }</span>
        <span class="cov8" title="1">return strings.Join(urls, ",")</span>
}

// Set sets a secret for a given URL from a "secret=url" value.
func (dc *basicGitConfig) Set(value string) error <span class="cov8" title="1">{
        parts := strings.Split(value, "=")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("expect entries of the form secret=url, got: %v", value)
        }</span>
        <span class="cov8" title="1">secret := parts[0]
        url := parts[1]

        if _, ok := dc.entries[url]; ok </span><span class="cov8" title="1">{
                return fmt.Errorf("multiple entries for url: %v", url)
        }</span>

        <span class="cov8" title="1">e, err := newBasicEntry(url, secret)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dc.entries[url] = *e
        dc.order = append(dc.order, url)
        return nil</span>
}

// Write builds a .gitconfig file from dc.entries and writes it to disk
// in the directory provided. If dc.entries is empty then nothing is
// written.
func (dc *basicGitConfig) Write(directory string) error <span class="cov8" title="1">{
        if len(dc.entries) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">gitConfigPath := filepath.Join(directory, ".gitconfig")
        gitConfigs := []string{
                "[credential]\n        helper = store\n",
        }
        for _, k := range dc.order </span><span class="cov8" title="1">{
                v := dc.entries[k]
                gitConfigs = append(gitConfigs, v.configBlurb(k))
        }</span>
        <span class="cov8" title="1">gitConfigContent := strings.Join(gitConfigs, "")
        if err := os.WriteFile(gitConfigPath, []byte(gitConfigContent), 0600); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gitCredentialsPath := filepath.Join(directory, ".git-credentials")
        var gitCredentials []string
        for _, k := range dc.order </span><span class="cov8" title="1">{
                v := dc.entries[k]
                gitCredentials = append(gitCredentials, v.authURL.String())
        }</span>
        <span class="cov8" title="1">gitCredentials = append(gitCredentials, "") // Get a trailing newline
        gitCredentialsContent := strings.Join(gitCredentials, "\n")
        return os.WriteFile(gitCredentialsPath, []byte(gitCredentialsContent), 0600)</span>
}

type basicEntry struct {
        secret   string
        username string
        password string
        // Has the form: https://user:pass@url.com
        authURL *url.URL
}

func (be *basicEntry) configBlurb(u string) string <span class="cov8" title="1">{
        return fmt.Sprintf("[credential %q]\n        username = %s\n", u, be.escapedUsername())
}</span>

func (be *basicEntry) escapedUsername() string <span class="cov8" title="1">{
        if strings.Contains(be.username, "\\") </span><span class="cov8" title="1">{
                return strings.ReplaceAll(be.username, "\\", "\\\\")
        }</span>
        <span class="cov8" title="1">return be.username</span>
}

func newBasicEntry(u, secret string) (*basicEntry, error) <span class="cov8" title="1">{
        secretPath := credmatcher.VolumeName(secret)

        ub, err := os.ReadFile(filepath.Join(secretPath, common.BasicAuthUsernameKey))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">username := string(ub)

        pb, err := os.ReadFile(filepath.Join(secretPath, common.BasicAuthPasswordKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">password := string(pb)

        pu, err := url.Parse(u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">pu.User = url.UserPassword(username, password)

        return &amp;basicEntry{
                secret:   secret,
                username: username,
                password: password,
                authURL:  pu,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file393" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitcreds

import (
        "flag"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/credentials/common"
        credmatcher "github.com/tektoncd/pipeline/pkg/credentials/matcher"
        credwriter "github.com/tektoncd/pipeline/pkg/credentials/writer"
)

const (
        annotationPrefix = "tekton.dev/git-"
        basicAuthFlag    = "basic-git"
        sshFlag          = "ssh-git"
)

var (
        basicConfig basicGitConfig
        sshConfig   sshGitConfig
)

// AddFlags adds CLI flags that gitcreds supports to a given flag.FlagSet.
func AddFlags(flagSet *flag.FlagSet) <span class="cov8" title="1">{
        flags(flagSet)
}</span>

func flags(fs *flag.FlagSet) <span class="cov8" title="1">{
        basicConfig = basicGitConfig{
                entries: make(map[string]basicEntry),
                order:   []string{},
        }
        sshConfig = sshGitConfig{
                entries: make(map[string][]sshEntry),
                order:   []string{},
        }
        fs.Var(&amp;basicConfig, basicAuthFlag, "List of secret=url pairs.")
        fs.Var(&amp;sshConfig, sshFlag, "List of secret=url pairs.")
}</span>

type gitBuilder struct{}

// NewBuilder returns a new builder for Git credentials.
func NewBuilder() interface {
        credmatcher.Matcher
        credwriter.Writer
} <span class="cov8" title="1">{
        return &amp;gitBuilder{}
}</span>

// MatchingAnnotations extracts flags for the credential helper
// from the supplied secret and returns a slice (of length 0 or
// greater) of applicable domains.
func (*gitBuilder) MatchingAnnotations(secret credmatcher.Secret) []string <span class="cov8" title="1">{
        var flagName string
        var flags []string
        switch credmatcher.GetSecretType(secret) </span>{
        case common.SecretTypeBasicAuth:<span class="cov8" title="1">
                flagName = basicAuthFlag</span>
        case common.SecretTypeSSHAuth:<span class="cov8" title="1">
                flagName = sshFlag</span>
        case common.SecretTypeOpaque, common.SecretTypeServiceAccountToken, common.SecretTypeDockercfg, common.SecretTypeDockerConfigJson, common.SecretTypeTLS, common.SecretTypeBootstrapToken:<span class="cov8" title="1">
                fallthrough</span>
        default:<span class="cov8" title="1">
                return flags</span>
        }

        <span class="cov8" title="1">for _, v := range credwriter.SortAnnotations(secret.GetAnnotations(), annotationPrefix) </span><span class="cov8" title="1">{
                flags = append(flags, fmt.Sprintf("-%s=%s=%s", flagName, secret.GetName(), v))
        }</span>

        <span class="cov8" title="1">return flags</span>
}

// Write writes the credentials to the provided directory.
func (*gitBuilder) Write(directory string) error <span class="cov8" title="1">{
        if err := basicConfig.Write(directory); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return sshConfig.Write(directory)</span>
}
</pre>
		
		<pre class="file" id="file394" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitcreds

import (
        "fmt"
        "net"
        "os"
        "path/filepath"
        "strings"

        "github.com/tektoncd/pipeline/pkg/credentials/common"
        credmatcher "github.com/tektoncd/pipeline/pkg/credentials/matcher"
)

const sshKnownHosts = "known_hosts"

// As the flag is read, this status is populated.
// sshGitConfig implements flag.Value
type sshGitConfig struct {
        entries map[string][]sshEntry
        // The order we see things, for iterating over the above.
        order []string
}

func (dc *sshGitConfig) String() string <span class="cov8" title="1">{
        if dc == nil </span><span class="cov0" title="0">{
                // According to flag.Value this can happen.
                return ""
        }</span>
        <span class="cov8" title="1">var urls []string
        for _, k := range dc.order </span><span class="cov0" title="0">{
                for _, e := range dc.entries[k] </span><span class="cov0" title="0">{
                        urls = append(urls, fmt.Sprintf("%s=%s", e.secretName, k))
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(urls, ",")</span>
}

// Set sets a secret for a given URL from a "secret=url" value.
func (dc *sshGitConfig) Set(value string) error <span class="cov8" title="1">{
        parts := strings.Split(value, "=")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("expect entries of the form secret=url, got: %v", value)
        }</span>
        <span class="cov8" title="1">secretName := parts[0]
        url := parts[1]

        e, err := newSSHEntry(url, secretName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if _, exists := dc.entries[url]; !exists </span><span class="cov8" title="1">{
                dc.order = append(dc.order, url)
        }</span>
        <span class="cov8" title="1">dc.entries[url] = append(dc.entries[url], *e)
        return nil</span>
}

// Write puts dc's ssh entries into files in a .ssh directory, under
// the given directory. If dc has no entries then nothing is written.
func (dc *sshGitConfig) Write(directory string) error <span class="cov8" title="1">{
        if len(dc.entries) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">sshDir := filepath.Join(directory, ".ssh")
        if err := os.MkdirAll(sshDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Walk each of the entries and for each do three things:
        //  1. Write out: ~/.ssh/id_{secretName} with the secret key
        //  2. Compute its part of "~/.ssh/config"
        //  3. Compute its part of "~/.ssh/known_hosts"
        <span class="cov8" title="1">var configEntries []string
        var defaultPort = "22"
        var knownHosts []string
        for _, k := range dc.order </span><span class="cov8" title="1">{
                var host, port string
                var err error
                if host, port, err = net.SplitHostPort(k); err != nil </span><span class="cov8" title="1">{
                        host = k
                        port = defaultPort
                }</span>
                <span class="cov8" title="1">configEntry := fmt.Sprintf(`Host %s
    HostName %s
    Port %s
`, host, host, port)
                for _, e := range dc.entries[k] </span><span class="cov8" title="1">{
                        if err := e.Write(sshDir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">configEntry += fmt.Sprintf(`    IdentityFile %s
`, e.path(sshDir))
                        if e.knownHosts != "" </span><span class="cov8" title="1">{
                                knownHosts = append(knownHosts, e.knownHosts)
                        }</span>
                }
                <span class="cov8" title="1">configEntries = append(configEntries, configEntry)</span>
        }
        <span class="cov8" title="1">configPath := filepath.Join(sshDir, "config")
        configContent := strings.Join(configEntries, "")
        if err := os.WriteFile(configPath, []byte(configContent), 0600); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(knownHosts) &gt; 0 </span><span class="cov8" title="1">{
                knownHostsPath := filepath.Join(sshDir, "known_hosts")
                knownHostsContent := strings.Join(knownHosts, "\n")
                return os.WriteFile(knownHostsPath, []byte(knownHostsContent), 0600)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type sshEntry struct {
        secretName string
        privateKey string
        knownHosts string
}

func (be *sshEntry) path(sshDir string) string <span class="cov8" title="1">{
        return filepath.Join(sshDir, "id_"+be.secretName)
}</span>

func (be *sshEntry) Write(sshDir string) error <span class="cov8" title="1">{
        return os.WriteFile(be.path(sshDir), []byte(be.privateKey), 0600)
}</span>

func newSSHEntry(url, secretName string) (*sshEntry, error) <span class="cov8" title="1">{
        secretPath := credmatcher.VolumeName(secretName)

        pk, err := os.ReadFile(filepath.Join(secretPath, common.SSHAuthPrivateKey))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">privateKey := string(pk)

        knownHosts := ""
        if kh, err := os.ReadFile(filepath.Join(secretPath, sshKnownHosts)); err == nil </span><span class="cov8" title="1">{
                knownHosts = string(kh)
        }</span>

        <span class="cov8" title="1">return &amp;sshEntry{
                secretName: secretName,
                privateKey: privateKey,
                knownHosts: knownHosts,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file395" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package matcher

import (
        "fmt"
        "reflect"
)

// VolumePath is the path where build secrets are written.
// It is mutable and exported for testing.
var VolumePath = "/tekton/creds-secrets"

// Secret is the minimal interface needed for credential matching
type Secret interface {
        GetName() string
        GetAnnotations() map[string]string
}

// Matcher is the interface for a credential initializer of any type.
type Matcher interface {
        // MatchingAnnotations extracts flags for the credential
        // helper from the supplied secret and returns a slice (of length 0 or greater)
        MatchingAnnotations(secret Secret) []string
}

// VolumeName returns the full path to the secret, inside the VolumePath.
func VolumeName(secretName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", VolumePath, secretName)
}</span>

// GetSecretType returns secret type from secret interface using reflection
func GetSecretType(secret Secret) string <span class="cov8" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">v := reflect.ValueOf(secret)
        // If a pointer, check if it's nil before dereferencing
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">v = v.Elem()</span>
        }
        // access the Type field for Kubernetes secrets
        <span class="cov8" title="1">f := v.FieldByName("Type")
        if !f.IsValid() || !f.CanInterface() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%v", f.Interface())</span>
}
</pre>
		
		<pre class="file" id="file396" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package writer

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
)

const (
        // credsDirPermissions are the persmission bits assigned to the directories
        // copied out of the /tekton/creds and into a Step's HOME.
        credsDirPermissions = 0o700

        // credsFilePermissions are the persmission bits assigned to the files
        // copied out of /tekton/creds and into a Step's HOME.
        credsFilePermissions = 0o600
)

// CredsInitCredentials is the complete list of credentials that the legacy credentials
// helper (aka "creds-init") can write to /tekton/creds.
var CredsInitCredentials = []string{".docker", ".gitconfig", ".git-credentials", ".ssh"}

// Writer is the interface for a credential initializer of any type.
type Writer interface {
        // Write writes the credentials to the provided directory.
        Write(folder string) error
}

// SortAnnotations return sorted array of strings which has annotationPrefix
// as the prefix in secrets key
func SortAnnotations(secrets map[string]string, annotationPrefix string) []string <span class="cov0" title="0">{
        var mk []string
        for k, v := range secrets </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, annotationPrefix) </span><span class="cov0" title="0">{
                        mk = append(mk, v)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(mk)
        return mk</span>
}

// CopyCredsToHome copies credentials from the /tekton/creds directory into
// the current Step's HOME directory. A list of credential paths to try and
// copy is given as an arg, for example, []string{".docker", ".ssh"}. A missing
// /tekton/creds directory is not considered an error.
func CopyCredsToHome(credPaths []string) error <span class="cov0" title="0">{
        if info, err := os.Stat(pipeline.CredsDir); err != nil || !info.IsDir() </span><span class="cov0" title="0">{
                return nil //nolint:nilerr // safe to ignore error; no credentials available to copy
        }</span>

        <span class="cov0" title="0">homepath, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting the user's home directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, cred := range credPaths </span><span class="cov0" title="0">{
                source := filepath.Join(pipeline.CredsDir, cred)
                destination := filepath.Join(homepath, cred)
                err := tryCopyCred(source, destination)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: unsuccessful cred copy: %q from %q to %q: %v", cred, pipeline.CredsDir, homepath, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// tryCopyCred will recursively copy a given source path to a given
// destination path. A missing source file is treated as normal behaviour
// and no error is returned.
func tryCopyCred(source, destination string) error <span class="cov8" title="1">{
        fromInfo, err := os.Lstat(source)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unable to read source file info: %w", err)</span>
        }

        <span class="cov8" title="1">fromFile, err := os.Open(filepath.Clean(source))
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unable to open source: %w", err)</span>
        }
        <span class="cov8" title="1">defer fromFile.Close()

        if fromInfo.IsDir() </span><span class="cov8" title="1">{
                err := os.MkdirAll(destination, credsDirPermissions)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to create destination directory: %w", err)
                }</span>
                <span class="cov8" title="1">subdirs, err := fromFile.Readdirnames(0)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to read subdirectories of source: %w", err)
                }</span>
                <span class="cov8" title="1">for _, subdir := range subdirs </span><span class="cov8" title="1">{
                        src := filepath.Join(source, subdir)
                        dst := filepath.Join(destination, subdir)
                        if err := tryCopyCred(src, dst); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                flags := os.O_RDWR | os.O_CREATE | os.O_TRUNC
                toFile, err := os.OpenFile(destination, flags, credsFilePermissions)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to open destination: %w", err)
                }</span>
                <span class="cov8" title="1">defer toFile.Close()

                _, err = io.Copy(toFile, fromFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error copying from source to destination: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file397" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package entrypoint

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"

        "log"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/pipeline/internal/artifactref"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1/types"
        "github.com/tektoncd/pipeline/pkg/entrypoint/pipeline"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "github.com/tektoncd/pipeline/pkg/result"
        "github.com/tektoncd/pipeline/pkg/termination"
)

// RFC3339 with millisecond
const (
        timeFormat      = "2006-01-02T15:04:05.000Z07:00"
        ContinueOnError = "continue"
        FailOnError     = "stopAndFail"
)

const (
        breakpointExitSuffix                     = ".breakpointexit"
        breakpointBeforeStepSuffix               = ".beforestepexit"
        ResultExtractionMethodTerminationMessage = "termination-message"
        TerminationReasonSkipped                 = "Skipped"
        TerminationReasonCancelled               = "Cancelled"
        TerminationReasonTimeoutExceeded         = "TimeoutExceeded"
        // DownwardMountCancelFile is cancellation file mount to step, entrypoint will check this file to cancel the step.
        downwardMountPoint      = "/tekton/downward"
        downwardMountCancelFile = "cancel"
        stepPrefix              = "step-"
)
const (
        // CredsDir is the directory where credentials are placed to meet the legacy credentials
        // helpers image (aka "creds-init") contract
        CredsDir = "/tekton/creds" // #nosec
)

var DownwardMountCancelFile string

func init() <span class="cov8" title="1">{
        DownwardMountCancelFile = filepath.Join(downwardMountPoint, downwardMountCancelFile)
}</span>

// DebugBeforeStepError is an error means mark before step breakpoint failure
type DebugBeforeStepError string

func (e DebugBeforeStepError) Error() string <span class="cov8" title="1">{
        return string(e)
}</span>

var (
        errDebugBeforeStep = DebugBeforeStepError("before step breakpoint error file, user decided to skip the current step execution")
)

// ScriptDir for testing
var ScriptDir = pipeline.ScriptDir

// ContextError context error type
type ContextError string

// Error implements error interface
func (e ContextError) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>

type SkipError string

func (e SkipError) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>

var (
        // ErrContextDeadlineExceeded is the error returned when the context deadline is exceeded
        ErrContextDeadlineExceeded = ContextError(context.DeadlineExceeded.Error())
        // ErrContextCanceled is the error returned when the context is canceled
        ErrContextCanceled = ContextError(context.Canceled.Error())
        // ErrSkipPreviousStepFailed is the error returned when the step is skipped due to previous step error
        ErrSkipPreviousStepFailed = SkipError("error file present, bail and skip the step")
)

// IsContextDeadlineError determine whether the error is context deadline
func IsContextDeadlineError(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrContextDeadlineExceeded)
}</span>

// IsContextCanceledError determine whether the error is context canceled
func IsContextCanceledError(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrContextCanceled)
}</span>

// Entrypointer holds fields for running commands with redirected
// entrypoints.
type Entrypointer struct {
        // Command is the original specified command and args.
        Command []string

        // WaitFiles is the set of files to wait for. If empty, execution
        // begins immediately.
        WaitFiles []string
        // WaitFileContent indicates the WaitFile should have non-zero size
        // before continuing with execution.
        WaitFileContent bool
        // PostFile is the file to write when complete. If not specified, no
        // file is written.
        PostFile string

        // Termination path is the path of a file to write the starting time of this endpopint
        TerminationPath string

        // Waiter encapsulates waiting for files to exist.
        Waiter Waiter
        // Runner encapsulates running commands.
        Runner Runner
        // PostWriter encapsulates writing files when complete.
        PostWriter PostWriter

        // StepResults is the set of files that might contain step results
        StepResults []string
        // Results is the set of files that might contain task results
        Results []string
        // Timeout is an optional user-specified duration within which the Step must complete
        Timeout *time.Duration
        // BreakpointOnFailure helps determine if entrypoint execution needs to adapt debugging requirements
        BreakpointOnFailure bool
        // DebugBeforeStep help user attach container before execution
        DebugBeforeStep bool
        // OnError defines exiting behavior of the entrypoint
        // set it to "stopAndFail" to indicate the entrypoint to exit the taskRun if the container exits with non zero exit code
        // set it to "continue" to indicate the entrypoint to continue executing the rest of the steps irrespective of the container exit code
        OnError string
        // StepMetadataDir is the directory for a step where the step related metadata can be stored
        StepMetadataDir string
        // SpireWorkloadAPI connects to spire and does obtains SVID based on taskrun
        SpireWorkloadAPI EntrypointerAPIClient
        // ResultsDirectory is the directory to find results, defaults to pipeline.DefaultResultPath
        ResultsDirectory string
        // ResultExtractionMethod is the method using which the controller extracts the results from the task pod.
        ResultExtractionMethod string

        // StepWhenExpressions     a list of when expression to decide if the step should be skipped
        StepWhenExpressions v1.StepWhenExpressions

        // ArtifactsDirectory is the directory to find artifacts, defaults to pipeline.ArtifactsDir
        ArtifactsDirectory string
}

// Waiter encapsulates waiting for files to exist.
type Waiter interface {
        // Wait blocks until the specified file exists or the context is done.
        Wait(ctx context.Context, file string, expectContent bool, breakpointOnFailure bool) error
}

// Runner encapsulates running commands.
type Runner interface {
        Run(ctx context.Context, args ...string) error
}

// PostWriter encapsulates writing a file when complete.
type PostWriter interface {
        // Write writes to the path when complete.
        Write(file, content string)
}

// Go optionally waits for a file, runs the command, and writes a
// post file.
func (e Entrypointer) Go() error <span class="cov8" title="1">{
        output := []result.RunResult{}
        defer func() </span><span class="cov8" title="1">{
                if wErr := termination.WriteMessage(e.TerminationPath, output); wErr != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error while writing message: %s", wErr)
                }</span>
        }()

        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Join(e.StepMetadataDir, "results"), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Join(e.StepMetadataDir, "artifacts"), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, f := range e.WaitFiles </span><span class="cov8" title="1">{
                if err := e.Waiter.Wait(context.Background(), f, e.WaitFileContent, e.BreakpointOnFailure); err != nil </span><span class="cov8" title="1">{
                        // An error happened while waiting, so we bail
                        // *but* we write postfile to make next steps bail too.
                        // In case of breakpoint on failure do not write post file.
                        if !e.BreakpointOnFailure </span><span class="cov8" title="1">{
                                e.WritePostFile(e.PostFile, err)
                        }</span>
                        <span class="cov8" title="1">output = append(output, result.RunResult{
                                Key:        "StartedAt",
                                Value:      time.Now().Format(timeFormat),
                                ResultType: result.InternalTektonResultType,
                        })

                        if errors.Is(err, ErrSkipPreviousStepFailed) </span><span class="cov8" title="1">{
                                output = append(output, e.outputRunResult(TerminationReasonSkipped))
                        }</span>

                        <span class="cov8" title="1">return err</span>
                }
        }

        <span class="cov8" title="1">var err error
        if e.DebugBeforeStep </span><span class="cov8" title="1">{
                err = e.waitBeforeStepDebug()
        }</span>

        <span class="cov8" title="1">output = append(output, result.RunResult{
                Key:        "StartedAt",
                Value:      time.Now().Format(timeFormat),
                ResultType: result.InternalTektonResultType,
        })

        if e.Timeout != nil &amp;&amp; *e.Timeout &lt; time.Duration(0) </span><span class="cov8" title="1">{
                err = errors.New("negative timeout specified")
        }</span>
        <span class="cov8" title="1">ctx := context.Background()
        var cancel context.CancelFunc
        if err == nil </span><span class="cov8" title="1">{
                if err := e.applyStepResultSubstitutions(pipeline.StepsDir); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error while substituting step results:", slog.Any("error", err))
                }</span>
                <span class="cov8" title="1">if err := e.applyStepArtifactSubstitutions(pipeline.StepsDir); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error while substituting step artifacts:", slog.Any("error", err))
                }</span>

                <span class="cov8" title="1">ctx, cancel = context.WithCancel(ctx)
                if e.Timeout != nil &amp;&amp; *e.Timeout &gt; time.Duration(0) </span><span class="cov8" title="1">{
                        ctx, cancel = context.WithTimeout(ctx, *e.Timeout)
                }</span>
                <span class="cov8" title="1">defer cancel()
                // start a goroutine to listen for cancellation file
                go func() </span><span class="cov8" title="1">{
                        if err := e.waitingCancellation(ctx, cancel); err != nil &amp;&amp; (!IsContextCanceledError(err) &amp;&amp; !IsContextDeadlineError(err)) </span><span class="cov0" title="0">{
                                slog.Error("Error while waiting for cancellation", slog.Any("error", err))
                        }</span>
                }()
                <span class="cov8" title="1">allowExec, err1 := e.allowExec()

                switch </span>{
                case err1 != nil:<span class="cov0" title="0">
                        err = err1</span>
                case allowExec:<span class="cov8" title="1">
                        err = e.Runner.Run(ctx, e.Command...)</span>
                default:<span class="cov8" title="1">
                        slog.Info("Step was skipped due to when expressions were evaluated to false.")
                        output = append(output, e.outputRunResult(TerminationReasonSkipped))
                        e.WritePostFile(e.PostFile, nil)
                        e.WriteExitCodeFile(e.StepMetadataDir, "0")
                        return nil</span>
                }
        }

        <span class="cov8" title="1">var ee *exec.ExitError
        switch </span>{
        case err != nil &amp;&amp; errors.Is(err, errDebugBeforeStep):<span class="cov8" title="1">
                e.WritePostFile(e.PostFile, err)</span>
        case err != nil &amp;&amp; errors.Is(err, ErrContextCanceled):<span class="cov8" title="1">
                slog.Info("Step was canceling")
                output = append(output, e.outputRunResult(TerminationReasonCancelled))
                e.WritePostFile(e.PostFile, ErrContextCanceled)
                e.WriteExitCodeFile(e.StepMetadataDir, syscall.SIGKILL.String())</span>
        case errors.Is(err, ErrContextDeadlineExceeded):<span class="cov8" title="1">
                e.WritePostFile(e.PostFile, err)
                output = append(output, e.outputRunResult(TerminationReasonTimeoutExceeded))</span>
        case err != nil &amp;&amp; e.BreakpointOnFailure:<span class="cov0" title="0">
                slog.Info("Skipping writing to PostFile")</span>
        case e.OnError == ContinueOnError &amp;&amp; errors.As(err, &amp;ee):<span class="cov8" title="1">
                // with continue on error and an ExitError, write non-zero exit code and a post file
                exitCode := strconv.Itoa(ee.ExitCode())
                output = append(output, result.RunResult{
                        Key:        "ExitCode",
                        Value:      exitCode,
                        ResultType: result.InternalTektonResultType,
                })
                e.WritePostFile(e.PostFile, nil)
                e.WriteExitCodeFile(e.StepMetadataDir, exitCode)</span>
        case err == nil:<span class="cov8" title="1">
                // if err is nil, write zero exit code and a post file
                e.WritePostFile(e.PostFile, nil)
                e.WriteExitCodeFile(e.StepMetadataDir, "0")</span>
        default:<span class="cov8" title="1">
                // for a step without continue on error and any error, write a post file with .err
                e.WritePostFile(e.PostFile, err)</span>
        }

        // strings.Split(..) with an empty string returns an array that contains one element, an empty string.
        // This creates an error when trying to open the result folder as a file.
        <span class="cov8" title="1">if len(e.Results) &gt;= 1 &amp;&amp; e.Results[0] != "" </span><span class="cov8" title="1">{
                resultPath := pipeline.DefaultResultPath
                if e.ResultsDirectory != "" </span><span class="cov8" title="1">{
                        resultPath = e.ResultsDirectory
                }</span>
                <span class="cov8" title="1">if err := e.readResultsFromDisk(ctx, resultPath, result.TaskRunResultType); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error while substituting step artifacts:", slog.Any("error", err))
                        return err
                }</span>
        }
        <span class="cov8" title="1">if len(e.StepResults) &gt;= 1 &amp;&amp; e.StepResults[0] != "" </span><span class="cov8" title="1">{
                stepResultPath := filepath.Join(e.StepMetadataDir, "results")
                if e.ResultsDirectory != "" </span><span class="cov8" title="1">{
                        stepResultPath = e.ResultsDirectory
                }</span>
                <span class="cov8" title="1">if err := e.readResultsFromDisk(ctx, stepResultPath, result.StepResultType); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Error while substituting step artifacts:", slog.Any("error", err))
                        return err
                }</span>
        }

        <span class="cov8" title="1">if e.ResultExtractionMethod == ResultExtractionMethodTerminationMessage </span><span class="cov8" title="1">{
                e.appendArtifactOutputs(&amp;output)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func readArtifacts(fp string, resultType result.ResultType) ([]result.RunResult, error) <span class="cov8" title="1">{
        file, err := os.ReadFile(fp)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []result.RunResult{}, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return []result.RunResult{{Key: fp, Value: string(file), ResultType: resultType}}, nil</span>
}

func (e Entrypointer) appendArtifactOutputs(output *[]result.RunResult) <span class="cov8" title="1">{
        // step artifacts
        fp := filepath.Join(e.StepMetadataDir, "artifacts", "provenance.json")
        artifacts, err := readArtifacts(fp, result.StepArtifactsResultType)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error while handling step artifacts: %s", err)
        }</span>
        <span class="cov8" title="1">*output = append(*output, artifacts...)

        artifactsDir := pipeline.ArtifactsDir
        // task artifacts
        if e.ArtifactsDirectory != "" </span><span class="cov0" title="0">{
                artifactsDir = e.ArtifactsDirectory
        }</span>
        <span class="cov8" title="1">fp = filepath.Join(artifactsDir, "provenance.json")
        artifacts, err = readArtifacts(fp, result.TaskRunArtifactsResultType)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error while handling task artifacts: %s", err)
        }</span>
        <span class="cov8" title="1">*output = append(*output, artifacts...)</span>
}

func (e Entrypointer) allowExec() (bool, error) <span class="cov8" title="1">{
        when := e.StepWhenExpressions
        m := map[string]bool{}

        for _, we := range when </span><span class="cov8" title="1">{
                if we.CEL == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">b, ok := m[we.CEL]
                if ok &amp;&amp; !b </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">env, err := cel.NewEnv()
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">ast, iss := env.Compile(we.CEL)
                if iss.Err() != nil </span><span class="cov8" title="1">{
                        return false, iss.Err()
                }</span>
                // Generate an evaluable instance of the Ast within the environment
                <span class="cov8" title="1">prg, err := env.Program(ast)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                // Evaluate the CEL expression
                <span class="cov8" title="1">out, _, err := prg.Eval(map[string]interface{}{})
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">b, ok = out.Value().(bool)
                if !ok </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("the CEL expression %s is not evaluated to a boolean", we.CEL)
                }</span>
                <span class="cov8" title="1">if !b </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">m[we.CEL] = true</span>
        }
        <span class="cov8" title="1">return when.AllowsExecution(m), nil</span>
}

func (e Entrypointer) waitBeforeStepDebug() error <span class="cov8" title="1">{
        log.Println(`debug before step breakpoint has taken effect, waiting for user's decision:
1) continue, use cmd: /tekton/debug/scripts/debug-beforestep-continue
2) fail-continue, use cmd: /tekton/debug/scripts/debug-beforestep-fail-continue`)
        breakpointBeforeStepPostFile := e.PostFile + breakpointBeforeStepSuffix
        if waitErr := e.Waiter.Wait(context.Background(), breakpointBeforeStepPostFile, false, false); waitErr != nil </span><span class="cov8" title="1">{
                log.Println("error occurred while waiting for " + breakpointBeforeStepPostFile + " : " + errDebugBeforeStep.Error())
                return errDebugBeforeStep
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (e Entrypointer) readResultsFromDisk(ctx context.Context, resultDir string, resultType result.ResultType) error <span class="cov8" title="1">{
        output := []result.RunResult{}
        results := e.Results
        if resultType == result.StepResultType </span><span class="cov8" title="1">{
                results = e.StepResults
        }</span>
        <span class="cov8" title="1">for _, resultFile := range results </span><span class="cov8" title="1">{
                if resultFile == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">fileContents, err := os.ReadFile(filepath.Join(resultDir, resultFile))
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // if the file doesn't exist, ignore it
                <span class="cov8" title="1">output = append(output, result.RunResult{
                        Key:        resultFile,
                        Value:      string(fileContents),
                        ResultType: resultType,
                })</span>
        }

        <span class="cov8" title="1">signed, err := signResults(ctx, e.SpireWorkloadAPI, output)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">output = append(output, signed...)

        // push output to termination path
        if e.ResultExtractionMethod == ResultExtractionMethodTerminationMessage &amp;&amp; len(output) != 0 </span><span class="cov8" title="1">{
                if err := termination.WriteMessage(e.TerminationPath, output); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// BreakpointExitCode reads the post file and returns the exit code it contains
func (e Entrypointer) BreakpointExitCode(breakpointExitPostFile string) (int, error) <span class="cov8" title="1">{
        exitCode, err := os.ReadFile(breakpointExitPostFile)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("breakpoint postfile %s not found", breakpointExitPostFile)
        }</span>
        <span class="cov8" title="1">strExitCode := strings.TrimSuffix(string(exitCode), "\n")
        log.Println("Breakpoint exiting with exit code " + strExitCode)

        return strconv.Atoi(strExitCode)</span>
}

// WritePostFile write the postfile
func (e Entrypointer) WritePostFile(postFile string, err error) <span class="cov8" title="1">{
        if err != nil &amp;&amp; postFile != "" </span><span class="cov8" title="1">{
                postFile += ".err"
        }</span>
        <span class="cov8" title="1">if postFile != "" </span><span class="cov8" title="1">{
                e.PostWriter.Write(postFile, "")
        }</span>
}

// WriteExitCodeFile write the exitCodeFile
func (e Entrypointer) WriteExitCodeFile(stepPath, content string) <span class="cov8" title="1">{
        exitCodeFile := filepath.Join(stepPath, "exitCode")
        e.PostWriter.Write(exitCodeFile, content)
}</span>

// waitingCancellation waiting cancellation file, if no error occurs, call cancelFunc to cancel the context
func (e Entrypointer) waitingCancellation(ctx context.Context, cancel context.CancelFunc) error <span class="cov8" title="1">{
        if err := e.Waiter.Wait(ctx, DownwardMountCancelFile, true, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">cancel()
        return nil</span>
}

// CheckForBreakpointOnFailure if step up breakpoint on failure
// waiting breakpointExitPostFile to be written
func (e Entrypointer) CheckForBreakpointOnFailure() <span class="cov8" title="1">{
        if e.BreakpointOnFailure </span><span class="cov8" title="1">{
                log.Println(`debug onFailure breakpoint has taken effect, waiting for user's decision:
1) continue, use cmd: /tekton/debug/scripts/debug-continue
2) fail-continue, use cmd: /tekton/debug/scripts/debug-fail-continue`)
                breakpointExitPostFile := e.PostFile + breakpointExitSuffix
                if waitErr := e.Waiter.Wait(context.Background(), breakpointExitPostFile, false, false); waitErr != nil </span><span class="cov0" title="0">{
                        log.Println("error occurred while waiting for " + breakpointExitPostFile + " : " + waitErr.Error())
                }</span>
                // get exitcode from .breakpointexit
                <span class="cov8" title="1">exitCode, readErr := e.BreakpointExitCode(breakpointExitPostFile)
                // if readErr exists, the exitcode with default to 0 as we would like
                // to encourage to continue running the next steps in the taskRun
                if readErr != nil </span><span class="cov0" title="0">{
                        log.Println("error occurred while reading breakpoint exit code : " + readErr.Error())
                }</span>
                <span class="cov8" title="1">os.Exit(exitCode)</span>
        }
}

// GetContainerName prefixes the input name with "step-"
func GetContainerName(name string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s", stepPrefix, name)
}</span>

// loadStepResult reads the step result file and returns the string, array or object result value.
func loadStepResult(stepDir string, stepName string, resultName string) (v1.ResultValue, error) <span class="cov8" title="1">{
        v := v1.ResultValue{}
        fp := getStepResultPath(stepDir, GetContainerName(stepName), resultName)
        fileContents, err := os.ReadFile(fp)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov8" title="1">err = v.UnmarshalJSON(fileContents)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// getStepResultPath gets the path to the step result
func getStepResultPath(stepDir string, stepName string, resultName string) string <span class="cov8" title="1">{
        return filepath.Join(stepDir, stepName, "results", resultName)
}</span>

// findReplacement looks for any usage of step results in an input string.
// If found, it loads the results from the previous steps and provides the replacement value.
func findReplacement(stepDir string, s string) (string, []string, error) <span class="cov8" title="1">{
        value := strings.TrimSuffix(strings.TrimPrefix(s, "$("), ")")
        pr, err := resultref.ParseStepExpression(value)
        if err != nil </span><span class="cov8" title="1">{
                return "", nil, err
        }</span>
        <span class="cov8" title="1">result, err := loadStepResult(stepDir, pr.ResourceName, pr.ResultName)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov8" title="1">replaceWithArray := []string{}
        replaceWithString := ""

        switch pr.ResultType </span>{
        case "object":<span class="cov8" title="1">
                if pr.ObjectKey != "" </span><span class="cov8" title="1">{
                        replaceWithString = result.ObjectVal[pr.ObjectKey]
                }</span>
        case "array":<span class="cov8" title="1">
                if pr.ArrayIdx != nil </span><span class="cov8" title="1">{
                        replaceWithString = result.ArrayVal[*pr.ArrayIdx]
                }</span> else<span class="cov8" title="1"> {
                        replaceWithArray = append(replaceWithArray, result.ArrayVal...)
                }</span>
        // "string"
        default:<span class="cov8" title="1">
                replaceWithString = result.StringVal</span>
        }
        <span class="cov8" title="1">return replaceWithString, replaceWithArray, nil</span>
}

// replaceEnv performs replacements for step results in environment variables.
func replaceEnv(stepDir string) error <span class="cov8" title="1">{
        for _, e := range os.Environ() </span><span class="cov8" title="1">{
                pair := strings.SplitN(e, "=", 2)
                matches := resultref.StepResultRegex.FindAllStringSubmatch(pair[1], -1)
                v := pair[1]
                for _, m := range matches </span><span class="cov8" title="1">{
                        replaceWith, _, err := findReplacement(stepDir, m[0])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">v = strings.ReplaceAll(v, m[0], replaceWith)</span>
                }
                <span class="cov8" title="1">os.Setenv(pair[0], v)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// replaceCommandAndArgs performs replacements for step results in e.Command
func replaceCommandAndArgs(command []string, stepDir string) ([]string, error) <span class="cov8" title="1">{
        var newCommand []string
        for _, c := range command </span><span class="cov8" title="1">{
                matches := resultref.StepResultRegex.FindAllStringSubmatch(c, -1)
                newC := []string{c}
                for _, m := range matches </span><span class="cov8" title="1">{
                        replaceWithString, replaceWithArray, err := findReplacement(stepDir, m[0])
                        if err != nil </span><span class="cov8" title="1">{
                                return []string{}, fmt.Errorf("failed to find replacement for %s to replace %s", m[0], c)
                        }</span>
                        // replaceWithString and replaceWithArray are mutually exclusive
                        <span class="cov8" title="1">if len(replaceWithArray) &gt; 0 </span><span class="cov8" title="1">{
                                if c != m[0] </span><span class="cov8" title="1">{
                                        // it has to be exact in "$(steps.&lt;step-name&gt;.results.&lt;result-name&gt;[*])" format, without anything else in the original string
                                        return nil, errors.New("value must be in \"$(steps.&lt;step-name&gt;.results.&lt;result-name&gt;[*])\" format, when using array results")
                                }</span>
                                <span class="cov8" title="1">newC = replaceWithArray</span>
                        } else<span class="cov8" title="1"> {
                                newC[0] = strings.ReplaceAll(newC[0], m[0], replaceWithString)
                        }</span>
                }
                <span class="cov8" title="1">newCommand = append(newCommand, newC...)</span>
        }
        <span class="cov8" title="1">return newCommand, nil</span>
}

// applyStepResultSubstitutions applies the runtime step result substitutions in env, args and command.
func (e *Entrypointer) applyStepResultSubstitutions(stepDir string) error <span class="cov8" title="1">{
        // env
        if err := replaceEnv(stepDir); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // replace when
        <span class="cov8" title="1">newWhen, err := replaceWhen(stepDir, e.StepWhenExpressions)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">e.StepWhenExpressions = newWhen
        // command + args
        newCommand, err := replaceCommandAndArgs(e.Command, stepDir)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">e.Command = newCommand
        return nil</span>
}

func replaceWhen(stepDir string, when v1.StepWhenExpressions) (v1.StepWhenExpressions, error) <span class="cov8" title="1">{
        for i, w := range when </span><span class="cov8" title="1">{
                var newValues []string
        flag:
                for _, v := range when[i].Values </span><span class="cov8" title="1">{
                        matches := resultref.StepResultRegex.FindAllStringSubmatch(v, -1)
                        newV := v
                        for _, m := range matches </span><span class="cov8" title="1">{
                                replaceWithString, replaceWithArray, err := findReplacement(stepDir, m[0])
                                if err != nil </span><span class="cov8" title="1">{
                                        return v1.WhenExpressions{}, err
                                }</span>
                                // replaceWithString and replaceWithArray are mutually exclusive
                                <span class="cov8" title="1">if len(replaceWithArray) &gt; 0 </span><span class="cov8" title="1">{
                                        if v != m[0] </span><span class="cov8" title="1">{
                                                // it has to be exact in "$(steps.&lt;step-name&gt;.results.&lt;result-name&gt;[*])" format, without anything else in the original string
                                                return nil, errors.New("value must be in \"$(steps.&lt;step-name&gt;.results.&lt;result-name&gt;[*])\" format, when using array results")
                                        }</span>
                                        <span class="cov8" title="1">newValues = append(newValues, replaceWithArray...)
                                        continue flag</span>
                                }
                                <span class="cov8" title="1">newV = strings.ReplaceAll(newV, m[0], replaceWithString)</span>
                        }
                        <span class="cov8" title="1">newValues = append(newValues, newV)</span>
                }
                <span class="cov8" title="1">when[i].Values = newValues

                matches := resultref.StepResultRegex.FindAllStringSubmatch(w.Input, -1)
                v := when[i].Input
                for _, m := range matches </span><span class="cov8" title="1">{
                        replaceWith, _, err := findReplacement(stepDir, m[0])
                        if err != nil </span><span class="cov8" title="1">{
                                return v1.StepWhenExpressions{}, err
                        }</span>
                        <span class="cov8" title="1">v = strings.ReplaceAll(v, m[0], replaceWith)</span>
                }
                <span class="cov8" title="1">when[i].Input = v

                matches = resultref.StepResultRegex.FindAllStringSubmatch(w.CEL, -1)
                c := when[i].CEL
                for _, m := range matches </span><span class="cov8" title="1">{
                        replaceWith, _, err := findReplacement(stepDir, m[0])
                        if err != nil </span><span class="cov8" title="1">{
                                return v1.StepWhenExpressions{}, err
                        }</span>
                        <span class="cov8" title="1">c = strings.ReplaceAll(c, m[0], replaceWith)</span>
                }
                <span class="cov8" title="1">when[i].CEL = c</span>
        }
        <span class="cov8" title="1">return when, nil</span>
}

// outputRunResult returns the run reason for a termination
func (e Entrypointer) outputRunResult(terminationReason string) result.RunResult <span class="cov8" title="1">{
        return result.RunResult{
                Key:        "Reason",
                Value:      terminationReason,
                ResultType: result.InternalTektonResultType,
        }
}</span>

// getStepArtifactsPath gets the path to the step artifacts
func getStepArtifactsPath(stepDir string, containerName string) string <span class="cov8" title="1">{
        return filepath.Join(stepDir, containerName, "artifacts", "provenance.json")
}</span>

// loadStepArtifacts loads and parses the artifacts file for a specified step.
func loadStepArtifacts(stepDir string, containerName string) (v1.Artifacts, error) <span class="cov8" title="1">{
        v := v1.Artifacts{}
        fp := getStepArtifactsPath(stepDir, containerName)

        fileContents, err := os.ReadFile(fp)
        if err != nil </span><span class="cov8" title="1">{
                return v, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(fileContents, &amp;v)
        if err != nil </span><span class="cov8" title="1">{
                return v, err
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// getArtifactValues retrieves the values associated with a specified artifact reference.
// It parses the provided artifact template, loads the corresponding step's artifacts, and extracts the relevant values.
// If the artifact name is not specified in the template, the values of the first output are returned.
func getArtifactValues(dir string, template string) (string, error) <span class="cov8" title="1">{
        artifactTemplate, err := parseArtifactTemplate(template)

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">artifacts, err := loadStepArtifacts(dir, artifactTemplate.ContainerName)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // $(steps.stepName.outputs.artifactName) &lt;- artifacts.Output[artifactName].Values
        <span class="cov8" title="1">var t []v1.Artifact
        if artifactTemplate.Type == "outputs" </span><span class="cov8" title="1">{
                t = artifacts.Outputs
        }</span> else<span class="cov8" title="1"> {
                t = artifacts.Inputs
        }</span>

        <span class="cov8" title="1">for _, ar := range t </span><span class="cov8" title="1">{
                if ar.Name == artifactTemplate.ArtifactName </span><span class="cov8" title="1">{
                        marshal, err := json.Marshal(ar.Values)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return string(marshal), err</span>
                }
        }
        <span class="cov8" title="1">return "", fmt.Errorf("values for template %s not found", template)</span>
}

// parseArtifactTemplate parses an artifact template string and extracts relevant information into an ArtifactTemplate struct.
// The artifact template is expected to be in the format "$(steps.&lt;step-name&gt;.outputs.&lt;artifact-category-name&gt;)".
func parseArtifactTemplate(template string) (ArtifactTemplate, error) <span class="cov8" title="1">{
        if template == "" </span><span class="cov8" title="1">{
                return ArtifactTemplate{}, errors.New("template is empty")
        }</span>
        <span class="cov8" title="1">if artifactref.StepArtifactRegex.FindString(template) != template </span><span class="cov8" title="1">{
                return ArtifactTemplate{}, fmt.Errorf("invalid artifact template %s", template)
        }</span>
        <span class="cov8" title="1">template = strings.TrimSuffix(strings.TrimPrefix(template, "$("), ")")
        split := strings.Split(template, ".")
        at := ArtifactTemplate{
                ContainerName: "step-" + split[1],
                Type:          split[2],
        }
        if len(split) == 4 </span><span class="cov8" title="1">{
                at.ArtifactName = split[3]
        }</span>
        <span class="cov8" title="1">return at, nil</span>
}

// ArtifactTemplate holds steps artifacts metadata parsed from step artifacts interpolation
type ArtifactTemplate struct {
        ContainerName string
        Type          string // inputs or outputs
        ArtifactName  string
}

// applyStepArtifactSubstitutions replaces artifact references within a step's command and environment variables with their corresponding values.
//
// This function is designed to handle artifact substitutions in a script file, inline command, or environment variables.
//
// Args:
//
//        stepDir: The directory of the executing step.
//
// Returns:
//
//        An error object if any issues occur during substitution.
func (e *Entrypointer) applyStepArtifactSubstitutions(stepDir string) error <span class="cov8" title="1">{
        // Script was re-written into a file, we need to read the file to and substitute the content
        // and re-write the command.
        // While param substitution cannot be used in Script from StepAction, allowing artifact substitution doesn't seem bad as
        // artifacts are unmarshalled, should be safe.
        if len(e.Command) == 1 &amp;&amp; filepath.Dir(e.Command[0]) == filepath.Clean(ScriptDir) </span><span class="cov8" title="1">{
                dataBytes, err := os.ReadFile(e.Command[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fileContent := string(dataBytes)
                v, err := replaceValue(artifactref.StepArtifactRegex, fileContent, stepDir, getArtifactValues)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if v != fileContent </span><span class="cov8" title="1">{
                        temp, err := writeToTempFile(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">e.Command = []string{temp.Name()}</span>
                }
        } else<span class="cov8" title="1"> {
                command := e.Command
                var newCmd []string
                for _, c := range command </span><span class="cov8" title="1">{
                        v, err := replaceValue(artifactref.StepArtifactRegex, c, stepDir, getArtifactValues)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">newCmd = append(newCmd, v)</span>
                }
                <span class="cov8" title="1">e.Command = newCmd</span>
        }

        // substitute env
        <span class="cov8" title="1">for _, e := range os.Environ() </span><span class="cov8" title="1">{
                pair := strings.SplitN(e, "=", 2)
                v, err := replaceValue(artifactref.StepArtifactRegex, pair[1], stepDir, getArtifactValues)

                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">os.Setenv(pair[0], v)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func writeToTempFile(v string) (*os.File, error) <span class="cov8" title="1">{
        tmp, err := os.CreateTemp("", "script-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = os.Chmod(tmp.Name(), 0o755)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = tmp.WriteString(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = tmp.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return tmp, nil</span>
}

func replaceValue(regex *regexp.Regexp, src string, stepDir string, getValue func(string, string) (string, error)) (string, error) <span class="cov8" title="1">{
        matches := regex.FindAllStringSubmatch(src, -1)
        t := src
        for _, m := range matches </span><span class="cov8" title="1">{
                v, err := getValue(stepDir, m[0])
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">t = strings.ReplaceAll(t, m[0], v)</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}
</pre>
		
		<pre class="file" id="file398" style="display: none">//go:build !disable_spire

/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package entrypoint

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/result"
        "github.com/tektoncd/pipeline/pkg/spire"
)

// EntrypointerAPIClient defines the interface for SPIRE operations
type EntrypointerAPIClient interface {
        spire.EntrypointerAPIClient
}

func signResults(ctx context.Context, api EntrypointerAPIClient, results []result.RunResult) ([]result.RunResult, error) <span class="cov8" title="1">{
        if api == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return api.Sign(ctx, results)</span>
}
</pre>
		
		<pre class="file" id="file399" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package affinityassistant

import (
        "context"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/pod"

        "github.com/tektoncd/pipeline/pkg/apis/config"
)

type AffinityAssistantBehavior string

const (
        AffinityAssistantDisabled                    = AffinityAssistantBehavior("AffinityAssistantDisabled")
        AffinityAssistantPerWorkspace                = AffinityAssistantBehavior("AffinityAssistantPerWorkspace")
        AffinityAssistantPerPipelineRun              = AffinityAssistantBehavior("AffinityAssistantPerPipelineRun")
        AffinityAssistantPerPipelineRunWithIsolation = AffinityAssistantBehavior("AffinityAssistantPerPipelineRunWithIsolation")
)

// GetAffinityAssistantBehavior returns an AffinityAssistantBehavior based on the "coschedule" feature flags
func GetAffinityAssistantBehavior(ctx context.Context) (AffinityAssistantBehavior, error) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        coschedule := cfg.FeatureFlags.Coschedule

        switch coschedule </span>{
        case config.CoschedulePipelineRuns:<span class="cov8" title="1">
                return AffinityAssistantPerPipelineRun, nil</span>
        case config.CoscheduleIsolatePipelineRun:<span class="cov8" title="1">
                return AffinityAssistantPerPipelineRunWithIsolation, nil</span>
        case config.CoscheduleWorkspaces:<span class="cov8" title="1">
                return AffinityAssistantPerWorkspace, nil</span>
        case config.CoscheduleDisabled:<span class="cov8" title="1">
                return AffinityAssistantDisabled, nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("unknown affinity assistant coschedule: %v", coschedule)</span>
}

// ContainerConfig defines AffinityAssistant container configuration
type ContainerConfig struct {
        Image                 string
        SecurityContextConfig pod.SecurityContextConfig
}
</pre>
		
		<pre class="file" id="file400" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package affinityassistant

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/pod"
        "github.com/tektoncd/pipeline/pkg/workspace"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NewTransformer returns a pod.Transformer that will pod affinity if needed
func NewTransformer(_ context.Context, annotations map[string]string) pod.Transformer <span class="cov8" title="1">{
        return func(p *corev1.Pod) (*corev1.Pod, error) </span><span class="cov8" title="1">{
                // Using node affinity on taskRuns sharing PVC workspace.  When Affinity Assistant
                // is disabled, an affinityAssistantName is not set.
                if affinityAssistantName := annotations[workspace.AnnotationAffinityAssistantName]; affinityAssistantName != "" </span><span class="cov8" title="1">{
                        if p.Spec.Affinity == nil </span><span class="cov8" title="1">{
                                p.Spec.Affinity = &amp;corev1.Affinity{}
                        }</span>
                        <span class="cov8" title="1">mergeAffinityWithAffinityAssistant(p.Spec.Affinity, affinityAssistantName)</span>
                }
                <span class="cov8" title="1">return p, nil</span>
        }
}

func mergeAffinityWithAffinityAssistant(affinity *corev1.Affinity, affinityAssistantName string) <span class="cov8" title="1">{
        podAffinityTerm := podAffinityTermUsingAffinityAssistant(affinityAssistantName)

        if affinity.PodAffinity == nil </span><span class="cov8" title="1">{
                affinity.PodAffinity = &amp;corev1.PodAffinity{}
        }</span>

        <span class="cov8" title="1">affinity.PodAffinity.RequiredDuringSchedulingIgnoredDuringExecution =
                append(affinity.PodAffinity.RequiredDuringSchedulingIgnoredDuringExecution, *podAffinityTerm)</span>
}

// podAffinityTermUsingAffinityAssistant achieves pod Affinity term for taskRun
// pods so that the taskRun is scheduled to the Node where the Affinity Assistant pod
// is scheduled.
func podAffinityTermUsingAffinityAssistant(affinityAssistantName string) *corev1.PodAffinityTerm <span class="cov8" title="1">{
        return &amp;corev1.PodAffinityTerm{LabelSelector: &amp;metav1.LabelSelector{
                MatchLabels: map[string]string{
                        workspace.LabelInstance:  affinityAssistantName,
                        workspace.LabelComponent: workspace.ComponentNameAffinityAssistant,
                },
        },
                TopologyKey: "kubernetes.io/hostname",
        }
}</span>
</pre>
		
		<pre class="file" id="file401" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package compare

import (
        "github.com/google/go-cmp/cmp"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
)

// IsZero returns true if the resource quantity has a zero value
func IsZero(q resource.Quantity) bool <span class="cov0" title="0">{
        return (&amp;q).IsZero()
}</span>

// MaxRequest returns the largest resource request
// A zero request is considered the smallest request
func MaxRequest(quantities ...resource.Quantity) resource.Quantity <span class="cov0" title="0">{
        max := resource.Quantity{}
        for _, q := range quantities </span><span class="cov0" title="0">{
                if q.Cmp(max) &gt; 0 </span><span class="cov0" title="0">{
                        max = q
                }</span>
        }
        <span class="cov0" title="0">return max</span>
}

// MinLimit returns the smallest resource limit
// A zero limit is considered higher than any other resource limit.
func MinLimit(quantities ...resource.Quantity) resource.Quantity <span class="cov0" title="0">{
        min := resource.Quantity{}
        for _, q := range quantities </span><span class="cov0" title="0">{
                if min.IsZero() </span><span class="cov0" title="0">{
                        min = q
                }</span> else<span class="cov0" title="0"> if q.Cmp(min) &lt; 0 </span><span class="cov0" title="0">{
                        min = q
                }</span>
        }
        <span class="cov0" title="0">return min</span>
}

// ResourceQuantityCmp allows resource quantities to be compared in tests
var ResourceQuantityCmp = cmp.Comparer(func(x, y resource.Quantity) bool <span class="cov0" title="0">{
        return x.Cmp(y) == 0
}</span>)

func equateAlways(_, _ interface{}) bool <span class="cov0" title="0">{ return true }</span>

// EquateEmptyResourceList returns a comparison option that will equate resource lists
// if neither contains non-empty resource quantities.
func EquateEmptyResourceList() cmp.Option <span class="cov0" title="0">{
        return cmp.FilterValues(func(x, y corev1.ResourceList) bool </span><span class="cov0" title="0">{ return IsEmpty(x) &amp;&amp; IsEmpty(y) }</span>, cmp.Comparer(equateAlways))
}

// IsEmpty returns false if the ResourceList contains non-empty resource quantities.
func IsEmpty(x corev1.ResourceList) bool <span class="cov0" title="0">{
        if len(x) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, q := range x </span><span class="cov0" title="0">{
                if !q.IsZero() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file402" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package limitrange

import (
        "github.com/tektoncd/pipeline/pkg/internal/computeresources/compare"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        "k8s.io/apimachinery/pkg/labels"
        corev1listers "k8s.io/client-go/listers/core/v1"
)

// GetVirtualLimitRange returns a pointer to a single LimitRange representing the most restrictive
// requirements of all LimitRanges present in the namespace, or a nil pointer if there are no LimitRanges.
// This LimitRange meets the following constraints:
// - Its max is the smallest max of all the LimitRanges
// - Its min is the largest min of all the LimitRanges
// - Its maxLimitRequestRatio is the smallest maxLimitRequestRatio of all the LimitRanges
// - Its default is the smallest default of any of the LimitRanges that fits within the minimum and maximum
// - Its defaultRequest is the smallest defaultRequest of any of the LimitRanges that fits within the minimum and maximum
//
// This function isn't guaranteed to return a LimitRange with consistent constraints.
// For example, the minimum could be greater than the maximum.
func GetVirtualLimitRange(namespace string, lister corev1listers.LimitRangeLister) (*corev1.LimitRange, error) <span class="cov8" title="1">{
        limitRanges, err := lister.LimitRanges(namespace).List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var limitRange *corev1.LimitRange
        switch </span>{
        case len(limitRanges) == 0:<span class="cov8" title="1">
                // No LimitRange defined
                break</span>
        case len(limitRanges) == 1:<span class="cov8" title="1">
                // One LimitRange defined
                limitRange = limitRanges[0]</span>
        default:<span class="cov8" title="1">
                // Several LimitRange defined
                limitRange = &amp;corev1.LimitRange{}
                m := map[corev1.LimitType]corev1.LimitRangeItem{}
                for _, lr := range limitRanges </span><span class="cov8" title="1">{
                        for _, item := range lr.Spec.Limits </span><span class="cov8" title="1">{
                                _, exists := m[item.Type]
                                if !exists </span><span class="cov8" title="1">{
                                        m[item.Type] = corev1.LimitRangeItem{
                                                Type:                 item.Type,
                                                Min:                  corev1.ResourceList{},
                                                Max:                  corev1.ResourceList{},
                                                Default:              corev1.ResourceList{},
                                                DefaultRequest:       corev1.ResourceList{},
                                                MaxLimitRequestRatio: corev1.ResourceList{},
                                        }
                                }</span>
                                // Min
                                <span class="cov8" title="1">m[item.Type].Min[corev1.ResourceCPU] = compare.MaxRequest(m[item.Type].Min[corev1.ResourceCPU], item.Min[corev1.ResourceCPU])
                                m[item.Type].Min[corev1.ResourceMemory] = compare.MaxRequest(m[item.Type].Min[corev1.ResourceMemory], item.Min[corev1.ResourceMemory])
                                m[item.Type].Min[corev1.ResourceEphemeralStorage] = compare.MaxRequest(m[item.Type].Min[corev1.ResourceEphemeralStorage], item.Min[corev1.ResourceEphemeralStorage])
                                // Max
                                m[item.Type].Max[corev1.ResourceCPU] = compare.MinLimit(m[item.Type].Max[corev1.ResourceCPU], item.Max[corev1.ResourceCPU])
                                m[item.Type].Max[corev1.ResourceMemory] = compare.MinLimit(m[item.Type].Max[corev1.ResourceMemory], item.Max[corev1.ResourceMemory])
                                m[item.Type].Max[corev1.ResourceEphemeralStorage] = compare.MinLimit(m[item.Type].Max[corev1.ResourceEphemeralStorage], item.Max[corev1.ResourceEphemeralStorage])
                                // MaxLimitRequestRatio
                                // The smallest ratio is the most restrictive
                                m[item.Type].MaxLimitRequestRatio[corev1.ResourceCPU] = compare.MinLimit(m[item.Type].MaxLimitRequestRatio[corev1.ResourceCPU], item.MaxLimitRequestRatio[corev1.ResourceCPU])
                                m[item.Type].MaxLimitRequestRatio[corev1.ResourceMemory] = compare.MinLimit(m[item.Type].MaxLimitRequestRatio[corev1.ResourceMemory], item.MaxLimitRequestRatio[corev1.ResourceMemory])
                                m[item.Type].MaxLimitRequestRatio[corev1.ResourceEphemeralStorage] = compare.MinLimit(m[item.Type].MaxLimitRequestRatio[corev1.ResourceEphemeralStorage], item.MaxLimitRequestRatio[corev1.ResourceEphemeralStorage])</span>
                        }
                }
                // Handle Default and DefaultRequest
                <span class="cov8" title="1">for _, lr := range limitRanges </span><span class="cov8" title="1">{
                        for _, item := range lr.Spec.Limits </span><span class="cov8" title="1">{
                                // Default
                                m[item.Type].Default[corev1.ResourceCPU] = minOfBetween(m[item.Type].Default[corev1.ResourceCPU], item.Default[corev1.ResourceCPU], m[item.Type].Min[corev1.ResourceCPU], m[item.Type].Max[corev1.ResourceCPU])
                                m[item.Type].Default[corev1.ResourceMemory] = minOfBetween(m[item.Type].Default[corev1.ResourceMemory], item.Default[corev1.ResourceMemory], m[item.Type].Min[corev1.ResourceMemory], m[item.Type].Max[corev1.ResourceMemory])
                                m[item.Type].Default[corev1.ResourceEphemeralStorage] = minOfBetween(m[item.Type].Default[corev1.ResourceEphemeralStorage], item.Default[corev1.ResourceEphemeralStorage], m[item.Type].Min[corev1.ResourceEphemeralStorage], m[item.Type].Max[corev1.ResourceEphemeralStorage])
                                // DefaultRequest
                                m[item.Type].DefaultRequest[corev1.ResourceCPU] = minOfBetween(m[item.Type].DefaultRequest[corev1.ResourceCPU], item.DefaultRequest[corev1.ResourceCPU], m[item.Type].Min[corev1.ResourceCPU], m[item.Type].Max[corev1.ResourceCPU])
                                m[item.Type].DefaultRequest[corev1.ResourceMemory] = minOfBetween(m[item.Type].DefaultRequest[corev1.ResourceMemory], item.DefaultRequest[corev1.ResourceMemory], m[item.Type].Min[corev1.ResourceMemory], m[item.Type].Max[corev1.ResourceMemory])
                                m[item.Type].DefaultRequest[corev1.ResourceEphemeralStorage] = minOfBetween(m[item.Type].DefaultRequest[corev1.ResourceEphemeralStorage], item.DefaultRequest[corev1.ResourceEphemeralStorage], m[item.Type].Min[corev1.ResourceCPU], m[item.Type].Max[corev1.ResourceCPU])
                        }</span>
                }
                <span class="cov8" title="1">for _, v := range m </span><span class="cov8" title="1">{
                        limitRange.Spec.Limits = append(limitRange.Spec.Limits, v)
                }</span>
        }
        <span class="cov8" title="1">return limitRange, nil</span>
}

func minOfBetween(a, b, min, max resource.Quantity) resource.Quantity <span class="cov8" title="1">{
        if compare.IsZero(a) || (&amp;a).Cmp(b) &gt; 0 </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file403" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tasklevel

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
)

// ApplyTaskLevelComputeResources applies the task-level compute resource requirements to each Step.
func ApplyTaskLevelComputeResources(steps []v1.Step, computeResources *corev1.ResourceRequirements) <span class="cov8" title="1">{
        if computeResources == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if computeResources.Requests == nil &amp;&amp; computeResources.Limits == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">averageRequests := computeAverageRequests(computeResources.Requests, len(steps))
        averageLimits := computeAverageRequests(computeResources.Limits, len(steps))
        for i := range steps </span><span class="cov8" title="1">{
                // if no requests are specified in step or task level, the limits are used to avoid
                // unnecessary higher requests by Kubernetes default behavior.
                if steps[i].ComputeResources.Requests == nil &amp;&amp; computeResources.Requests == nil </span><span class="cov8" title="1">{
                        steps[i].ComputeResources.Requests = averageLimits
                }</span> else<span class="cov8" title="1"> {
                        steps[i].ComputeResources.Requests = averageRequests
                }</span>
                <span class="cov8" title="1">steps[i].ComputeResources.Limits = computeResources.Limits</span>
        }
}

// computeAverageRequests computes the average of the requests of all the steps.
func computeAverageRequests(requests corev1.ResourceList, steps int) corev1.ResourceList <span class="cov8" title="1">{
        if len(requests) == 0 || steps == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">averageRequests := corev1.ResourceList{}
        for k, v := range requests </span><span class="cov8" title="1">{
                if k == corev1.ResourceMemory || k == corev1.ResourceEphemeralStorage </span><span class="cov8" title="1">{
                        averageRequests[k] = *resource.NewQuantity(v.Value()/int64(steps), requests[k].Format)
                        continue</span>
                }
                <span class="cov8" title="1">averageRequests[k] = *resource.NewMilliQuantity(v.MilliValue()/int64(steps), requests[k].Format)</span>
        }
        <span class="cov8" title="1">return averageRequests</span>
}
</pre>
		
		<pre class="file" id="file404" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package computeresources

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/internal/computeresources/compare"
        "github.com/tektoncd/pipeline/pkg/internal/computeresources/limitrange"
        "github.com/tektoncd/pipeline/pkg/pod"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        corev1listers "k8s.io/client-go/listers/core/v1"
)

var resourceNames = []corev1.ResourceName{corev1.ResourceCPU, corev1.ResourceMemory, corev1.ResourceEphemeralStorage}

// NewTransformer returns a pod.Transformer that will modify limits if needed
func NewTransformer(ctx context.Context, namespace string, lister corev1listers.LimitRangeLister) pod.Transformer <span class="cov0" title="0">{
        return func(p *corev1.Pod) (*corev1.Pod, error) </span><span class="cov0" title="0">{
                limitRange, err := limitrange.GetVirtualLimitRange(namespace, lister)
                if err != nil </span><span class="cov0" title="0">{
                        return p, err
                }</span>
                <span class="cov0" title="0">return transformPodBasedOnLimitRange(p, limitRange), nil</span>
        }
}

// transformPodBasedOnLimitRange modifies the pod's containers' resource requirements to meet the constraints of the LimitRange.
// The only supported type of LimitRange is "Container".
// For any container:
// - If the container has requests, they are set to the max of (requests, limitRange minimum).
// - If the container doesn't have requests, they are set to the max of (limitRange minimum, "default"),
// where "default" is the LimitRange defaultRequest (for init containers) or the LimitRange defaultRequest / # of app containers
// (for app containers).
// - If the container has limits, they are set to the min of (limits, limitRange maximum).
// - If the container doesn't have limits, they are set to the min of (limitRange maximum, limitRange default).
func transformPodBasedOnLimitRange(p *corev1.Pod, limitRange *corev1.LimitRange) *corev1.Pod <span class="cov8" title="1">{
        // No LimitRange defined, nothing to transform, bail early we don't have anything to transform.
        if limitRange == nil </span><span class="cov0" title="0">{
                return p
        }</span>

        // The assumption here is that the min, max, default, ratio have already been
        // computed if there is multiple LimitRange to satisfy the most (if we can).
        // Count the number of step containers in the Pod.
        // This should help us find the smallest request to apply to containers
        <span class="cov8" title="1">nbStepContainers := 0
        for _, c := range p.Spec.Containers </span><span class="cov8" title="1">{
                if pod.IsContainerStep(c.Name) </span><span class="cov8" title="1">{
                        nbStepContainers++
                }</span>
        }

        // FIXME(#4230) maxLimitRequestRatio to support later
        <span class="cov8" title="1">defaultStepContainerRequests := getDefaultStepContainerRequest(limitRange, nbStepContainers)

        for i, c := range p.Spec.Containers </span><span class="cov8" title="1">{
                if !pod.IsContainerStep(c.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if p.Spec.Containers[i].Resources.Requests == nil </span><span class="cov8" title="1">{
                        p.Spec.Containers[i].Resources.Requests = defaultStepContainerRequests
                }</span> else<span class="cov8" title="1"> {
                        for _, name := range resourceNames </span><span class="cov8" title="1">{
                                setRequests(name, p.Spec.Containers[i].Resources.Requests, defaultStepContainerRequests)
                        }</span>
                }
        }
        <span class="cov8" title="1">return p</span>
}

func setRequests(name corev1.ResourceName, dst, src corev1.ResourceList) <span class="cov8" title="1">{
        if compare.IsZero(dst[name]) &amp;&amp; !compare.IsZero(src[name]) </span><span class="cov8" title="1">{
                dst[name] = src[name]
        }</span>
}

// Returns the default requests to use for each step container, determined by dividing the LimitRange default requests
// among the step containers, and applying the LimitRange minimum if necessary
func getDefaultStepContainerRequest(limitRange *corev1.LimitRange, nbContainers int) corev1.ResourceList <span class="cov8" title="1">{
        // Support only Type Container to start with
        var r corev1.ResourceList = map[corev1.ResourceName]resource.Quantity{}
        for _, item := range limitRange.Spec.Limits </span><span class="cov8" title="1">{
                // Only support LimitTypeContainer
                if item.Type == corev1.LimitTypeContainer </span><span class="cov8" title="1">{
                        for _, name := range resourceNames </span><span class="cov8" title="1">{
                                var defaultRequest resource.Quantity
                                var min resource.Quantity
                                request := r[name]
                                if item.DefaultRequest != nil </span><span class="cov8" title="1">{
                                        defaultRequest = item.DefaultRequest[name]
                                }</span>
                                <span class="cov8" title="1">if item.Min != nil </span><span class="cov8" title="1">{
                                        min = item.Min[name]
                                }</span>

                                <span class="cov8" title="1">var result resource.Quantity
                                if name == corev1.ResourceMemory || name == corev1.ResourceEphemeralStorage </span><span class="cov8" title="1">{
                                        result = compare.MaxRequest(request, *resource.NewQuantity(defaultRequest.Value()/int64(nbContainers), defaultRequest.Format), min)
                                }</span> else<span class="cov8" title="1"> {
                                        result = compare.MaxRequest(request, *resource.NewMilliQuantity(defaultRequest.MilliValue()/int64(nbContainers), defaultRequest.Format), min)
                                }</span>
                                // only set non-zero request values
                                <span class="cov8" title="1">if !compare.IsZero(result) </span><span class="cov8" title="1">{
                                        r[name] = result
                                }</span>
                        }
                }
        }
        // return nil if the resource list is empty to avoid setting an empty defaultrequest
        <span class="cov8" title="1">if len(r) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file405" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package defaultresourcerequirements

import (
        "context"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/pod"
        corev1 "k8s.io/api/core/v1"
)

// NewTransformer returns a pod.Transformer that will modify container resources if needed
func NewTransformer(ctx context.Context) pod.Transformer <span class="cov8" title="1">{
        // update init container and containers resource requirements
        // resource limits and requests values are taken from a config map
        configDefaults := config.FromContextOrDefaults(ctx).Defaults
        return func(pod *corev1.Pod) (*corev1.Pod, error) </span><span class="cov8" title="1">{
                return updateResourceRequirements(configDefaults.DefaultContainerResourceRequirements, pod), nil
        }</span>
}

// updates init containers and containers resource requirements of a pod base of config_defaults configmap.
func updateResourceRequirements(resourceRequirementsMap map[string]corev1.ResourceRequirements, pod *corev1.Pod) *corev1.Pod <span class="cov8" title="1">{
        if len(resourceRequirementsMap) == 0 </span><span class="cov8" title="1">{
                return pod
        }</span>

        // collect all the available container names from the resource requirement map
        // some of the container names: place-scripts, prepare, working-dir-initializer
        // some of the container names with prefix: prefix-scripts, prefix-sidecar-scripts
        <span class="cov8" title="1">containerNames := []string{}
        containerNamesWithPrefix := []string{}
        for containerName := range resourceRequirementsMap </span><span class="cov8" title="1">{
                // skip the default key
                if containerName == config.ResourceRequirementDefaultContainerKey </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(containerName, "prefix-") </span><span class="cov8" title="1">{
                        containerNamesWithPrefix = append(containerNamesWithPrefix, containerName)
                }</span> else<span class="cov8" title="1"> {
                        containerNames = append(containerNames, containerName)
                }</span>
        }

        // update the containers resource requirements which does not have resource requirements
        <span class="cov8" title="1">for _, containerName := range containerNames </span><span class="cov8" title="1">{
                resourceRequirements := resourceRequirementsMap[containerName]
                if resourceRequirements.Size() == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // update init containers
                <span class="cov8" title="1">for index := range pod.Spec.InitContainers </span><span class="cov8" title="1">{
                        targetContainer := pod.Spec.InitContainers[index]
                        if containerName == targetContainer.Name &amp;&amp; targetContainer.Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.InitContainers[index].Resources = resourceRequirements
                        }</span>
                }
                // update containers
                <span class="cov8" title="1">for index := range pod.Spec.Containers </span><span class="cov8" title="1">{
                        targetContainer := pod.Spec.Containers[index]
                        if containerName == targetContainer.Name &amp;&amp; targetContainer.Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.Containers[index].Resources = resourceRequirements
                        }</span>
                }
        }

        // update the containers resource requirements which does not have resource requirements with the mentioned prefix
        <span class="cov8" title="1">for _, containerPrefix := range containerNamesWithPrefix </span><span class="cov8" title="1">{
                resourceRequirements := resourceRequirementsMap[containerPrefix]
                if resourceRequirements.Size() == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // get actual container name, remove "prefix-" string and append "-" at the end
                // append '-' in the container prefix
                <span class="cov8" title="1">containerPrefix = strings.Replace(containerPrefix, "prefix-", "", 1)
                containerPrefix += "-"

                // update init containers
                for index := range pod.Spec.InitContainers </span><span class="cov8" title="1">{
                        targetContainer := pod.Spec.InitContainers[index]
                        if strings.HasPrefix(targetContainer.Name, containerPrefix) &amp;&amp; targetContainer.Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.InitContainers[index].Resources = resourceRequirements
                        }</span>
                }
                // update containers
                <span class="cov8" title="1">for index := range pod.Spec.Containers </span><span class="cov8" title="1">{
                        targetContainer := pod.Spec.Containers[index]
                        if strings.HasPrefix(targetContainer.Name, containerPrefix) &amp;&amp; targetContainer.Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.Containers[index].Resources = resourceRequirements
                        }</span>
                }
        }

        // reset of the containers resource requirements which has empty resource requirements
        <span class="cov8" title="1">if resourceRequirements, found := resourceRequirementsMap[config.ResourceRequirementDefaultContainerKey]; found &amp;&amp; resourceRequirements.Size() != 0 </span><span class="cov8" title="1">{
                // update init containers
                for index := range pod.Spec.InitContainers </span><span class="cov8" title="1">{
                        if pod.Spec.InitContainers[index].Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.InitContainers[index].Resources = resourceRequirements
                        }</span>
                }
                // update containers
                <span class="cov8" title="1">for index := range pod.Spec.Containers </span><span class="cov8" title="1">{
                        if pod.Spec.Containers[index].Resources.Size() == 0 </span><span class="cov8" title="1">{
                                pod.Spec.Containers[index].Resources = resourceRequirements
                        }</span>
                }
        }

        <span class="cov8" title="1">return pod</span>
}
</pre>
		
		<pre class="file" id="file406" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package resolution

import (
        "encoding/base64"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// CreateResolutionRequestStatusWithData returns a ResolutionRequestStatus with the resolved content.
func CreateResolutionRequestStatusWithData(content []byte) *v1beta1.ResolutionRequestStatus <span class="cov0" title="0">{
        return &amp;v1beta1.ResolutionRequestStatus{
                Status: duckv1.Status{},
                ResolutionRequestStatusFields: v1beta1.ResolutionRequestStatusFields{
                        Data: base64.StdEncoding.Strict().EncodeToString(content),
                },
        }
}</span>

// CreateResolutionRequestFailureStatus returns a ResolutionRequestStatus with failure.
func CreateResolutionRequestFailureStatus() *v1beta1.ResolutionRequestStatus <span class="cov0" title="0">{
        return &amp;v1beta1.ResolutionRequestStatus{
                Status: duckv1.Status{
                        Conditions: duckv1.Conditions{{
                                Type:   apis.ConditionSucceeded,
                                Status: corev1.ConditionFalse,
                                Reason: common.ReasonResolutionFailed,
                        }},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file407" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resultref

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

const (
        resultExpressionFormat     = "tasks.&lt;taskName&gt;.results.&lt;resultName&gt;"
        stepResultExpressionFormat = "steps.&lt;stepName&gt;.results.&lt;resultName&gt;"
        // Result expressions of the form &lt;resultName&gt;.&lt;attribute&gt; will be treated as object results.
        // If a string result name contains a dot, brackets should be used to differentiate it from an object result.
        // https://github.com/tektoncd/community/blob/main/teps/0075-object-param-and-result-types.md#collisions-with-builtin-variable-replacement
        objectResultExpressionFormat     = "tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;"
        objectStepResultExpressionFormat = "steps.&lt;stepName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;"
        // ResultStepPart Constant used to define the "steps" part of a step result reference
        ResultStepPart = "steps"
        // ResultTaskPart Constant used to define the "tasks" part of a pipeline result reference
        ResultTaskPart = "tasks"
        // ResultFinallyPart Constant used to define the "finally" part of a pipeline result reference
        ResultFinallyPart = "finally"
        // ResultResultPart Constant used to define the "results" part of a pipeline result reference
        ResultResultPart = "results"

        // arrayIndexing will match all `[int]` and `[*]` for parseExpression
        arrayIndexing          = `\[([0-9])*\*?\]`
        stepResultUsagePattern = `\$\(steps\..*?\.results\..*?\)`
)

// arrayIndexingRegex is used to match `[int]` and `[*]`
var arrayIndexingRegex = regexp.MustCompile(arrayIndexing)

// StepResultRegex compiles the regex pattern for the usage of step results.
var StepResultRegex = regexp.MustCompile(stepResultUsagePattern)

// LooksLikeResultRef attempts to check if the given string looks like it contains any
// result references. Returns true if it does, false otherwise
func LooksLikeResultRef(expression string) bool <span class="cov8" title="1">{
        subExpressions := strings.Split(expression, ".")
        return len(subExpressions) &gt;= 4 &amp;&amp; (subExpressions[0] == ResultTaskPart || subExpressions[0] == ResultFinallyPart) &amp;&amp; subExpressions[2] == ResultResultPart
}</span>

// looksLikeStepResultRef attempts to check if the given string looks like it contains any
// step result references. Returns true if it does, false otherwise
func looksLikeStepResultRef(expression string) bool <span class="cov8" title="1">{
        subExpressions := strings.Split(expression, ".")
        return len(subExpressions) &gt;= 4 &amp;&amp; subExpressions[0] == ResultStepPart &amp;&amp; subExpressions[2] == ResultResultPart
}</span>

// ParsedResult captures the task/step name, result name, type,
// array idx (in case of array result) and
// object key (in case of an object result).
// This is generated by parsing expressions that use
// $(tasks.taskName.results.resultName...) or $(steps.stepName.results.resultName...)
type ParsedResult struct {
        ResourceName string
        ResultName   string
        ResultType   string
        ArrayIdx     *int
        ObjectKey    string
}

// parseExpression parses "task name", "result name", "array index" (iff it's an array result) and "object key name" (iff it's an object result)
// 1. Reference string result
// - Input: tasks.myTask.results.aStringResult
// - Output: "myTask", "aStringResult", nil, "", nil
// 2. Reference Object value with key:
// - Input: tasks.myTask.results.anObjectResult.key1
// - Output: "myTask", "anObjectResult", nil, "key1", nil
// 3. Reference array elements with array indexing :
// - Input: tasks.myTask.results.anArrayResult[1]
// - Output: "myTask", "anArrayResult", 1, "", nil
// 4. Referencing whole array or object result:
// - Input: tasks.myTask.results.Result[*]
// - Output: "myTask", "Result", nil, "", nil
// Invalid Case:
// - Input: tasks.myTask.results.resultName.foo.bar
// - Output: "", "", nil, "", error
// TODO: may use regex for each type to handle possible reference formats
func parseExpression(substitutionExpression string) (ParsedResult, error) <span class="cov8" title="1">{
        if LooksLikeResultRef(substitutionExpression) || looksLikeStepResultRef(substitutionExpression) </span><span class="cov8" title="1">{
                subExpressions := strings.Split(substitutionExpression, ".")
                // For string result: tasks.&lt;taskName&gt;.results.&lt;stringResultName&gt;
                // For string step result: steps.&lt;stepName&gt;.results.&lt;stringResultName&gt;
                // For array result: tasks.&lt;taskName&gt;.results.&lt;arrayResultName&gt;[index]
                // For array step result: steps.&lt;stepName&gt;.results.&lt;arrayResultName&gt;[index]
                if len(subExpressions) == 4 </span><span class="cov8" title="1">{
                        resultName, stringIdx := ParseResultName(subExpressions[3])
                        if stringIdx != "" </span><span class="cov8" title="1">{
                                if stringIdx == "*" </span><span class="cov8" title="1">{
                                        pr := ParsedResult{
                                                ResourceName: subExpressions[1],
                                                ResultName:   resultName,
                                                ResultType:   "array",
                                        }
                                        return pr, nil
                                }</span>
                                <span class="cov8" title="1">intIdx, _ := strconv.Atoi(stringIdx)
                                pr := ParsedResult{
                                        ResourceName: subExpressions[1],
                                        ResultName:   resultName,
                                        ResultType:   "array",
                                        ArrayIdx:     &amp;intIdx,
                                }
                                return pr, nil</span>
                        }
                        <span class="cov8" title="1">pr := ParsedResult{
                                ResourceName: subExpressions[1],
                                ResultName:   resultName,
                                ResultType:   "string",
                        }
                        return pr, nil</span>
                } else<span class="cov8" title="1"> if len(subExpressions) == 5 </span><span class="cov8" title="1">{
                        // For object type result: tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;
                        // For object type step result: steps.&lt;stepName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;
                        pr := ParsedResult{
                                ResourceName: subExpressions[1],
                                ResultName:   subExpressions[3],
                                ResultType:   "object",
                                ObjectKey:    subExpressions[4],
                        }
                        return pr, nil
                }</span>
        }
        <span class="cov8" title="1">return ParsedResult{}, fmt.Errorf("must be one of the form 1). %q; 2). %q; 3). %q; 4). %q", resultExpressionFormat, objectResultExpressionFormat, stepResultExpressionFormat, objectStepResultExpressionFormat)</span>
}

// ParseTaskExpression parses the input string and searches for the use of task result usage.
func ParseTaskExpression(substitutionExpression string) (ParsedResult, error) <span class="cov8" title="1">{
        if LooksLikeResultRef(substitutionExpression) </span><span class="cov8" title="1">{
                return parseExpression(substitutionExpression)
        }</span>
        <span class="cov8" title="1">return ParsedResult{}, fmt.Errorf("must be one of the form 1). %q; 2). %q", resultExpressionFormat, objectResultExpressionFormat)</span>
}

// ParseStepExpression parses the input string and searches for the use of step result usage.
func ParseStepExpression(substitutionExpression string) (ParsedResult, error) <span class="cov8" title="1">{
        if looksLikeStepResultRef(substitutionExpression) </span><span class="cov8" title="1">{
                return parseExpression(substitutionExpression)
        }</span>
        <span class="cov8" title="1">return ParsedResult{}, fmt.Errorf("must be one of the form 1). %q; 2). %q", stepResultExpressionFormat, objectStepResultExpressionFormat)</span>
}

// ParseResultName parse the input string to extract resultName and result index.
// Array indexing:
// Input:  anArrayResult[1]
// Output: anArrayResult, "1"
// Array star reference:
// Input:  anArrayResult[*]
// Output: anArrayResult, "*"
func ParseResultName(resultName string) (string, string) <span class="cov8" title="1">{
        stringIdx := strings.TrimSuffix(strings.TrimPrefix(arrayIndexingRegex.FindString(resultName), "["), "]")
        resultName = arrayIndexingRegex.ReplaceAllString(resultName, "")
        return resultName, stringIdx
}</span>
</pre>
		
		<pre class="file" id="file408" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package list

import "fmt"

// IsSame will return an error indicating if there are extra or missing strings
// between the required and provided strings, or will return no error if the two
// contain the same values.
func IsSame(required, provided []string) error <span class="cov8" title="1">{
        missing := DiffLeft(required, provided)
        if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("didn't provide required values: %s", missing)
        }</span>
        <span class="cov8" title="1">extra := DiffLeft(provided, required)
        if len(extra) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("provided extra values: %s", extra)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DiffLeft will return all strings which are in the left slice of strings but
// not in the right.
func DiffLeft(left, right []string) []string <span class="cov8" title="1">{
        extra := []string{}
        for _, s := range left </span><span class="cov8" title="1">{
                found := false
                for _, s2 := range right </span><span class="cov8" title="1">{
                        if s == s2 </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        extra = append(extra, s)
                }</span>
        }
        <span class="cov8" title="1">return extra</span>
}
</pre>
		
		<pre class="file" id="file409" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package names

import (
        "fmt"
        "hash/fnv"
        "regexp"
        "strconv"
        "strings"

        utilrand "k8s.io/apimachinery/pkg/util/rand"
)

// NameGenerator generates names for objects. Some backends may have more information
// available to guide selection of new names and this interface hides those details.
type NameGenerator interface {
        // RestrictLengthWithRandomSuffix generates a valid name from the base name, adding a random suffix to
        // the base. If base is valid, the returned name must also be valid. The generator is
        // responsible for knowing the maximum valid name length.
        RestrictLengthWithRandomSuffix(base string) string

        // RestrictLength generates a valid name from the name of a step specified in a Task,
        // shortening it to the maximum valid name length if needed.
        RestrictLength(base string) string
}

// simpleNameGenerator generates random names.
type simpleNameGenerator struct{}

// SimpleNameGenerator is a generator that returns the name plus a random suffix of five alphanumerics
// when a name is requested. The string is guaranteed to not exceed the length of a standard Kubernetes
// name (63 characters)
var SimpleNameGenerator NameGenerator = simpleNameGenerator{}

const (
        // TODO: make this flexible for non-core resources with alternate naming rules.
        maxNameLength          = 63
        randomLength           = 5
        maxGeneratedNameLength = maxNameLength - randomLength - 1
)

// RestrictLengthWithRandomSuffix takes a base name and returns a potentially shortened version of that name with
// a random suffix, with the whole string no longer than 63 characters.
func (simpleNameGenerator) RestrictLengthWithRandomSuffix(base string) string <span class="cov8" title="1">{
        if len(base) &gt; maxGeneratedNameLength </span><span class="cov8" title="1">{
                base = base[:maxGeneratedNameLength]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", base, utilrand.String(randomLength))</span>
}

var alphaNumericRE = regexp.MustCompile(`^[a-zA-Z0-9]+$`)

// RestrictLength takes a base name and returns a potentially shortened version of that name, no longer than 63 characters.
func (simpleNameGenerator) RestrictLength(base string) string <span class="cov8" title="1">{
        if len(base) &gt; maxNameLength </span><span class="cov8" title="1">{
                base = base[:maxNameLength]
        }</span>

        <span class="cov8" title="1">for !alphaNumericRE.MatchString(base[len(base)-1:]) </span><span class="cov8" title="1">{
                base = base[:len(base)-1]
        }</span>
        <span class="cov8" title="1">return base</span>
}

// GenerateHashedName creates a unique name with a hashed suffix.
func GenerateHashedName(prefix, name string, hashedLength int) string <span class="cov8" title="1">{
        if hashedLength &lt;= 0 </span><span class="cov8" title="1">{
                hashedLength = randomLength
        }</span>
        <span class="cov8" title="1">h := fnv.New32a()
        h.Write([]byte(name))
        suffix := strconv.FormatUint(uint64(h.Sum32()), 16)
        if ln := len(suffix); ln &gt; hashedLength </span><span class="cov8" title="1">{
                suffix = suffix[:hashedLength]
        }</span> else<span class="cov8" title="1"> if ln &lt; hashedLength </span><span class="cov8" title="1">{
                suffix += strings.Repeat("0", hashedLength-ln)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", prefix, suffix)</span>
}
</pre>
		
		<pre class="file" id="file410" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fake

import (
        "context"

        _ "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/fake" // Make sure the fake pipelinerun informer is setup
        "github.com/tektoncd/pipeline/pkg/pipelinerunmetrics"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return pipelinerunmetrics.WithClient(ctx) }</span>)
        <span class="cov0" title="0">injection.Fake.RegisterInformer(pipelinerunmetrics.WithInformer)</span>
}
</pre>
		
		<pre class="file" id="file411" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerunmetrics

import (
        "context"

        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
        <span class="cov8" title="1">injection.Default.RegisterInformer(WithInformer)</span>
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

// WithClient adds a metrics recorder to the given context
func WithClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create pipelinerun metrics recorder %v", err)
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the pipelinerunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov0" title="0">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *pipelinerunmetrics.Recorder from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*Recorder)</span>
}

// InformerKey is used for associating the Informer inside the context.Context.
type InformerKey struct{}

// WithInformer returns the given context, and a configured informer
func WithInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        return ctx, &amp;recorderInformer{
                ctx:     ctx,
                metrics: Get(ctx),
                lister:  pipelineruninformer.Get(ctx).Lister(),
        }
}</span>

type recorderInformer struct {
        ctx     context.Context
        metrics *Recorder
        lister  listers.PipelineRunLister
}

var _ controller.Informer = (*recorderInformer)(nil)

// Run starts the recorder informer in a goroutine
func (ri *recorderInformer) Run(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Turn the stopCh into a context for reporting metrics.
        ctx, cancel := context.WithCancel(ri.ctx)
        go func() </span><span class="cov0" title="0">{
                &lt;-stopCh
                cancel()
        }</span>()

        <span class="cov0" title="0">go ri.metrics.ReportRunningPipelineRuns(ctx, ri.lister)</span>
}

// HasSynced returns whether the informer has synced, which in this case will always be true.
func (ri *recorderInformer) HasSynced() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file412" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerunmetrics

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "golang.org/x/crypto/blake2b"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/labels"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"
)

const (
        runningPRLevelPipelinerun = "pipelinerun"
        runningPRLevelPipeline    = "pipeline"
        runningPRLevelNamespace   = "namespace"
        runningPRLevelCluster     = ""
)

var (
        pipelinerunTag = tag.MustNewKey("pipelinerun")
        pipelineTag    = tag.MustNewKey("pipeline")
        namespaceTag   = tag.MustNewKey("namespace")
        statusTag      = tag.MustNewKey("status")
        reasonTag      = tag.MustNewKey("reason")

        prDuration = stats.Float64(
                "pipelinerun_duration_seconds",
                "The pipelinerun execution time in seconds",
                stats.UnitDimensionless)
        prDurationView *view.View

        prTotal = stats.Float64("pipelinerun_total",
                "Number of pipelineruns",
                stats.UnitDimensionless)
        prTotalView *view.View

        runningPRs = stats.Float64("running_pipelineruns",
                "Number of pipelineruns executing currently",
                stats.UnitDimensionless)
        runningPRsView *view.View

        runningPRsWaitingOnPipelineResolution = stats.Float64("running_pipelineruns_waiting_on_pipeline_resolution",
                "Number of pipelineruns executing currently that are waiting on resolution requests for their pipeline references.",
                stats.UnitDimensionless)
        runningPRsWaitingOnPipelineResolutionView *view.View

        runningPRsWaitingOnTaskResolution = stats.Float64("running_pipelineruns_waiting_on_task_resolution",
                "Number of pipelineruns executing currently that are waiting on resolution requests for the task references of their taskrun children.",
                stats.UnitDimensionless)
        runningPRsWaitingOnTaskResolutionView *view.View
)

const (
        // ReasonCancelled indicates that a PipelineRun was cancelled.
        // Aliased for backwards compatibility; additional reasons should not be added here.
        ReasonCancelled = v1.PipelineRunReasonCancelled

        anonymous = "anonymous"
)

// Recorder holds keys for Tekton metrics
type Recorder struct {
        mutex       sync.Mutex
        initialized bool
        cfg         *config.Metrics

        insertTag func(pipeline,
                pipelinerun string) []tag.Mutator

        ReportingPeriod time.Duration

        hash string
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once           sync.Once
        r              *Recorder
        errRegistering error
)

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;Recorder{
                        initialized: true,

                        // Default to 30s intervals.
                        ReportingPeriod: 30 * time.Second,
                }

                cfg := config.FromContextOrDefaults(ctx)
                r.cfg = cfg.Metrics
                errRegistering = viewRegister(cfg.Metrics)
                if errRegistering != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, errRegistering</span>
}

func viewRegister(cfg *config.Metrics) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        var prunTag []tag.Key
        switch cfg.PipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipelinerun:<span class="cov8" title="1">
                prunTag = []tag.Key{pipelinerunTag, pipelineTag}
                r.insertTag = pipelinerunInsertTag</span>
        case config.PipelinerunLevelAtPipeline:<span class="cov0" title="0">
                prunTag = []tag.Key{pipelineTag}
                r.insertTag = pipelineInsertTag</span>
        case config.PipelinerunLevelAtNS:<span class="cov8" title="1">
                prunTag = []tag.Key{}
                r.insertTag = nilInsertTag</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid config for PipelinerunLevel: " + cfg.PipelinerunLevel)</span>
        }

        <span class="cov8" title="1">var runningPRTag []tag.Key
        switch cfg.RunningPipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipelinerun:<span class="cov8" title="1">
                runningPRTag = []tag.Key{pipelinerunTag, pipelineTag, namespaceTag}</span>
        case config.PipelinerunLevelAtPipeline:<span class="cov8" title="1">
                runningPRTag = []tag.Key{pipelineTag, namespaceTag}</span>
        case config.PipelinerunLevelAtNS:<span class="cov8" title="1">
                runningPRTag = []tag.Key{namespaceTag}</span>
        default:<span class="cov8" title="1">
                runningPRTag = []tag.Key{}</span>
        }

        <span class="cov8" title="1">distribution := view.Distribution(10, 30, 60, 300, 900, 1800, 3600, 5400, 10800, 21600, 43200, 86400)

        if cfg.PipelinerunLevel == config.PipelinerunLevelAtPipelinerun </span><span class="cov8" title="1">{
                distribution = view.LastValue()
        }</span> else<span class="cov8" title="1"> {
                switch cfg.DurationPipelinerunType </span>{
                case config.DurationTaskrunTypeHistogram:<span class="cov0" title="0"></span>
                case config.DurationTaskrunTypeLastValue:<span class="cov8" title="1">
                        distribution = view.LastValue()</span>
                default:<span class="cov0" title="0">
                        return errors.New("invalid config for DurationTaskrunType: " + cfg.DurationTaskrunType)</span>
                }
        }

        <span class="cov8" title="1">if cfg.CountWithReason </span><span class="cov8" title="1">{
                prunTag = append(prunTag, reasonTag)
        }</span>

        <span class="cov8" title="1">prDurationView = &amp;view.View{
                Description: prDuration.Description(),
                Measure:     prDuration,
                Aggregation: distribution,
                TagKeys:     append([]tag.Key{statusTag, namespaceTag}, prunTag...),
        }

        prTotalView = &amp;view.View{
                Description: prTotal.Description(),
                Measure:     prTotal,
                Aggregation: view.Count(),
                TagKeys:     []tag.Key{statusTag},
        }

        runningPRsView = &amp;view.View{
                Description: runningPRs.Description(),
                Measure:     runningPRs,
                Aggregation: view.LastValue(),
                TagKeys:     runningPRTag,
        }

        runningPRsWaitingOnPipelineResolutionView = &amp;view.View{
                Description: runningPRsWaitingOnPipelineResolution.Description(),
                Measure:     runningPRsWaitingOnPipelineResolution,
                Aggregation: view.LastValue(),
        }

        runningPRsWaitingOnTaskResolutionView = &amp;view.View{
                Description: runningPRsWaitingOnTaskResolution.Description(),
                Measure:     runningPRsWaitingOnTaskResolution,
                Aggregation: view.LastValue(),
        }

        return view.Register(
                prDurationView,
                prTotalView,
                runningPRsView,
                runningPRsWaitingOnPipelineResolutionView,
                runningPRsWaitingOnTaskResolutionView,
        )</span>
}

func viewUnregister() <span class="cov8" title="1">{
        view.Unregister(prDurationView,
                prTotalView,
                runningPRsView,
                runningPRsWaitingOnPipelineResolutionView,
                runningPRsWaitingOnTaskResolutionView)
}</span>

// OnStore returns a function that checks if metrics are configured for a config.Store, and registers it if so
func OnStore(logger *zap.SugaredLogger, r *Recorder) func(name string,
        value interface{}) <span class="cov8" title="1">{
        return func(name string, value interface{}) </span><span class="cov8" title="1">{
                if name == config.GetMetricsConfigName() </span><span class="cov8" title="1">{
                        cfg, ok := value.(*config.Metrics)
                        if !ok </span><span class="cov8" title="1">{
                                logger.Error("Failed to do type insertion for extracting metrics config")
                                return
                        }</span>
                        <span class="cov8" title="1">updated := r.updateConfig(cfg)
                        if !updated </span><span class="cov8" title="1">{
                                return
                        }</span>
                        // Update metrics according to configuration
                        <span class="cov8" title="1">viewUnregister()
                        err := viewRegister(cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to register View %v ", err)
                                return
                        }</span>
                }
        }
}

func pipelinerunInsertTag(pipeline, pipelinerun string) []tag.Mutator <span class="cov8" title="1">{
        return []tag.Mutator{
                tag.Insert(pipelineTag, pipeline),
                tag.Insert(pipelinerunTag, pipelinerun),
        }
}</span>

func pipelineInsertTag(pipeline, pipelinerun string) []tag.Mutator <span class="cov0" title="0">{
        return []tag.Mutator{tag.Insert(pipelineTag, pipeline)}
}</span>

func nilInsertTag(task, taskrun string) []tag.Mutator <span class="cov0" title="0">{
        return []tag.Mutator{}
}</span>

func getPipelineTagName(pr *v1.PipelineRun) string <span class="cov8" title="1">{
        pipelineName := anonymous
        switch </span>{
        case pr.Spec.PipelineRef != nil &amp;&amp; pr.Spec.PipelineRef.Name != "":<span class="cov8" title="1">
                pipelineName = pr.Spec.PipelineRef.Name</span>
        case pr.Spec.PipelineSpec != nil:<span class="cov0" title="0"></span>
        default:<span class="cov8" title="1">
                if len(pr.Labels) &gt; 0 </span><span class="cov8" title="1">{
                        pipelineLabel, hasPipelineLabel := pr.Labels[pipeline.PipelineLabelKey]
                        if hasPipelineLabel &amp;&amp; len(pipelineLabel) &gt; 0 </span><span class="cov8" title="1">{
                                pipelineName = pipelineLabel
                        }</span>
                }
        }

        <span class="cov8" title="1">return pipelineName</span>
}

func (r *Recorder) updateConfig(cfg *config.Metrics) bool <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        var hash string
        if cfg != nil </span><span class="cov8" title="1">{
                s := fmt.Sprintf("%v", *cfg)
                sum := blake2b.Sum256([]byte(s))
                hash = hex.EncodeToString(sum[:])
        }</span>

        <span class="cov8" title="1">if r.hash == hash </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">r.cfg = cfg
        r.hash = hash

        return true</span>
}

// DurationAndCount logs the duration of PipelineRun execution and
// count for number of PipelineRuns succeed or failed
// returns an error if it fails to log the metrics
func (r *Recorder) DurationAndCount(pr *v1.PipelineRun, beforeCondition *apis.Condition) error <span class="cov8" title="1">{
        if !r.initialized </span><span class="cov8" title="1">{
                return fmt.Errorf("ignoring the metrics recording for %s , failed to initialize the metrics recorder", pr.Name)
        }</span>

        <span class="cov8" title="1">afterCondition := pr.Status.GetCondition(apis.ConditionSucceeded)
        // To avoid recount
        if equality.Semantic.DeepEqual(beforeCondition, afterCondition) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">r.mutex.Lock()
        defer r.mutex.Unlock()

        duration := time.Duration(0)
        if pr.Status.StartTime != nil </span><span class="cov8" title="1">{
                duration = time.Since(pr.Status.StartTime.Time)
                if pr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                        duration = pr.Status.CompletionTime.Sub(pr.Status.StartTime.Time)
                }</span>
        }

        <span class="cov8" title="1">cond := pr.Status.GetCondition(apis.ConditionSucceeded)
        status := "success"
        if cond.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                status = "failed"
                if cond.Reason == v1.PipelineRunReasonCancelled.String() </span><span class="cov8" title="1">{
                        status = "cancelled"
                }</span>
        }
        <span class="cov8" title="1">reason := cond.Reason

        pipelineName := getPipelineTagName(pr)

        ctx, err := tag.New(
                context.Background(),
                append([]tag.Mutator{
                        tag.Insert(namespaceTag, pr.Namespace),
                        tag.Insert(statusTag, status), tag.Insert(reasonTag, reason),
                }, r.insertTag(pipelineName, pr.Name)...)...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, prDuration.M(duration.Seconds()))
        metrics.Record(ctx, prTotal.M(1))

        return nil</span>
}

// RunningPipelineRuns logs the number of PipelineRuns running right now
// returns an error if it fails to log the metrics
func (r *Recorder) RunningPipelineRuns(lister listers.PipelineRunLister) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        if !r.initialized </span><span class="cov8" title="1">{
                return errors.New("ignoring the metrics recording, failed to initialize the metrics recorder")
        }</span>

        <span class="cov8" title="1">prs, err := lister.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pipelineruns while generating metrics : %w", err)
        }</span>

        <span class="cov8" title="1">var runningPipelineRuns int
        var trsWaitResolvingTaskRef int
        var prsWaitResolvingPipelineRef int
        countMap := map[string]int{}

        for _, pr := range prs </span><span class="cov8" title="1">{
                pipelineName := getPipelineTagName(pr)
                pipelineRunKey := ""
                mutators := []tag.Mutator{
                        tag.Insert(namespaceTag, pr.Namespace),
                        tag.Insert(pipelineTag, pipelineName),
                        tag.Insert(pipelinerunTag, pr.Name),
                }
                if r.cfg != nil </span><span class="cov8" title="1">{
                        switch r.cfg.RunningPipelinerunLevel </span>{
                        case runningPRLevelPipelinerun:<span class="cov8" title="1">
                                pipelineRunKey = pipelineRunKey + "#" + pr.Name
                                fallthrough</span>
                        case runningPRLevelPipeline:<span class="cov8" title="1">
                                pipelineRunKey = pipelineRunKey + "#" + pipelineName
                                fallthrough</span>
                        case runningPRLevelNamespace:<span class="cov8" title="1">
                                pipelineRunKey = pipelineRunKey + "#" + pr.Namespace</span>
                        case runningPRLevelCluster:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("RunningPipelineRunLevel value \"%s\" is not valid ", r.cfg.RunningPipelinerunLevel)</span>
                        }
                }
                <span class="cov8" title="1">ctx_, err_ := tag.New(context.Background(), mutators...)
                if err_ != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !pr.IsDone() &amp;&amp; !pr.IsPending() </span><span class="cov8" title="1">{
                        countMap[pipelineRunKey]++
                        metrics.Record(ctx_, runningPRs.M(float64(countMap[pipelineRunKey])))
                        runningPipelineRuns++
                        succeedCondition := pr.Status.GetCondition(apis.ConditionSucceeded)
                        if succeedCondition != nil &amp;&amp; succeedCondition.Status == corev1.ConditionUnknown </span><span class="cov8" title="1">{
                                switch succeedCondition.Reason </span>{
                                case v1.TaskRunReasonResolvingTaskRef:<span class="cov8" title="1">
                                        trsWaitResolvingTaskRef++</span>
                                case v1.PipelineRunReasonResolvingPipelineRef.String():<span class="cov8" title="1">
                                        prsWaitResolvingPipelineRef++</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        // In case there are no running PipelineRuns for the pipelineRunKey, set the metric value to 0 to ensure
                        //  the metric is set for the key.
                        if _, exists := countMap[pipelineRunKey]; !exists </span><span class="cov8" title="1">{
                                countMap[pipelineRunKey] = 0
                                metrics.Record(ctx_, runningPRs.M(0))
                        }</span>
                }
        }

        <span class="cov8" title="1">ctx, err := tag.New(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metrics.Record(ctx, runningPRsWaitingOnPipelineResolution.M(float64(prsWaitResolvingPipelineRef)))
        metrics.Record(ctx, runningPRsWaitingOnTaskResolution.M(float64(trsWaitResolvingTaskRef)))
        metrics.Record(ctx, runningPRs.M(float64(runningPipelineRuns)))

        return nil</span>
}

// ReportRunningPipelineRuns invokes RunningPipelineRuns on our configured PeriodSeconds
// until the context is cancelled.
func (r *Recorder) ReportRunningPipelineRuns(ctx context.Context, lister listers.PipelineRunLister) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        for </span><span class="cov0" title="0">{
                delay := time.NewTimer(r.ReportingPeriod)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // When the context is cancelled, stop reporting.
                        if !delay.Stop() </span><span class="cov0" title="0">{
                                &lt;-delay.C
                        }</span>
                        <span class="cov0" title="0">return</span>

                case &lt;-delay.C:<span class="cov0" title="0">
                        // Every 30s surface a metric for the number of running pipelines.
                        if err := r.RunningPipelineRuns(lister); err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to log the metrics : %v", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file413" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platforms

import (
        "errors"
        "fmt"
        "log/slog"
        "path"
        "runtime"
        "sync"
)

var (
        errNotImplemented = errors.New("not implemented")
)

const (
        Unknown = "unknown"
        Arm     = "arm"
        Arm64   = "arm64"
        Windows = "windows"
        Darwin  = "darwin"
        FreeBSD = "freebsd"
)

// Platform describes the platform which the image in the manifest runs on.
type Platform struct {
        // Architecture field specifies the CPU architecture, for example
        // `amd64` or `ppc64le`.
        Architecture string `json:"architecture"`

        // OS specifies the operating system, for example `linux` or `windows`.
        OS string `json:"os"`

        // OSVersion is an optional field specifying the operating system
        // version, for example on Windows `10.0.14393.1066`.
        OSVersion string `json:"os.version,omitempty"`

        // OSFeatures is an optional field specifying an array of strings,
        // each listing a required OS feature (for example on Windows `win32k`).
        OSFeatures []string `json:"os.features,omitempty"`

        // Variant is an optional field specifying a variant of the CPU, for
        // example `v7` to specify ARMv7 when architecture is `arm`.
        Variant string `json:"variant,omitempty"`
}

func NewPlatform() *Platform <span class="cov8" title="1">{
        p := &amp;Platform{
                OS:           runtime.GOOS,
                Architecture: runtime.GOARCH,
                Variant:      cpuVariant(),
        }
        return p
}</span>

func (p *Platform) Format() string <span class="cov8" title="1">{
        if p.OS == "" </span><span class="cov0" title="0">{
                return Unknown
        }</span>

        <span class="cov8" title="1">return path.Join(p.OS, p.Architecture, p.Variant)</span>
}

// Present the ARM instruction set architecture, eg: v7, v8
// Don't use this value directly; call cpuVariant() instead.
var cpuVariantValue string

var cpuVariantOnce sync.Once

func cpuVariant() string <span class="cov8" title="1">{
        cpuVariantOnce.Do(func() </span><span class="cov8" title="1">{
                if isArmArch(runtime.GOARCH) </span><span class="cov0" title="0">{
                        var err error
                        cpuVariantValue, err = getCPUVariant()
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to get CPU variant", "os", runtime.GOOS, "error", err)
                        }</span>
                }
        })
        <span class="cov8" title="1">return cpuVariantValue</span>
}

// isArmArch returns true if the architecture is ARM.
//
// The arch value should be normalized before being passed to this function.
func isArmArch(arch string) bool <span class="cov8" title="1">{
        switch arch </span>{
        case Arm, Arm64:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getCPUVariant() (string, error) <span class="cov8" title="1">{
        var variant string

        switch runtime.GOOS </span>{
        case Windows, Darwin:<span class="cov0" title="0">
                // Windows/Darwin only supports v7 for ARM32 and v8 for ARM64
                switch runtime.GOARCH </span>{
                case Arm64:<span class="cov0" title="0">
                        variant = "v8"</span>
                case Arm:<span class="cov0" title="0">
                        variant = "v7"</span>
                default:<span class="cov0" title="0">
                        variant = Unknown</span>
                }
        case FreeBSD:<span class="cov0" title="0">
                // FreeBSD supports ARMv6 and ARMv7 as well as ARMv4 and ARMv5 (though deprecated)
                // detecting those variants is currently unimplemented
                switch runtime.GOARCH </span>{
                case Arm64:<span class="cov0" title="0">
                        variant = "v8"</span>
                default:<span class="cov0" title="0">
                        variant = Unknown</span>
                }
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("getCPUVariant for OS %s: %w", runtime.GOOS, errNotImplemented)</span>
        }

        <span class="cov0" title="0">return variant, nil</span>
}
</pre>
		
		<pre class="file" id="file414" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/credentials/dockercreds"
        "github.com/tektoncd/pipeline/pkg/credentials/gitcreds"
        credmatcher "github.com/tektoncd/pipeline/pkg/credentials/matcher"
        credwriter "github.com/tektoncd/pipeline/pkg/credentials/writer"
        "github.com/tektoncd/pipeline/pkg/names"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

const (
        credsInitHomeMountPrefix = "tekton-creds-init-home" // #nosec
        sshKnownHosts            = "known_hosts"
)

var dnsLabel1123Forbidden = regexp.MustCompile("[^a-zA-Z0-9-]+")

// credsInit reads secrets available to the given service account and
// searches for annotations matching a specific format (documented in
// docs/auth.md). Matching secrets are turned into Volumes for the Pod
// and VolumeMounts to be given to each Step. Additionally, a list of
// entrypointer arguments are returned, each with a meaning specific to
// the credential type it describes: git credentials expect one set of
// args while docker credentials expect another.
//
// Any errors encountered during this process are returned to the
// caller. If no matching annotated secrets are found, nil lists with a
// nil error are returned.
func credsInit(ctx context.Context, obj runtime.Object, serviceAccountName, namespace string, kubeclient kubernetes.Interface) ([]string, []corev1.Volume, []corev1.VolumeMount, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        cfg := config.FromContextOrDefaults(ctx)
        if cfg != nil &amp;&amp; cfg.FeatureFlags != nil &amp;&amp; cfg.FeatureFlags.DisableCredsInit </span><span class="cov8" title="1">{
                return nil, nil, nil, nil
        }</span>

        // service account if not specified in pipeline/task spec, read it from the ConfigMap
        // and defaults to `default` if its missing from the ConfigMap as well
        <span class="cov8" title="1">if serviceAccountName == "" </span><span class="cov8" title="1">{
                serviceAccountName = config.DefaultServiceAccountValue
        }</span>

        <span class="cov8" title="1">sa, err := kubeclient.CoreV1().ServiceAccounts(namespace).Get(ctx, serviceAccountName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov8" title="1">builders := []interface {
                credmatcher.Matcher
                credwriter.Writer
        }{dockercreds.NewBuilder(), gitcreds.NewBuilder()}

        var volumeMounts []corev1.VolumeMount
        var volumes []corev1.Volume
        var args []string
        var missingSecrets []string

        defer func() </span><span class="cov8" title="1">{
                recorder := controller.GetEventRecorder(ctx)
                if len(missingSecrets) &gt; 0 &amp;&amp; recorder != nil &amp;&amp; obj != nil </span><span class="cov8" title="1">{
                        recorder.Eventf(obj, corev1.EventTypeWarning, "FailedToRetrieveSecret",
                                "Unable to retrieve some secrets (%s); attempting to use them may not succeed.",
                                strings.Join(missingSecrets, ", "))
                }</span>
        }()

        // Track duplicated secrets, prevent errors like this:
        //  Pod "xxx" is invalid: spec.containers[0].volumeMounts[12].mountPath: Invalid value:
        //  "/tekton/creds-secrets/demo-docker-credentials": must be unique
        <span class="cov8" title="1">visitedSecrets := make(map[string]struct{})
        for _, secretEntry := range sa.Secrets </span><span class="cov8" title="1">{
                if secretEntry.Name == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := visitedSecrets[secretEntry.Name]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">visitedSecrets[secretEntry.Name] = struct{}{}

                secret, err := kubeclient.CoreV1().Secrets(namespace).Get(ctx, secretEntry.Name, metav1.GetOptions{})
                if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        missingSecrets = append(missingSecrets, secretEntry.Name)
                        logger.Warnf("Secret %q in ServiceAccount %s/%s not found, skipping", secretEntry.Name, namespace, serviceAccountName)
                        continue</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>

                <span class="cov8" title="1">if err := checkGitSSHSecret(ctx, secret); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>

                <span class="cov8" title="1">matched := false
                for _, b := range builders </span><span class="cov8" title="1">{
                        if sa := b.MatchingAnnotations(secret); len(sa) &gt; 0 </span><span class="cov8" title="1">{
                                matched = true
                                args = append(args, sa...)
                        }</span>
                }

                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                        // While secret names can use RFC1123 DNS subdomain name rules, the volume mount
                        // name required the stricter DNS label standard, for example no dots anymore.
                        sanitizedName := dnsLabel1123Forbidden.ReplaceAllString(secret.Name, "-")
                        name := names.SimpleNameGenerator.RestrictLengthWithRandomSuffix("tekton-internal-secret-volume-" + sanitizedName)
                        volumeMounts = append(volumeMounts, corev1.VolumeMount{
                                Name:      name,
                                MountPath: credmatcher.VolumeName(secret.Name),
                        })
                        volumes = append(volumes, corev1.Volume{
                                Name: name,
                                VolumeSource: corev1.VolumeSource{
                                        Secret: &amp;corev1.SecretVolumeSource{
                                                SecretName: secret.Name,
                                        },
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov8" title="1">{
                // There are no creds to initialize.
                return nil, nil, nil, nil
        }</span>

        <span class="cov8" title="1">return args, volumes, volumeMounts, nil</span>
}

// getCredsInitVolume returns a Volume and VolumeMount for /tekton/creds. Each call
// will return a new volume and volume mount. Takes an integer index to append to
// the name of the volume.
func getCredsInitVolume(ctx context.Context, idx int) (*corev1.Volume, *corev1.VolumeMount) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if cfg != nil &amp;&amp; cfg.FeatureFlags != nil &amp;&amp; cfg.FeatureFlags.DisableCredsInit </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">name := fmt.Sprintf("%s-%d", credsInitHomeMountPrefix, idx)
        v := corev1.Volume{
                Name: name,
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{
                        Medium: corev1.StorageMediumMemory,
                }},
        }
        vm := corev1.VolumeMount{
                Name:      name,
                MountPath: pipeline.CredsDir,
        }
        return &amp;v, &amp;vm</span>
}

// checkGitSSHSecret requires `known_host` field must be included in Git SSH Secret when feature flag
// `require-git-ssh-secret-known-hosts` is true.
func checkGitSSHSecret(ctx context.Context, secret *corev1.Secret) error <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)

        if secret.Type == corev1.SecretTypeSSHAuth &amp;&amp; cfg.FeatureFlags.RequireGitSSHSecretKnownHosts </span><span class="cov8" title="1">{
                if _, ok := secret.Data[sshKnownHosts]; !ok </span><span class="cov8" title="1">{
                        return errors.New("TaskRun validation failed. Git SSH Secret must have \"known_hosts\" included " +
                                "when feature flag \"require-git-ssh-secret-known-hosts\" is set to true")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file415" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "gomodules.xyz/jsonpatch/v2"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
)

const (
        binVolumeName    = "tekton-internal-bin"
        binDir           = "/tekton/bin"
        entrypointBinary = binDir + "/entrypoint"

        runVolumeName = "tekton-internal-run"

        // RunDir is the directory that contains runtime variable data for TaskRuns.
        // This includes files for handling container ordering, exit status codes, and more.
        // See [https://github.com/tektoncd/pipeline/blob/main/docs/developers/taskruns.md#tekton]
        // for more details.
        RunDir = "/tekton/run"

        downwardVolumeName     = "tekton-internal-downward"
        downwardMountPoint     = "/tekton/downward"
        terminationPath        = "/tekton/termination"
        downwardMountReadyFile = "ready"
        readyAnnotation        = "tekton.dev/ready"
        readyAnnotationValue   = "READY"

        stepPrefix    = "step-"
        sidecarPrefix = "sidecar-"

        downwardMountCancelFile = "cancel"
        cancelAnnotation        = "tekton.dev/cancel"
        cancelAnnotationValue   = "CANCEL"
)

var (
        // TODO(#1605): Generate volumeMount names, to avoid collisions.
        binMount = corev1.VolumeMount{
                Name:      binVolumeName,
                MountPath: binDir,
        }
        binROMount = corev1.VolumeMount{
                Name:      binVolumeName,
                MountPath: binDir,
                ReadOnly:  true,
        }
        binVolume = corev1.Volume{
                Name:         binVolumeName,
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }
        internalStepsMount = corev1.VolumeMount{
                Name:      "tekton-internal-steps",
                MountPath: pipeline.StepsDir,
        }

        downwardCancelVolumeItem = corev1.DownwardAPIVolumeFile{
                Path: downwardMountCancelFile,
                FieldRef: &amp;corev1.ObjectFieldSelector{
                        FieldPath: fmt.Sprintf("metadata.annotations['%s']", cancelAnnotation),
                },
        }
        // TODO(#1605): Signal sidecar readiness by injecting entrypoint,
        // remove dependency on Downward API.
        downwardVolume = corev1.Volume{
                Name: downwardVolumeName,
                VolumeSource: corev1.VolumeSource{
                        DownwardAPI: &amp;corev1.DownwardAPIVolumeSource{
                                Items: []corev1.DownwardAPIVolumeFile{{
                                        Path: downwardMountReadyFile,
                                        FieldRef: &amp;corev1.ObjectFieldSelector{
                                                FieldPath: fmt.Sprintf("metadata.annotations['%s']", readyAnnotation),
                                        },
                                }},
                        },
                },
        }
        downwardMount = corev1.VolumeMount{
                Name:      downwardVolumeName,
                MountPath: downwardMountPoint,
                // Marking this volume mount readonly is technically redundant,
                // since the volume itself is readonly, but including for completeness.
                ReadOnly: true,
        }
        // DownwardMountCancelFile is cancellation file mount to step, entrypoint will check this file to cancel the step.
        DownwardMountCancelFile = filepath.Join(downwardMountPoint, downwardMountCancelFile)
)

// orderContainers returns the specified steps, modified so that they are
// executed in order by overriding the entrypoint binary.
//
// Containers must have Command specified; if the user didn't specify a
// command, we must have fetched the image's ENTRYPOINT before calling this
// method, using entrypoint_lookup.go.
// Additionally, Step timeouts are added as entrypoint flag.
func orderContainers(ctx context.Context, commonExtraEntrypointArgs []string, steps []corev1.Container, taskSpec *v1.TaskSpec, breakpointConfig *v1.TaskRunDebug, waitForReadyAnnotation, enableKeepPodOnCancel bool) ([]corev1.Container, error) <span class="cov8" title="1">{
        if len(steps) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no steps specified")
        }</span>

        <span class="cov8" title="1">for i, s := range steps </span><span class="cov8" title="1">{
                var argsForEntrypoint = []string{}
                idx := strconv.Itoa(i)
                if i == 0 </span><span class="cov8" title="1">{
                        if waitForReadyAnnotation </span><span class="cov8" title="1">{
                                argsForEntrypoint = append(argsForEntrypoint,
                                        // First step waits for the Downward volume file.
                                        "-wait_file", filepath.Join(downwardMountPoint, downwardMountReadyFile),
                                        "-wait_file_content", // Wait for file contents, not just an empty file.
                                )
                        }</span>
                } else<span class="cov8" title="1"> { // Not the first step - wait for previous
                        argsForEntrypoint = append(argsForEntrypoint, "-wait_file", filepath.Join(RunDir, strconv.Itoa(i-1), "out"))
                }</span>
                <span class="cov8" title="1">argsForEntrypoint = append(argsForEntrypoint,
                        // Start next step.
                        "-post_file", filepath.Join(RunDir, idx, "out"),
                        "-termination_path", terminationPath,
                        "-step_metadata_dir", filepath.Join(RunDir, idx, "status"),
                )

                argsForEntrypoint = append(argsForEntrypoint, commonExtraEntrypointArgs...)
                if taskSpec != nil </span><span class="cov8" title="1">{
                        if taskSpec.Steps != nil &amp;&amp; len(taskSpec.Steps) &gt;= i+1 </span><span class="cov8" title="1">{
                                if taskSpec.Steps[i].OnError != "" </span><span class="cov8" title="1">{
                                        if taskSpec.Steps[i].OnError != v1.Continue &amp;&amp; taskSpec.Steps[i].OnError != v1.StopAndFail </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("task step onError must be either \"%s\" or \"%s\" but it is set to an invalid value \"%s\"",
                                                        v1.Continue, v1.StopAndFail, taskSpec.Steps[i].OnError)
                                        }</span>
                                        <span class="cov8" title="1">argsForEntrypoint = append(argsForEntrypoint, "-on_error", string(taskSpec.Steps[i].OnError))</span>
                                }
                                <span class="cov8" title="1">if taskSpec.Steps[i].Timeout != nil </span><span class="cov8" title="1">{
                                        argsForEntrypoint = append(argsForEntrypoint, "-timeout", taskSpec.Steps[i].Timeout.Duration.String())
                                }</span>
                                <span class="cov8" title="1">if taskSpec.Steps[i].StdoutConfig != nil </span><span class="cov8" title="1">{
                                        argsForEntrypoint = append(argsForEntrypoint, "-stdout_path", taskSpec.Steps[i].StdoutConfig.Path)
                                }</span>
                                <span class="cov8" title="1">if taskSpec.Steps[i].StderrConfig != nil </span><span class="cov8" title="1">{
                                        argsForEntrypoint = append(argsForEntrypoint, "-stderr_path", taskSpec.Steps[i].StderrConfig.Path)
                                }</span>
                                // add step results
                                <span class="cov8" title="1">stepResultArgs := stepResultArgument(taskSpec.Steps[i].Results)

                                argsForEntrypoint = append(argsForEntrypoint, stepResultArgs...)
                                if len(taskSpec.Steps[i].When) &gt; 0 </span><span class="cov8" title="1">{
                                        // marshal and pass to the entrypoint and unmarshal it there.
                                        marshal, err := json.Marshal(taskSpec.Steps[i].When)

                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("faile to resolve when %w", err)
                                        }</span>
                                        <span class="cov8" title="1">argsForEntrypoint = append(argsForEntrypoint, "--when_expressions", string(marshal))</span>
                                }
                        }
                        <span class="cov8" title="1">argsForEntrypoint = append(argsForEntrypoint, resultArgument(steps, taskSpec.Results)...)</span>
                }

                <span class="cov8" title="1">if breakpointConfig != nil &amp;&amp; breakpointConfig.NeedsDebugOnFailure() </span><span class="cov8" title="1">{
                        argsForEntrypoint = append(argsForEntrypoint, "-breakpoint_on_failure")
                }</span>
                <span class="cov8" title="1">if breakpointConfig != nil &amp;&amp; breakpointConfig.NeedsDebugBeforeStep(s.Name) </span><span class="cov8" title="1">{
                        argsForEntrypoint = append(argsForEntrypoint, "-debug_before_step")
                }</span>

                <span class="cov8" title="1">cmd, args := s.Command, s.Args
                if len(cmd) &gt; 0 </span><span class="cov8" title="1">{
                        argsForEntrypoint = append(argsForEntrypoint, "-entrypoint", cmd[0])
                }</span>
                <span class="cov8" title="1">if len(cmd) &gt; 1 </span><span class="cov8" title="1">{
                        args = append(cmd[1:], args...)
                }</span>
                <span class="cov8" title="1">argsForEntrypoint = append(argsForEntrypoint, "--")
                argsForEntrypoint = append(argsForEntrypoint, args...)

                steps[i].Command = []string{entrypointBinary}
                steps[i].Args = argsForEntrypoint
                steps[i].TerminationMessagePath = terminationPath
                if (i == 0 &amp;&amp; waitForReadyAnnotation) || enableKeepPodOnCancel </span><span class="cov8" title="1">{
                        // Mount the Downward volume into the first step container.
                        // if enableKeepPodOnCancel is true, mount the Downward volume into all the steps.
                        steps[i].VolumeMounts = append(steps[i].VolumeMounts, downwardMount)
                }</span>
        }

        <span class="cov8" title="1">return steps, nil</span>
}

// stepResultArgument creates the cli arguments for step results to the entrypointer.
func stepResultArgument(stepResults []v1.StepResult) []string <span class="cov8" title="1">{
        if len(stepResults) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">stepResultNames := []string{}
        for _, r := range stepResults </span><span class="cov8" title="1">{
                stepResultNames = append(stepResultNames, r.Name)
        }</span>
        <span class="cov8" title="1">return []string{"-step_results", strings.Join(stepResultNames, ",")}</span>
}

func resultArgument(steps []corev1.Container, results []v1.TaskResult) []string <span class="cov8" title="1">{
        if len(results) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return []string{"-results", collectResultsName(results)}</span>
}

func collectResultsName(results []v1.TaskResult) string <span class="cov8" title="1">{
        var resultNames []string
        for _, r := range results </span><span class="cov8" title="1">{
                if r.Value == nil </span><span class="cov8" title="1">{
                        resultNames = append(resultNames, r.Name)
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(resultNames, ",")</span>
}

var replaceReadyPatchBytes, replaceCancelPatchBytes []byte

func init() <span class="cov8" title="1">{
        // https://stackoverflow.com/questions/55573724/create-a-patch-to-add-a-kubernetes-annotation
        readyAnnotationPath := "/metadata/annotations/" + strings.Replace(readyAnnotation, "/", "~1", 1)
        var err error
        replaceReadyPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{{
                Operation: "replace",
                Path:      readyAnnotationPath,
                Value:     readyAnnotationValue,
        }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal replace ready patch bytes: %v", err)
        }</span>

        <span class="cov8" title="1">cancelAnnotationPath := "/metadata/annotations/" + strings.Replace(cancelAnnotation, "/", "~1", 1)
        replaceCancelPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{{
                Operation: "replace",
                Path:      cancelAnnotationPath,
                Value:     cancelAnnotationValue,
        }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal replace cancel patch bytes: %v", err)
        }</span>
}

// CancelPod cancels the pod
func CancelPod(ctx context.Context, kubeClient kubernetes.Interface, namespace, podName string) error <span class="cov8" title="1">{
        // PATCH the Pod's annotations to replace the cancel annotation with the
        // "CANCEL" value, to signal the pod to be cancelled.
        _, err := kubeClient.CoreV1().Pods(namespace).Patch(ctx, podName, types.JSONPatchType, replaceCancelPatchBytes, metav1.PatchOptions{})
        return err
}</span>

// UpdateReady updates the Pod's annotations to signal the first step to start
// by projecting the ready annotation via the Downward API.
func UpdateReady(ctx context.Context, kubeclient kubernetes.Interface, pod corev1.Pod) error <span class="cov8" title="1">{
        // Don't PATCH if the annotation is already Ready.
        if pod.Annotations[readyAnnotation] == readyAnnotationValue </span><span class="cov8" title="1">{
                return nil
        }</span>

        // PATCH the Pod's annotations to replace the ready annotation with the
        // "READY" value, to signal the first step to start.
        <span class="cov8" title="1">_, err := kubeclient.CoreV1().Pods(pod.Namespace).Patch(ctx, pod.Name, types.JSONPatchType, replaceReadyPatchBytes, metav1.PatchOptions{})
        return err</span>
}

// StopSidecars updates sidecar containers in the Pod to a nop image, which
// exits successfully immediately.
func StopSidecars(ctx context.Context, nopImage string, kubeclient kubernetes.Interface, namespace, name string) (*corev1.Pod, error) <span class="cov8" title="1">{
        newPod, err := kubeclient.CoreV1().Pods(namespace).Get(ctx, name, metav1.GetOptions{})
        if k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                // return NotFound as-is, since the K8s error checks don't handle wrapping.
                return nil, err
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting Pod %q when stopping sidecars: %w", name, err)
        }</span>

        <span class="cov8" title="1">updated := false
        if newPod.Status.Phase == corev1.PodRunning </span><span class="cov8" title="1">{
                for _, s := range newPod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                        // If the results-from is set to sidecar logs,
                        // a sidecar container with name `sidecar-log-results` is injected by the reconiler.
                        // Do not kill this sidecar. Let it exit gracefully.
                        if config.FromContextOrDefaults(ctx).FeatureFlags.ResultExtractionMethod == config.ResultExtractionMethodSidecarLogs &amp;&amp; s.Name == pipeline.ReservedResultsSidecarContainerName </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // Stop any running container that isn't a step.
                        // An injected sidecar container might not have the
                        // "sidecar-" prefix, so we can't just look for that
                        // prefix.
                        <span class="cov8" title="1">if !IsContainerStep(s.Name) &amp;&amp; s.State.Running != nil </span><span class="cov8" title="1">{
                                for j, c := range newPod.Spec.Containers </span><span class="cov8" title="1">{
                                        if c.Name == s.Name &amp;&amp; c.Image != nopImage </span><span class="cov8" title="1">{
                                                updated = true
                                                newPod.Spec.Containers[j].Image = nopImage
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                if newPod, err = kubeclient.CoreV1().Pods(newPod.Namespace).Update(ctx, newPod, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error stopping sidecars of Pod %q: %w", name, err)
                }</span>
        }
        <span class="cov8" title="1">return newPod, nil</span>
}

// IsSidecarStatusRunning determines if any SidecarStatus on a TaskRun
// is still running.
func IsSidecarStatusRunning(tr *v1.TaskRun) bool <span class="cov8" title="1">{
        for _, sidecar := range tr.Status.Sidecars </span><span class="cov8" title="1">{
                if sidecar.Terminated == nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// IsContainerStep returns true if the container name indicates that it
// represents a step.
func IsContainerStep(name string) bool <span class="cov8" title="1">{ return strings.HasPrefix(name, stepPrefix) }</span>

// IsContainerSidecar returns true if the container name indicates that it
// represents a sidecar.
func IsContainerSidecar(name string) bool <span class="cov8" title="1">{ return strings.HasPrefix(name, sidecarPrefix) }</span>

// TrimStepPrefix returns the container name, stripped of its step prefix.
func TrimStepPrefix(name string) string <span class="cov8" title="1">{ return strings.TrimPrefix(name, stepPrefix) }</span>

// TrimSidecarPrefix returns the container name, stripped of its sidecar
// prefix.
func TrimSidecarPrefix(name string) string <span class="cov8" title="1">{ return strings.TrimPrefix(name, sidecarPrefix) }</span>

// StepName returns the step name after adding "step-" prefix to the actual step name or
// returns "step-unnamed-&lt;step-index&gt;" if not specified
func StepName(name string, i int) string <span class="cov8" title="1">{
        if name != "" </span><span class="cov8" title="1">{
                return GetContainerName(name)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%sunnamed-%d", stepPrefix, i)</span>
}

// GetContainerName prefixes the input name with "step-"
func GetContainerName(name string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s", stepPrefix, name)
}</span>
</pre>
		
		<pre class="file" id="file416" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "encoding/json"

        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        corev1 "k8s.io/api/core/v1"
)

// EntrypointCache looks up an image's entrypoint (command) in a container
// image registry, possibly using the given service account's credentials.
type EntrypointCache interface {
        // get the Image data for the given image reference. If the value is
        // not found in the cache, it will be fetched from the image registry,
        // possibly using K8s service account imagePullSecrets.
        //
        // It also returns the digest associated with the given reference. If
        // the reference referred to an index, the returned digest will be the
        // index's digest, not any platform-specific image contained by the
        // index.
        get(ctx context.Context, ref name.Reference, namespace, serviceAccountName string, imagePullSecrets []corev1.LocalObjectReference, hasArgs bool) (*imageData, error)
}

// imageData contains information looked up about an image or multi-platform image index.
type imageData struct {
        digest   v1.Hash
        commands map[string][]string // map of platform -&gt; []command
}

// resolveEntrypoints looks up container image ENTRYPOINTs for all steps that
// don't specify a Command.
//
// Images that are not specified by digest will be specified by digest after
// lookup in the resulting list of containers.
func resolveEntrypoints(ctx context.Context, cache EntrypointCache, namespace, serviceAccountName string, imagePullSecrets []corev1.LocalObjectReference, steps []corev1.Container) ([]corev1.Container, error) <span class="cov8" title="1">{
        // Keep a local cache of name-&gt;imageData lookups, just for the scope of
        // resolving this set of steps. If the image is pushed to before the
        // next run, we need to resolve its digest and commands again, but we
        // can skip lookups while resolving the same TaskRun.
        localCache := map[name.Reference]imageData{}
        for i, s := range steps </span><span class="cov8" title="1">{
                // If the command is already specified, there's nothing to resolve.
                if len(s.Command) &gt; 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">hasArgs := len(s.Args) &gt; 0

                ref, err := name.ParseReference(s.Image, name.WeakValidation)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var id imageData
                if cid, found := localCache[ref]; found </span><span class="cov8" title="1">{
                        id = cid
                }</span> else<span class="cov8" title="1"> {
                        // Look it up for real.
                        lid, err := cache.get(ctx, ref, namespace, serviceAccountName, imagePullSecrets, hasArgs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">id = *lid

                        // Cache it locally in case another step in this task specifies the same image.
                        localCache[ref] = *lid</span>
                }

                // Resolve the original reference to a reference by digest.
                <span class="cov8" title="1">steps[i].Image = ref.Context().Digest(id.digest.String()).String()

                // Encode the map of platform-&gt;command to JSON and pass it via env var.
                b, err := json.Marshal(id.commands)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">steps[i].Env = append(steps[i].Env, corev1.EnvVar{
                        Name:  "TEKTON_PLATFORM_COMMANDS",
                        Value: string(b),
                })</span>
        }
        <span class="cov8" title="1">return steps, nil</span>
}
</pre>
		
		<pre class="file" id="file417" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/go-containerregistry/pkg/authn/k8schain"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        lru "github.com/hashicorp/golang-lru"
        "github.com/tektoncd/pipeline/pkg/platforms"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/kubernetes"
)

const cacheSize = 1024

type entrypointCache struct {
        kubeclient kubernetes.Interface
        lru        *lru.Cache // cache of digest-&gt;map[string][]string commands
}

// NewEntrypointCache returns a new entrypoint cache implementation that uses
// K8s credentials to pull image metadata from a container image registry.
func NewEntrypointCache(kubeclient kubernetes.Interface) (EntrypointCache, error) <span class="cov8" title="1">{
        lru, err := lru.New(cacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;entrypointCache{
                kubeclient: kubeclient,
                lru:        lru,
        }, nil</span>
}

// Get gets the image from the cache for the given ref, namespace, and SA.
//
// It also returns the digest associated with the given reference. If the
// reference referred to an index, the returned digest will be the index's
// digest, not any platform-specific image contained by the index.
func (e *entrypointCache) get(ctx context.Context, ref name.Reference, namespace, serviceAccountName string, imagePullSecrets []corev1.LocalObjectReference, hasArgs bool) (*imageData, error) <span class="cov8" title="1">{
        // If image is specified by digest, check the local cache.
        if digest, ok := ref.(name.Digest); ok </span><span class="cov8" title="1">{
                if id, ok := e.lru.Get(digest.String()); ok </span><span class="cov0" title="0">{
                        return id.(*imageData), nil
                }</span>
        }

        <span class="cov8" title="1">pullSecretsNames := make([]string, 0, len(imagePullSecrets))
        for _, ps := range imagePullSecrets </span><span class="cov8" title="1">{
                pullSecretsNames = append(pullSecretsNames, ps.Name)
        }</span>
        // Consult the remote registry, using imagePullSecrets.
        <span class="cov8" title="1">kc, err := k8schain.New(ctx, e.kubeclient, k8schain.Options{
                Namespace:          namespace,
                ServiceAccountName: serviceAccountName,
                ImagePullSecrets:   pullSecretsNames,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating k8schain: %w", err)
        }</span>

        <span class="cov8" title="1">desc, err := remote.Get(ref, remote.WithAuthFromKeychain(kc))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check the cache for this ref@digest, in case we've seen it before.
        // This saves looking up each constinuent image's commands if we've seen
        // the multi-platform image before.
        <span class="cov8" title="1">refByDigest := ref.Context().Digest(desc.Digest.String()).String()
        if id, ok := e.lru.Get(refByDigest); ok </span><span class="cov0" title="0">{
                return id.(*imageData), nil
        }</span>

        <span class="cov8" title="1">id := &amp;imageData{
                digest:   desc.Digest,
                commands: map[string][]string{},
        }
        switch </span>{
        case desc.MediaType.IsImage():<span class="cov8" title="1">
                img, err := desc.Image()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ep, plat, err := imageInfo(img, hasArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">id.commands[plat] = ep</span>
        case desc.MediaType.IsIndex():<span class="cov0" title="0">
                idx, err := desc.ImageIndex()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">id.commands, err = buildCommandMap(idx, hasArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("unsupported media type for image reference")</span>
        }

        // Cache the digest-&gt;commands for future lookup.
        <span class="cov8" title="1">e.lru.Add(refByDigest, id)

        return id, nil</span>
}

func buildCommandMap(idx v1.ImageIndex, hasArgs bool) (map[string][]string, error) <span class="cov8" title="1">{
        // Map platform strings to digest, to handle some ~malformed images
        // that specify the same manifest multiple times.
        platToDigest := map[string]v1.Hash{}

        cmds := map[string][]string{}

        mf, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, desc := range mf.Manifests </span><span class="cov8" title="1">{
                plat := desc.Platform.String()
                // skip unknown platforms.
                // Docker uses these to store attestation data: https://docs.docker.com/build/attestations/attestation-storage/#examples
                if plat == "unknown/unknown" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if got, found := platToDigest[plat]; found &amp;&amp; got != desc.Digest </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("duplicate unique image found for platform: %s: found %s and %s", plat, got, desc.Digest)
                }</span>
                <span class="cov8" title="1">platToDigest[plat] = desc.Digest
                img, err := idx.Image(desc.Digest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cmds[plat], _, err = imageInfo(img, hasArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return cmds, nil</span>
}

func imageInfo(img v1.Image, hasArgs bool) (cmd []string, platform string, err error) <span class="cov8" title="1">{
        cf, err := img.ConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">ep := cf.Config.Entrypoint
        if len(ep) == 0 </span><span class="cov8" title="1">{
                ep = cf.Config.Cmd
        }</span> else<span class="cov8" title="1"> if !hasArgs </span><span class="cov8" title="1">{
                // If no args, join Cmd to Entrypoint
                ep = append(ep, cf.Config.Cmd...)
        }</span>

        <span class="cov8" title="1">platformObj := platforms.NewPlatform()
        platformObj.OS = cf.OS
        platformObj.Architecture = cf.Architecture
        // A single image's config metadata doesn't include the CPU
        // architecture variant, but we'll assume this is okay since
        // the runtime node's image selection will also select the same
        // image. This will only be a problem if the image is a
        // single-platform image that happens to specify a variant, and
        // the runtime node it gets assigned to has a value for
        // runtime.GOARM.
        platform = platformObj.Format()

        return ep, platform, nil</span>
}
</pre>
		
		<pre class="file" id="file418" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "math"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/internal/computeresources/tasklevel"
        "github.com/tektoncd/pipeline/pkg/names"
        tknreconciler "github.com/tektoncd/pipeline/pkg/reconciler"
        "github.com/tektoncd/pipeline/pkg/spire"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/version"
        "k8s.io/client-go/kubernetes"
        "k8s.io/utils/strings/slices"
        "knative.dev/pkg/changeset"
        "knative.dev/pkg/kmap"
        "knative.dev/pkg/kmeta"
)

const (
        // TektonHermeticEnvVar is the env var we set in containers to indicate they should be run hermetically
        TektonHermeticEnvVar = "TEKTON_HERMETIC"

        // ExecutionModeAnnotation is an experimental optional annotation to set the execution mode on a TaskRun
        ExecutionModeAnnotation = "experimental.tekton.dev/execution-mode"

        // ExecutionModeHermetic indicates hermetic execution mode
        ExecutionModeHermetic = "hermetic"

        // deadlineFactor is the factor we multiply the taskrun timeout with to determine the activeDeadlineSeconds of the Pod.
        // It has to be higher than the timeout (to not be killed before)
        deadlineFactor = 1.5

        // SpiffeCsiDriver is the CSI storage plugin needed for injection of SPIFFE workload api.
        SpiffeCsiDriver = "csi.spiffe.io"

        // OsSelectorLabel is the label Kubernetes uses for OS-specific workloads (https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetes-io-os)
        OsSelectorLabel = "kubernetes.io/os"

        // TerminationReasonTimeoutExceeded indicates a step execution timed out.
        TerminationReasonTimeoutExceeded = "TimeoutExceeded"

        // TerminationReasonSkipped indicates a step execution was skipped due to previous step failed.
        TerminationReasonSkipped = "Skipped"

        // TerminationReasonContinued indicates a step errored but was ignored since onError was set to continue.
        TerminationReasonContinued = "Continued"

        // TerminationReasonCancelled indicates a step was cancelled.
        TerminationReasonCancelled = "Cancelled"

        StepArtifactPathPattern = "step.artifacts.path"

        // K8s version to determine if to use native k8s sidecar or Tekton sidecar
        SidecarK8sMinorVersionCheck = 29
)

// These are effectively const, but Go doesn't have such an annotation.
var (
        ReleaseAnnotation = "pipeline.tekton.dev/release"

        groupVersionKind = schema.GroupVersionKind{
                Group:   v1.SchemeGroupVersion.Group,
                Version: v1.SchemeGroupVersion.Version,
                Kind:    "TaskRun",
        }
        // These are injected into all of the source/step containers.
        implicitVolumeMounts = []corev1.VolumeMount{{
                Name:      "tekton-internal-workspace",
                MountPath: pipeline.WorkspaceDir,
        }, {
                Name:      "tekton-internal-home",
                MountPath: pipeline.HomeDir,
        }, {
                Name:      "tekton-internal-results",
                MountPath: pipeline.DefaultResultPath,
        }, {
                Name:      "tekton-internal-steps",
                MountPath: pipeline.StepsDir,
                ReadOnly:  true,
        }, {
                Name:      "tekton-internal-artifacts",
                MountPath: pipeline.ArtifactsDir,
        }}
        implicitVolumes = []corev1.Volume{{
                Name:         "tekton-internal-workspace",
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }, {
                Name:         "tekton-internal-home",
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }, {
                Name:         "tekton-internal-results",
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }, {
                Name:         "tekton-internal-steps",
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }, {
                Name:         "tekton-internal-artifacts",
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }}

        // MaxActiveDeadlineSeconds is a maximum permitted value to be used for a task with no timeout
        MaxActiveDeadlineSeconds = int64(math.MaxInt32)
)

// Builder exposes options to configure Pod construction from TaskSpecs/Runs.
type Builder struct {
        Images          pipeline.Images
        KubeClient      kubernetes.Interface
        EntrypointCache EntrypointCache
}

// Transformer is a function that will transform a Pod. This can be used to mutate
// a Pod generated by Tekton after it got generated.
type Transformer func(*corev1.Pod) (*corev1.Pod, error)

// Build creates a Pod using the configuration options set on b and the TaskRun
// and TaskSpec provided in its arguments. An error is returned if there are
// any problems during the conversion.
func (b *Builder) Build(ctx context.Context, taskRun *v1.TaskRun, taskSpec v1.TaskSpec, transformers ...Transformer) (*corev1.Pod, error) <span class="cov8" title="1">{
        var (
                scriptsInit                                       *corev1.Container
                initContainers, stepContainers, sidecarContainers []corev1.Container
                volumes                                           []corev1.Volume
        )
        volumeMounts := []corev1.VolumeMount{binROMount}
        implicitEnvVars := []corev1.EnvVar{}
        featureFlags := config.FromContextOrDefaults(ctx).FeatureFlags
        defaultForbiddenEnv := config.FromContextOrDefaults(ctx).Defaults.DefaultForbiddenEnv
        alphaAPIEnabled := featureFlags.EnableAPIFields == config.AlphaAPIFields
        sidecarLogsResultsEnabled := config.FromContextOrDefaults(ctx).FeatureFlags.ResultExtractionMethod == config.ResultExtractionMethodSidecarLogs
        enableKeepPodOnCancel := featureFlags.EnableKeepPodOnCancel
        setSecurityContext := config.FromContextOrDefaults(ctx).FeatureFlags.SetSecurityContext
        setSecurityContextReadOnlyRootFilesystem := config.FromContextOrDefaults(ctx).FeatureFlags.SetSecurityContextReadOnlyRootFilesystem
        defaultManagedByLabelValue := config.FromContextOrDefaults(ctx).Defaults.DefaultManagedByLabelValue

        // Add our implicit volumes first, so they can be overridden by the user if they prefer.
        volumes = append(volumes, implicitVolumes...)
        volumeMounts = append(volumeMounts, implicitVolumeMounts...)

        // Create Volumes and VolumeMounts for any credentials found in annotated
        // Secrets, along with any arguments needed by Step entrypoints to process
        // those secrets.
        commonExtraEntrypointArgs := []string{}
        // Entrypoint arg to enable or disable spire
        if config.IsSpireEnabled(ctx) </span><span class="cov8" title="1">{
                commonExtraEntrypointArgs = append(commonExtraEntrypointArgs, "-enable_spire")
        }</span>
        <span class="cov8" title="1">credEntrypointArgs, credVolumes, credVolumeMounts, err := credsInit(ctx, taskRun, taskRun.Spec.ServiceAccountName, taskRun.Namespace, b.KubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">commonExtraEntrypointArgs = append(commonExtraEntrypointArgs, credEntrypointArgs...)
        volumes = append(volumes, credVolumes...)
        volumeMounts = append(volumeMounts, credVolumeMounts...)

        // Merge step template with steps.
        // TODO(#1605): Move MergeSteps to pkg/pod
        steps, err := v1.MergeStepsWithStepTemplate(taskSpec.StepTemplate, taskSpec.Steps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">steps, err = v1.MergeStepsWithSpecs(steps, taskRun.Spec.StepSpecs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if taskRun.Spec.ComputeResources != nil </span><span class="cov8" title="1">{
                tasklevel.ApplyTaskLevelComputeResources(steps, taskRun.Spec.ComputeResources)
        }</span>

        <span class="cov8" title="1">securityContextConfig := SecurityContextConfig{
                SetSecurityContext:        setSecurityContext,
                SetReadOnlyRootFilesystem: setSecurityContextReadOnlyRootFilesystem,
        }

        windows := usesWindows(taskRun)
        pollingInterval := config.FromContextOrDefaults(ctx).Defaults.DefaultSidecarLogPollingInterval
        if sidecarLogsResultsEnabled </span><span class="cov8" title="1">{
                if taskSpec.Results != nil || artifactsPathReferenced(steps) </span><span class="cov8" title="1">{
                        // create a results sidecar
                        resultsSidecar, err := createResultsSidecar(taskSpec, b.Images.SidecarLogResultsImage, securityContextConfig, windows, pollingInterval)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">taskSpec.Sidecars = append(taskSpec.Sidecars, resultsSidecar)
                        commonExtraEntrypointArgs = append(commonExtraEntrypointArgs, "-result_from", config.ResultExtractionMethodSidecarLogs)</span>
                }
        }

        <span class="cov8" title="1">sidecars, err := v1.MergeSidecarsWithSpecs(taskSpec.Sidecars, taskRun.Spec.SidecarSpecs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">initContainers = []corev1.Container{
                entrypointInitContainer(b.Images.EntrypointImage, steps, securityContextConfig, windows),
        }

        // Convert any steps with Script to command+args.
        // If any are found, append an init container to initialize scripts.
        if alphaAPIEnabled </span><span class="cov8" title="1">{
                scriptsInit, stepContainers, sidecarContainers = convertScripts(b.Images.ShellImage, b.Images.ShellImageWin, steps, sidecars, taskRun.Spec.Debug, securityContextConfig)
        }</span> else<span class="cov8" title="1"> {
                scriptsInit, stepContainers, sidecarContainers = convertScripts(b.Images.ShellImage, "", steps, sidecars, nil, securityContextConfig)
        }</span>

        <span class="cov8" title="1">if scriptsInit != nil </span><span class="cov8" title="1">{
                initContainers = append(initContainers, *scriptsInit)
                volumes = append(volumes, scriptsVolume)
        }</span>
        <span class="cov8" title="1">if alphaAPIEnabled &amp;&amp; taskRun.Spec.Debug != nil &amp;&amp; taskRun.Spec.Debug.NeedsDebug() </span><span class="cov8" title="1">{
                volumes = append(volumes, debugScriptsVolume, debugInfoVolume)
        }</span>
        // Initialize any workingDirs under /workspace.
        <span class="cov8" title="1">if workingDirInit := workingDirInit(b.Images.WorkingDirInitImage, stepContainers, securityContextConfig, windows); workingDirInit != nil </span><span class="cov8" title="1">{
                initContainers = append(initContainers, *workingDirInit)
        }</span>

        // By default, use an empty pod template and take the one defined in the task run spec if any
        <span class="cov8" title="1">podTemplate := pod.Template{}

        if taskRun.Spec.PodTemplate != nil </span><span class="cov8" title="1">{
                podTemplate = *taskRun.Spec.PodTemplate
        }</span>

        // Resolve entrypoint for any steps that don't specify command.
        <span class="cov8" title="1">stepContainers, err = resolveEntrypoints(ctx, b.EntrypointCache, taskRun.Namespace, taskRun.Spec.ServiceAccountName, podTemplate.ImagePullSecrets, stepContainers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">readyImmediately := isPodReadyImmediately(*featureFlags, taskSpec.Sidecars)

        if alphaAPIEnabled </span><span class="cov8" title="1">{
                stepContainers, err = orderContainers(ctx, commonExtraEntrypointArgs, stepContainers, &amp;taskSpec, taskRun.Spec.Debug, !readyImmediately, enableKeepPodOnCancel)
        }</span> else<span class="cov8" title="1"> {
                stepContainers, err = orderContainers(ctx, commonExtraEntrypointArgs, stepContainers, &amp;taskSpec, nil, !readyImmediately, enableKeepPodOnCancel)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">volumes = append(volumes, binVolume)
        if !readyImmediately || enableKeepPodOnCancel </span><span class="cov8" title="1">{
                downwardVolumeDup := downwardVolume.DeepCopy()
                if enableKeepPodOnCancel </span><span class="cov8" title="1">{
                        downwardVolumeDup.VolumeSource.DownwardAPI.Items = append(downwardVolumeDup.VolumeSource.DownwardAPI.Items, downwardCancelVolumeItem)
                }</span>
                <span class="cov8" title="1">volumes = append(volumes, *downwardVolumeDup)</span>
        }

        // Order of precedence for envs
        // implicit env vars
        // Superceded by step env vars
        // Superceded by config-default default-pod-template envs
        // Superceded by podTemplate envs
        <span class="cov8" title="1">if len(implicitEnvVars) &gt; 0 </span><span class="cov0" title="0">{
                for i, s := range stepContainers </span><span class="cov0" title="0">{
                        env := append(implicitEnvVars, s.Env...) //nolint:gocritic
                        stepContainers[i].Env = env
                }</span>
        }
        <span class="cov8" title="1">filteredEnvs := []corev1.EnvVar{}
        for _, e := range podTemplate.Env </span><span class="cov8" title="1">{
                if !slices.Contains(defaultForbiddenEnv, e.Name) </span><span class="cov8" title="1">{
                        filteredEnvs = append(filteredEnvs, e)
                }</span>
        }
        <span class="cov8" title="1">if len(podTemplate.Env) &gt; 0 </span><span class="cov8" title="1">{
                for i, s := range stepContainers </span><span class="cov8" title="1">{
                        env := append(s.Env, filteredEnvs...) //nolint:gocritic
                        stepContainers[i].Env = env
                }</span>
        }
        // Add env var if hermetic execution was requested &amp; if the alpha API is enabled
        <span class="cov8" title="1">if taskRun.Annotations[ExecutionModeAnnotation] == ExecutionModeHermetic &amp;&amp; alphaAPIEnabled </span><span class="cov8" title="1">{
                for i, s := range stepContainers </span><span class="cov8" title="1">{
                        // Add it at the end so it overrides
                        env := append(s.Env, corev1.EnvVar{Name: TektonHermeticEnvVar, Value: "1"}) //nolint:gocritic
                        stepContainers[i].Env = env
                }</span>
        }

        // Add implicit volume mounts to each step, unless the step specifies
        // its own volume mount at that path.
        <span class="cov8" title="1">for i, s := range stepContainers </span><span class="cov8" title="1">{
                // Mount /tekton/creds with a fresh volume for each Step. It needs to
                // be world-writeable and empty so creds can be initialized in there. Cant
                // guarantee what UID container runs with. If legacy credential helper (creds-init)
                // is disabled via feature flag then these can be nil since we don't want to mount
                // the automatic credential volume.
                v, vm := getCredsInitVolume(ctx, i)
                if v != nil &amp;&amp; vm != nil </span><span class="cov8" title="1">{
                        volumes = append(volumes, *v)
                        s.VolumeMounts = append(s.VolumeMounts, *vm)
                }</span>

                // Add /tekton/run state volumes.
                // Each step should only mount their own volume as RW,
                // all other steps should be mounted RO.
                <span class="cov8" title="1">volumes = append(volumes, runVolume(i))
                for j := range stepContainers </span><span class="cov8" title="1">{
                        s.VolumeMounts = append(s.VolumeMounts, runMount(j, i != j))
                }</span>

                <span class="cov8" title="1">requestedVolumeMounts := map[string]bool{}
                for _, vm := range s.VolumeMounts </span><span class="cov8" title="1">{
                        requestedVolumeMounts[filepath.Clean(vm.MountPath)] = true
                }</span>
                <span class="cov8" title="1">var toAdd []corev1.VolumeMount
                for _, imp := range volumeMounts </span><span class="cov8" title="1">{
                        if !requestedVolumeMounts[filepath.Clean(imp.MountPath)] </span><span class="cov8" title="1">{
                                toAdd = append(toAdd, imp)
                        }</span>
                }
                <span class="cov8" title="1">vms := append(s.VolumeMounts, toAdd...) //nolint:gocritic
                stepContainers[i].VolumeMounts = vms</span>
        }

        <span class="cov8" title="1">if sidecarLogsResultsEnabled </span><span class="cov8" title="1">{
                // Mount implicit volumes onto sidecarContainers
                // so that they can access /tekton/results and /tekton/run.
                if taskSpec.Results != nil || artifactsPathReferenced(steps) </span><span class="cov8" title="1">{
                        for i, s := range sidecarContainers </span><span class="cov8" title="1">{
                                if s.Name != pipeline.ReservedResultsSidecarName </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">for j := range stepContainers </span><span class="cov8" title="1">{
                                        s.VolumeMounts = append(s.VolumeMounts, runMount(j, true))
                                }</span>
                                <span class="cov8" title="1">requestedVolumeMounts := map[string]bool{}
                                for _, vm := range s.VolumeMounts </span><span class="cov8" title="1">{
                                        requestedVolumeMounts[filepath.Clean(vm.MountPath)] = true
                                }</span>
                                <span class="cov8" title="1">var toAdd []corev1.VolumeMount
                                for _, imp := range volumeMounts </span><span class="cov8" title="1">{
                                        if !requestedVolumeMounts[filepath.Clean(imp.MountPath)] </span><span class="cov8" title="1">{
                                                toAdd = append(toAdd, imp)
                                        }</span>
                                }
                                <span class="cov8" title="1">vms := append(s.VolumeMounts, toAdd...) //nolint:gocritic
                                sidecarContainers[i].VolumeMounts = vms</span>
                        }
                }
        }

        // This loop:
        // - sets container name to add "step-" prefix or "step-unnamed-#" if not specified.
        // TODO(#1605): Remove this loop and make each transformation in
        // isolation.
        <span class="cov8" title="1">for i, s := range stepContainers </span><span class="cov8" title="1">{
                stepContainers[i].Name = names.SimpleNameGenerator.RestrictLength(StepName(s.Name, i))
        }</span>

        // Add podTemplate Volumes to the explicitly declared use volumes
        <span class="cov8" title="1">volumes = append(volumes, taskSpec.Volumes...)
        volumes = append(volumes, podTemplate.Volumes...)

        if err := v1.ValidateVolumes(volumes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">readonly := true
        if config.IsSpireEnabled(ctx) </span><span class="cov8" title="1">{
                // add SPIRE's CSI volume to the explicitly declared use volumes
                volumes = append(volumes, corev1.Volume{
                        Name: spire.WorkloadAPI,
                        VolumeSource: corev1.VolumeSource{
                                CSI: &amp;corev1.CSIVolumeSource{
                                        Driver:   SpiffeCsiDriver,
                                        ReadOnly: &amp;readonly,
                                },
                        },
                })

                // mount SPIRE's CSI volume to each Step Container
                for i := range stepContainers </span><span class="cov8" title="1">{
                        c := &amp;stepContainers[i]
                        c.VolumeMounts = append(c.VolumeMounts, corev1.VolumeMount{
                                Name:      spire.WorkloadAPI,
                                MountPath: spire.VolumeMountPath,
                                ReadOnly:  readonly,
                        })
                }</span>
                <span class="cov8" title="1">for i := range initContainers </span><span class="cov8" title="1">{
                        // mount SPIRE's CSI volume to each Init Container
                        c := &amp;initContainers[i]
                        c.VolumeMounts = append(c.VolumeMounts, corev1.VolumeMount{
                                Name:      spire.WorkloadAPI,
                                MountPath: spire.VolumeMountPath,
                                ReadOnly:  readonly,
                        })
                }</span>
        }

        <span class="cov8" title="1">mergedPodContainers := stepContainers
        mergedPodInitContainers := initContainers

        useTektonSidecar := true
        if config.FromContextOrDefaults(ctx).FeatureFlags.EnableKubernetesSidecar </span><span class="cov8" title="1">{
                // Go through the logic for enable-kubernetes feature flag
                // Kubernetes Version
                dc := b.KubeClient.Discovery()
                sv, err := dc.ServerVersion()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if IsNativeSidecarSupport(sv) </span><span class="cov8" title="1">{
                        // Add RestartPolicy and Merge into initContainer
                        useTektonSidecar = false
                        for i := range sidecarContainers </span><span class="cov8" title="1">{
                                sc := &amp;sidecarContainers[i]
                                always := corev1.ContainerRestartPolicyAlways
                                sc.RestartPolicy = &amp;always
                                sc.Name = names.SimpleNameGenerator.RestrictLength(fmt.Sprintf("%v%v", sidecarPrefix, sc.Name))
                                mergedPodInitContainers = append(mergedPodInitContainers, *sc)
                        }</span>
                }
        }
        <span class="cov8" title="1">if useTektonSidecar </span><span class="cov8" title="1">{
                // Merge sidecar containers with step containers.
                for _, sc := range sidecarContainers </span><span class="cov8" title="1">{
                        sc.Name = names.SimpleNameGenerator.RestrictLength(fmt.Sprintf("%v%v", sidecarPrefix, sc.Name))
                        mergedPodContainers = append(mergedPodContainers, sc)
                }</span>
        }

        <span class="cov8" title="1">var dnsPolicy corev1.DNSPolicy
        if podTemplate.DNSPolicy != nil </span><span class="cov8" title="1">{
                dnsPolicy = *podTemplate.DNSPolicy
        }</span>

        <span class="cov8" title="1">var priorityClassName string
        if podTemplate.PriorityClassName != nil </span><span class="cov8" title="1">{
                priorityClassName = *podTemplate.PriorityClassName
        }</span>

        <span class="cov8" title="1">podAnnotations := kmap.ExcludeKeys(kmeta.CopyMap(taskRun.Annotations), tknreconciler.KubernetesManagedByAnnotationKey)
        podAnnotations[ReleaseAnnotation] = changeset.Get()

        if readyImmediately </span><span class="cov8" title="1">{
                podAnnotations[readyAnnotation] = readyAnnotationValue
        }</span>

        // calculate the activeDeadlineSeconds based on the specified timeout (uses default timeout if it's not specified)
        <span class="cov8" title="1">activeDeadlineSeconds := int64(taskRun.GetTimeout(ctx).Seconds() * deadlineFactor)
        // set activeDeadlineSeconds to the max. allowed value i.e. max int32 when timeout is explicitly set to 0
        if taskRun.GetTimeout(ctx) == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                activeDeadlineSeconds = MaxActiveDeadlineSeconds
        }</span>

        <span class="cov8" title="1">podNameSuffix := "-pod"
        if taskRunRetries := len(taskRun.Status.RetriesStatus); taskRunRetries &gt; 0 </span><span class="cov8" title="1">{
                podNameSuffix = fmt.Sprintf("%s-retry%d", podNameSuffix, taskRunRetries)
        }</span>
        <span class="cov8" title="1">newPod := &amp;corev1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        // We execute the build's pod in the same namespace as where the build was
                        // created so that it can access colocated resources.
                        Namespace: taskRun.Namespace,
                        // Generate a unique name based on the build's name.
                        // The name is univocally generated so that in case of
                        // stale informer cache, we never create duplicate Pods
                        Name: kmeta.ChildName(taskRun.Name, podNameSuffix),
                        // If our parent TaskRun is deleted, then we should be as well.
                        OwnerReferences: []metav1.OwnerReference{
                                *metav1.NewControllerRef(taskRun, groupVersionKind),
                        },
                        Annotations: podAnnotations,
                        Labels:      makeLabels(taskRun, defaultManagedByLabelValue),
                },
                Spec: corev1.PodSpec{
                        RestartPolicy:                corev1.RestartPolicyNever,
                        InitContainers:               mergedPodInitContainers,
                        Containers:                   mergedPodContainers,
                        ServiceAccountName:           taskRun.Spec.ServiceAccountName,
                        Volumes:                      volumes,
                        NodeSelector:                 podTemplate.NodeSelector,
                        Tolerations:                  podTemplate.Tolerations,
                        Affinity:                     podTemplate.Affinity,
                        SecurityContext:              podTemplate.SecurityContext,
                        RuntimeClassName:             podTemplate.RuntimeClassName,
                        AutomountServiceAccountToken: podTemplate.AutomountServiceAccountToken,
                        SchedulerName:                podTemplate.SchedulerName,
                        HostNetwork:                  podTemplate.HostNetwork,
                        DNSPolicy:                    dnsPolicy,
                        DNSConfig:                    podTemplate.DNSConfig,
                        EnableServiceLinks:           podTemplate.EnableServiceLinks,
                        PriorityClassName:            priorityClassName,
                        ImagePullSecrets:             podTemplate.ImagePullSecrets,
                        HostAliases:                  podTemplate.HostAliases,
                        TopologySpreadConstraints:    podTemplate.TopologySpreadConstraints,
                        ActiveDeadlineSeconds:        &amp;activeDeadlineSeconds, // Set ActiveDeadlineSeconds to mark the pod as "terminating" (like a Job)
                },
        }

        for _, f := range transformers </span><span class="cov0" title="0">{
                newPod, err = f(newPod)
                if err != nil </span><span class="cov0" title="0">{
                        return newPod, err
                }</span>
        }

        <span class="cov8" title="1">return newPod, nil</span>
}

// makeLabels constructs the labels we will propagate from TaskRuns to Pods.
func makeLabels(s *v1.TaskRun, defaultManagedByLabelValue string) map[string]string <span class="cov8" title="1">{
        labels := make(map[string]string, len(s.ObjectMeta.Labels)+1)
        // NB: Set this *before* passing through TaskRun labels. If the TaskRun
        // has a managed-by label, it should override this default.

        // Copy through the TaskRun's labels to the underlying Pod's.
        for k, v := range s.ObjectMeta.Labels </span><span class="cov8" title="1">{
                labels[k] = v
        }</span>

        // NB: Set this *after* passing through TaskRun Labels. If the TaskRun
        // specifies this label, it should be overridden by this value.
        <span class="cov8" title="1">labels[pipeline.TaskRunLabelKey] = s.Name
        labels[pipeline.TaskRunUIDLabelKey] = string(s.UID)
        // Enforce app.kubernetes.io/managed-by to be the value configured
        labels[tknreconciler.KubernetesManagedByAnnotationKey] = defaultManagedByLabelValue
        return labels</span>
}

// isPodReadyImmediately returns a bool indicating whether the
// controller should consider the Pod "Ready" as soon as it's deployed.
// This will add the `Ready` annotation when creating the Pod,
// and prevent the first step from waiting for the annotation to appear before starting.
func isPodReadyImmediately(featureFlags config.FeatureFlags, sidecars []v1.Sidecar) bool <span class="cov8" title="1">{
        // If the TaskRun has sidecars, we must wait for them
        if len(sidecars) &gt; 0 || featureFlags.RunningInEnvWithInjectedSidecars </span><span class="cov8" title="1">{
                if featureFlags.AwaitSidecarReadiness </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">log.Printf("warning: not waiting for sidecars before starting first Step of Task pod")</span>
        }
        <span class="cov8" title="1">return true</span>
}

func runMount(i int, ro bool) corev1.VolumeMount <span class="cov8" title="1">{
        return corev1.VolumeMount{
                Name:      fmt.Sprintf("%s-%d", runVolumeName, i),
                MountPath: filepath.Join(RunDir, strconv.Itoa(i)),
                ReadOnly:  ro,
        }
}</span>

func runVolume(i int) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name:         fmt.Sprintf("%s-%d", runVolumeName, i),
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }
}</span>

// entrypointInitContainer generates a few init containers based of a set of command (in images), volumes to run, and whether the pod will run on a windows node
// This should effectively merge multiple command and volumes together.
// If setSecurityContext is true, the init container will include a security context
// allowing it to run in namespaces with restriced pod security admission.
func entrypointInitContainer(image string, steps []v1.Step, securityContext SecurityContextConfig, windows bool) corev1.Container <span class="cov8" title="1">{
        // Invoke the entrypoint binary in "cp mode" to copy itself
        // into the correct location for later steps and initialize steps folder
        command := []string{"/ko-app/entrypoint", "init", "/ko-app/entrypoint", entrypointBinary}
        for i, s := range steps </span><span class="cov8" title="1">{
                command = append(command, StepName(s.Name, i))
        }</span>
        <span class="cov8" title="1">volumeMounts := []corev1.VolumeMount{binMount, internalStepsMount}

        // Rewrite steps with entrypoint binary. Append the entrypoint init
        // container to place the entrypoint binary. Also add timeout flags
        // to entrypoint binary.
        prepareInitContainer := corev1.Container{
                Name:  "prepare",
                Image: image,
                // Rewrite default WorkingDir from "/home/nonroot" to "/"
                // as suggested at https://github.com/GoogleContainerTools/distroless/issues/718
                // to avoid permission errors with nonroot users not equal to `65532`
                WorkingDir:   "/",
                Command:      command,
                VolumeMounts: volumeMounts,
        }
        if securityContext.SetSecurityContext </span><span class="cov8" title="1">{
                prepareInitContainer.SecurityContext = securityContext.GetSecurityContext(windows)
        }</span>
        <span class="cov8" title="1">return prepareInitContainer</span>
}

// createResultsSidecar creates a sidecar that will run the sidecarlogresults binary,
// based on the spec of the Task, the image that should run in the results sidecar,
// whether it will run on a windows node, and whether the sidecar should include a security context
// that will allow it to run in namespaces with "restricted" pod security admission.
// It will also provide arguments to the binary that allow it to surface the step results.
func createResultsSidecar(taskSpec v1.TaskSpec, image string, securityContext SecurityContextConfig, windows bool, pollingInterval time.Duration) (v1.Sidecar, error) <span class="cov8" title="1">{
        names := make([]string, 0, len(taskSpec.Results))
        for _, r := range taskSpec.Results </span><span class="cov8" title="1">{
                names = append(names, r.Name)
        }</span>

        <span class="cov8" title="1">stepNames := make([]string, 0, len(taskSpec.Steps))
        var artifactProducerSteps []string
        for i, s := range taskSpec.Steps </span><span class="cov8" title="1">{
                stepName := StepName(s.Name, i)
                stepNames = append(stepNames, stepName)
                if artifactPathReferencedInStep(s) </span><span class="cov8" title="1">{
                        artifactProducerSteps = append(artifactProducerSteps, GetContainerName(s.Name))
                }</span>
        }

        <span class="cov8" title="1">resultsStr := strings.Join(names, ",")
        command := []string{"/ko-app/sidecarlogresults", "-results-dir", pipeline.DefaultResultPath, "-result-names", resultsStr, "-step-names", strings.Join(artifactProducerSteps, ",")}

        // create a map of container Name to step results
        stepResults := map[string][]string{}
        for i, s := range taskSpec.Steps </span><span class="cov8" title="1">{
                if len(s.Results) &gt; 0 </span><span class="cov8" title="1">{
                        stepName := StepName(s.Name, i)
                        stepResults[stepName] = make([]string, 0, len(s.Results))
                        for _, r := range s.Results </span><span class="cov8" title="1">{
                                stepResults[stepName] = append(stepResults[stepName], r.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">stepResultsBytes, err := json.Marshal(stepResults)
        if err != nil </span><span class="cov0" title="0">{
                return v1.Sidecar{}, err
        }</span>
        <span class="cov8" title="1">if len(stepResultsBytes) &gt; 0 </span><span class="cov8" title="1">{
                command = append(command, "-step-results", string(stepResultsBytes))
        }</span>
        <span class="cov8" title="1">sidecar := v1.Sidecar{
                Name:    pipeline.ReservedResultsSidecarName,
                Image:   image,
                Command: command,
                Env: []corev1.EnvVar{
                        {
                                Name:  "SIDECAR_LOG_POLLING_INTERVAL",
                                Value: pollingInterval.String(),
                        },
                },
        }

        if securityContext.SetSecurityContext </span><span class="cov8" title="1">{
                sidecar.SecurityContext = securityContext.GetSecurityContext(windows)
        }</span>

        <span class="cov8" title="1">return sidecar, nil</span>
}

// usesWindows returns true if the TaskRun will run on a windows node,
// based on its node selector.
// See https://kubernetes.io/docs/concepts/windows/user-guide/ for more info.
func usesWindows(tr *v1.TaskRun) bool <span class="cov8" title="1">{
        if tr.Spec.PodTemplate == nil || tr.Spec.PodTemplate.NodeSelector == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">osSelector := tr.Spec.PodTemplate.NodeSelector[OsSelectorLabel]
        return osSelector == "windows"</span>
}

func artifactsPathReferenced(steps []v1.Step) bool <span class="cov8" title="1">{
        for _, step := range steps </span><span class="cov8" title="1">{
                if artifactPathReferencedInStep(step) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func artifactPathReferencedInStep(step v1.Step) bool <span class="cov8" title="1">{
        // `$(step.artifacts.path)` in  taskRun.Spec.TaskSpec.Steps and `taskSpec.steps` are substituted when building the pod while when setting status for taskRun
        // neither of them is substituted, so we need two forms to check if artifactsPath is referenced in steps.
        unresolvedPath := "$(" + artifactref.StepArtifactPathPattern + ")"

        path := filepath.Join(pipeline.StepsDir, GetContainerName(step.Name), "artifacts", "provenance.json")
        if strings.Contains(step.Script, path) || strings.Contains(step.Script, unresolvedPath) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, arg := range step.Args </span><span class="cov8" title="1">{
                if strings.Contains(arg, path) || strings.Contains(arg, unresolvedPath) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">for _, c := range step.Command </span><span class="cov8" title="1">{
                if strings.Contains(c, path) || strings.Contains(c, unresolvedPath) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">for _, e := range step.Env </span><span class="cov8" title="1">{
                if strings.Contains(e.Value, path) || strings.Contains(e.Value, unresolvedPath) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isNativeSidecarSupport returns true if k8s api has native sidecar support
// based on the k8s version (1.29+).
// See https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/ for more info.
func IsNativeSidecarSupport(serverVersion *version.Info) bool <span class="cov8" title="1">{
        minor := strings.TrimSuffix(serverVersion.Minor, "+") // Remove '+' if present
        majorInt, _ := strconv.Atoi(serverVersion.Major)
        minorInt, _ := strconv.Atoi(minor)
        if (majorInt == 1 &amp;&amp; minorInt &gt;= SidecarK8sMinorVersionCheck) || majorInt &gt; 1 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file419" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "encoding/base64"
        "fmt"
        "path/filepath"
        "strconv"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/names"
        corev1 "k8s.io/api/core/v1"
)

const (
        scriptsVolumeName      = "tekton-internal-scripts"
        debugScriptsVolumeName = "tekton-internal-debug-scripts"
        debugInfoVolumeName    = "tekton-internal-debug-info"
        scriptsDir             = "/tekton/scripts"
        debugScriptsDir        = "/tekton/debug/scripts"
        defaultScriptPreamble  = "#!/bin/sh\nset -e\n"
        debugInfoDir           = "/tekton/debug/info"
)

var (
        // Volume definition attached to Pods generated from TaskRuns that have
        // steps that specify a Script.
        scriptsVolume = corev1.Volume{
                Name:         scriptsVolumeName,
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }
        scriptsVolumeMount = corev1.VolumeMount{
                Name:      scriptsVolumeName,
                MountPath: scriptsDir,
                ReadOnly:  true,
        }
        writeScriptsVolumeMount = corev1.VolumeMount{
                Name:      scriptsVolumeName,
                MountPath: scriptsDir,
                ReadOnly:  false,
        }
        debugScriptsVolume = corev1.Volume{
                Name:         debugScriptsVolumeName,
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }
        debugScriptsVolumeMount = corev1.VolumeMount{
                Name:      debugScriptsVolumeName,
                MountPath: debugScriptsDir,
        }
        debugInfoVolume = corev1.Volume{
                Name:         debugInfoVolumeName,
                VolumeSource: corev1.VolumeSource{EmptyDir: &amp;corev1.EmptyDirVolumeSource{}},
        }
)

// convertScripts creates an init container that mounts any Scripts specified by
// the input Steps and Sidecars. It returns the init container, plus two slices of Containers
// representing the Steps and Sidecars, respectively, that use the scripts from the init container.
// Other inputs:
//   - shellImageLinux and shellImageWindows: the images that should be used by the init container,
//     depending on the OS the Task will run on
//   - debugConfig: the TaskRun's debug configuration
//   - setSecurityContext: whether the init container should include a security context that will
//     allow it to run in a namespace with "restricted" pod security admission
func convertScripts(shellImageLinux string, shellImageWin string, steps []v1.Step, sidecars []v1.Sidecar, debugConfig *v1.TaskRunDebug, securityContext SecurityContextConfig) (*corev1.Container, []corev1.Container, []corev1.Container) <span class="cov8" title="1">{
        // Place scripts is an init container used for creating scripts in the
        // /tekton/scripts directory which would be later used by the step containers
        // as a Command
        requiresWindows := checkWindowsRequirement(steps, sidecars)

        shellImage := shellImageLinux
        shellCommand := "sh"
        shellArg := "-c"

        // Set windows variants for Image, Command and Args
        if requiresWindows </span><span class="cov8" title="1">{
                shellImage = shellImageWin
                shellCommand = "pwsh"
                shellArg = "-Command"
        }</span>

        <span class="cov8" title="1">placeScriptsInit := corev1.Container{
                Name:         "place-scripts",
                Image:        shellImage,
                Command:      []string{shellCommand},
                Args:         []string{shellArg, ""},
                VolumeMounts: []corev1.VolumeMount{writeScriptsVolumeMount, binMount},
        }

        if securityContext.SetSecurityContext </span><span class="cov8" title="1">{
                placeScriptsInit.SecurityContext = securityContext.GetSecurityContext(requiresWindows)
        }</span>

        // Add mounts for debug
        <span class="cov8" title="1">if debugConfig != nil &amp;&amp; debugConfig.NeedsDebug() </span><span class="cov8" title="1">{
                placeScriptsInit.VolumeMounts = append(placeScriptsInit.VolumeMounts, debugScriptsVolumeMount)
        }</span>

        <span class="cov8" title="1">convertedStepContainers := convertListOfSteps(steps, &amp;placeScriptsInit, debugConfig, "script")
        sidecarContainers := convertListOfSidecars(sidecars, &amp;placeScriptsInit, "sidecar-script")

        if hasScripts(steps, sidecars, debugConfig) </span><span class="cov8" title="1">{
                return &amp;placeScriptsInit, convertedStepContainers, sidecarContainers
        }</span>
        <span class="cov8" title="1">return nil, convertedStepContainers, sidecarContainers</span>
}

// convertListOfSidecars iterates through the list of sidecars, generates the script file name and heredoc termination string,
// adds an entry to the init container args, sets up the step container to run the script, and sets the volume mounts.
func convertListOfSidecars(sidecars []v1.Sidecar, initContainer *corev1.Container, namePrefix string) []corev1.Container <span class="cov8" title="1">{
        containers := []corev1.Container{}
        for i, s := range sidecars </span><span class="cov8" title="1">{
                c := s.ToK8sContainer()
                if s.Script != "" </span><span class="cov8" title="1">{
                        placeScriptInContainer(s.Script, getScriptFile(scriptsDir, fmt.Sprintf("%s-%d", namePrefix, i)), c, initContainer)
                }</span>
                <span class="cov8" title="1">containers = append(containers, *c)</span>
        }
        <span class="cov8" title="1">return containers</span>
}

// convertListOfSteps iterates through the list of steps, generates the script file name and heredoc termination string,
// adds an entry to the init container args, sets up the step container to run the script, and sets the volume mounts.
func convertListOfSteps(steps []v1.Step, initContainer *corev1.Container, debugConfig *v1.TaskRunDebug, namePrefix string) []corev1.Container <span class="cov8" title="1">{
        containers := []corev1.Container{}
        for i, s := range steps </span><span class="cov8" title="1">{
                c := steps[i].ToK8sContainer()
                if s.Script != "" </span><span class="cov8" title="1">{
                        placeScriptInContainer(s.Script, getScriptFile(scriptsDir, fmt.Sprintf("%s-%d", namePrefix, i)), c, initContainer)
                }</span>
                <span class="cov8" title="1">containers = append(containers, *c)</span>
        }
        <span class="cov8" title="1">placeDebugScriptInContainers(containers, initContainer, debugConfig)
        return containers</span>
}

func getScriptFile(scriptsDir, scriptName string) string <span class="cov8" title="1">{
        return filepath.Join(scriptsDir, names.SimpleNameGenerator.RestrictLengthWithRandomSuffix(scriptName))
}</span>

// placeScriptInContainer given a piece of script to be executed, placeScriptInContainer firstly modifies initContainer
// so that it capsules the target script into scriptFile, then it modifies the container so that it can execute the scriptFile
// in runtime.
func placeScriptInContainer(script, scriptFile string, c *corev1.Container, initContainer *corev1.Container) <span class="cov8" title="1">{
        if script == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">cleaned := strings.TrimSpace(script)
        hasShebang := strings.HasPrefix(cleaned, "#!")
        requiresWindows := strings.HasPrefix(cleaned, "#!win")

        if !hasShebang </span><span class="cov8" title="1">{
                script = defaultScriptPreamble + script
        }</span>

        // Append to the place-scripts script to place the
        // script file in a known location in the scripts volume.
        <span class="cov8" title="1">if requiresWindows </span><span class="cov8" title="1">{
                command, args, script, scriptFile := extractWindowsScriptComponents(script, scriptFile)
                initContainer.Args[1] += fmt.Sprintf(`@"
%s
"@ | Out-File -FilePath %s
`, script, scriptFile)

                c.Command = command
                // Append existing args field to end of derived args
                args = append(args, c.Args...)
                c.Args = args
        }</span> else<span class="cov8" title="1"> {
                // Only encode the script for linux scripts
                // The decode-script subcommand of the entrypoint does not work under windows
                script = encodeScript(script)
                heredoc := "_EOF_" // underscores because base64 doesn't include them in its alphabet
                initContainer.Args[1] += fmt.Sprintf(`scriptfile="%s"
touch ${scriptfile} &amp;&amp; chmod +x ${scriptfile}
cat &gt; ${scriptfile} &lt;&lt; '%s'
%s
%s
/tekton/bin/entrypoint decode-script "${scriptfile}"
`, scriptFile, heredoc, script, heredoc)

                // Set the command to execute the correct script in the mounted volume.
                // A previous merge with stepTemplate may have populated
                // Command and Args, even though this is not normally valid, so
                // we'll clear out the Args and overwrite Command.
                c.Command = []string{scriptFile}
        }</span>
        <span class="cov8" title="1">c.VolumeMounts = append(c.VolumeMounts, scriptsVolumeMount)</span>
}

// encodeScript encodes a script field into a format that avoids kubernetes' built-in processing of container args,
// which can mangle dollar signs and unexpectedly replace variable references in the user's script.
func encodeScript(script string) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString([]byte(script))
}</span>

// placeDebugScriptInContainers inserts debug scripts into containers. It capsules those scripts to files in initContainer,
// then executes those scripts in target containers.
func placeDebugScriptInContainers(containers []corev1.Container, initContainer *corev1.Container, debugConfig *v1.TaskRunDebug) <span class="cov8" title="1">{
        if debugConfig == nil || !debugConfig.NeedsDebug() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">isDebugOnFailure := debugConfig != nil &amp;&amp; debugConfig.NeedsDebugOnFailure()
        var needDebugBeforeStep bool

        for i := range containers </span><span class="cov8" title="1">{
                debugInfoVolumeMount := corev1.VolumeMount{
                        Name:      debugInfoVolumeName,
                        MountPath: filepath.Join(debugInfoDir, strconv.Itoa(i)),
                }
                (&amp;containers[i]).VolumeMounts = append((&amp;containers[i]).VolumeMounts, debugScriptsVolumeMount, debugInfoVolumeMount)
                if debugConfig != nil &amp;&amp; debugConfig.NeedsDebugBeforeStep(containers[i].Name) </span><span class="cov8" title="1">{
                        needDebugBeforeStep = true
                }</span>
        }

        <span class="cov8" title="1">type script struct {
                name    string
                content string
        }
        debugScripts := make([]script, 0)
        if isDebugOnFailure </span><span class="cov8" title="1">{
                debugScripts = append(debugScripts, []script{{
                        name:    "continue",
                        content: defaultScriptPreamble + fmt.Sprintf(debugContinueScriptTemplate, len(containers), debugInfoDir, RunDir),
                }, {
                        name:    "fail-continue",
                        content: defaultScriptPreamble + fmt.Sprintf(debugFailScriptTemplate, len(containers), debugInfoDir, RunDir),
                }}...)
        }</span>
        <span class="cov8" title="1">if needDebugBeforeStep </span><span class="cov8" title="1">{
                debugScripts = append(debugScripts, []script{{
                        name:    "beforestep-continue",
                        content: defaultScriptPreamble + fmt.Sprintf(debugBeforeStepContinueScriptTemplate, len(containers), debugInfoDir, RunDir),
                }, {
                        name:    "beforestep-fail-continue",
                        content: defaultScriptPreamble + fmt.Sprintf(debugBeforeStepFailScriptTemplate, len(containers), debugInfoDir, RunDir),
                }}...)
        }</span>

        // Add debug or breakpoint related scripts to /tekton/debug/scripts
        // Iterate through the debugScripts and add routine for each of them in the initContainer for their creation
        <span class="cov8" title="1">for _, debugScript := range debugScripts </span><span class="cov8" title="1">{
                tmpFile := filepath.Join(debugScriptsDir, fmt.Sprintf("%s-%s", "debug", debugScript.name))
                heredoc := names.SimpleNameGenerator.RestrictLengthWithRandomSuffix(fmt.Sprintf("%s-%s-heredoc-randomly-generated", "debug", debugScript.name))

                initContainer.Args[1] += fmt.Sprintf(initScriptDirective, tmpFile, heredoc, debugScript.content, heredoc)
        }</span>
}

// hasScripts determines if we need to generate scripts in InitContainer given steps, sidecars and breakpoints.
func hasScripts(steps []v1.Step, sidecars []v1.Sidecar, debugConfig *v1.TaskRunDebug) bool <span class="cov8" title="1">{
        for _, s := range steps </span><span class="cov8" title="1">{
                if s.Script != "" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">for _, s := range sidecars </span><span class="cov8" title="1">{
                if s.Script != "" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return debugConfig != nil &amp;&amp; debugConfig.NeedsDebug()</span>
}

func checkWindowsRequirement(steps []v1.Step, sidecars []v1.Sidecar) bool <span class="cov8" title="1">{
        // Detect windows shebangs
        for _, step := range steps </span><span class="cov8" title="1">{
                cleaned := strings.TrimSpace(step.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        // If no step needs windows, then check sidecars to be sure
        <span class="cov8" title="1">for _, sidecar := range sidecars </span><span class="cov8" title="1">{
                cleaned := strings.TrimSpace(sidecar.Script)
                if strings.HasPrefix(cleaned, "#!win") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func extractWindowsScriptComponents(script string, fileName string) ([]string, []string, string, string) <span class="cov8" title="1">{
        // Set the command to execute the correct script in the mounted volume.
        shebangLine := strings.Split(script, "\n")[0]
        splitLine := strings.Split(shebangLine, " ")
        var command, args []string
        if len(splitLine) &gt; 1 </span><span class="cov8" title="1">{
                strippedCommand := splitLine[1:]
                command = strippedCommand[0:1]
                // Handle legacy powershell limitation
                if strings.HasPrefix(command[0], "powershell") </span><span class="cov8" title="1">{
                        fileName += ".ps1"
                }</span>
                <span class="cov8" title="1">if len(strippedCommand) &gt; 1 </span><span class="cov8" title="1">{
                        args = strippedCommand[1:]
                        args = append(args, fileName)
                }</span> else<span class="cov8" title="1"> {
                        args = []string{fileName}
                }</span>
        } else<span class="cov8" title="1"> {
                // If no interpreter is specified then strip the shebang and
                // create a .cmd file
                fileName += ".cmd"
                commandLines := strings.Split(script, "\n")[1:]
                script = strings.Join(commandLines, "\n")
                command = []string{fileName}
                args = []string{}
        }</span>

        <span class="cov8" title="1">return command, args, script, fileName</span>
}
</pre>
		
		<pre class="file" id="file420" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        corev1 "k8s.io/api/core/v1"
)

var (
        // Used in security context of pod init containers
        allowPrivilegeEscalation = false
        runAsNonRoot             = true
        readOnlyRootFilesystem   = true

        // LinuxSecurityContext allow init containers to run in namespaces
        // with "restricted" pod security admission
        // See https://kubernetes.io/docs/concepts/security/pod-security-standards/#restricted
        LinuxSecurityContext = &amp;corev1.SecurityContext{
                AllowPrivilegeEscalation: &amp;allowPrivilegeEscalation,
                Capabilities: &amp;corev1.Capabilities{
                        Drop: []corev1.Capability{"ALL"},
                },
                RunAsNonRoot: &amp;runAsNonRoot,
                SeccompProfile: &amp;corev1.SeccompProfile{
                        Type: corev1.SeccompProfileTypeRuntimeDefault,
                },
        }

        // WindowsSecurityContext adds securityContext that is supported by Windows OS.
        WindowsSecurityContext = &amp;corev1.SecurityContext{
                RunAsNonRoot: &amp;runAsNonRoot,
        }
)

// SecurityContextConfig is configuration for setting security context for init containers and affinity assistant container.
type SecurityContextConfig struct {
        SetSecurityContext        bool
        SetReadOnlyRootFilesystem bool
}

func (c SecurityContextConfig) GetSecurityContext(isWindows bool) *corev1.SecurityContext <span class="cov8" title="1">{
        if isWindows </span><span class="cov8" title="1">{
                return WindowsSecurityContext
        }</span>

        <span class="cov8" title="1">if !c.SetReadOnlyRootFilesystem </span><span class="cov8" title="1">{
                return LinuxSecurityContext
        }</span>

        <span class="cov8" title="1">securityContext := LinuxSecurityContext.DeepCopy()
        securityContext.ReadOnlyRootFilesystem = &amp;readOnlyRootFilesystem
        return securityContext</span>
}
</pre>
		
		<pre class="file" id="file421" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/internal/sidecarlogresults"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/result"
        "github.com/tektoncd/pipeline/pkg/termination"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
)

// Aliased for backwards compatibility; do not add additional TaskRun reasons here
var (
        // ReasonFailedResolution indicated that the reason for failure status is
        // that references within the TaskRun could not be resolved
        ReasonFailedResolution = v1.TaskRunReasonFailedResolution.String()
        // ReasonFailedValidation indicated that the reason for failure status is
        // that taskrun failed runtime validation
        ReasonFailedValidation = v1.TaskRunReasonFailedValidation.String()
        // ReasonTaskFailedValidation indicated that the reason for failure status is
        // that task failed runtime validation
        ReasonTaskFailedValidation = v1.TaskRunReasonTaskFailedValidation.String()
        // ReasonResourceVerificationFailed indicates that the task fails the trusted resource verification,
        // it could be the content has changed, signature is invalid or public key is invalid
        ReasonResourceVerificationFailed = v1.TaskRunReasonResourceVerificationFailed.String()
)

const (
        // ReasonExceededResourceQuota indicates that the TaskRun failed to create a pod due to
        // a ResourceQuota in the namespace
        ReasonExceededResourceQuota = "ExceededResourceQuota"

        // ReasonExceededNodeResources indicates that the TaskRun's pod has failed to start due
        // to resource constraints on the node
        ReasonExceededNodeResources = "ExceededNodeResources"

        // ReasonPullImageFailed indicates that the TaskRun's pod failed to pull image
        ReasonPullImageFailed = "PullImageFailed"

        // ReasonCreateContainerConfigError indicates that the TaskRun failed to create a pod due to
        // config error of container
        ReasonCreateContainerConfigError = "CreateContainerConfigError"

        // ReasonPodCreationFailed indicates that the reason for the current condition
        // is that the creation of the pod backing the TaskRun failed
        ReasonPodCreationFailed = "PodCreationFailed"

        // ReasonPodAdmissionFailed indicates that the TaskRun's pod failed to pass admission validation
        ReasonPodAdmissionFailed = "PodAdmissionFailed"

        // ReasonPending indicates that the pod is in corev1.Pending, and the reason is not
        // ReasonExceededNodeResources or isPodHitConfigError
        ReasonPodPending = "Pending"

        // timeFormat is RFC3339 with millisecond
        timeFormat = "2006-01-02T15:04:05.000Z07:00"
)

const (
        oomKilled = "OOMKilled"
        evicted   = "Evicted"
)

// SidecarsReady returns true if all of the Pod's sidecars are Ready or
// Terminated.
func SidecarsReady(podStatus corev1.PodStatus) bool <span class="cov8" title="1">{
        if podStatus.Phase != corev1.PodRunning </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, s := range podStatus.ContainerStatuses </span><span class="cov8" title="1">{
                // If the step indicates that it's a step, skip it.
                // An injected sidecar might not have the "sidecar-" prefix, so
                // we can't just look for that prefix, we need to look at any
                // non-step container.
                if IsContainerStep(s.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if s.State.Running != nil &amp;&amp; s.Ready </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if s.State.Terminated != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// MakeTaskRunStatus returns a TaskRunStatus based on the Pod's status.
func MakeTaskRunStatus(ctx context.Context, logger *zap.SugaredLogger, tr v1.TaskRun, pod *corev1.Pod, kubeclient kubernetes.Interface, ts *v1.TaskSpec) (v1.TaskRunStatus, error) <span class="cov8" title="1">{
        trs := &amp;tr.Status
        if trs.GetCondition(apis.ConditionSucceeded) == nil || trs.GetCondition(apis.ConditionSucceeded).Status == corev1.ConditionUnknown </span><span class="cov8" title="1">{
                // If the taskRunStatus doesn't exist yet, it's because we just started running
                markStatusRunning(trs, v1.TaskRunReasonRunning.String(), "Not all Steps in the Task have finished executing")
        }</span>

        <span class="cov8" title="1">sortPodContainerStatuses(pod.Status.ContainerStatuses, pod.Spec.Containers)

        complete := areContainersCompleted(ctx, pod) || isPodCompleted(pod)

        // When EnableKubernetesSidecar is true, we need to ensure all init containers
        // are completed before considering the taskRun complete, in addition to the regular containers.
        // This is because sidecars in Kubernetes can keep running after the main containers complete.
        if config.FromContextOrDefaults(ctx).FeatureFlags.EnableKubernetesSidecar </span><span class="cov8" title="1">{
                complete = complete &amp;&amp; areInitContainersCompleted(ctx, pod)
        }</span>

        <span class="cov8" title="1">if complete </span><span class="cov8" title="1">{
                onError, ok := tr.Annotations[v1.PipelineTaskOnErrorAnnotation]
                if ok </span><span class="cov8" title="1">{
                        updateCompletedTaskRunStatus(logger, trs, pod, v1.PipelineTaskOnErrorType(onError))
                }</span> else<span class="cov8" title="1"> {
                        updateCompletedTaskRunStatus(logger, trs, pod, "")
                }</span>
        } else<span class="cov8" title="1"> {
                updateIncompleteTaskRunStatus(trs, pod)
        }</span>

        <span class="cov8" title="1">trs.PodName = pod.Name
        trs.Sidecars = []v1.SidecarState{}

        var stepStatuses []corev1.ContainerStatus
        var sidecarStatuses []corev1.ContainerStatus
        for _, s := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if IsContainerStep(s.Name) </span><span class="cov8" title="1">{
                        stepStatuses = append(stepStatuses, s)
                }</span> else<span class="cov8" title="1"> if IsContainerSidecar(s.Name) </span><span class="cov8" title="1">{
                        sidecarStatuses = append(sidecarStatuses, s)
                }</span>
        }
        <span class="cov8" title="1">for _, s := range pod.Status.InitContainerStatuses </span><span class="cov8" title="1">{
                if IsContainerSidecar(s.Name) </span><span class="cov8" title="1">{
                        sidecarStatuses = append(sidecarStatuses, s)
                }</span>
        }

        <span class="cov8" title="1">err := setTaskRunStatusBasedOnStepStatus(ctx, logger, stepStatuses, &amp;tr, pod.Status.Phase, kubeclient, ts)

        setTaskRunStatusBasedOnSidecarStatus(sidecarStatuses, trs)

        trs.Results = removeDuplicateResults(trs.Results)

        return *trs, err</span>
}

func createTaskResultsFromStepResults(stepRunRes []v1.TaskRunStepResult, neededStepResults map[string]string) []v1.TaskRunResult <span class="cov8" title="1">{
        taskResults := []v1.TaskRunResult{}
        for _, r := range stepRunRes </span><span class="cov8" title="1">{
                // this result was requested by the Task
                if _, ok := neededStepResults[r.Name]; ok </span><span class="cov8" title="1">{
                        taskRunResult := v1.TaskRunResult{
                                Name:  neededStepResults[r.Name],
                                Type:  r.Type,
                                Value: r.Value,
                        }
                        taskResults = append(taskResults, taskRunResult)
                }</span>
        }
        <span class="cov8" title="1">return taskResults</span>
}

func setTaskRunArtifactsFromRunResult(runResults []result.RunResult, artifacts *v1.Artifacts) error <span class="cov8" title="1">{
        for _, slr := range runResults </span><span class="cov8" title="1">{
                if slr.ResultType == result.TaskRunArtifactsResultType </span><span class="cov0" title="0">{
                        return json.Unmarshal([]byte(slr.Value), artifacts)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getTaskResultsFromSidecarLogs(runResults []result.RunResult) []result.RunResult <span class="cov8" title="1">{
        taskResultsFromSidecarLogs := []result.RunResult{}
        for _, slr := range runResults </span><span class="cov8" title="1">{
                if slr.ResultType == result.TaskRunResultType </span><span class="cov8" title="1">{
                        taskResultsFromSidecarLogs = append(taskResultsFromSidecarLogs, slr)
                }</span>
        }
        <span class="cov8" title="1">return taskResultsFromSidecarLogs</span>
}

func getStepResultsFromSidecarLogs(sidecarLogResults []result.RunResult, containerName string) ([]result.RunResult, error) <span class="cov8" title="1">{
        stepResultsFromSidecarLogs := []result.RunResult{}
        for _, slr := range sidecarLogResults </span><span class="cov8" title="1">{
                if slr.ResultType == result.StepResultType </span><span class="cov8" title="1">{
                        stepName, resultName, err := sidecarlogresults.ExtractStepAndResultFromSidecarResultName(slr.Key)
                        if err != nil </span><span class="cov8" title="1">{
                                return []result.RunResult{}, err
                        }</span>
                        <span class="cov8" title="1">if stepName == containerName </span><span class="cov8" title="1">{
                                slr.Key = resultName
                                stepResultsFromSidecarLogs = append(stepResultsFromSidecarLogs, slr)
                        }</span>
                }
        }
        <span class="cov8" title="1">return stepResultsFromSidecarLogs, nil</span>
}

func setTaskRunStatusBasedOnStepStatus(ctx context.Context, logger *zap.SugaredLogger, stepStatuses []corev1.ContainerStatus, tr *v1.TaskRun, podPhase corev1.PodPhase, kubeclient kubernetes.Interface, ts *v1.TaskSpec) error <span class="cov8" title="1">{
        trs := &amp;tr.Status
        var errs []error

        // collect results from taskrun spec and taskspec
        specResults := []v1.TaskResult{}
        if tr.Spec.TaskSpec != nil </span><span class="cov8" title="1">{
                specResults = append(specResults, tr.Spec.TaskSpec.Results...)
        }</span>
        <span class="cov8" title="1">if ts != nil </span><span class="cov8" title="1">{
                specResults = append(specResults, ts.Results...)
        }</span>

        // Extract results from sidecar logs
        <span class="cov8" title="1">sidecarLogsResultsEnabled := config.FromContextOrDefaults(ctx).FeatureFlags.ResultExtractionMethod == config.ResultExtractionMethodSidecarLogs
        // temporary solution to check if artifacts sidecar created in taskRun as we don't have the api for users to declare if a step/task is producing artifacts yet
        artifactsSidecarCreated := artifactsPathReferenced(ts.Steps)
        sidecarLogResults := []result.RunResult{}

        if sidecarLogsResultsEnabled </span><span class="cov8" title="1">{
                // extraction of results from sidecar logs
                if tr.Status.TaskSpec.Results != nil || artifactsSidecarCreated </span><span class="cov8" title="1">{
                        slr, err := sidecarlogresults.GetResultsFromSidecarLogs(ctx, kubeclient, tr.Namespace, tr.Status.PodName, pipeline.ReservedResultsSidecarContainerName, podPhase)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                        }</span>
                        <span class="cov8" title="1">sidecarLogResults = append(sidecarLogResults, slr...)</span>
                }
        }
        // Populate Task results from sidecar logs
        <span class="cov8" title="1">taskResultsFromSidecarLogs := getTaskResultsFromSidecarLogs(sidecarLogResults)
        taskResults, _, _ := filterResults(taskResultsFromSidecarLogs, specResults, nil)
        if tr.IsDone() </span><span class="cov8" title="1">{
                trs.Results = append(trs.Results, taskResults...)
                var tras v1.Artifacts
                err := setTaskRunArtifactsFromRunResult(sidecarLogResults, &amp;tras)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to set artifacts value from sidecar logs: %v", err)
                        errs = append(errs, err)
                }</span> else<span class="cov8" title="1"> {
                        trs.Artifacts = &amp;tras
                }</span>
        }

        // Continue with extraction of termination messages
        <span class="cov8" title="1">for _, s := range stepStatuses </span><span class="cov8" title="1">{
                // Avoid changing the original value by modifying the pointer value.
                state := s.State.DeepCopy()
                taskRunStepResults := []v1.TaskRunStepResult{}

                // Identify Step Results
                stepResults := []v1.StepResult{}
                if ts != nil </span><span class="cov8" title="1">{
                        for _, step := range ts.Steps </span><span class="cov8" title="1">{
                                if GetContainerName(step.Name) == s.Name </span><span class="cov8" title="1">{
                                        stepResults = append(stepResults, step.Results...)
                                }</span>
                        }
                }
                // Identify StepResults needed by the Task Results
                <span class="cov8" title="1">neededStepResults, err := findStepResultsFetchedByTask(s.Name, specResults)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                // populate step results from sidecar logs
                <span class="cov8" title="1">stepResultsFromSidecarLogs, err := getStepResultsFromSidecarLogs(sidecarLogResults, s.Name)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
                <span class="cov8" title="1">_, stepRunRes, _ := filterResults(stepResultsFromSidecarLogs, specResults, stepResults)
                if tr.IsDone() </span><span class="cov8" title="1">{
                        taskRunStepResults = append(taskRunStepResults, stepRunRes...)
                        // Set TaskResults from StepResults
                        trs.Results = append(trs.Results, createTaskResultsFromStepResults(stepRunRes, neededStepResults)...)
                }</span>
                <span class="cov8" title="1">var sas v1.Artifacts

                err = setStepArtifactsValueFromSidecarLogResult(sidecarLogResults, s.Name, &amp;sas)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to set artifacts value from sidecar logs: %v", err)
                        errs = append(errs, err)
                }</span>

                // Parse termination messages
                <span class="cov8" title="1">terminationReason := ""
                if state.Terminated != nil &amp;&amp; len(state.Terminated.Message) != 0 </span><span class="cov8" title="1">{
                        msg := state.Terminated.Message

                        results, err := termination.ParseMessage(logger, msg)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("termination message could not be parsed sas JSON: %v", err)
                                errs = append(errs, err)
                        }</span> else<span class="cov8" title="1"> {
                                err := setStepArtifactsValueFromTerminationMessageRunResult(results, &amp;sas)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error setting step artifacts of step %q in taskrun %q: %v", s.Name, tr.Name, err)
                                        errs = append(errs, err)
                                }</span>
                                <span class="cov8" title="1">time, err := extractStartedAtTimeFromResults(results)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error setting the start time of step %q in taskrun %q: %v", s.Name, tr.Name, err)
                                        errs = append(errs, err)
                                }</span>
                                <span class="cov8" title="1">exitCode, err := extractExitCodeFromResults(results)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error extracting the exit code of step %q in taskrun %q: %v", s.Name, tr.Name, err)
                                        errs = append(errs, err)
                                }</span>

                                <span class="cov8" title="1">taskResults, stepRunRes, filteredResults := filterResults(results, specResults, stepResults)
                                if tr.IsDone() </span><span class="cov8" title="1">{
                                        taskRunStepResults = append(taskRunStepResults, stepRunRes...)
                                        // Set TaskResults from StepResults
                                        taskResults = append(taskResults, createTaskResultsFromStepResults(stepRunRes, neededStepResults)...)
                                        trs.Results = append(trs.Results, taskResults...)

                                        var tras v1.Artifacts
                                        err := setTaskRunArtifactsFromRunResult(filteredResults, &amp;tras)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Errorf("error setting step artifacts in taskrun %q: %v", tr.Name, err)
                                                errs = append(errs, err)
                                        }</span>
                                        <span class="cov8" title="1">trs.Artifacts.Merge(&amp;tras)
                                        trs.Artifacts.Merge(&amp;sas)</span>
                                }
                                <span class="cov8" title="1">msg, err = createMessageFromResults(filteredResults)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("%v", err)
                                        errs = append(errs, err)
                                }</span> else<span class="cov8" title="1"> {
                                        state.Terminated.Message = msg
                                }</span>
                                <span class="cov8" title="1">if time != nil </span><span class="cov8" title="1">{
                                        state.Terminated.StartedAt = *time
                                }</span>
                                <span class="cov8" title="1">if exitCode != nil </span><span class="cov8" title="1">{
                                        state.Terminated.ExitCode = *exitCode
                                }</span>

                                <span class="cov8" title="1">terminationFromResults := extractTerminationReasonFromResults(results)
                                terminationReason = getTerminationReason(state.Terminated.Reason, terminationFromResults, exitCode)</span>
                        }
                }
                <span class="cov8" title="1">stepState := v1.StepState{
                        ContainerState:    *state.DeepCopy(),
                        Name:              TrimStepPrefix(s.Name),
                        Container:         s.Name,
                        ImageID:           s.ImageID,
                        Results:           taskRunStepResults,
                        TerminationReason: terminationReason,
                        Inputs:            sas.Inputs,
                        Outputs:           sas.Outputs,
                }
                foundStep := false
                for i, ss := range trs.Steps </span><span class="cov8" title="1">{
                        if ss.Name == stepState.Name </span><span class="cov8" title="1">{
                                stepState.Provenance = ss.Provenance
                                trs.Steps[i] = stepState
                                foundStep = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !foundStep </span><span class="cov8" title="1">{
                        trs.Steps = append(trs.Steps, stepState)
                }</span>
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func setStepArtifactsValueFromSidecarLogResult(results []result.RunResult, name string, artifacts *v1.Artifacts) error <span class="cov8" title="1">{
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Key == name &amp;&amp; r.ResultType == result.StepArtifactsResultType </span><span class="cov0" title="0">{
                        return json.Unmarshal([]byte(r.Value), artifacts)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setStepArtifactsValueFromTerminationMessageRunResult(results []result.RunResult, artifacts *v1.Artifacts) error <span class="cov8" title="1">{
        for _, r := range results </span><span class="cov8" title="1">{
                if r.ResultType == result.StepArtifactsResultType </span><span class="cov8" title="1">{
                        return json.Unmarshal([]byte(r.Value), artifacts)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setTaskRunStatusBasedOnSidecarStatus(sidecarStatuses []corev1.ContainerStatus, trs *v1.TaskRunStatus) <span class="cov8" title="1">{
        for _, s := range sidecarStatuses </span><span class="cov8" title="1">{
                trs.Sidecars = append(trs.Sidecars, v1.SidecarState{
                        ContainerState: *s.State.DeepCopy(),
                        Name:           TrimSidecarPrefix(s.Name),
                        Container:      s.Name,
                        ImageID:        s.ImageID,
                })
        }</span>
}

func createMessageFromResults(results []result.RunResult) (string, error) <span class="cov8" title="1">{
        if len(results) == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">bytes, err := json.Marshal(results)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error marshalling remaining results back into termination message: %w", err)
        }</span>
        <span class="cov8" title="1">return string(bytes), nil</span>
}

// findStepResultsFetchedByTask fetches step results that the Task needs.
// It accepts a container name and the TaskResults as input and outputs
// a map with the name of the step result as the key and the name of the task result that is fetching it as value.
func findStepResultsFetchedByTask(containerName string, specResults []v1.TaskResult) (map[string]string, error) <span class="cov8" title="1">{
        neededStepResults := map[string]string{}
        for _, r := range specResults </span><span class="cov8" title="1">{
                if r.Value != nil </span><span class="cov8" title="1">{
                        if r.Value.StringVal != "" </span><span class="cov8" title="1">{
                                sName, resultName, err := v1.ExtractStepResultName(r.Value.StringVal)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                // Only look at named results - referencing unnamed steps is unsupported.
                                <span class="cov8" title="1">if GetContainerName(sName) == containerName </span><span class="cov8" title="1">{
                                        neededStepResults[resultName] = r.Name
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return neededStepResults, nil</span>
}

// filterResults filters the RunResults and TaskResults based on the results declared in the task spec.
// It returns a slice of any of the input results that are defined in the task spec, converted to TaskRunResults,
// and a slice of any of the RunResults that don't represent internal values (i.e. those that should not be displayed in the TaskRun status.
func filterResults(results []result.RunResult, specResults []v1.TaskResult, stepResults []v1.StepResult) ([]v1.TaskRunResult, []v1.TaskRunStepResult, []result.RunResult) <span class="cov8" title="1">{
        var taskResults []v1.TaskRunResult
        var taskRunStepResults []v1.TaskRunStepResult
        var filteredResults []result.RunResult
        neededTypes := make(map[string]v1.ResultsType)
        neededStepTypes := make(map[string]v1.ResultsType)
        for _, r := range specResults </span><span class="cov8" title="1">{
                neededTypes[r.Name] = r.Type
        }</span>
        <span class="cov8" title="1">for _, r := range stepResults </span><span class="cov8" title="1">{
                neededStepTypes[r.Name] = r.Type
        }</span>
        <span class="cov8" title="1">for _, r := range results </span><span class="cov8" title="1">{
                switch r.ResultType </span>{
                case result.TaskRunResultType:<span class="cov8" title="1">
                        var taskRunResult v1.TaskRunResult
                        if neededTypes[r.Key] == v1.ResultsTypeString </span><span class="cov8" title="1">{
                                taskRunResult = v1.TaskRunResult{
                                        Name:  r.Key,
                                        Type:  v1.ResultsTypeString,
                                        Value: *v1.NewStructuredValues(r.Value),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                v := v1.ResultValue{}
                                err := v.UnmarshalJSON([]byte(r.Value))
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">taskRunResult = v1.TaskRunResult{
                                        Name:  r.Key,
                                        Type:  v1.ResultsType(v.Type),
                                        Value: v,
                                }</span>
                        }
                        <span class="cov8" title="1">taskResults = append(taskResults, taskRunResult)
                        filteredResults = append(filteredResults, r)</span>
                case result.StepResultType:<span class="cov8" title="1">
                        var taskRunStepResult v1.TaskRunStepResult
                        if neededStepTypes[r.Key] == v1.ResultsTypeString </span><span class="cov8" title="1">{
                                taskRunStepResult = v1.TaskRunStepResult{
                                        Name:  r.Key,
                                        Type:  v1.ResultsTypeString,
                                        Value: *v1.NewStructuredValues(r.Value),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                v := v1.ResultValue{}
                                err := v.UnmarshalJSON([]byte(r.Value))
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">taskRunStepResult = v1.TaskRunStepResult{
                                        Name:  r.Key,
                                        Type:  v1.ResultsType(v.Type),
                                        Value: v,
                                }</span>
                        }
                        <span class="cov8" title="1">taskRunStepResults = append(taskRunStepResults, taskRunStepResult)
                        filteredResults = append(filteredResults, r)</span>
                case result.StepArtifactsResultType:<span class="cov8" title="1">
                        filteredResults = append(filteredResults, r)
                        continue</span>
                case result.TaskRunArtifactsResultType:<span class="cov0" title="0">
                        filteredResults = append(filteredResults, r)
                        continue</span>
                case result.InternalTektonResultType:<span class="cov8" title="1">
                        // Internal messages are ignored because they're not used as external result
                        continue</span>
                default:<span class="cov8" title="1">
                        filteredResults = append(filteredResults, r)</span>
                }
        }
        <span class="cov8" title="1">return taskResults, taskRunStepResults, filteredResults</span>
}

func removeDuplicateResults(taskRunResult []v1.TaskRunResult) []v1.TaskRunResult <span class="cov8" title="1">{
        if len(taskRunResult) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">uniq := make([]v1.TaskRunResult, 0)
        latest := make(map[string]v1.TaskRunResult, 0)
        for _, res := range taskRunResult </span><span class="cov8" title="1">{
                if _, seen := latest[res.Name]; !seen </span><span class="cov8" title="1">{
                        uniq = append(uniq, res)
                }</span>
                <span class="cov8" title="1">latest[res.Name] = res</span>
        }
        <span class="cov8" title="1">for i, res := range uniq </span><span class="cov8" title="1">{
                uniq[i] = latest[res.Name]
        }</span>
        <span class="cov8" title="1">return uniq</span>
}

func extractStartedAtTimeFromResults(results []result.RunResult) (*metav1.Time, error) <span class="cov8" title="1">{
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Key == "StartedAt" </span><span class="cov8" title="1">{
                        t, err := time.Parse(timeFormat, result.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not parse time value %q in StartedAt field: %w", result.Value, err)
                        }</span>
                        <span class="cov8" title="1">startedAt := metav1.NewTime(t)
                        return &amp;startedAt, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, nil</span> //nolint:nilnil // would be more ergonomic to return a sentinel error
}

func extractExitCodeFromResults(results []result.RunResult) (*int32, error) <span class="cov8" title="1">{
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Key == "ExitCode" </span><span class="cov8" title="1">{
                        // We could just pass the string through but this provides extra validation
                        i, err := strconv.ParseInt(result.Value, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not parse int value %q in ExitCode field: %w", result.Value, err)
                        }</span>
                        <span class="cov8" title="1">exitCode := int32(i) // #nosec G115: ParseInt was called with bit size 32, so this is safe
                        return &amp;exitCode, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, nil</span> //nolint:nilnil // would be more ergonomic to return a sentinel error
}

func extractTerminationReasonFromResults(results []result.RunResult) string <span class="cov8" title="1">{
        for _, r := range results </span><span class="cov8" title="1">{
                if r.ResultType == result.InternalTektonResultType &amp;&amp; r.Key == "Reason" </span><span class="cov8" title="1">{
                        return r.Value
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getTerminationReason(terminatedStateReason string, terminationFromResults string, exitCodeFromResults *int32) string <span class="cov8" title="1">{
        if terminationFromResults != "" </span><span class="cov8" title="1">{
                return terminationFromResults
        }</span>

        <span class="cov8" title="1">if exitCodeFromResults != nil </span><span class="cov8" title="1">{
                return TerminationReasonContinued
        }</span>

        <span class="cov8" title="1">return terminatedStateReason</span>
}

func updateCompletedTaskRunStatus(logger *zap.SugaredLogger, trs *v1.TaskRunStatus, pod *corev1.Pod, onError v1.PipelineTaskOnErrorType) <span class="cov8" title="1">{
        if DidTaskRunFail(pod) </span><span class="cov8" title="1">{
                msg := getFailureMessage(logger, pod)
                if onError == v1.PipelineTaskContinue </span><span class="cov8" title="1">{
                        markStatusFailure(trs, v1.TaskRunReasonFailureIgnored.String(), msg)
                }</span> else<span class="cov8" title="1"> {
                        markStatusFailure(trs, v1.TaskRunReasonFailed.String(), msg)
                }</span>
        } else<span class="cov8" title="1"> {
                markStatusSuccess(trs)
        }</span>

        // update tr completed time
        <span class="cov8" title="1">trs.CompletionTime = &amp;metav1.Time{Time: time.Now()}</span>
}

func updateIncompleteTaskRunStatus(trs *v1.TaskRunStatus, pod *corev1.Pod) <span class="cov8" title="1">{
        switch pod.Status.Phase </span>{
        case corev1.PodRunning:<span class="cov8" title="1">
                markStatusRunning(trs, v1.TaskRunReasonRunning.String(), "Not all Steps in the Task have finished executing")</span>
        case corev1.PodPending:<span class="cov8" title="1">
                switch </span>{
                case IsPodExceedingNodeResources(pod):<span class="cov8" title="1">
                        markStatusRunning(trs, ReasonExceededNodeResources, "TaskRun Pod exceeded available resources")</span>
                case isSubPathDirectoryError(pod):<span class="cov8" title="1">
                        // if subPath directory creation errors, mark as running and wait for recovery
                        markStatusRunning(trs, ReasonPodPending, "Waiting for subPath directory creation to complete")</span>
                case isPodHitConfigError(pod):<span class="cov8" title="1">
                        markStatusFailure(trs, ReasonCreateContainerConfigError, "Failed to create pod due to config error")</span>
                case isPullImageError(pod):<span class="cov8" title="1">
                        markStatusRunning(trs, ReasonPullImageFailed, getWaitingMessage(pod))</span>
                default:<span class="cov8" title="1">
                        markStatusRunning(trs, ReasonPodPending, getWaitingMessage(pod))</span>
                }
        case corev1.PodSucceeded, corev1.PodFailed, corev1.PodUnknown:<span class="cov0" title="0"></span>
                // Do nothing; pod has completed or is in an unknown state.
        }
}

// isPodCompleted checks if the given pod is completed.
// A pod is considered completed if its phase is either "Succeeded" or "Failed".
//
// If it is foreseeable that the pod will eventually be in a failed state,
// but it remains in a Running status for a visible period of time, it should be considered completed in advance.
//
// For example, when certain steps encounter OOM, only the pods that have timed out will change to a failed state,
// we should consider them completed in advance.
func isPodCompleted(pod *corev1.Pod) bool <span class="cov8" title="1">{
        if pod.Status.Phase == corev1.PodSucceeded || pod.Status.Phase == corev1.PodFailed </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, s := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if IsContainerStep(s.Name) </span><span class="cov8" title="1">{
                        if s.State.Terminated != nil </span><span class="cov8" title="1">{
                                if isOOMKilled(s) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

// DidTaskRunFail check the status of pod to decide if related taskrun is failed
func DidTaskRunFail(pod *corev1.Pod) bool <span class="cov8" title="1">{
        if pod.Status.Phase == corev1.PodFailed </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, s := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if IsContainerStep(s.Name) </span><span class="cov8" title="1">{
                        if s.State.Terminated != nil </span><span class="cov8" title="1">{
                                if s.State.Terminated.ExitCode != 0 || isOOMKilled(s) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

// IsPodArchived indicates if a pod is archived in the retriesStatus.
func IsPodArchived(pod *corev1.Pod, trs *v1.TaskRunStatus) bool <span class="cov8" title="1">{
        for _, retryStatus := range trs.RetriesStatus </span><span class="cov8" title="1">{
                if retryStatus.PodName == pod.GetName() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// containerNameFilter is a function that filters container names.
type containerNameFilter func(name string) bool

// isMatchingAnyFilter returns true if the container name matches any of the filters.
func isMatchingAnyFilter(name string, filters []containerNameFilter) bool <span class="cov8" title="1">{
        for _, filter := range filters </span><span class="cov8" title="1">{
                if filter(name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// areInitContainersCompleted returns true if all init containers in the pod are completed.
func areInitContainersCompleted(ctx context.Context, pod *corev1.Pod) bool <span class="cov8" title="1">{
        if len(pod.Status.InitContainerStatuses) == 0 ||
                !(pod.Status.Phase == corev1.PodRunning || pod.Status.Phase == corev1.PodSucceeded) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, containerStatus := range pod.Status.InitContainerStatuses </span><span class="cov8" title="1">{
                if containerStatus.State.Terminated == nil </span><span class="cov8" title="1">{
                        // if any init container is not completed, return false
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// areContainersCompleted returns true if all related containers in the pod are completed.
func areContainersCompleted(ctx context.Context, pod *corev1.Pod) bool <span class="cov8" title="1">{
        nameFilters := []containerNameFilter{IsContainerStep}
        if config.FromContextOrDefaults(ctx).FeatureFlags.ResultExtractionMethod == config.ResultExtractionMethodSidecarLogs </span><span class="cov8" title="1">{
                // If we are using sidecar logs to extract results, we need to wait for the sidecar to complete.
                // Avoid failing to obtain the final result from the sidecar because the sidecar is not yet complete.
                nameFilters = append(nameFilters, func(name string) bool </span><span class="cov8" title="1">{
                        return name == pipeline.ReservedResultsSidecarContainerName
                }</span>)
        }
        <span class="cov8" title="1">return checkContainersCompleted(pod, nameFilters)</span>
}

// checkContainersCompleted returns true if containers in the pod are completed.
func checkContainersCompleted(pod *corev1.Pod, nameFilters []containerNameFilter) bool <span class="cov8" title="1">{
        if len(pod.Status.ContainerStatuses) == 0 ||
                !(pod.Status.Phase == corev1.PodRunning || pod.Status.Phase == corev1.PodSucceeded) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if isMatchingAnyFilter(containerStatus.Name, nameFilters) &amp;&amp; containerStatus.State.Terminated == nil </span><span class="cov8" title="1">{
                        // if any container is not completed, return false
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func getFailureMessage(logger *zap.SugaredLogger, pod *corev1.Pod) string <span class="cov8" title="1">{
        // If a pod was evicted, use the pods status message before trying to
        // determine a failure message from the pod's container statuses. A
        // container may have a generic exit code that contains less information,
        // such as an exit code and message related to not being located.
        if pod.Status.Reason == evicted </span><span class="cov8" title="1">{
                return pod.Status.Message
        }</span>

        // First, try to surface an error about the actual init container that failed.
        <span class="cov8" title="1">for _, status := range pod.Status.InitContainerStatuses </span><span class="cov8" title="1">{
                if msg := extractContainerFailureMessage(logger, status, pod.ObjectMeta); len(msg) &gt; 0 </span><span class="cov8" title="1">{
                        return "init container failed, " + msg
                }</span>
        }

        // Next, try to surface an error about the actual build step that failed.
        <span class="cov8" title="1">for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if msg := extractContainerFailureMessage(logger, status, pod.ObjectMeta); len(msg) &gt; 0 </span><span class="cov8" title="1">{
                        return msg
                }</span>
        }
        // Next, return the Pod's status message if it has one.
        <span class="cov8" title="1">if pod.Status.Message != "" </span><span class="cov8" title="1">{
                return pod.Status.Message
        }</span>

        <span class="cov8" title="1">for _, s := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if IsContainerStep(s.Name) </span><span class="cov8" title="1">{
                        if s.State.Terminated != nil </span><span class="cov8" title="1">{
                                if isOOMKilled(s) </span><span class="cov8" title="1">{
                                        return oomKilled
                                }</span>
                        }
                }
        }

        // Lastly fall back on a generic error message.
        <span class="cov8" title="1">return "build failed for unspecified reasons."</span>
}

// extractContainerFailureMessage returns the container failure message by container status or init container status.
func extractContainerFailureMessage(logger *zap.SugaredLogger, status corev1.ContainerStatus, podMetaData metav1.ObjectMeta) string <span class="cov8" title="1">{
        term := status.State.Terminated
        if term != nil </span><span class="cov8" title="1">{
                msg := status.State.Terminated.Message
                r, _ := termination.ParseMessage(logger, msg)
                for _, runResult := range r </span><span class="cov8" title="1">{
                        if runResult.ResultType == result.InternalTektonResultType &amp;&amp; runResult.Key == "Reason" &amp;&amp; runResult.Value == TerminationReasonTimeoutExceeded </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%q exited because the step exceeded the specified timeout limit", status.Name)
                        }</span>
                }
                <span class="cov8" title="1">if term.ExitCode != 0 </span><span class="cov8" title="1">{
                        // Include the termination reason, if available to add clarity for causes such as external signals, e.g. OOM
                        if term.Reason != "" </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%q exited with code %d: %s", status.Name, term.ExitCode, term.Reason)
                        }</span>
                        <span class="cov8" title="1">return fmt.Sprintf("%q exited with code %d", status.Name, term.ExitCode)</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// IsPodExceedingNodeResources returns true if the Pod's status indicates there
// are insufficient resources to schedule the Pod.
func IsPodExceedingNodeResources(pod *corev1.Pod) bool <span class="cov8" title="1">{
        for _, podStatus := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if podStatus.Reason == corev1.PodReasonUnschedulable &amp;&amp; strings.Contains(podStatus.Message, "Insufficient") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isPodHitConfigError returns true if the Pod's status undicates there are config error raised
func isPodHitConfigError(pod *corev1.Pod) bool <span class="cov8" title="1">{
        for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if containerStatus.State.Waiting != nil &amp;&amp; containerStatus.State.Waiting.Reason == ReasonCreateContainerConfigError </span><span class="cov8" title="1">{
                        // for subPath directory creation errors, we want to allow recovery
                        if strings.Contains(containerStatus.State.Waiting.Message, "failed to create subPath directory") </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// isPullImageError returns true if the Pod's status indicates there are any error when pulling image
func isPullImageError(pod *corev1.Pod) bool <span class="cov8" title="1">{
        for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if containerStatus.State.Waiting != nil &amp;&amp; isImageErrorReason(containerStatus.State.Waiting.Reason) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isImageErrorReason(reason string) bool <span class="cov8" title="1">{
        // Reference from https://github.com/kubernetes/kubernetes/blob/a1c8e9386af844757333733714fa1757489735b3/pkg/kubelet/images/types.go#L26
        imageErrorReasons := []string{
                "ImagePullBackOff",
                "ImageInspectError",
                "ErrImagePull",
                "ErrImageNeverPull",
                "RegistryUnavailable",
                "InvalidImageName",
        }
        for _, imageReason := range imageErrorReasons </span><span class="cov8" title="1">{
                if imageReason == reason </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getWaitingMessage(pod *corev1.Pod) string <span class="cov8" title="1">{
        // First, try to surface reason for pending/unknown about the actual build step.
        for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                wait := status.State.Waiting
                if wait != nil &amp;&amp; wait.Message != "" </span><span class="cov8" title="1">{
                        return fmt.Sprintf("build step %q is pending with reason %q",
                                status.Name, wait.Message)
                }</span>
        }
        // Try to surface underlying reason by inspecting pod's recent status if condition is not true
        <span class="cov8" title="1">for i, podStatus := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if podStatus.Status != corev1.ConditionTrue </span><span class="cov8" title="1">{
                        return fmt.Sprintf("pod status %q:%q; message: %q",
                                pod.Status.Conditions[i].Type,
                                pod.Status.Conditions[i].Status,
                                pod.Status.Conditions[i].Message)
                }</span>
        }
        // Next, return the Pod's status message if it has one.
        <span class="cov8" title="1">if pod.Status.Message != "" </span><span class="cov8" title="1">{
                return pod.Status.Message
        }</span>

        // Lastly fall back on a generic pending message.
        <span class="cov8" title="1">return "Pending"</span>
}

// markStatusRunning sets taskrun status to running
func markStatusRunning(trs *v1.TaskRunStatus, reason, message string) <span class="cov8" title="1">{
        trs.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionUnknown,
                Reason:  reason,
                Message: message,
        })
}</span>

// markStatusFailure sets taskrun status to failure with specified reason
func markStatusFailure(trs *v1.TaskRunStatus, reason string, message string) <span class="cov8" title="1">{
        trs.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionFalse,
                Reason:  reason,
                Message: message,
        })
}</span>

// markStatusSuccess sets taskrun status to success
func markStatusSuccess(trs *v1.TaskRunStatus) <span class="cov8" title="1">{
        trs.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionSucceeded,
                Status:  corev1.ConditionTrue,
                Reason:  v1.TaskRunReasonSuccessful.String(),
                Message: "All Steps have completed executing",
        })
}</span>

// sortPodContainerStatuses reorders a pod's container statuses so that
// they're in the same order as the step containers from the TaskSpec.
func sortPodContainerStatuses(podContainerStatuses []corev1.ContainerStatus, podSpecContainers []corev1.Container) <span class="cov8" title="1">{
        statuses := map[string]corev1.ContainerStatus{}
        for _, status := range podContainerStatuses </span><span class="cov8" title="1">{
                statuses[status.Name] = status
        }</span>
        <span class="cov8" title="1">for i, c := range podSpecContainers </span><span class="cov8" title="1">{
                // prevent out-of-bounds panic on incorrectly formed lists
                if i &lt; len(podContainerStatuses) </span><span class="cov8" title="1">{
                        podContainerStatuses[i] = statuses[c.Name]
                }</span>
        }
}

func isOOMKilled(s corev1.ContainerStatus) bool <span class="cov8" title="1">{
        return s.State.Terminated.Reason == oomKilled
}</span>

func isSubPathDirectoryError(pod *corev1.Pod) bool <span class="cov8" title="1">{
        for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if containerStatus.State.Waiting != nil &amp;&amp;
                        containerStatus.State.Waiting.Reason == ReasonCreateContainerConfigError &amp;&amp;
                        strings.Contains(containerStatus.State.Waiting.Message, "failed to create subPath directory") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file422" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pod

import (
        "path/filepath"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
)

// workingDirInit returns a Container that should be run as an init
// container to ensure that all steps' workingDirs relative to the workspace
// exist.
//
// If no such directories need to be created (i.e., no relative workingDirs
// are specified), this method returns nil, as no init container is necessary.
// If setSecurityContext is true, the init container will include a security context
// allowing it to run in namespaces with restriced pod security admission.
// If the init container will run on windows, `windows` should be set to `true`,
// so that the correct security context can be applied.
func workingDirInit(workingdirinitImage string, stepContainers []corev1.Container, securityContext SecurityContextConfig, windows bool) *corev1.Container <span class="cov8" title="1">{
        // Gather all unique workingDirs.
        workingDirs := sets.NewString()
        for _, step := range stepContainers </span><span class="cov8" title="1">{
                if step.WorkingDir != "" </span><span class="cov8" title="1">{
                        workingDirs.Insert(step.WorkingDir)
                }</span>
        }
        <span class="cov8" title="1">if workingDirs.Len() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Clean and append each relative workingDir.
        <span class="cov8" title="1">var relativeDirs []string
        for _, wd := range workingDirs.List() </span><span class="cov8" title="1">{
                p := filepath.Clean(wd)
                if !filepath.IsAbs(p) || strings.HasPrefix(p, "/workspace/") </span><span class="cov8" title="1">{
                        relativeDirs = append(relativeDirs, p)
                }</span>
        }

        <span class="cov8" title="1">if len(relativeDirs) == 0 </span><span class="cov0" title="0">{
                // There are no workingDirs to initialize.
                return nil
        }</span>

        <span class="cov8" title="1">c := &amp;corev1.Container{
                Name:         "working-dir-initializer",
                Image:        workingdirinitImage,
                Command:      []string{"/ko-app/workingdirinit"},
                Args:         relativeDirs,
                WorkingDir:   pipeline.WorkspaceDir,
                VolumeMounts: implicitVolumeMounts,
        }
        if securityContext.SetSecurityContext </span><span class="cov8" title="1">{
                c.SecurityContext = securityContext.GetSecurityContext(windows)
        }</span>

        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file423" style="display: none">package apiserver

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

var (
        ErrReferencedObjectValidationFailed = errors.New("validation failed for referenced object")
        ErrCouldntValidateObjectRetryable   = errors.New("retryable error validating referenced object")
        ErrCouldntValidateObjectPermanent   = errors.New("permanent error validating referenced object")
)

// DryRunValidate validates the obj by issuing a dry-run create request for it in the given namespace.
// This allows validating admission webhooks to process the object without actually creating it.
// obj must be a v1/v1beta1 Task or Pipeline.
func DryRunValidate(ctx context.Context, namespace string, obj runtime.Object, tekton clientset.Interface) (runtime.Object, error) <span class="cov8" title="1">{
        dryRunObjName := uuid.NewString() // Use a randomized name for the Pipeline/Task in case there is already another Pipeline/Task of the same name

        switch obj := obj.(type) </span>{
        case *v1.Pipeline:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the PipelineRun
                mutatedObj, err := tekton.TektonV1().Pipelines(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>
        case *v1beta1.Pipeline:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the PipelineRun
                mutatedObj, err := tekton.TektonV1beta1().Pipelines(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>
        case *v1.Task:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the TaskRun
                mutatedObj, err := tekton.TektonV1().Tasks(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>
        case *v1beta1.Task:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the TaskRun
                mutatedObj, err := tekton.TektonV1beta1().Tasks(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>
        case *v1alpha1.StepAction:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the StepAction
                mutatedObj, err := tekton.TektonV1alpha1().StepActions(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>

        case *v1beta1.StepAction:<span class="cov8" title="1">
                dryRunObj := obj.DeepCopy()
                dryRunObj.Name = dryRunObjName
                dryRunObj.Namespace = namespace // Make sure the namespace is the same as the StepAction
                mutatedObj, err := tekton.TektonV1beta1().StepActions(namespace).Create(ctx, dryRunObj, metav1.CreateOptions{DryRun: []string{metav1.DryRunAll}})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, handleDryRunCreateErr(err, obj.Name)
                }</span>
                <span class="cov8" title="1">return mutatedObj, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported object GVK %s", obj.GetObjectKind().GroupVersionKind())</span>
        }
}

func handleDryRunCreateErr(err error, objectName string) error <span class="cov8" title="1">{
        var errType error
        switch </span>{
        case apierrors.IsBadRequest(err):<span class="cov8" title="1"> // Object rejected by validating webhook
                errType = ErrReferencedObjectValidationFailed</span>
        case apierrors.IsInvalid(err), apierrors.IsMethodNotSupported(err):<span class="cov8" title="1">
                errType = pipelineErrors.WrapUserError(ErrCouldntValidateObjectPermanent)</span>
        case apierrors.IsTimeout(err), apierrors.IsServerTimeout(err), apierrors.IsTooManyRequests(err):<span class="cov8" title="1">
                errType = ErrCouldntValidateObjectRetryable</span>
        default:<span class="cov0" title="0">
                // Assume unknown errors are retryable
                // Additional errors can be added to the switch statements as needed
                errType = ErrCouldntValidateObjectRetryable</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("%w %s: %w", errType, objectName, err)</span>
}
</pre>
		
		<pre class="file" id="file424" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cache

import (
        "encoding/json"
        "errors"
        "fmt"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        lru "github.com/hashicorp/golang-lru"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
)

// Struct to unmarshal the event data
type eventData struct {
        CustomRun *v1beta1.CustomRun `json:"customRun,omitempty"`
}

// ContainsOrAddCloudEvent checks if the event exists in the cache
func ContainsOrAddCloudEvent(cacheClient *lru.Cache, event *cloudevents.Event) (bool, error) <span class="cov8" title="1">{
        if cacheClient == nil </span><span class="cov0" title="0">{
                return false, errors.New("cache client is nil")
        }</span>
        <span class="cov8" title="1">eventKey, err := EventKey(event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">isPresent, _ := cacheClient.ContainsOrAdd(eventKey, nil)
        return isPresent, nil</span>
}

// EventKey defines whether an event is considered different from another
// in future we might want to let specific event types override this
func EventKey(event *cloudevents.Event) (string, error) <span class="cov8" title="1">{
        var (
                data              eventData
                resourceName      string
                resourceNamespace string
                resourceKind      string
        )
        err := json.Unmarshal(event.Data(), &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if data.CustomRun == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid CustomRun data in %v", event)
        }</span>
        <span class="cov8" title="1">resourceName = data.CustomRun.Name
        resourceNamespace = data.CustomRun.Namespace
        resourceKind = "customrun"
        eventType := event.Type()
        return fmt.Sprintf("%s/%s/%s/%s", eventType, resourceKind, resourceNamespace, resourceName), nil</span>
}
</pre>
		
		<pre class="file" id="file425" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cache

import (
        "context"

        lru "github.com/hashicorp/golang-lru"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

// With 4 events per Run, we can store events for 1024 concurrent Runs
const bufferSize = 4096

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(withCacheClient)
}</span>

// cacheKey is a way to associate the Cache from inside the context.Context
type cacheKey struct{}

func withCacheClientFromSize(ctx context.Context, size int) context.Context <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        cacheClient, err := lru.New(size)
        logger.Infof("CACHE CLIENT %+v", cacheClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("unable to create cacheClient :" + err.Error())
        }</span>

        <span class="cov0" title="0">return ToContext(ctx, cacheClient)</span>
}

func withCacheClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return withCacheClientFromSize(ctx, bufferSize)
}</span>

// Get extracts the cloudEventClient client from the context.
func Get(ctx context.Context) *lru.Cache <span class="cov0" title="0">{
        untyped := ctx.Value(cacheKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Unable to fetch client from context.")
                return nil
        }</span>
        <span class="cov0" title="0">return untyped.(*lru.Cache)</span>
}

// ToContext adds the cloud events client to the context
func ToContext(ctx context.Context, c *lru.Cache) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, cacheKey{}, c)
}</span>
</pre>
		
		<pre class="file" id="file426" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cache

import (
        "context"

        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

const fakeBufferSize = 128

func init() <span class="cov8" title="1">{
        injection.Fake.RegisterClient(withFakeCacheClient)
}</span>

func withFakeCacheClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return withCacheClientFromSize(ctx, fakeBufferSize)
}</span>
</pre>
		
		<pre class="file" id="file427" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "errors"
        "time"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        lru "github.com/hashicorp/golang-lru"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cache"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
        controller "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func cloudEventsSink(ctx context.Context) string <span class="cov8" title="1">{
        configs := config.FromContextOrDefaults(ctx)
        // Try the sink configuration first
        sink := configs.Events.Sink
        if sink == "" </span><span class="cov8" title="1">{
                // Fall back to the deprecated flag is the new one is not set
                // This ensures no changes in behaviour for existing users of the deprecated flag
                sink = configs.Defaults.DefaultCloudEventsSink
        }</span>
        <span class="cov8" title="1">return sink</span>
}

// EmitCloudEvents emits CloudEvents (only) for object
func EmitCloudEvents(ctx context.Context, object runtime.Object) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if sink := cloudEventsSink(ctx); sink != "" </span><span class="cov8" title="1">{
                ctx = cloudevents.ContextWithTarget(ctx, sink)
                err := SendCloudEventWithRetries(ctx, object)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to emit cloud events %v", err.Error())
                }</span>
        }
}

// EmitCloudEventsWhenConditionChange emits CloudEvents when there is a change in condition
func EmitCloudEventsWhenConditionChange(ctx context.Context, beforeCondition *apis.Condition, afterCondition *apis.Condition, object runtime.Object) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if sink := cloudEventsSink(ctx); sink != "" </span><span class="cov8" title="1">{
                ctx = cloudevents.ContextWithTarget(ctx, sink)

                // Only send events if the new condition represents a change
                if !equality.Semantic.DeepEqual(beforeCondition, afterCondition) </span><span class="cov8" title="1">{
                        err := SendCloudEventWithRetries(ctx, object)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to emit cloud events %v", err.Error())
                        }</span>
                }
        }
}

// SendCloudEventWithRetries sends a cloud event for the specified resource.
// It does not block and it perform retries with backoff using the cloudevents
// sdk-go capabilities.
// It accepts a runtime.Object to avoid making objectWithCondition public since
// it's only used within the events/cloudevents packages.
func SendCloudEventWithRetries(ctx context.Context, object runtime.Object) error <span class="cov8" title="1">{
        var (
                o           objectWithCondition
                ok          bool
                cacheClient *lru.Cache
        )
        if o, ok = object.(objectWithCondition); !ok </span><span class="cov0" title="0">{
                return errors.New("input object does not satisfy objectWithCondition")
        }</span>
        <span class="cov8" title="1">logger := logging.FromContext(ctx)
        ceClient := Get(ctx)
        if ceClient == nil </span><span class="cov8" title="1">{
                return errors.New("no cloud events client found in the context")
        }</span>
        <span class="cov8" title="1">event, err := EventForObjectWithCondition(ctx, o)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Events for CustomRuns require a cache of events that have been sent
        <span class="cov8" title="1">_, isCustomRun := object.(*v1beta1.CustomRun)
        if isCustomRun </span><span class="cov8" title="1">{
                cacheClient = cache.Get(ctx)
        }</span>

        <span class="cov8" title="1">wasIn := make(chan error)

        ceClient.addCount()
        go func() </span><span class="cov8" title="1">{
                defer ceClient.decreaseCount()
                wasIn &lt;- nil
                logger.Debugf("Sending cloudevent of type %q", event.Type())
                // In case of Run event, check cache if cloudevent is already sent
                if isCustomRun </span><span class="cov8" title="1">{
                        cloudEventSent, err := cache.ContainsOrAddCloudEvent(cacheClient, event)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Error while checking cache: %s", err)
                        }</span>
                        <span class="cov8" title="1">if cloudEventSent </span><span class="cov0" title="0">{
                                logger.Infof("cloudevent %v already sent", event)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if result := ceClient.Send(cloudevents.ContextWithRetriesExponentialBackoff(ctx, 10*time.Millisecond, 10), *event); !cloudevents.IsACK(result) </span><span class="cov8" title="1">{
                        logger.Warnf("Failed to send cloudevent: %s", result.Error())
                        recorder := controller.GetEventRecorder(ctx)
                        if recorder == nil </span><span class="cov0" title="0">{
                                logger.Warnf("No recorder in context, cannot emit error event")
                                return
                        }</span>
                        <span class="cov8" title="1">recorder.Event(object, corev1.EventTypeWarning, "Cloud Event Failure", result.Error())</span>
                }
        }()

        <span class="cov8" title="1">return &lt;-wasIn</span>
}
</pre>
		
		<pre class="file" id="file428" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "errors"
        "fmt"
        "strings"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        "github.com/google/uuid"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "knative.dev/pkg/apis"
)

// TektonEventType holds the types of cloud events sent by Tekton
type TektonEventType string

const (
        // TaskRunStartedEventV1 is sent for TaskRuns with "ConditionSucceeded" "Unknown"
        // the first time they are picked up by the reconciler
        TaskRunStartedEventV1 TektonEventType = "dev.tekton.event.taskrun.started.v1"
        // TaskRunRunningEventV1 is sent for TaskRuns with "ConditionSucceeded" "Unknown"
        // once the TaskRun is validated and Pod created
        TaskRunRunningEventV1 TektonEventType = "dev.tekton.event.taskrun.running.v1"
        // TaskRunUnknownEventV1 is sent for TaskRuns with "ConditionSucceeded" "Unknown"
        // It can be used as a confirmation that the TaskRun is still running.
        TaskRunUnknownEventV1 TektonEventType = "dev.tekton.event.taskrun.unknown.v1"
        // TaskRunSuccessfulEventV1 is sent for TaskRuns with "ConditionSucceeded" "True"
        TaskRunSuccessfulEventV1 TektonEventType = "dev.tekton.event.taskrun.successful.v1"
        // TaskRunFailedEventV1 is sent for TaskRuns with "ConditionSucceeded" "False"
        TaskRunFailedEventV1 TektonEventType = "dev.tekton.event.taskrun.failed.v1"
        // PipelineRunStartedEventV1 is sent for PipelineRuns with "ConditionSucceeded" "Unknown"
        // the first time they are picked up by the reconciler
        PipelineRunStartedEventV1 TektonEventType = "dev.tekton.event.pipelinerun.started.v1"
        // PipelineRunRunningEventV1 is sent for PipelineRuns with "ConditionSucceeded" "Unknown"
        // once the PipelineRun is validated and Pod created
        PipelineRunRunningEventV1 TektonEventType = "dev.tekton.event.pipelinerun.running.v1"
        // PipelineRunUnknownEventV1 is sent for PipelineRuns with "ConditionSucceeded" "Unknown"
        // It can be used as a confirmation that the PipelineRun is still running.
        PipelineRunUnknownEventV1 TektonEventType = "dev.tekton.event.pipelinerun.unknown.v1"
        // PipelineRunSuccessfulEventV1 is sent for PipelineRuns with "ConditionSucceeded" "True"
        PipelineRunSuccessfulEventV1 TektonEventType = "dev.tekton.event.pipelinerun.successful.v1"
        // PipelineRunFailedEventV1 is sent for PipelineRuns with "ConditionSucceeded" "False"
        PipelineRunFailedEventV1 TektonEventType = "dev.tekton.event.pipelinerun.failed.v1"
        // CustomRunStartedEventV1 is sent for CustomRuns with "ConditionSucceeded" "Unknown"
        // the first time they are picked up by the reconciler
        CustomRunStartedEventV1 TektonEventType = "dev.tekton.event.customrun.started.v1"
        // CustomRunRunningEventV1 is sent for CustomRuns with "ConditionSucceeded" "Unknown"
        // once the CustomRun is validated and Pod created
        CustomRunRunningEventV1 TektonEventType = "dev.tekton.event.customrun.running.v1"
        // CustomRunSuccessfulEventV1 is sent for CustomRuns with "ConditionSucceeded" "True"
        CustomRunSuccessfulEventV1 TektonEventType = "dev.tekton.event.customrun.successful.v1"
        // CustomRunFailedEventV1 is sent for CustomRuns with "ConditionSucceeded" "False"
        CustomRunFailedEventV1 TektonEventType = "dev.tekton.event.customrun.failed.v1"
)

func (t TektonEventType) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

// CEClient wraps the `Client` interface from github.com/cloudevents/sdk-go/v2/cloudevents
// and has methods to count the cloud events being sent, those methods are for testing purposes.
type CEClient interface {
        cloudevents.Client
        // addCount increments the count of events to be sent
        addCount()
        // decreaseCount decrements the count of events to be sent, indicating the event has been sent
        decreaseCount()
}

// TektonCloudEventData type is used to marshal and unmarshal the payload of
// a Tekton cloud event. It can include a TaskRun or a PipelineRun
type TektonCloudEventData struct {
        TaskRun     *v1beta1.TaskRun     `json:"taskRun,omitempty"`
        PipelineRun *v1beta1.PipelineRun `json:"pipelineRun,omitempty"`
        CustomRun   *v1beta1.CustomRun   `json:"customRun,omitempty"`
}

// newTektonCloudEventData returns a new instance of TektonCloudEventData
func newTektonCloudEventData(ctx context.Context, runObject objectWithCondition) (TektonCloudEventData, error) <span class="cov8" title="1">{
        tektonCloudEventData := TektonCloudEventData{}
        switch v := runObject.(type) </span>{
        case *v1beta1.TaskRun:<span class="cov0" title="0">
                tektonCloudEventData.TaskRun = v</span>
        case *v1beta1.PipelineRun:<span class="cov0" title="0">
                tektonCloudEventData.PipelineRun = v</span>
        case *v1.TaskRun:<span class="cov8" title="1">
                v1beta1TaskRun := &amp;v1beta1.TaskRun{}
                if err := v1beta1TaskRun.ConvertFrom(ctx, v); err != nil </span><span class="cov0" title="0">{
                        return TektonCloudEventData{}, err
                }</span>
                <span class="cov8" title="1">tektonCloudEventData.TaskRun = v1beta1TaskRun</span>
        case *v1.PipelineRun:<span class="cov8" title="1">
                v1beta1PipelineRun := &amp;v1beta1.PipelineRun{}
                if err := v1beta1PipelineRun.ConvertFrom(ctx, v); err != nil </span><span class="cov0" title="0">{
                        return TektonCloudEventData{}, err
                }</span>
                <span class="cov8" title="1">tektonCloudEventData.PipelineRun = v1beta1PipelineRun</span>
        case *v1beta1.CustomRun:<span class="cov8" title="1">
                tektonCloudEventData.CustomRun = v</span>
        }
        <span class="cov8" title="1">return tektonCloudEventData, nil</span>
}

// EventForObjectWithCondition creates a new event based for an objectWithCondition,
// or returns an error if not possible.
func EventForObjectWithCondition(ctx context.Context, runObject objectWithCondition) (*cloudevents.Event, error) <span class="cov8" title="1">{
        event := cloudevents.NewEvent()
        event.SetID(uuid.New().String())
        event.SetSubject(runObject.GetObjectMeta().GetName())
        // TODO: SelfLink is deprecated https://github.com/tektoncd/pipeline/issues/2676
        source := runObject.GetObjectMeta().GetSelfLink()
        if source == "" </span><span class="cov8" title="1">{
                gvk := runObject.GetObjectKind().GroupVersionKind()
                source = fmt.Sprintf("/apis/%s/%s/namespaces/%s/%s/%s",
                        gvk.Group,
                        gvk.Version,
                        runObject.GetObjectMeta().GetNamespace(),
                        gvk.Kind,
                        runObject.GetObjectMeta().GetName())
        }</span>
        <span class="cov8" title="1">event.SetSource(source)
        eventType, err := getEventType(runObject)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if eventType == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no matching event type found")
        }</span>
        <span class="cov8" title="1">event.SetType(eventType.String())

        tektonCloudEventData, err := newTektonCloudEventData(ctx, runObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := event.SetData(cloudevents.ApplicationJSON, tektonCloudEventData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;event, nil</span>
}

func getEventType(runObject objectWithCondition) (*TektonEventType, error) <span class="cov8" title="1">{
        var eventType TektonEventType
        c := runObject.GetStatusCondition().GetCondition(apis.ConditionSucceeded)
        if c == nil </span><span class="cov8" title="1">{
                // When the `Run` is created, it may not have any condition until it's
                // picked up by the `Run` reconciler. In that case we consider the run
                // as started. In all other cases, conditions have to be initialised
                switch runObject.(type) </span>{
                case *v1beta1.CustomRun:<span class="cov8" title="1">
                        eventType = CustomRunStartedEventV1
                        return &amp;eventType, nil</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("no condition for ConditionSucceeded in %T", runObject)</span>
                }
        }
        <span class="cov8" title="1">switch </span>{
        case c.IsUnknown():<span class="cov8" title="1">
                switch runObject.(type) </span>{
                case *v1beta1.TaskRun:<span class="cov0" title="0">
                        switch c.Reason </span>{
                        case v1beta1.TaskRunReasonStarted.String():<span class="cov0" title="0">
                                eventType = TaskRunStartedEventV1</span>
                        case v1beta1.TaskRunReasonRunning.String():<span class="cov0" title="0">
                                eventType = TaskRunRunningEventV1</span>
                        default:<span class="cov0" title="0">
                                eventType = TaskRunUnknownEventV1</span>
                        }
                case *v1.TaskRun:<span class="cov0" title="0">
                        switch c.Reason </span>{
                        case v1.TaskRunReasonStarted.String():<span class="cov0" title="0">
                                eventType = TaskRunStartedEventV1</span>
                        case v1.TaskRunReasonRunning.String():<span class="cov0" title="0">
                                eventType = TaskRunRunningEventV1</span>
                        default:<span class="cov0" title="0">
                                eventType = TaskRunUnknownEventV1</span>
                        }
                case *v1beta1.PipelineRun:<span class="cov0" title="0">
                        switch c.Reason </span>{
                        case v1beta1.PipelineRunReasonStarted.String():<span class="cov0" title="0">
                                eventType = PipelineRunStartedEventV1</span>
                        case v1beta1.PipelineRunReasonRunning.String():<span class="cov0" title="0">
                                eventType = PipelineRunRunningEventV1</span>
                        default:<span class="cov0" title="0">
                                eventType = PipelineRunUnknownEventV1</span>
                        }
                case *v1.PipelineRun:<span class="cov8" title="1">
                        switch c.Reason </span>{
                        case v1.PipelineRunReasonStarted.String():<span class="cov8" title="1">
                                eventType = PipelineRunStartedEventV1</span>
                        case v1.PipelineRunReasonRunning.String():<span class="cov0" title="0">
                                eventType = PipelineRunRunningEventV1</span>
                        default:<span class="cov0" title="0">
                                eventType = PipelineRunUnknownEventV1</span>
                        }

                case *v1beta1.CustomRun:<span class="cov0" title="0">
                        // CustomRun controller have the freedom of setting reasons as they wish
                        // so we cannot make many assumptions here. If a condition is set
                        // to unknown (not finished), we sent the running event
                        eventType = CustomRunRunningEventV1</span>
                }
        case c.IsFalse():<span class="cov0" title="0">
                switch runObject.(type) </span>{
                case *v1.TaskRun:<span class="cov0" title="0">
                        eventType = TaskRunFailedEventV1</span>
                case *v1.PipelineRun:<span class="cov0" title="0">
                        eventType = PipelineRunFailedEventV1</span>
                case *v1beta1.TaskRun:<span class="cov0" title="0">
                        eventType = TaskRunFailedEventV1</span>
                case *v1beta1.PipelineRun:<span class="cov0" title="0">
                        eventType = PipelineRunFailedEventV1</span>
                case *v1beta1.CustomRun:<span class="cov0" title="0">
                        eventType = CustomRunFailedEventV1</span>
                }
        case c.IsTrue():<span class="cov8" title="1">
                switch runObject.(type) </span>{
                case *v1beta1.TaskRun:<span class="cov0" title="0">
                        eventType = TaskRunSuccessfulEventV1</span>
                case *v1beta1.PipelineRun:<span class="cov0" title="0">
                        eventType = PipelineRunSuccessfulEventV1</span>
                case *v1.TaskRun:<span class="cov8" title="1">
                        eventType = TaskRunSuccessfulEventV1</span>
                case *v1.PipelineRun:<span class="cov8" title="1">
                        eventType = PipelineRunSuccessfulEventV1</span>
                case *v1beta1.CustomRun:<span class="cov0" title="0">
                        eventType = CustomRunSuccessfulEventV1</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown condition for in %T.Status %s", runObject, c.Status)</span>
        }
        <span class="cov8" title="1">return &amp;eventType, nil</span>
}

// GetCloudEventDeliveryCompareOptions returns compare options to sort
// and compare a list of CloudEventDelivery
func GetCloudEventDeliveryCompareOptions() []cmp.Option <span class="cov0" title="0">{
        // Setup cmp options
        cloudDeliveryStateCompare := func(x, y v1beta1.CloudEventDeliveryState) bool </span><span class="cov0" title="0">{
                return cmp.Equal(x.Condition, y.Condition) &amp;&amp; cmp.Equal(x.RetryCount, y.RetryCount)
        }</span>
        <span class="cov0" title="0">less := func(x, y v1beta1.CloudEventDelivery) bool </span><span class="cov0" title="0">{
                return strings.Compare(x.Target, y.Target) &lt; 0 || (strings.Compare(x.Target, y.Target) == 0 &amp;&amp; x.Status.SentAt.Before(y.Status.SentAt))
        }</span>
        <span class="cov0" title="0">return []cmp.Option{
                cmpopts.SortSlices(less),
                cmp.Comparer(func(x, y v1beta1.CloudEventDelivery) bool </span><span class="cov0" title="0">{
                        return (strings.Compare(x.Target, y.Target) == 0) &amp;&amp; cloudDeliveryStateCompare(x.Status, y.Status)
                }</span>),
        }
}
</pre>
		
		<pre class="file" id="file429" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "net/http"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/cloudevents/sdk-go/v2/client"
        "github.com/cloudevents/sdk-go/v2/event"
        "github.com/cloudevents/sdk-go/v2/protocol"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{
                return withCloudEventClient(ctx)
        }</span>)
}

// ceKey is used to associate the CloudEventClient inside the context.Context
type ceKey struct{}

func withCloudEventClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // When KeepAlive is enabled the connections are not reused - see
        // Bug https://github.com/tektoncd/pipeline/issues/3190. This causes the
        // number of connections to keep growing, even if when we limit max idle
        // connections in the transport.
        // TODO(afrittoli) Re-enable keep alive and ensure connections are reused
        // See feature https://github.com/tektoncd/pipeline/issues/3204
        var useOnceTransport http.RoundTripper = &amp;http.Transport{
                DisableKeepAlives: true,
        }

        p, err := cloudevents.NewHTTP(cloudevents.WithRoundTripper(useOnceTransport))
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents http protocol: %s", err)
        }</span>

        <span class="cov0" title="0">cloudEventClient, err := cloudevents.NewClient(p, cloudevents.WithUUIDs(), cloudevents.WithTimeNow())
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents client: %s", err)
        }</span>

        <span class="cov0" title="0">celient := CloudClient{
                client: cloudEventClient,
        }
        return context.WithValue(ctx, ceKey{}, celient)</span>
}

// CloudClient is a wrapper of CloudEvents client and implements addCount and decreaseCount
type CloudClient struct {
        client client.Client
}

// AddCount does nothing
func (c CloudClient) addCount() {<span class="cov0" title="0">
}</span>

// DecreaseCount does nothing
func (c CloudClient) decreaseCount() {<span class="cov0" title="0">
}</span>

// Send invokes call client.Send
func (c CloudClient) Send(ctx context.Context, event cloudevents.Event) protocol.Result <span class="cov0" title="0">{
        return c.client.Send(ctx, event)
}</span>

// Request invokes client.Request
func (c CloudClient) Request(ctx context.Context, event event.Event) (*cloudevents.Event, protocol.Result) <span class="cov0" title="0">{
        return c.client.Request(ctx, event)
}</span>

// StartReceiver invokes client.StartReceiver
func (c CloudClient) StartReceiver(ctx context.Context, fn interface{}) error <span class="cov0" title="0">{
        return c.client.StartReceiver(ctx, fn)
}</span>

// Get extracts the cloudEventClient client from the context.
func Get(ctx context.Context) CEClient <span class="cov8" title="1">{
        untyped := ctx.Value(ceKey{})
        if untyped == nil </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Errorf(
                        "Unable to fetch client from context.")
                return nil
        }</span>
        <span class="cov8" title="1">return untyped.(CEClient)</span>
}

// ToContext adds the cloud events client to the context
func ToContext(ctx context.Context, cec CEClient) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ceKey{}, cec)
}</span>
</pre>
		
		<pre class="file" id="file430" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "fmt"
        "regexp"
        "sync"
        "testing"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/cloudevents/sdk-go/v2/protocol"
)

// FakeClientBehaviour defines how the client will behave
type FakeClientBehaviour struct {
        SendSuccessfully bool
}

// FakeClient is a fake CloudEvent client for unit testing
// Holding a pointer to the behaviour allows to change the behaviour of a client
type FakeClient struct {
        behaviour *FakeClientBehaviour
        // Modelled after k8s.io/client-go fake recorder
        events chan string
        // waitGroup is used to block until all events have been sent
        waitGroup *sync.WaitGroup
}

// newFakeClient is a FakeClient factory, it returns a client for the target
func newFakeClient(behaviour *FakeClientBehaviour, expectedEventCount int) CEClient <span class="cov8" title="1">{
        return FakeClient{
                behaviour: behaviour,
                // set buffersize to length of want events to make sure no extra events are sent
                events:    make(chan string, expectedEventCount),
                waitGroup: &amp;sync.WaitGroup{},
        }
}</span>

var _ cloudevents.Client = (*FakeClient)(nil)

// Send fakes the Send method from cloudevents.Client
func (c FakeClient) Send(ctx context.Context, event cloudevents.Event) protocol.Result <span class="cov8" title="1">{
        if c.behaviour.SendSuccessfully </span><span class="cov8" title="1">{
                // This is to prevent extra events are sent. We don't read events from channel before we call CheckCloudEventsUnordered
                if len(c.events) &lt; cap(c.events) </span><span class="cov8" title="1">{
                        c.events &lt;- event.String()
                        return nil
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("channel is full of size:%v, but extra event wants to be sent:%v", cap(c.events), event)</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("had to fail. Event ID: %s", event.ID())</span>
}

// Request fakes the Request method from cloudevents.Client
func (c FakeClient) Request(ctx context.Context, event cloudevents.Event) (*cloudevents.Event, protocol.Result) <span class="cov0" title="0">{
        if c.behaviour.SendSuccessfully </span><span class="cov0" title="0">{
                if len(c.events) &lt; cap(c.events) </span><span class="cov0" title="0">{
                        c.events &lt;- event.String()
                        return &amp;event, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("channel is full of size:%v, but extra event wants to be sent:%v", cap(c.events), event)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("had to fail. Event ID: %s", event.ID())</span>
}

// StartReceiver fakes StartReceiver method from cloudevents.Client
func (c FakeClient) StartReceiver(ctx context.Context, fn interface{}) error <span class="cov0" title="0">{
        return nil
}</span>

// addCount can be used to add the count when each event is going to be sent
func (c FakeClient) addCount() <span class="cov8" title="1">{
        c.waitGroup.Add(1)
}</span>

// decreaseCount can be used to the decrease the count when each event is sent
func (c FakeClient) decreaseCount() <span class="cov8" title="1">{
        c.waitGroup.Done()
}</span>

// WithFakeClient adds to the context a fake client with the desired behaviour and expectedEventCount
func WithFakeClient(ctx context.Context, behaviour *FakeClientBehaviour, expectedEventCount int) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, ceKey{}, newFakeClient(behaviour, expectedEventCount))
}</span>

// CheckCloudEventsUnordered checks that all events in wantEvents, and no others,
// were received via the given chan, in any order.
// Block until all events have been sent.
func (c *FakeClient) CheckCloudEventsUnordered(t *testing.T, testName string, wantEvents []string) <span class="cov8" title="1">{
        t.Helper()
        c.waitGroup.Wait()
        expected := append([]string{}, wantEvents...)
        channelEvents := len(c.events)

        // extra events are prevented in FakeClient's Send function.
        // fewer events are detected because we collect all events from channel and compare with wantEvents

        for range channelEvents </span><span class="cov8" title="1">{
                event := &lt;-c.events
                if len(expected) == 0 </span><span class="cov0" title="0">{
                        t.Errorf("extra event received: %q", event)
                }</span>
                <span class="cov8" title="1">found := false
                for wantIdx, want := range expected </span><span class="cov8" title="1">{
                        matching, err := regexp.MatchString(want, event)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Errorf("something went wrong matching an event: %s", err)
                        }</span>
                        <span class="cov8" title="1">if matching </span><span class="cov8" title="1">{
                                found = true
                                // Remove event from list of those we expect to receive
                                expected[wantIdx] = expected[len(expected)-1]
                                expected = expected[:len(expected)-1]
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        t.Errorf("unexpected event received: %q", event)
                }</span>
        }
        <span class="cov8" title="1">if len(expected) != 0 </span><span class="cov0" title="0">{
                t.Errorf("%d events %#v are not received", len(expected), expected)
        }</span>
}
</pre>
		
		<pre class="file" id="file431" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package events

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/k8sevent"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
)

// Emit emits events for object
// Two types of events are supported, k8s and cloud events.
//
// k8s events are always sent if afterCondition is different from beforeCondition
// Cloud events are always sent if enabled, i.e. if a sink is available
func Emit(ctx context.Context, beforeCondition *apis.Condition, afterCondition *apis.Condition, object runtime.Object) <span class="cov8" title="1">{
        k8sevent.EmitK8sEvents(ctx, beforeCondition, afterCondition, object)
        cloudevent.EmitCloudEventsWhenConditionChange(ctx, beforeCondition, afterCondition, object)
}</span>

// EmitCloudEvents is refactored to cloudevent, this is to avoid breaking change
var EmitCloudEvents = cloudevent.EmitCloudEvents

// EmitError is refactored to k8sevent, this is to avoid breaking change
var EmitError = k8sevent.EmitError
</pre>
		
		<pre class="file" id="file432" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package k8sevent

import (
        "context"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
)

const (
        // EventReasonSucceded is the reason set for events about successful completion of TaskRuns / PipelineRuns
        EventReasonSucceded = "Succeeded"
        // EventReasonFailed is the reason set for events about unsuccessful completion of TaskRuns / PipelineRuns
        EventReasonFailed = "Failed"
        // EventReasonStarted is the reason set for events about the start of TaskRuns / PipelineRuns
        EventReasonStarted = "Started"
        // EventReasonError is the reason set for events related to TaskRuns / PipelineRuns reconcile errors
        EventReasonError = "Error"
)

// EmitK8sEvents emits kubernetes events for object
// k8s events are always sent if afterCondition is different from beforeCondition
func EmitK8sEvents(ctx context.Context, beforeCondition *apis.Condition, afterCondition *apis.Condition, object runtime.Object) <span class="cov8" title="1">{
        recorder := controller.GetEventRecorder(ctx)
        // Events that are going to be sent
        //
        // Status "ConditionUnknown":
        //   beforeCondition == nil, emit EventReasonStarted
        //   beforeCondition != nil, emit afterCondition.Reason
        //
        //  Status "ConditionTrue": emit EventReasonSucceded
        //  Status "ConditionFalse": emit EventReasonFailed
        if !equality.Semantic.DeepEqual(beforeCondition, afterCondition) &amp;&amp; afterCondition != nil </span><span class="cov8" title="1">{
                // If the condition changed, and the target condition is not empty, we send an event
                switch afterCondition.Status </span>{
                case corev1.ConditionTrue:<span class="cov8" title="1">
                        recorder.Event(object, corev1.EventTypeNormal, EventReasonSucceded, afterCondition.Message)</span>
                case corev1.ConditionFalse:<span class="cov8" title="1">
                        recorder.Event(object, corev1.EventTypeWarning, EventReasonFailed, afterCondition.Message)</span>
                case corev1.ConditionUnknown:<span class="cov8" title="1">
                        if beforeCondition == nil </span><span class="cov8" title="1">{
                                // If the condition changed, the status is "unknown", and there was no condition before,
                                // we emit the "Started event". We ignore further updates of the "unknown" status.
                                recorder.Event(object, corev1.EventTypeNormal, EventReasonStarted, "")
                        }</span> else<span class="cov8" title="1"> {
                                // If the condition changed, the status is "unknown", and there was a condition before,
                                // we emit an event that matches the reason and message of the condition.
                                // This is used for instance to signal the transition from "started" to "running"
                                recorder.Event(object, corev1.EventTypeNormal, afterCondition.Reason, afterCondition.Message)
                        }</span>
                }
        }
}

// EmitError emits a failure associated to an error
func EmitError(c record.EventRecorder, err error, object runtime.Object) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                c.Event(object, corev1.EventTypeWarning, EventReasonError, err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file433" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package k8sevent

import (
        "fmt"
        "regexp"
        "testing"
        "time"

        "k8s.io/apimachinery/pkg/util/wait"
)

// CheckEventsOrdered checks that the events received via the given chan are the same as wantEvents,
// in the same order.
func CheckEventsOrdered(t *testing.T, eventChan chan string, testName string, wantEvents []string) error <span class="cov8" title="1">{
        t.Helper()
        err := eventsFromChannel(eventChan, wantEvents)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in test %s: %w", testName, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// eventsFromChannel takes a chan of string, a test name, and a list of events that a test
// expects to receive. The events must be received in the same order they appear in the
// wantEvents list. Any extra or too few received events are considered errors.
func eventsFromChannel(c chan string, wantEvents []string) error <span class="cov8" title="1">{
        // We get events from a channel, so the timeout is here to avoid waiting
        // on the channel forever if fewer than expected events are received.
        // We only hit the timeout in case of failure of the test, so the actual value
        // of the timeout is not so relevant, it's only used when tests are going to fail.
        // on the channel forever if fewer than expected events are received
        timer := time.After(wait.ForeverTestTimeout)
        foundEvents := []string{}
        for ii := range wantEvents </span><span class="cov8" title="1">{
                // We loop over all the events that we expect. Once they are all received
                // we exit the loop. If we never receive enough events, the timeout takes us
                // out of the loop.
                select </span>{
                case event := &lt;-c:<span class="cov8" title="1">
                        foundEvents = append(foundEvents, event)
                        wantEvent := wantEvents[ii]
                        // If the event is an exact match, there is no need to use regular expressions for matching.
                        // This can avoid the need to escape special characters, such as *, in the event to match.
                        if wantEvent == event </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">matching, err := regexp.MatchString(wantEvent, event)
                        if err == nil </span><span class="cov8" title="1">{
                                if !matching </span><span class="cov0" title="0">{
                                        return fmt.Errorf("expected event \"%s\" but got \"%s\" instead", wantEvent, event)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("something went wrong matching the event: %w", err)
                        }</span>
                case &lt;-timer:<span class="cov0" title="0">
                        return fmt.Errorf("received %d events but %d expected. Found events: %#v", len(foundEvents), len(wantEvents), foundEvents)</span>
                }
        }
        // Check if there are extra events in the channel, return error if found.
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case event := &lt;-c:<span class="cov0" title="0">
                        return fmt.Errorf("unexpected event: %q", event)</span>
                default:<span class="cov8" title="1">
                        return nil</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file434" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package customrun

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        customruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun"
        customrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun"
        cacheclient "github.com/tektoncd/pipeline/pkg/reconciler/events/cache"
        cloudeventclient "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController instantiates a new controller.Impl from knative.dev/pkg/controller
// This is a read-only controller, hence the SkipStatusUpdates set to true
func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                customRunInformer := customruninformer.Get(ctx)

                configStore := config.NewStore(logger.Named("config-store"))
                configStore.WatchConfigs(cmw)

                c := &amp;Reconciler{
                        cloudEventClient: cloudeventclient.Get(ctx),
                        cacheClient:      cacheclient.Get(ctx),
                }
                impl := customrunreconciler.NewImpl(ctx, c, func(impl *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        return controller.Options{
                                AgentName:         pipeline.CustomRunControllerName,
                                ConfigStore:       configStore,
                                SkipStatusUpdates: true,
                        }
                }</span>)

                <span class="cov8" title="1">if _, err := customRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register CustomRun informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file435" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package customrun

import (
        "context"

        lru "github.com/hashicorp/golang-lru"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        customrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun"
        "github.com/tektoncd/pipeline/pkg/reconciler/events"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cache"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        cloudEventClient cloudevent.CEClient
        cacheClient      *lru.Cache
}

// Check that our Reconciler implements customrunreconciler.Interface
var (
        _ customrunreconciler.Interface = (*Reconciler)(nil)
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two. It then updates the Status block of the CustomRun
// resource with the current status of the resource.
func (c *Reconciler) ReconcileKind(ctx context.Context, customRun *v1beta1.CustomRun) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        configs := config.FromContextOrDefaults(ctx)
        ctx = cloudevent.ToContext(ctx, c.cloudEventClient)
        ctx = cache.ToContext(ctx, c.cacheClient)
        logger.Infof("Reconciling %s", customRun.Name)

        // Create a copy of the CustomRun object, just in case, to avoid sync'ing changes
        customRunEvents := *customRun.DeepCopy()

        if configs.FeatureFlags.SendCloudEventsForRuns </span><span class="cov8" title="1">{
                // Custom task controllers may be sending events for "CustomRuns" associated
                // to the custom tasks they control. To avoid sending duplicate events,
                // CloudEvents for "CustomRuns" are only sent when enabled

                // Read and log the condition
                condition := customRunEvents.Status.GetCondition(apis.ConditionSucceeded)
                logger.Debugf("Emitting cloudevent for %s, condition: %s", customRunEvents.Name, condition)

                events.EmitCloudEvents(ctx, &amp;customRunEvents)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file436" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dag

import (
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/tektoncd/pipeline/pkg/list"
        "k8s.io/apimachinery/pkg/util/sets"
)

// Task is an interface for all types that could be in a DAG
type Task interface {
        HashKey() string
        Deps() []string
}

// Tasks is an interface for lists of types that could be in a DAG
type Tasks interface {
        Items() []Task
}

// Node represents a Task in a pipeline.
type Node struct {
        // Key represent a unique name of the node in a graph
        Key string
        // Prev represent all the Previous task Nodes for the current Task
        Prev []*Node
        // Next represent all the Next task Nodes for the current Task
        Next []*Node
}

// Graph represents the Pipeline Graph
type Graph struct {
        // Nodes represent map of PipelineTask name to Node in Pipeline Graph
        Nodes map[string]*Node
}

// Returns an empty Pipeline Graph
func newGraph() *Graph <span class="cov8" title="1">{
        return &amp;Graph{Nodes: map[string]*Node{}}
}</span>

func (g *Graph) addPipelineTask(t Task) (*Node, error) <span class="cov8" title="1">{
        if _, ok := g.Nodes[t.HashKey()]; ok </span><span class="cov8" title="1">{
                return nil, errors.New("duplicate pipeline task")
        }</span>
        <span class="cov8" title="1">newNode := &amp;Node{
                Key: t.HashKey(),
        }
        g.Nodes[t.HashKey()] = newNode
        return newNode, nil</span>
}

// Build returns a valid pipeline Graph. Returns error if the pipeline is invalid
func Build(tasks Tasks, deps map[string][]string) (*Graph, error) <span class="cov8" title="1">{
        d := newGraph()

        // Add all Tasks mentioned in the `PipelineSpec`
        for _, pt := range tasks.Items() </span><span class="cov8" title="1">{
                if _, err := d.addPipelineTask(pt); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("task %s is already present in Graph, can't add it again: %w", pt.HashKey(), err)
                }</span>
        }

        // Ensure no cycles in the graph
        <span class="cov8" title="1">if err := findCyclesInDependencies(deps); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cycle detected; %w", err)
        }</span>

        // Process all from and runAfter constraints to add task dependency
        <span class="cov8" title="1">for pt, taskDeps := range deps </span><span class="cov8" title="1">{
                for _, previousTask := range taskDeps </span><span class="cov8" title="1">{
                        if err := addLink(pt, previousTask, d.Nodes); err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("couldn't add link between %s and %s: %w", pt, previousTask, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return d, nil</span>
}

// GetCandidateTasks returns a set of names of PipelineTasks whose ancestors are all completed,
// given a list of finished doneTasks. If the specified
// doneTasks are invalid (i.e. if it is indicated that a Task is done, but the
// previous Tasks are not done), an error is returned.
func GetCandidateTasks(g *Graph, doneTasks ...string) (sets.String, error) <span class="cov8" title="1">{
        roots := getRoots(g)
        tm := sets.NewString(doneTasks...)
        d := sets.NewString()

        visited := sets.NewString()
        for _, root := range roots </span><span class="cov8" title="1">{
                schedulable := findSchedulable(root, visited, tm)
                for _, taskName := range schedulable </span><span class="cov8" title="1">{
                        d.Insert(taskName)
                }</span>
        }

        <span class="cov8" title="1">var visitedNames []string
        for v := range visited </span><span class="cov8" title="1">{
                visitedNames = append(visitedNames, v)
        }</span>

        <span class="cov8" title="1">notVisited := list.DiffLeft(doneTasks, visitedNames)
        if len(notVisited) &gt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid list of done tasks; some tasks were indicated completed without ancestors being done: %v", notVisited)
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}

func linkPipelineTasks(prev *Node, next *Node) <span class="cov8" title="1">{
        next.Prev = append(next.Prev, prev)
        prev.Next = append(prev.Next, next)
}</span>

// use Kahn's algorithm to find cycles in dependencies
func findCyclesInDependencies(deps map[string][]string) error <span class="cov8" title="1">{
        independentTasks := sets.NewString()
        dag := make(map[string]sets.String, len(deps))
        childMap := make(map[string]sets.String, len(deps))
        for task, taskDeps := range deps </span><span class="cov8" title="1">{
                if len(taskDeps) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">dag[task] = sets.NewString(taskDeps...)
                for _, dep := range taskDeps </span><span class="cov8" title="1">{
                        if len(deps[dep]) == 0 </span><span class="cov8" title="1">{
                                independentTasks.Insert(dep)
                        }</span>
                        <span class="cov8" title="1">if children, ok := childMap[dep]; ok </span><span class="cov8" title="1">{
                                children.Insert(task)
                        }</span> else<span class="cov8" title="1"> {
                                childMap[dep] = sets.NewString(task)
                        }</span>
                }
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                parent, ok := independentTasks.PopAny()
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">children := childMap[parent]
                for </span><span class="cov8" title="1">{
                        child, ok := children.PopAny()
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">dag[child].Delete(parent)
                        if dag[child].Len() == 0 </span><span class="cov8" title="1">{
                                independentTasks.Insert(child)
                                delete(dag, child)
                        }</span>
                }
        }

        <span class="cov8" title="1">return getInterdependencyError(dag)</span>
}

func getInterdependencyError(dag map[string]sets.String) error <span class="cov8" title="1">{
        if len(dag) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">firstChild := ""
        for task := range dag </span><span class="cov8" title="1">{
                if firstChild == "" || firstChild &gt; task </span><span class="cov8" title="1">{
                        firstChild = task
                }</span>
        }
        <span class="cov8" title="1">deps := dag[firstChild].List()
        depNames := make([]string, 0, len(deps))
        sort.Strings(deps)
        for _, dep := range deps </span><span class="cov8" title="1">{
                depNames = append(depNames, fmt.Sprintf("%q", dep))
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("task %q depends on %s", firstChild, strings.Join(depNames, ", "))</span>
}

func addLink(pt string, previousTask string, nodes map[string]*Node) error <span class="cov8" title="1">{
        prev, ok := nodes[previousTask]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s depends on %s but %s wasn't present in Pipeline", pt, previousTask, previousTask)
        }</span>
        <span class="cov8" title="1">next := nodes[pt]
        linkPipelineTasks(prev, next)
        return nil</span>
}

func getRoots(g *Graph) []*Node <span class="cov8" title="1">{
        n := []*Node{}
        for _, node := range g.Nodes </span><span class="cov8" title="1">{
                if len(node.Prev) == 0 </span><span class="cov8" title="1">{
                        n = append(n, node)
                }</span>
        }
        <span class="cov8" title="1">return n</span>
}

func findSchedulable(n *Node, visited sets.String, doneTasks sets.String) []string <span class="cov8" title="1">{
        if visited.Has(n.Key) </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">visited.Insert(n.Key)
        if doneTasks.Has(n.Key) </span><span class="cov8" title="1">{
                schedulable := []string{}
                // This one is done! Take note of it and look at the next candidate
                for _, next := range n.Next </span><span class="cov8" title="1">{
                        if _, ok := visited[next.Key]; !ok </span><span class="cov8" title="1">{
                                schedulable = append(schedulable, findSchedulable(next, visited, doneTasks)...)
                        }</span>
                }
                <span class="cov8" title="1">return schedulable</span>
        }
        // This one isn't done! Return it if it's schedulable
        <span class="cov8" title="1">if isSchedulable(doneTasks, n.Prev) </span><span class="cov8" title="1">{
                // FIXME(vdemeester)
                return []string{n.Key}
        }</span>
        // This one isn't done, but it also isn't ready to schedule
        <span class="cov8" title="1">return []string{}</span>
}

func isSchedulable(doneTasks sets.String, prevs []*Node) bool <span class="cov8" title="1">{
        if len(prevs) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">collected := []string{}
        for _, n := range prevs </span><span class="cov8" title="1">{
                if doneTasks.Has(n.Key) </span><span class="cov8" title="1">{
                        collected = append(collected, n.Key)
                }</span>
        }
        <span class="cov8" title="1">return len(collected) == len(prevs)</span>
}
</pre>
		
		<pre class="file" id="file437" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/internal/affinityassistant"
        aa "github.com/tektoncd/pipeline/pkg/internal/affinityassistant"
        pipelinePod "github.com/tektoncd/pipeline/pkg/pod"
        "github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim"
        "github.com/tektoncd/pipeline/pkg/workspace"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        errorutils "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
)

const (
        // ReasonCouldntCreateOrUpdateAffinityAssistantStatefulSet indicates that a PipelineRun uses workspaces with PersistentVolumeClaim
        // as a volume source and expect an Assistant StatefulSet in AffinityAssistantPerWorkspace behavior, but couldn't create a StatefulSet.
        ReasonCouldntCreateOrUpdateAffinityAssistantStatefulSet = "ReasonCouldntCreateOrUpdateAffinityAssistantStatefulSet"
)

var (
        // Deprecated: use volumeclain.ErrPvcCreationFailed instead
        ErrPvcCreationFailed = volumeclaim.ErrPvcCreationFailed
        // Deprecated: use volumeclaim.ErrAffinityAssistantCreationFailed instead
        ErrPvcCreationFailedRetryable      = volumeclaim.ErrPvcCreationFailedRetryable
        ErrAffinityAssistantCreationFailed = errors.New("Affinity Assistant creation error")
)

// createOrUpdateAffinityAssistantsAndPVCs creates Affinity Assistant StatefulSets and PVCs based on AffinityAssistantBehavior.
// This is done to achieve Node Affinity for taskruns in a pipelinerun, and make it possible for the taskruns to execute parallel while sharing volume.
// If the AffinityAssistantBehavior is AffinityAssistantPerWorkspace, it creates an Affinity Assistant for
// every taskrun in the pipelinerun that use the same PVC based volume.
// If the AffinityAssistantBehavior is AffinityAssistantPerPipelineRun or AffinityAssistantPerPipelineRunWithIsolation,
// it creates one Affinity Assistant for the pipelinerun.
func (c *Reconciler) createOrUpdateAffinityAssistantsAndPVCs(ctx context.Context, pr *v1.PipelineRun, aaBehavior aa.AffinityAssistantBehavior) error <span class="cov8" title="1">{
        var unschedulableNodes sets.Set[string] = nil

        var claimTemplates []corev1.PersistentVolumeClaim
        var claimNames []string
        claimNameToWorkspaceName := map[string]string{}
        claimTemplateToWorkspace := map[*corev1.PersistentVolumeClaim]v1.WorkspaceBinding{}

        for _, w := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                if w.PersistentVolumeClaim == nil &amp;&amp; w.VolumeClaimTemplate == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if w.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        claim := w.PersistentVolumeClaim
                        claimNames = append(claimNames, claim.ClaimName)
                        claimNameToWorkspaceName[claim.ClaimName] = w.Name
                }</span> else<span class="cov8" title="1"> if w.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        claimTemplate := w.VolumeClaimTemplate.DeepCopy()
                        claimTemplate.Name = volumeclaim.GeneratePVCNameFromWorkspaceBinding(w.VolumeClaimTemplate.Name, w, *kmeta.NewControllerRef(pr))
                        claimTemplates = append(claimTemplates, *claimTemplate)
                        claimTemplateToWorkspace[claimTemplate] = w
                }</span>
        }
        <span class="cov8" title="1">switch aaBehavior </span>{
        case aa.AffinityAssistantPerWorkspace:<span class="cov8" title="1">
                for claimName, workspaceName := range claimNameToWorkspaceName </span><span class="cov8" title="1">{
                        aaName := GetAffinityAssistantName(workspaceName, pr.Name)
                        if err := c.createOrUpdateAffinityAssistant(ctx, aaName, pr, nil, []string{claimName}, unschedulableNodes); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: %v", ErrAffinityAssistantCreationFailed, err)
                        }</span>
                }
                <span class="cov8" title="1">for claimTemplate, workspace := range claimTemplateToWorkspace </span><span class="cov8" title="1">{
                        // To support PVC auto deletion at pipelinerun deletion time, the OwnerReference of the PVCs should be set to the owning pipelinerun instead of the StatefulSets,
                        // so we create PVCs from PipelineRuns' VolumeClaimTemplate and pass the PVCs to the Affinity Assistant StatefulSet for volume scheduling.
                        if err := c.pvcHandler.CreatePVCFromVolumeClaimTemplate(ctx, workspace, *kmeta.NewControllerRef(pr), pr.Namespace); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">aaName := GetAffinityAssistantName(workspace.Name, pr.Name)
                        if err := c.createOrUpdateAffinityAssistant(ctx, aaName, pr, nil, []string{claimTemplate.Name}, unschedulableNodes); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: %v", ErrAffinityAssistantCreationFailed, err)
                        }</span>
                }
        case aa.AffinityAssistantPerPipelineRun, aa.AffinityAssistantPerPipelineRunWithIsolation:<span class="cov8" title="1">
                aaName := GetAffinityAssistantName("", pr.Name)
                // The PVCs are created via StatefulSet's VolumeClaimTemplate for volume scheduling
                // in AffinityAssistantPerPipelineRun or AffinityAssistantPerPipelineRunWithIsolation modes.
                // This is because PVCs from pipelinerun's VolumeClaimTemplate are enforced to be deleted at pipelinerun completion time in these modes,
                // and there is no requirement of the PVC OwnerReference.
                if err := c.createOrUpdateAffinityAssistant(ctx, aaName, pr, claimTemplates, claimNames, unschedulableNodes); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: %v", ErrAffinityAssistantCreationFailed, err)
                }</span>
        case aa.AffinityAssistantDisabled:<span class="cov8" title="1">
                for _, workspace := range claimTemplateToWorkspace </span><span class="cov8" title="1">{
                        if err := c.pvcHandler.CreatePVCFromVolumeClaimTemplate(ctx, workspace, *kmeta.NewControllerRef(pr), pr.Namespace); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// createOrUpdateAffinityAssistant creates an Affinity Assistant Statefulset with the provided affinityAssistantName and pipelinerun information.
// The VolumeClaimTemplates and Volumes of StatefulSet reference the resolved claimTemplates and claims respectively.
// It maintains a set of unschedulableNodes to detect and recreate Affinity Assistant in case of the node is cordoned to avoid pipelinerun deadlock.
func (c *Reconciler) createOrUpdateAffinityAssistant(ctx context.Context, affinityAssistantName string, pr *v1.PipelineRun, claimTemplates []corev1.PersistentVolumeClaim, claimNames []string, unschedulableNodes sets.Set[string]) []error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        cfg := config.FromContextOrDefaults(ctx)

        var errs []error
        a, err := c.KubeClientSet.AppsV1().StatefulSets(pr.Namespace).Get(ctx, affinityAssistantName, metav1.GetOptions{})
        switch </span>{
        // check whether the affinity assistant (StatefulSet) exists or not, create one if it does not exist
        case apierrors.IsNotFound(err):<span class="cov8" title="1">
                aaBehavior, err := aa.GetAffinityAssistantBehavior(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return []error{err}
                }</span>

                <span class="cov8" title="1">securityContextConfig := pipelinePod.SecurityContextConfig{
                        SetSecurityContext:        cfg.FeatureFlags.SetSecurityContext,
                        SetReadOnlyRootFilesystem: cfg.FeatureFlags.SetSecurityContextReadOnlyRootFilesystem,
                }

                containerConfig := aa.ContainerConfig{
                        Image:                 c.Images.NopImage,
                        SecurityContextConfig: securityContextConfig,
                }

                affinityAssistantStatefulSet := affinityAssistantStatefulSet(aaBehavior, affinityAssistantName, pr, claimTemplates, claimNames, containerConfig, cfg.Defaults.DefaultAAPodTemplate)
                _, err = c.KubeClientSet.AppsV1().StatefulSets(pr.Namespace).Create(ctx, affinityAssistantStatefulSet, metav1.CreateOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("failed to create StatefulSet %s: %w", affinityAssistantName, err))
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        logger.Infof("Created StatefulSet %s in namespace %s", affinityAssistantName, pr.Namespace)
                }</span>
        // check whether the affinity assistant (StatefulSet) exists and the affinity assistant pod is created
        // this check requires the StatefulSet to have the readyReplicas set to 1 to allow for any delay between the StatefulSet creation
        // and the necessary pod creation, the delay can be caused by any dependency on PVCs and PVs creation
        // this case addresses issues specified in https://github.com/tektoncd/pipeline/issues/6586
        case err == nil &amp;&amp; a != nil &amp;&amp; a.Status.ReadyReplicas == 1:<span class="cov8" title="1">
                if unschedulableNodes == nil </span><span class="cov8" title="1">{
                        ns, err := c.KubeClientSet.CoreV1().Nodes().List(ctx, metav1.ListOptions{
                                FieldSelector: "spec.unschedulable=true",
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("could not get the list of nodes, err: %w", err))
                        }</span>
                        <span class="cov8" title="1">unschedulableNodes = sets.Set[string]{}
                        // maintain the list of nodes which are unschedulable
                        for _, n := range ns.Items </span><span class="cov8" title="1">{
                                unschedulableNodes.Insert(n.Name)
                        }</span>
                }
                <span class="cov8" title="1">if unschedulableNodes.Len() &gt; 0 </span><span class="cov8" title="1">{
                        // get the pod created for a given StatefulSet, pod is assigned ordinal of 0 with the replicas set to 1
                        p, err := c.KubeClientSet.CoreV1().Pods(pr.Namespace).Get(ctx, a.Name+"-0", metav1.GetOptions{})
                        // ignore instead of failing if the affinity assistant pod was not found
                        if err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("could not get the affinity assistant pod for StatefulSet %s: %w", a.Name, err))
                        }</span>
                        // check the node which hosts the affinity assistant pod if it is unschedulable or cordoned
                        <span class="cov8" title="1">if p != nil &amp;&amp; unschedulableNodes.Has(p.Spec.NodeName) </span><span class="cov8" title="1">{
                                // if the node is unschedulable, delete the affinity assistant pod such that a StatefulSet can recreate the same pod on a different node
                                err = c.KubeClientSet.CoreV1().Pods(p.Namespace).Delete(ctx, p.Name, metav1.DeleteOptions{})
                                if err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, fmt.Errorf("error deleting affinity assistant pod %s in ns %s: %w", p.Name, p.Namespace, err))
                                }</span>
                        }
                }
        case err != nil:<span class="cov0" title="0">
                errs = append(errs, fmt.Errorf("failed to retrieve StatefulSet %s: %w", affinityAssistantName, err))</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// cleanupAffinityAssistantsAndPVCs deletes Affinity Assistant StatefulSets and PVCs created from VolumeClaimTemplates
func (c *Reconciler) cleanupAffinityAssistantsAndPVCs(ctx context.Context, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        aaBehavior, err := aa.GetAffinityAssistantBehavior(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var errs []error
        switch aaBehavior </span>{
        case aa.AffinityAssistantPerWorkspace:<span class="cov8" title="1">
                // TODO (#5776): support optional PVC deletion behavior for per-workspace mode
                for _, w := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                        if w.PersistentVolumeClaim != nil || w.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                                affinityAssistantName := GetAffinityAssistantName(w.Name, pr.Name)
                                if err := c.KubeClientSet.AppsV1().StatefulSets(pr.Namespace).Delete(ctx, affinityAssistantName, metav1.DeleteOptions{}); err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                        errs = append(errs, fmt.Errorf("failed to delete StatefulSet %s: %w", affinityAssistantName, err))
                                }</span>
                        }
                }
        case aa.AffinityAssistantPerPipelineRun, aa.AffinityAssistantPerPipelineRunWithIsolation:<span class="cov8" title="1">
                affinityAssistantName := GetAffinityAssistantName("", pr.Name)
                if err := c.KubeClientSet.AppsV1().StatefulSets(pr.Namespace).Delete(ctx, affinityAssistantName, metav1.DeleteOptions{}); err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to delete StatefulSet %s: %w", affinityAssistantName, err))
                }</span>

                // cleanup PVCs created by Affinity Assistants
                <span class="cov8" title="1">for _, w := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                        if w.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                                pvcName := getPersistentVolumeClaimNameWithAffinityAssistant("", pr.Name, w, *kmeta.NewControllerRef(pr))
                                if err := c.pvcHandler.PurgeFinalizerAndDeletePVCForWorkspace(ctx, pvcName, pr.Namespace); err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, err)
                                }</span>
                        }
                }
        case aa.AffinityAssistantDisabled:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">return errorutils.NewAggregate(errs)</span>
}

// getPersistentVolumeClaimNameWithAffinityAssistant returns the PersistentVolumeClaim name that is
// created by the Affinity Assistant StatefulSet VolumeClaimTemplate when Affinity Assistant is enabled.
// The PVCs created by StatefulSet VolumeClaimTemplates follow the format `&lt;pvcName&gt;-&lt;affinityAssistantName&gt;-0`
func getPersistentVolumeClaimNameWithAffinityAssistant(pipelineWorkspaceName, prName string, wb v1.WorkspaceBinding, owner metav1.OwnerReference) string <span class="cov8" title="1">{
        pvcName := volumeclaim.GeneratePVCNameFromWorkspaceBinding(wb.VolumeClaimTemplate.Name, wb, owner)
        affinityAssistantName := GetAffinityAssistantName(pipelineWorkspaceName, prName)
        return fmt.Sprintf("%s-%s-0", pvcName, affinityAssistantName)
}</span>

// getAffinityAssistantAnnotationVal generates and returns the value for `pipeline.tekton.dev/affinity-assistant` annotation
// based on aaBehavior, pipelinePVCWorkspaceName and prName
func getAffinityAssistantAnnotationVal(aaBehavior affinityassistant.AffinityAssistantBehavior, pipelinePVCWorkspaceName string, prName string) string <span class="cov8" title="1">{
        switch aaBehavior </span>{
        case affinityassistant.AffinityAssistantPerWorkspace:<span class="cov8" title="1">
                if pipelinePVCWorkspaceName != "" </span><span class="cov8" title="1">{
                        return GetAffinityAssistantName(pipelinePVCWorkspaceName, prName)
                }</span>
        case affinityassistant.AffinityAssistantPerPipelineRun, affinityassistant.AffinityAssistantPerPipelineRunWithIsolation:<span class="cov8" title="1">
                return GetAffinityAssistantName("", prName)</span>

        case affinityassistant.AffinityAssistantDisabled:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">return ""</span>
}

// GetAffinityAssistantName returns the Affinity Assistant name based on pipelineWorkspaceName and pipelineRunName
func GetAffinityAssistantName(pipelineWorkspaceName string, pipelineRunName string) string <span class="cov8" title="1">{
        hashBytes := sha256.Sum256([]byte(pipelineWorkspaceName + pipelineRunName))
        hashString := hex.EncodeToString(hashBytes[:])
        return fmt.Sprintf("%s-%s", workspace.ComponentNameAffinityAssistant, hashString[:10])
}</span>

func getStatefulSetLabels(pr *v1.PipelineRun, affinityAssistantName string) map[string]string <span class="cov8" title="1">{
        // Propagate labels from PipelineRun to StatefulSet.
        labels := make(map[string]string, len(pr.ObjectMeta.Labels)+1)
        for key, val := range pr.ObjectMeta.Labels </span><span class="cov8" title="1">{
                labels[key] = val
        }</span>
        <span class="cov8" title="1">labels[pipeline.PipelineRunLabelKey] = pr.Name

        // LabelInstance is used to configure PodAffinity for all TaskRuns belonging to this Affinity Assistant
        // LabelComponent is used to configure PodAntiAffinity to other Affinity Assistants
        labels[workspace.LabelInstance] = affinityAssistantName
        labels[workspace.LabelComponent] = workspace.ComponentNameAffinityAssistant
        return labels</span>
}

// affinityAssistantStatefulSet returns an Affinity Assistant as a StatefulSet based on the AffinityAssistantBehavior
// with the given AffinityAssistantTemplate applied to the StatefulSet PodTemplateSpec.
// The VolumeClaimTemplates and Volume of StatefulSet reference the PipelineRun WorkspaceBinding VolumeClaimTempalte and the PVCs respectively.
// The PVs created by the StatefulSet are scheduled to the same availability zone which avoids PV scheduling conflict.
func affinityAssistantStatefulSet(aaBehavior aa.AffinityAssistantBehavior, name string, pr *v1.PipelineRun, claimTemplates []corev1.PersistentVolumeClaim, claimNames []string, containerConfig aa.ContainerConfig, defaultAATpl *pod.AffinityAssistantTemplate) *appsv1.StatefulSet <span class="cov8" title="1">{
        // We want a singleton pod
        replicas := int32(1)

        tpl := &amp;pod.AffinityAssistantTemplate{}
        // merge pod template from spec and default if any of them are defined
        if pr.Spec.TaskRunTemplate.PodTemplate != nil || defaultAATpl != nil </span><span class="cov8" title="1">{
                tpl = pod.MergeAAPodTemplateWithDefault(pr.Spec.TaskRunTemplate.PodTemplate.ToAffinityAssistantTemplate(), defaultAATpl)
        }</span>

        <span class="cov8" title="1">var mounts []corev1.VolumeMount
        for _, claimTemplate := range claimTemplates </span><span class="cov8" title="1">{
                mounts = append(mounts, corev1.VolumeMount{Name: claimTemplate.Name, MountPath: claimTemplate.Name})
        }</span>

        <span class="cov8" title="1">securityContext := &amp;corev1.SecurityContext{}
        if containerConfig.SecurityContextConfig.SetSecurityContext </span><span class="cov8" title="1">{
                isWindows := tpl.NodeSelector[pipelinePod.OsSelectorLabel] == "windows"
                securityContext = containerConfig.SecurityContextConfig.GetSecurityContext(isWindows)
        }</span>

        <span class="cov8" title="1">var priorityClassName string
        if tpl.PriorityClassName != nil </span><span class="cov8" title="1">{
                priorityClassName = *tpl.PriorityClassName
        }</span>

        <span class="cov8" title="1">containers := []corev1.Container{{
                Name:  "affinity-assistant",
                Image: containerConfig.Image,
                Args:  []string{"tekton_run_indefinitely"},

                // Set requests == limits to get QoS class _Guaranteed_.
                // See https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/#create-a-pod-that-gets-assigned-a-qos-class-of-guaranteed
                // Affinity Assistant pod is a placeholder; request minimal resources
                Resources: corev1.ResourceRequirements{
                        Limits: corev1.ResourceList{
                                "cpu":    resource.MustParse("50m"),
                                "memory": resource.MustParse("100Mi"),
                        },
                        Requests: corev1.ResourceList{
                                "cpu":    resource.MustParse("50m"),
                                "memory": resource.MustParse("100Mi"),
                        },
                },
                VolumeMounts:    mounts,
                SecurityContext: securityContext,
        }}

        var volumes []corev1.Volume
        for i, claimName := range claimNames </span><span class="cov8" title="1">{
                volumes = append(volumes, corev1.Volume{
                        Name: fmt.Sprintf("workspace-%d", i),
                        VolumeSource: corev1.VolumeSource{
                                // A Pod mounting a PersistentVolumeClaim that has a StorageClass with
                                // volumeBindingMode: Immediate
                                // the PV is allocated on a Node first, and then the pod need to be
                                // scheduled to that node.
                                // To support those PVCs, the Affinity Assistant must also mount the
                                // same PersistentVolumeClaim - to be sure that the Affinity Assistant
                                // pod is scheduled to the same Availability Zone as the PV, when using
                                // a regional cluster. This is called VolumeScheduling.
                                PersistentVolumeClaim: &amp;corev1.PersistentVolumeClaimVolumeSource{ClaimName: claimName},
                        },
                })
        }</span>

        <span class="cov8" title="1">return &amp;appsv1.StatefulSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "StatefulSet",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:            name,
                        Labels:          getStatefulSetLabels(pr, name),
                        OwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(pr)},
                },
                Spec: appsv1.StatefulSetSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: getStatefulSetLabels(pr, name),
                        },
                        // by setting VolumeClaimTemplates from StatefulSet, all the PVs are scheduled to the same Availability Zone as the StatefulSet
                        VolumeClaimTemplates: claimTemplates,
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: getStatefulSetLabels(pr, name),
                                },
                                Spec: corev1.PodSpec{
                                        Containers: containers,

                                        Tolerations:       tpl.Tolerations,
                                        NodeSelector:      tpl.NodeSelector,
                                        ImagePullSecrets:  tpl.ImagePullSecrets,
                                        SecurityContext:   tpl.SecurityContext,
                                        PriorityClassName: priorityClassName,

                                        Affinity: getAssistantAffinityMergedWithPodTemplateAffinity(pr, aaBehavior),
                                        Volumes:  volumes,
                                },
                        },
                },
        }</span>
}

// getAssistantAffinityMergedWithPodTemplateAffinity return the affinity that merged with PipelineRun PodTemplate affinity.
func getAssistantAffinityMergedWithPodTemplateAffinity(pr *v1.PipelineRun, aaBehavior aa.AffinityAssistantBehavior) *corev1.Affinity <span class="cov8" title="1">{
        affinityAssistantsAffinity := &amp;corev1.Affinity{}
        if pr.Spec.TaskRunTemplate.PodTemplate != nil &amp;&amp; pr.Spec.TaskRunTemplate.PodTemplate.Affinity != nil </span><span class="cov8" title="1">{
                affinityAssistantsAffinity = pr.Spec.TaskRunTemplate.PodTemplate.Affinity
        }</span>
        <span class="cov8" title="1">if affinityAssistantsAffinity.PodAntiAffinity == nil </span><span class="cov8" title="1">{
                affinityAssistantsAffinity.PodAntiAffinity = &amp;corev1.PodAntiAffinity{}
        }</span>

        <span class="cov8" title="1">repelOtherAffinityAssistantsPodAffinityTerm := corev1.PodAffinityTerm{
                LabelSelector: &amp;metav1.LabelSelector{
                        MatchLabels: map[string]string{
                                workspace.LabelComponent: workspace.ComponentNameAffinityAssistant,
                        },
                },
                TopologyKey: "kubernetes.io/hostname",
        }

        if aaBehavior == aa.AffinityAssistantPerPipelineRunWithIsolation </span><span class="cov8" title="1">{
                // use RequiredDuringSchedulingIgnoredDuringExecution term to enforce only one pipelinerun can run in a node at a time
                affinityAssistantsAffinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution = append(affinityAssistantsAffinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution,
                        repelOtherAffinityAssistantsPodAffinityTerm)
        }</span> else<span class="cov8" title="1"> {
                preferredRepelOtherAffinityAssistantsPodAffinityTerm := corev1.WeightedPodAffinityTerm{
                        Weight:          100,
                        PodAffinityTerm: repelOtherAffinityAssistantsPodAffinityTerm,
                }
                // use RequiredDuringSchedulingIgnoredDuringExecution term to schedule pipelineruns to different nodes when possible
                affinityAssistantsAffinity.PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution = append(affinityAssistantsAffinity.PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution,
                        preferredRepelOtherAffinityAssistantsPodAffinityTerm)
        }</span>

        <span class="cov8" title="1">return affinityAssistantsAffinity</span>
}
</pre>
		
		<pre class="file" id="file438" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        jsonpatch "gomodules.xyz/jsonpatch/v2"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var cancelTaskRunPatchBytes, cancelCustomRunPatchBytes []byte

func init() <span class="cov8" title="1">{
        var err error
        cancelTaskRunPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{
                {
                        Operation: "add",
                        Path:      "/spec/status",
                        Value:     v1.TaskRunSpecStatusCancelled,
                },
                {
                        Operation: "add",
                        Path:      "/spec/statusMessage",
                        Value:     v1.TaskRunCancelledByPipelineMsg,
                }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal TaskRun cancel patch bytes: %v", err)
        }</span>
        <span class="cov8" title="1">cancelCustomRunPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{
                {
                        Operation: "add",
                        Path:      "/spec/status",
                        Value:     v1beta1.CustomRunSpecStatusCancelled,
                },
                {
                        Operation: "add",
                        Path:      "/spec/statusMessage",
                        Value:     v1beta1.CustomRunCancelledByPipelineMsg,
                }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal CustomRun cancel patch bytes: %v", err)
        }</span>
}

func cancelCustomRun(ctx context.Context, runName string, namespace string, clientSet clientset.Interface) error <span class="cov8" title="1">{
        _, err := clientSet.TektonV1beta1().CustomRuns(namespace).Patch(ctx, runName, types.JSONPatchType, cancelCustomRunPatchBytes, metav1.PatchOptions{}, "")
        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                // The resource may have been deleted in the meanwhile, but we should
                // still be able to cancel the PipelineRun
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func cancelTaskRun(ctx context.Context, taskRunName string, namespace string, clientSet clientset.Interface) error <span class="cov8" title="1">{
        _, err := clientSet.TektonV1().TaskRuns(namespace).Patch(ctx, taskRunName, types.JSONPatchType, cancelTaskRunPatchBytes, metav1.PatchOptions{}, "")
        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                // The resource may have been deleted in the meanwhile, but we should
                // still be able to cancel the PipelineRun
                return nil
        }</span>
        <span class="cov8" title="1">if pipelineErrors.IsImmutableTaskRunSpecError(err) </span><span class="cov0" title="0">{
                // The TaskRun may have completed and the spec field is immutable, we should ignore this error.
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

// cancelPipelineRun marks the PipelineRun as cancelled and any resolved TaskRun(s) too.
func cancelPipelineRun(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface) error <span class="cov8" title="1">{
        errs := cancelPipelineTaskRuns(ctx, logger, pr, clientSet)

        // If we successfully cancelled all the TaskRuns and Runs, we can consider the PipelineRun cancelled.
        if len(errs) == 0 </span><span class="cov8" title="1">{
                reason := v1.PipelineRunReasonCancelled

                pr.Status.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionFalse,
                        Reason:  reason.String(),
                        Message: fmt.Sprintf("PipelineRun %q was cancelled", pr.Name),
                })
                // update pr completed time
                pr.Status.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        }</span> else<span class="cov8" title="1"> {
                e := strings.Join(errs, "\n")
                // Indicate that we failed to cancel the PipelineRun
                pr.Status.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionUnknown,
                        Reason:  v1.PipelineRunReasonCouldntCancel.String(),
                        Message: fmt.Sprintf("PipelineRun %q was cancelled but had errors trying to cancel TaskRuns and/or Runs: %s", pr.Name, e),
                })
                return fmt.Errorf("error(s) from cancelling TaskRun(s) from PipelineRun %s: %s", pr.Name, e)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// cancelPipelineTaskRuns patches `TaskRun` and `Run` with canceled status
func cancelPipelineTaskRuns(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface) []string <span class="cov8" title="1">{
        return cancelPipelineTaskRunsForTaskNames(ctx, logger, pr, clientSet, sets.NewString())
}</span>

// cancelPipelineTaskRunsForTaskNames patches `TaskRun`s and `Run`s for the given task names, or all if no task names are given, with canceled status
func cancelPipelineTaskRunsForTaskNames(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface, taskNames sets.String) []string <span class="cov8" title="1">{
        errs := []string{}

        trNames, customRunNames, err := getChildObjectsFromPRStatusForTaskNames(ctx, pr.Status, taskNames)
        if err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err.Error())
        }</span>

        <span class="cov8" title="1">for _, taskRunName := range trNames </span><span class="cov8" title="1">{
                logger.Infof("cancelling TaskRun %s", taskRunName)

                if err := cancelTaskRun(ctx, taskRunName, pr.Namespace, clientSet); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("failed to patch TaskRun `%s` with cancellation: %w", taskRunName, err).Error())
                        continue</span>
                }
        }

        <span class="cov8" title="1">for _, runName := range customRunNames </span><span class="cov8" title="1">{
                logger.Infof("cancelling CustomRun %s", runName)

                if err := cancelCustomRun(ctx, runName, pr.Namespace, clientSet); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to patch CustomRun `%s` with cancellation: %w", runName, err).Error())
                        continue</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

// getChildObjectsFromPRStatusForTaskNames returns taskruns and customruns in the PipelineRunStatus's ChildReferences,
// based on the given set of PipelineTask names. If that set is empty, all are returned.
func getChildObjectsFromPRStatusForTaskNames(ctx context.Context, prs v1.PipelineRunStatus, taskNames sets.String) ([]string, []string, error) <span class="cov8" title="1">{
        var trNames []string
        var customRunNames []string
        unknownChildKinds := make(map[string]string)

        for _, cr := range prs.ChildReferences </span><span class="cov8" title="1">{
                if taskNames.Len() == 0 || taskNames.Has(cr.PipelineTaskName) </span><span class="cov8" title="1">{
                        switch cr.Kind </span>{
                        case taskRun:<span class="cov8" title="1">
                                trNames = append(trNames, cr.Name)</span>
                        case customRun:<span class="cov8" title="1">
                                customRunNames = append(customRunNames, cr.Name)</span>
                        default:<span class="cov8" title="1">
                                unknownChildKinds[cr.Name] = cr.Kind</span>
                        }
                }
        }

        <span class="cov8" title="1">var err error
        if len(unknownChildKinds) &gt; 0 </span><span class="cov8" title="1">{
                err = fmt.Errorf("found child objects of unknown kinds: %v", unknownChildKinds)
        }</span>

        <span class="cov8" title="1">return trNames, customRunNames, err</span>
}

// gracefullyCancelPipelineRun marks any non-final resolved TaskRun(s) as cancelled and runs finally.
func gracefullyCancelPipelineRun(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface) error <span class="cov8" title="1">{
        errs := cancelPipelineTaskRuns(ctx, logger, pr, clientSet)

        // If we successfully cancelled all the TaskRuns and Runs, we can proceed with the PipelineRun reconciliation to trigger finally.
        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                e := strings.Join(errs, "\n")
                // Indicate that we failed to cancel the PipelineRun
                pr.Status.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionUnknown,
                        Reason:  v1.PipelineRunReasonCouldntCancel.String(),
                        Message: fmt.Sprintf("PipelineRun %q was cancelled but had errors trying to cancel TaskRuns and/or Runs: %s", pr.Name, e),
                })
                return fmt.Errorf("error(s) from cancelling TaskRun(s) from PipelineRun %s: %s", pr.Name, e)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file439" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        verificationpolicyinformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy"
        customruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        resolutionclient "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        resolutioninformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        "github.com/tektoncd/pipeline/pkg/pipelinerunmetrics"
        cloudeventclient "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim"
        resolution "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        "github.com/tektoncd/pipeline/pkg/tracing"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        secretinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/secret"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

const (
        // TracerProviderName is the name of TraceProvider
        TracerProviderName = "pipelinerun-reconciler"
)

// NewController instantiates a new controller.Impl from knative.dev/pkg/controller
func NewController(opts *pipeline.Options, clock clock.PassiveClock) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                kubeclientset := kubeclient.Get(ctx)
                pipelineclientset := pipelineclient.Get(ctx)
                taskRunInformer := taskruninformer.Get(ctx)
                customRunInformer := customruninformer.Get(ctx)
                pipelineRunInformer := pipelineruninformer.Get(ctx)
                resolutionInformer := resolutioninformer.Get(ctx)
                verificationpolicyInformer := verificationpolicyinformer.Get(ctx)
                secretinformer := secretinformer.Get(ctx)
                tracerProvider := tracing.New(TracerProviderName, logger.Named("tracing"))
                pipelinerunmetricsRecorder := pipelinerunmetrics.Get(ctx)
                //nolint:contextcheck // OnStore methods does not support context as a parameter
                configStore := config.NewStore(logger.Named("config-store"),
                        pipelinerunmetrics.OnStore(logger, pipelinerunmetricsRecorder),
                        tracerProvider.OnStore(secretinformer.Lister()),
                )
                configStore.WatchConfigs(cmw)

                c := &amp;Reconciler{
                        KubeClientSet:            kubeclientset,
                        PipelineClientSet:        pipelineclientset,
                        Images:                   opts.Images,
                        Clock:                    clock,
                        pipelineRunLister:        pipelineRunInformer.Lister(),
                        taskRunLister:            taskRunInformer.Lister(),
                        customRunLister:          customRunInformer.Lister(),
                        verificationPolicyLister: verificationpolicyInformer.Lister(),
                        cloudEventClient:         cloudeventclient.Get(ctx),
                        metrics:                  pipelinerunmetricsRecorder,
                        pvcHandler:               volumeclaim.NewPVCHandler(kubeclientset, logger),
                        resolutionRequester:      resolution.NewCRDRequester(resolutionclient.Get(ctx), resolutionInformer.Lister()),
                        tracerProvider:           tracerProvider,
                }
                impl := pipelinerunreconciler.NewImpl(ctx, c, func(impl *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        return controller.Options{
                                AgentName:   pipeline.PipelineRunControllerName,
                                ConfigStore: configStore,
                        }
                }</span>)

                <span class="cov8" title="1">if _, err := secretinformer.Informer().AddEventHandler(controller.HandleAll(tracerProvider.Handler)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Secret informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := pipelineRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register PipelineRun informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := taskRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1.PipelineRun{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register TaskRun informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := customRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1.PipelineRun{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register CustomRun informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := resolutionInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1.PipelineRun{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ResolutionRequest informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file440" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "reflect"
        "regexp"
        "strings"
        "time"

        "k8s.io/apimachinery/pkg/util/wait"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        alpha1listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        beta1listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        ctrl "github.com/tektoncd/pipeline/pkg/controller"
        "github.com/tektoncd/pipeline/pkg/internal/affinityassistant"
        resolutionutil "github.com/tektoncd/pipeline/pkg/internal/resolution"
        "github.com/tektoncd/pipeline/pkg/pipelinerunmetrics"
        tknreconciler "github.com/tektoncd/pipeline/pkg/reconciler"
        "github.com/tektoncd/pipeline/pkg/reconciler/apiserver"
        "github.com/tektoncd/pipeline/pkg/reconciler/events"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        rprp "github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/pipelinespec"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/resources"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun"
        tresources "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"
        "github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim"
        "github.com/tektoncd/pipeline/pkg/remote"
        resolution "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        "github.com/tektoncd/pipeline/pkg/workspace"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        k8slabels "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/client-go/kubernetes"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmap"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Aliased for backwards compatibility; do not add additional reasons here
var (
        // ReasonCouldntGetPipeline indicates that the reason for the failure status is that the
        // associated Pipeline couldn't be retrieved
        ReasonCouldntGetPipeline = v1.PipelineRunReasonCouldntGetPipeline.String()
        // ReasonInvalidBindings indicates that the reason for the failure status is that the
        // PipelineResources bound in the PipelineRun didn't match those declared in the Pipeline
        ReasonInvalidBindings = v1.PipelineRunReasonInvalidBindings.String()
        // ReasonInvalidWorkspaceBinding indicates that a Pipeline expects a workspace but a
        // PipelineRun has provided an invalid binding.
        ReasonInvalidWorkspaceBinding = v1.PipelineRunReasonInvalidWorkspaceBinding.String()
        // ReasonInvalidTaskRunSpec indicates that PipelineRun.Spec.TaskRunSpecs[].PipelineTaskName is defined with
        // a not exist taskName in pipelineSpec.
        ReasonInvalidTaskRunSpec = v1.PipelineRunReasonInvalidTaskRunSpec.String()
        // ReasonParameterTypeMismatch indicates that the reason for the failure status is that
        // parameter(s) declared in the PipelineRun do not have the some declared type as the
        // parameters(s) declared in the Pipeline that they are supposed to override.
        ReasonParameterTypeMismatch = v1.PipelineRunReasonParameterTypeMismatch.String()
        // ReasonObjectParameterMissKeys indicates that the object param value provided from PipelineRun spec
        // misses some keys required for the object param declared in Pipeline spec.
        ReasonObjectParameterMissKeys = v1.PipelineRunReasonObjectParameterMissKeys.String()
        // ReasonParamArrayIndexingInvalid indicates that the use of param array indexing is out of bound.
        ReasonParamArrayIndexingInvalid = v1.PipelineRunReasonParamArrayIndexingInvalid.String()
        // ReasonCouldntGetTask indicates that the reason for the failure status is that the
        // associated Pipeline's Tasks couldn't all be retrieved
        ReasonCouldntGetTask = v1.PipelineRunReasonCouldntGetTask.String()
        // ReasonParameterMissing indicates that the reason for the failure status is that the
        // associated PipelineRun didn't provide all the required parameters
        ReasonParameterMissing = v1.PipelineRunReasonParameterMissing.String()
        // ReasonFailedValidation indicates that the reason for failure status is
        // that pipelinerun failed runtime validation
        ReasonFailedValidation = v1.PipelineRunReasonFailedValidation.String()
        // ReasonInvalidGraph indicates that the reason for the failure status is that the
        // associated Pipeline is an invalid graph (a.k.a wrong order, cycle, )
        ReasonInvalidGraph = v1.PipelineRunReasonInvalidGraph.String()
        // ReasonCancelled indicates that a PipelineRun was cancelled.
        ReasonCancelled = v1.PipelineRunReasonCancelled.String()
        // ReasonPending indicates that a PipelineRun is pending.
        ReasonPending = v1.PipelineRunReasonPending.String()
        // ReasonCouldntCancel indicates that a PipelineRun was cancelled but attempting to update
        // all of the running TaskRuns as cancelled failed.
        ReasonCouldntCancel = v1.PipelineRunReasonCouldntCancel.String()
        // ReasonCouldntTimeOut indicates that a PipelineRun was timed out but attempting to update
        // all of the running TaskRuns as timed out failed.
        ReasonCouldntTimeOut = v1.PipelineRunReasonCouldntTimeOut.String()
        // ReasonInvalidMatrixParameterTypes indicates a matrix contains invalid parameter types
        ReasonInvalidMatrixParameterTypes = v1.PipelineRunReasonInvalidMatrixParameterTypes.String()
        // ReasonInvalidTaskResultReference indicates a task result was declared
        // but was not initialized by that task
        ReasonInvalidTaskResultReference = v1.PipelineRunReasonInvalidTaskResultReference.String()
        // ReasonRequiredWorkspaceMarkedOptional indicates an optional workspace
        // has been passed to a Task that is expecting a non-optional workspace
        ReasonRequiredWorkspaceMarkedOptional = v1.PipelineRunReasonRequiredWorkspaceMarkedOptional.String()
        // ReasonResolvingPipelineRef indicates that the PipelineRun is waiting for
        // its pipelineRef to be asynchronously resolved.
        ReasonResolvingPipelineRef = v1.PipelineRunReasonResolvingPipelineRef.String()
        // ReasonResourceVerificationFailed indicates that the pipeline fails the trusted resource verification,
        // it could be the content has changed, signature is invalid or public key is invalid
        ReasonResourceVerificationFailed = v1.PipelineRunReasonResourceVerificationFailed.String()
        // ReasonCreateRunFailed indicates that the pipeline fails to create the taskrun or other run resources
        ReasonCreateRunFailed = v1.PipelineRunReasonCreateRunFailed.String()
)

// constants used as kind descriptors for various types of runs; these constants
// match their corresponding controller names. Given that it's odd to use a
// "ControllerName" const in describing the type of run, we import these
// constants (for consistency) but rename them (for ergonomic semantics).
const (
        taskRun   = pipeline.TaskRunControllerName
        customRun = pipeline.CustomRunControllerName
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        KubeClientSet     kubernetes.Interface
        PipelineClientSet clientset.Interface
        Images            pipeline.Images
        Clock             clock.PassiveClock

        // listers index properties about resources
        pipelineRunLister        listers.PipelineRunLister
        taskRunLister            listers.TaskRunLister
        customRunLister          beta1listers.CustomRunLister
        verificationPolicyLister alpha1listers.VerificationPolicyLister
        cloudEventClient         cloudevent.CEClient
        metrics                  *pipelinerunmetrics.Recorder
        pvcHandler               volumeclaim.PvcHandler
        resolutionRequester      resolution.Requester
        tracerProvider           trace.TracerProvider
}

var (
        // Check that our Reconciler implements pipelinerunreconciler.Interface
        _                              pipelinerunreconciler.Interface = (*Reconciler)(nil)
        filterReservedAnnotationRegexp                                 = regexp.MustCompile(pipeline.TektonReservedAnnotationExpr)
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two. It then updates the Status block of the Pipeline Run
// resource with the current status of the resource.
func (c *Reconciler) ReconcileKind(ctx context.Context, pr *v1.PipelineRun) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        ctx = cloudevent.ToContext(ctx, c.cloudEventClient)
        ctx = initTracing(ctx, c.tracerProvider, pr)
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "PipelineRun:ReconcileKind")
        defer span.End()

        span.SetAttributes(
                attribute.String("pipelinerun", pr.Name), attribute.String("namespace", pr.Namespace),
        )

        // Read the initial condition
        before := pr.Status.GetCondition(apis.ConditionSucceeded)

        // Check if we are failing to mark this as timed out for a while. If we are, mark immediately and finish the
        // reconcile. We are assuming here that if the PipelineRun has timed out for a long time, it had time to run
        // before and it kept failing. One reason that can happen is exceeding etcd request size limit. Finishing it early
        // makes sure the request size is manageable
        if !pr.IsDone() &amp;&amp; pr.HasTimedOutForALongTime(ctx, c.Clock) &amp;&amp; !pr.IsTimeoutConditionSet() </span><span class="cov8" title="1">{
                if err := timeoutPipelineRun(ctx, logger, pr, c.PipelineClientSet); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := c.finishReconcileUpdateEmitEvents(ctx, pr, before, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return controller.NewPermanentError(errors.New("PipelineRun has timed out for a long time"))</span>
        }

        <span class="cov8" title="1">if !pr.HasStarted() &amp;&amp; !pr.IsPending() </span><span class="cov8" title="1">{
                pr.Status.InitializeConditions(c.Clock)
                // In case node time was not synchronized, when controller has been scheduled to other nodes.
                if pr.Status.StartTime.Sub(pr.CreationTimestamp.Time) &lt; 0 </span><span class="cov0" title="0">{
                        logger.Warnf("PipelineRun %s createTimestamp %s is after the pipelineRun started %s", pr.GetNamespacedName().String(), pr.CreationTimestamp, pr.Status.StartTime)
                        pr.Status.StartTime = &amp;pr.CreationTimestamp
                }</span>

                // Emit events. During the first reconcile the status of the PipelineRun may change twice
                // from not Started to Started and then to Running, so we need to sent the event here
                // and at the end of 'Reconcile' again.
                // We also want to send the "Started" event as soon as possible for anyone who may be waiting
                // on the event to perform user facing initialisations, such has reset a CI check status
                <span class="cov8" title="1">afterCondition := pr.Status.GetCondition(apis.ConditionSucceeded)
                events.Emit(ctx, nil, afterCondition, pr)

                // We already sent an event for start, so update `before` with the current status
                before = pr.Status.GetCondition(apis.ConditionSucceeded)</span>
        }

        // list VerificationPolicies for trusted resources
        <span class="cov8" title="1">vp, err := c.verificationPolicyLister.VerificationPolicies(pr.Namespace).List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list VerificationPolicies from namespace %s with error %w", pr.Namespace, err)
        }</span>
        <span class="cov8" title="1">getPipelineFunc := resources.GetPipelineFunc(ctx, c.KubeClientSet, c.PipelineClientSet, c.resolutionRequester, pr, vp)

        if pr.IsDone() </span><span class="cov8" title="1">{
                pr.SetDefaults(ctx)
                err := c.cleanupAffinityAssistantsAndPVCs(ctx, pr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to delete StatefulSet or PVC for PipelineRun %s: %v", pr.Name, err)
                }</span>
                <span class="cov8" title="1">return c.finishReconcileUpdateEmitEvents(ctx, pr, before, err)</span>
        }

        <span class="cov8" title="1">if err := propagatePipelineNameLabelToPipelineRun(pr); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to propagate pipeline name label to pipelinerun %s: %v", pr.Name, err)
                return c.finishReconcileUpdateEmitEvents(ctx, pr, before, err)
        }</span>

        // If the pipelinerun is cancelled, cancel tasks and update status
        <span class="cov8" title="1">if pr.IsCancelled() </span><span class="cov8" title="1">{
                err := cancelPipelineRun(ctx, logger, pr, c.PipelineClientSet)
                return c.finishReconcileUpdateEmitEvents(ctx, pr, before, err)
        }</span>

        // Make sure that the PipelineRun status is in sync with the actual TaskRuns
        <span class="cov8" title="1">err = c.updatePipelineRunStatusFromInformer(ctx, pr)
        if err != nil </span><span class="cov0" title="0">{
                // This should not fail. Return the error so we can re-try later.
                logger.Errorf("Error while syncing the pipelinerun status: %v", err.Error())
                return c.finishReconcileUpdateEmitEvents(ctx, pr, before, err)
        }</span>

        // Reconcile this copy of the pipelinerun and then write back any status or label
        // updates regardless of whether the reconciliation errored out.
        <span class="cov8" title="1">if err = c.reconcile(ctx, pr, getPipelineFunc, before); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Reconcile error: %v", err.Error())
        }</span>

        <span class="cov8" title="1">if err = c.finishReconcileUpdateEmitEvents(ctx, pr, before, err); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if pr.Status.StartTime != nil </span><span class="cov8" title="1">{
                // Compute the time since the task started.
                elapsed := c.Clock.Since(pr.Status.StartTime.Time)
                // Snooze this resource until the appropriate timeout has elapsed.
                // but if the timeout has been disabled by setting timeout to 0, we
                // do not want to subtract from 0, because a negative wait time will
                // result in the requeue happening essentially immediately
                timeout := pr.PipelineTimeout(ctx)
                taskTimeout := pr.TasksTimeout()
                waitTime := timeout - elapsed
                if timeout == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        waitTime = time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes) * time.Minute
                }</span>
                <span class="cov8" title="1">if pr.Status.FinallyStartTime == nil &amp;&amp; taskTimeout != nil </span><span class="cov8" title="1">{
                        waitTime = pr.TasksTimeout().Duration - elapsed
                        if taskTimeout.Duration == config.NoTimeoutDuration </span><span class="cov0" title="0">{
                                waitTime = time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes) * time.Minute
                        }</span>
                } else<span class="cov8" title="1"> if pr.Status.FinallyStartTime != nil &amp;&amp; pr.FinallyTimeout() != nil &amp;&amp;
                        pr.FinallyTimeout().Duration != config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        finallyWaitTime := pr.FinallyTimeout().Duration - c.Clock.Since(pr.Status.FinallyStartTime.Time)
                        if finallyWaitTime &lt; waitTime </span><span class="cov0" title="0">{
                                waitTime = finallyWaitTime
                        }</span>
                }
                <span class="cov8" title="1">return controller.NewRequeueAfter(waitTime)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *Reconciler) durationAndCountMetrics(ctx context.Context, pr *v1.PipelineRun, beforeCondition *apis.Condition) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "durationAndCountMetrics")
        defer span.End()
        logger := logging.FromContext(ctx)
        if pr.IsDone() </span><span class="cov8" title="1">{
                err := c.metrics.DurationAndCount(pr, beforeCondition)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to log the metrics : %v", err)
                }</span>
        }
}

func (c *Reconciler) finishReconcileUpdateEmitEvents(ctx context.Context, pr *v1.PipelineRun, beforeCondition *apis.Condition, previousError error) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "finishReconcileUpdateEmitEvents")
        defer span.End()
        logger := logging.FromContext(ctx)

        afterCondition := pr.Status.GetCondition(apis.ConditionSucceeded)
        events.Emit(ctx, beforeCondition, afterCondition, pr)
        _, err := c.updateLabelsAndAnnotations(ctx, pr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to update PipelineRun labels/annotations", zap.Error(err))
                events.EmitError(controller.GetEventRecorder(ctx), err, pr)
        }</span>

        <span class="cov8" title="1">errs := errors.Join(previousError, err)
        if controller.IsPermanentError(previousError) </span><span class="cov8" title="1">{
                return controller.NewPermanentError(errs)
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// resolvePipelineState will attempt to resolve each referenced pipeline task in the pipeline's spec and all of the resources
// specified by those tasks.
func (c *Reconciler) resolvePipelineState(
        ctx context.Context,
        pipelineTasks []v1.PipelineTask,
        pipelineMeta *metav1.ObjectMeta,
        pr *v1.PipelineRun,
        pst resources.PipelineRunState,
) (resources.PipelineRunState, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "resolvePipelineState")
        defer span.End()
        // Resolve each pipeline task individually because they each could have a different reference context (remote or local).
        for _, pipelineTask := range pipelineTasks </span><span class="cov8" title="1">{
                // We need the TaskRun name to ensure that we don't perform an additional remote resolution request for a PipelineTask
                // in the TaskRun reconciler.
                trName := resources.GetTaskRunName(
                        pr.Status.ChildReferences,
                        pipelineTask.Name,
                        pr.Name,
                )

                // list VerificationPolicies for trusted resources
                vp, err := c.verificationPolicyLister.VerificationPolicies(pr.Namespace).List(labels.Everything())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list VerificationPolicies from namespace %s with error %w", pr.Namespace, err)
                }</span>

                <span class="cov8" title="1">getTaskFunc := tresources.GetTaskFunc(
                        ctx,
                        c.KubeClientSet,
                        c.PipelineClientSet,
                        c.resolutionRequester,
                        pr,
                        pipelineTask.TaskRef,
                        trName,
                        pr.Namespace,
                        pr.Spec.TaskRunTemplate.ServiceAccountName,
                        vp,
                )

                getTaskRunFunc := func(name string) (*v1.TaskRun, error) </span><span class="cov8" title="1">{
                        return c.taskRunLister.TaskRuns(pr.Namespace).Get(name)
                }</span>

                <span class="cov8" title="1">getCustomRunFunc := func(name string) (*v1beta1.CustomRun, error) </span><span class="cov8" title="1">{
                        r, err := c.customRunLister.CustomRuns(pr.Namespace).Get(name)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return r, nil</span>
                }

                <span class="cov8" title="1">resolvedTask, err := resources.ResolvePipelineTask(ctx,
                        *pr,
                        getTaskFunc,
                        getTaskRunFunc,
                        getCustomRunFunc,
                        pipelineTask,
                        pst,
                )
                if err != nil </span><span class="cov8" title="1">{
                        if resolutioncommon.IsErrTransient(err) </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if errors.Is(err, remote.ErrRequestInProgress) </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">var nfErr *resources.TaskNotFoundError
                        if errors.As(err, &amp;nfErr) </span><span class="cov8" title="1">{
                                pr.Status.MarkFailed(v1.PipelineRunReasonCouldntGetTask.String(),
                                        "Pipeline %s/%s can't be Run; it contains Tasks that don't exist: %s",
                                        pipelineMeta.Namespace, pipelineMeta.Name, nfErr)
                        }</span> else<span class="cov8" title="1"> {
                                pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                                        "PipelineRun %s/%s can't be Run; couldn't resolve all references: %s",
                                        pipelineMeta.Namespace, pr.Name, pipelineErrors.WrapUserError(err))
                        }</span>
                        <span class="cov8" title="1">return nil, controller.NewPermanentError(err)</span>
                }

                <span class="cov8" title="1">if resolvedTask.ResolvedTask != nil &amp;&amp; resolvedTask.ResolvedTask.VerificationResult != nil </span><span class="cov8" title="1">{
                        cond, err := conditionFromVerificationResult(resolvedTask.ResolvedTask.VerificationResult, pr, pipelineTask.Name)
                        pr.Status.SetCondition(cond)
                        if err != nil </span><span class="cov8" title="1">{
                                pr.Status.MarkFailed(v1.PipelineRunReasonResourceVerificationFailed.String(), err.Error())
                                return nil, controller.NewPermanentError(err)
                        }</span>
                }
                <span class="cov8" title="1">pst = append(pst, resolvedTask)</span>
        }

        <span class="cov8" title="1">return pst, nil</span>
}

func (c *Reconciler) reconcile(ctx context.Context, pr *v1.PipelineRun, getPipelineFunc rprp.GetPipeline, beforeCondition *apis.Condition) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "reconcile")
        defer span.End()
        defer c.durationAndCountMetrics(ctx, pr, beforeCondition)
        logger := logging.FromContext(ctx)
        pr.SetDefaults(ctx)

        // When pipeline run is pending, return to avoid creating the task
        if pr.IsPending() </span><span class="cov8" title="1">{
                pr.Status.MarkRunning(v1.PipelineRunReasonPending.String(), fmt.Sprintf("PipelineRun %q is pending", pr.Name))
                return nil
        }</span>

        <span class="cov8" title="1">pipelineMeta, pipelineSpec, err := rprp.GetPipelineData(ctx, pr, getPipelineFunc)
        switch </span>{
        case errors.Is(err, remote.ErrRequestInProgress):<span class="cov8" title="1">
                message := fmt.Sprintf("PipelineRun %s/%s awaiting remote resource", pr.Namespace, pr.Name)
                pr.Status.MarkRunning(v1.PipelineRunReasonResolvingPipelineRef.String(), message)
                return nil</span>
        case errors.Is(err, apiserver.ErrReferencedObjectValidationFailed), errors.Is(err, apiserver.ErrCouldntValidateObjectPermanent):<span class="cov8" title="1">
                logger.Errorf("Failed dryRunValidation for PipelineRun %s: %w", pr.Name, err)
                pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                        "Failed dryRunValidation for PipelineRun %s: %s",
                        pr.Name, pipelineErrors.WrapUserError(err))
                return controller.NewPermanentError(err)</span>
        case errors.Is(err, apiserver.ErrCouldntValidateObjectRetryable):<span class="cov8" title="1">
                return err</span>
        case err != nil:<span class="cov8" title="1">
                logger.Errorf("Failed to determine Pipeline spec to use for pipelinerun %s: %v", pr.Name, err)
                pr.Status.MarkFailed(v1.PipelineRunReasonCouldntGetPipeline.String(),
                        "Error retrieving pipeline for pipelinerun %s/%s: %s",
                        pr.Namespace, pr.Name, err)
                return controller.NewPermanentError(err)</span>
        default:<span class="cov8" title="1">
                // Store the fetched PipelineSpec on the PipelineRun for auditing
                if err := storePipelineSpecAndMergeMeta(ctx, pr, pipelineSpec, pipelineMeta); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store PipelineSpec on PipelineRun.Status for pipelinerun %s: %v", pr.Name, err)
                }</span>
        }

        <span class="cov8" title="1">if pipelineMeta.VerificationResult != nil </span><span class="cov8" title="1">{
                cond, err := conditionFromVerificationResult(pipelineMeta.VerificationResult, pr, pipelineMeta.Name)
                pr.Status.SetCondition(cond)
                if err != nil </span><span class="cov8" title="1">{
                        pr.Status.MarkFailed(v1.PipelineRunReasonResourceVerificationFailed.String(), err.Error())
                        return controller.NewPermanentError(err)
                }</span>
        }

        <span class="cov8" title="1">d, err := dag.Build(v1.PipelineTaskList(pipelineSpec.Tasks), v1.PipelineTaskList(pipelineSpec.Tasks).Deps())
        if err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidGraph.String(),
                        "PipelineRun %s/%s's Pipeline DAG is invalid: %s",
                        pr.Namespace, pr.Name, pipelineErrors.WrapUserError(err))
                return controller.NewPermanentError(err)
        }</span>

        // build DAG with a list of final tasks, this DAG is used later to identify
        // if a task in PipelineRunState is final task or not
        // the finally section is optional and might not exist
        // dfinally holds an empty Graph in the absence of finally clause
        <span class="cov8" title="1">dfinally, err := dag.Build(v1.PipelineTaskList(pipelineSpec.Finally), map[string][]string{})
        if err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidGraph.String(),
                        "PipelineRun %s/%s's Pipeline DAG is invalid for finally clause: %s",
                        pr.Namespace, pr.Name, pipelineErrors.WrapUserError(err))
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if err := pipelineSpec.Validate(ctx); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                        "Pipeline %s/%s can't be Run; it has an invalid spec: %s",
                        pipelineMeta.Namespace, pipelineMeta.Name, pipelineErrors.WrapUserError(err))
                return controller.NewPermanentError(err)
        }</span>

        // Ensure that the PipelineRun provides all the parameters required by the Pipeline
        <span class="cov8" title="1">if err := resources.ValidateRequiredParametersProvided(&amp;pipelineSpec.Params, &amp;pr.Spec.Params); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonParameterMissing.String(),
                        "PipelineRun %s/%s is missing some parameters required by Pipeline %s/%s: %s",
                        pr.Namespace, pr.Name, pr.Namespace, pipelineMeta.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        // Ensure that the parameters from the PipelineRun are overriding Pipeline parameters with the same type.
        // Weird substitution issues can occur if this is not validated (ApplyParameters() does not verify type).
        <span class="cov8" title="1">if err = resources.ValidateParamTypesMatching(pipelineSpec, pr); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonParameterTypeMismatch.String(),
                        "PipelineRun %s/%s parameters have mismatching types with Pipeline %s/%s's parameters: %s",
                        pr.Namespace, pr.Name, pr.Namespace, pipelineMeta.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                if err := taskrun.ValidateEnumParam(ctx, pr.Spec.Params, pipelineSpec.Params); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("PipelineRun %q Param Enum validation failed: %v", pr.Name, err)
                        pr.Status.MarkFailed(v1.PipelineRunReasonInvalidParamValue.String(),
                                "PipelineRun %s/%s parameters have invalid value: %s",
                                pr.Namespace, pr.Name, pipelineErrors.WrapUserError(err))
                        return controller.NewPermanentError(err)
                }</span>
        }

        // Ensure that the keys of an object param declared in PipelineSpec are not missed in the PipelineRunSpec
        <span class="cov8" title="1">if err = resources.ValidateObjectParamRequiredKeys(pipelineSpec.Params, pr.Spec.Params); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonObjectParameterMissKeys.String(),
                        "PipelineRun %s/%s parameters is missing object keys required by Pipeline %s/%s's parameters: %s",
                        pr.Namespace, pr.Name, pr.Namespace, pipelineMeta.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        // Ensure that the array reference is not out of bound
        <span class="cov8" title="1">if err := resources.ValidateParamArrayIndex(pipelineSpec, pr.Spec.Params); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonParamArrayIndexingInvalid.String(),
                        "PipelineRun %s/%s failed validation: failed to validate Pipeline %s/%s's parameter which has an invalid index while referring to an array: %s",
                        pr.Namespace, pr.Name, pr.Namespace, pipelineMeta.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        // Ensure that the workspaces expected by the Pipeline are provided by the PipelineRun.
        <span class="cov8" title="1">if err := resources.ValidateWorkspaceBindings(pipelineSpec, pr); err != nil </span><span class="cov0" title="0">{
                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidWorkspaceBinding.String(),
                        "PipelineRun %s/%s doesn't bind Pipeline %s/%s's Workspaces correctly: %s",
                        pr.Namespace, pr.Name, pr.Namespace, pipelineMeta.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        // Ensure that the TaskRunSpecs defined are correct.
        <span class="cov8" title="1">if err := resources.ValidateTaskRunSpecs(pipelineSpec, pr); err != nil </span><span class="cov8" title="1">{
                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidTaskRunSpec.String(),
                        "PipelineRun %s/%s doesn't define taskRunSpecs correctly: %s",
                        pr.Namespace, pr.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">resources.ApplyParametersToWorkspaceBindings(ctx, pr)
        // Make a deep copy of the Pipeline and its Tasks before value substitution.
        // This is used to find referenced pipeline-level params at each PipelineTask when validate param enum subset requirement
        originalPipeline := pipelineSpec.DeepCopy()
        originalTasks := originalPipeline.Tasks
        originalTasks = append(originalTasks, originalPipeline.Finally...)

        // Apply parameter substitution from the PipelineRun
        pipelineSpec = resources.ApplyParameters(ctx, pipelineSpec, pr)
        pipelineSpec = resources.ApplyContexts(pipelineSpec, pipelineMeta.Name, pr)
        pipelineSpec = resources.ApplyWorkspaces(pipelineSpec, pr)
        // Update pipelinespec of pipelinerun's status field
        pr.Status.PipelineSpec = pipelineSpec

        // validate pipelineSpec after apply parameters
        if err := validatePipelineSpecAfterApplyParameters(ctx, pipelineSpec); err != nil </span><span class="cov8" title="1">{
                // This Run has failed, so we need to mark it as failed and stop reconciling it
                pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                        "Pipeline %s/%s can't be Run; it has an invalid spec: %s",
                        pipelineMeta.Namespace, pipelineMeta.Name, pipelineErrors.WrapUserError(err))
                return controller.NewPermanentError(err)
        }</span>

        // pipelineRunState holds a list of pipeline tasks after fetching their resolved Task specs.
        // pipelineRunState also holds a taskRun for each pipeline task after the taskRun is created
        // pipelineRunState is instantiated and updated on every reconcile cycle
        // Resolve the set of tasks (and possibly task runs).
        <span class="cov8" title="1">tasks := pipelineSpec.Tasks
        if len(pipelineSpec.Finally) &gt; 0 </span><span class="cov8" title="1">{
                tasks = append(tasks, pipelineSpec.Finally...)
        }</span>

        // We split tasks in two lists:
        // - those with a completed (Task|Custom)Run reference (i.e. those that finished running)
        // - those without a (Task|Custom)Run reference
        // We resolve the status for the former first, to collect all results available at this stage
        // We know that tasks in progress or completed have had their fan-out already calculated so
        // they can be safely processed in the first iteration. The underlying assumption is that if
        // a PipelineTask has at least one TaskRun associated, then all its TaskRuns have been
        // created already.
        // The second group takes as input the partial state built in the first iteration and finally
        // the two results are collated
        <span class="cov8" title="1">ranOrRunningTaskNames := sets.Set[string]{}
        ranOrRunningTasks := []v1.PipelineTask{}
        notStartedTasks := []v1.PipelineTask{}

        for _, child := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                ranOrRunningTaskNames.Insert(child.PipelineTaskName)
        }</span>
        <span class="cov8" title="1">for _, task := range tasks </span><span class="cov8" title="1">{
                if ranOrRunningTaskNames.Has(task.Name) </span><span class="cov8" title="1">{
                        ranOrRunningTasks = append(ranOrRunningTasks, task)
                }</span> else<span class="cov8" title="1"> {
                        notStartedTasks = append(notStartedTasks, task)
                }</span>
        }

        // First iteration
        <span class="cov8" title="1">pipelineRunState, err := c.resolvePipelineState(ctx, ranOrRunningTasks, pipelineMeta.ObjectMeta, pr, resources.PipelineRunState{})
        switch </span>{
        case errors.Is(err, remote.ErrRequestInProgress):<span class="cov0" title="0">
                message := fmt.Sprintf("PipelineRun %s/%s awaiting remote resource", pr.Namespace, pr.Name)
                pr.Status.MarkRunning(v1.TaskRunReasonResolvingTaskRef, message)
                return nil</span>
        case err != nil:<span class="cov8" title="1">
                return err</span>
        default:<span class="cov8" title="1"></span>
        }

        // Second iteration
        <span class="cov8" title="1">pipelineRunState, err = c.resolvePipelineState(ctx, notStartedTasks, pipelineMeta.ObjectMeta, pr, pipelineRunState)
        switch </span>{
        case errors.Is(err, remote.ErrRequestInProgress):<span class="cov8" title="1">
                message := fmt.Sprintf("PipelineRun %s/%s awaiting remote resource", pr.Namespace, pr.Name)
                pr.Status.MarkRunning(v1.TaskRunReasonResolvingTaskRef, message)
                return nil</span>
        case err != nil:<span class="cov8" title="1">
                return err</span>
        default:<span class="cov8" title="1"></span>
        }

        // Build PipelineRunFacts with a list of resolved pipeline tasks,
        // dag tasks graph and final tasks graph
        <span class="cov8" title="1">pipelineRunFacts := &amp;resources.PipelineRunFacts{
                State:           pipelineRunState,
                SpecStatus:      pr.Spec.Status,
                TasksGraph:      d,
                FinalTasksGraph: dfinally,
                TimeoutsState: resources.PipelineRunTimeoutsState{
                        Clock: c.Clock,
                },
        }
        if pr.Status.StartTime != nil </span><span class="cov8" title="1">{
                pipelineRunFacts.TimeoutsState.StartTime = &amp;pr.Status.StartTime.Time
        }</span>
        <span class="cov8" title="1">if pr.Status.FinallyStartTime != nil </span><span class="cov8" title="1">{
                pipelineRunFacts.TimeoutsState.FinallyStartTime = &amp;pr.Status.FinallyStartTime.Time
        }</span>
        <span class="cov8" title="1">tasksTimeout := pr.TasksTimeout()
        if tasksTimeout != nil </span><span class="cov8" title="1">{
                pipelineRunFacts.TimeoutsState.TasksTimeout = &amp;tasksTimeout.Duration
        }</span>
        <span class="cov8" title="1">finallyTimeout := pr.FinallyTimeout()
        if finallyTimeout != nil </span><span class="cov8" title="1">{
                pipelineRunFacts.TimeoutsState.FinallyTimeout = &amp;finallyTimeout.Duration
        }</span>
        <span class="cov8" title="1">if pipelineTimeout := pr.PipelineTimeout(ctx); pipelineTimeout != 0 </span><span class="cov8" title="1">{
                pipelineRunFacts.TimeoutsState.PipelineTimeout = &amp;pipelineTimeout
        }</span>

        <span class="cov8" title="1">for i, rpt := range pipelineRunFacts.State </span><span class="cov8" title="1">{
                if !rpt.IsCustomTask() </span><span class="cov8" title="1">{
                        err := taskrun.ValidateResolvedTask(ctx, rpt.PipelineTask.Params, rpt.PipelineTask.Matrix, rpt.ResolvedTask)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to validate pipelinerun %s with error %w", pr.Name, err)
                                pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                                        "Validation failed for pipelinerun %s with error %s",
                                        pr.Name, pipelineErrors.WrapUserError(err))
                                return controller.NewPermanentError(err)
                        }</span>

                        <span class="cov8" title="1">if config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                                if err := resources.ValidateParamEnumSubset(originalTasks[i].Params, pipelineSpec.Params, rpt.ResolvedTask); err != nil </span><span class="cov8" title="1">{
                                        logger.Errorf("Failed to validate pipelinerun %q with error %w", pr.Name, err)
                                        pr.Status.MarkFailed(v1.PipelineRunReasonFailedValidation.String(),
                                                "Validation failed for pipelinerun with error %s",
                                                pipelineErrors.WrapUserError(err))
                                        return controller.NewPermanentError(err)
                                }</span>
                        }
                }
        }

        // Evaluate the CEL of PipelineTask after the variable substitutions and validations.
        <span class="cov8" title="1">for _, rpt := range pipelineRunFacts.State </span><span class="cov8" title="1">{
                err := rpt.EvaluateCEL()
                if err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Error evaluating CEL %s: %v", pr.Name, err)
                        pr.Status.MarkFailed(string(v1.PipelineRunReasonCELEvaluationFailed),
                                "Error evaluating CEL %s: %w", pr.Name, pipelineErrors.WrapUserError(err))
                        return controller.NewPermanentError(err)
                }</span>
        }

        // check if pipeline run is gracefully cancelled and there are active pipeline task runs, which require cancelling
        <span class="cov8" title="1">if pr.IsGracefullyCancelled() &amp;&amp; pipelineRunFacts.IsRunning() </span><span class="cov8" title="1">{
                // If the pipelinerun is cancelled, cancel tasks, but run finally
                err := gracefullyCancelPipelineRun(ctx, logger, pr, c.PipelineClientSet)
                if err != nil </span><span class="cov8" title="1">{
                        // failed to cancel tasks, maybe retry would help (don't return permanent error)
                        return err
                }</span>
        }

        <span class="cov8" title="1">if pipelineRunFacts.State.IsBeforeFirstTaskRun() </span><span class="cov8" title="1">{
                if err := resources.ValidatePipelineTaskResults(pipelineRunFacts.State); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to resolve task result reference for %q with error %v", pr.Name, err)
                        pr.Status.MarkFailed(v1.PipelineRunReasonInvalidTaskResultReference.String(), err.Error())
                        return controller.NewPermanentError(err)
                }</span>

                <span class="cov8" title="1">if err := resources.ValidatePipelineResults(pipelineSpec, pipelineRunFacts.State); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to resolve pipeline result reference for %q with error %w", pr.Name, err)
                        pr.Status.MarkFailed(v1.PipelineRunReasonInvalidPipelineResultReference.String(),
                                "Failed to resolve pipeline result reference for %q with error %w",
                                pr.Name, err)
                        return controller.NewPermanentError(err)
                }</span>

                <span class="cov8" title="1">if err := resources.ValidateOptionalWorkspaces(pipelineSpec.Workspaces, pipelineRunFacts.State); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Optional workspace not supported by task: %w", err)
                        pr.Status.MarkFailed(v1.PipelineRunReasonRequiredWorkspaceMarkedOptional.String(),
                                "Optional workspace not supported by task: %w", pipelineErrors.WrapUserError(err))
                        return controller.NewPermanentError(err)
                }</span>

                <span class="cov8" title="1">aaBehavior, err := affinityassistant.GetAffinityAssistantBehavior(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.NewPermanentError(err)
                }</span>
                <span class="cov8" title="1">if err := c.createOrUpdateAffinityAssistantsAndPVCs(ctx, pr, aaBehavior); err != nil </span><span class="cov8" title="1">{
                        switch </span>{
                        case errors.Is(err, volumeclaim.ErrPvcCreationFailed):<span class="cov8" title="1">
                                logger.Errorf("Failed to create PVC for PipelineRun %s: %v", pr.Name, err)
                                pr.Status.MarkFailed(volumeclaim.ReasonCouldntCreateWorkspacePVC,
                                        "Failed to create PVC for PipelineRun %s/%s correctly: %s",
                                        pr.Namespace, pr.Name, err)</span>
                        case errors.Is(err, volumeclaim.ErrPvcCreationFailedRetryable):<span class="cov0" title="0">
                                logger.Errorf("Failed to create PVC for PipelineRun %s: %v", pr.Name, err)
                                pr.Status.MarkRunning(ReasonPending, "Waiting for PVC creation to succeed: %v", err)
                                return err</span> // not a permanent error, will requeue
                        case errors.Is(err, ErrAffinityAssistantCreationFailed):<span class="cov8" title="1">
                                logger.Errorf("Failed to create affinity assistant StatefulSet for PipelineRun %s: %v", pr.Name, err)
                                pr.Status.MarkFailed(ReasonCouldntCreateOrUpdateAffinityAssistantStatefulSet,
                                        "Failed to create StatefulSet for PipelineRun %s/%s correctly: %s",
                                        pr.Namespace, pr.Name, err)</span>
                        default:<span class="cov0" title="0">
                                logger.Errorf("default error handling for PipelineRun %s: %v", pr.Name, err)</span>
                        }
                        <span class="cov8" title="1">return controller.NewPermanentError(err)</span>
                }
        }

        <span class="cov8" title="1">if pr.Status.FinallyStartTime == nil </span><span class="cov8" title="1">{
                if pr.HaveTasksTimedOut(ctx, c.Clock) </span><span class="cov8" title="1">{
                        tasksToTimeOut := sets.NewString()
                        for _, pt := range pipelineRunFacts.State </span><span class="cov8" title="1">{
                                if !pt.IsFinalTask(pipelineRunFacts) &amp;&amp; pt.IsRunning() </span><span class="cov8" title="1">{
                                        tasksToTimeOut.Insert(pt.PipelineTask.Name)
                                }</span>
                        }
                        <span class="cov8" title="1">if tasksToTimeOut.Len() &gt; 0 </span><span class="cov8" title="1">{
                                logger.Debugf("PipelineRun tasks timeout of %s reached, cancelling tasks", tasksTimeout)
                                errs := timeoutPipelineTasksForTaskNames(ctx, logger, pr, c.PipelineClientSet, tasksToTimeOut)
                                if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                        errString := strings.Join(errs, "\n")
                                        logger.Errorf("Failed to timeout tasks for PipelineRun %s/%s: %s", pr.Namespace, pr.Name, errString)
                                        return fmt.Errorf("error(s) from cancelling TaskRun(s) from PipelineRun %s: %s", pr.Name, errString)
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> if pr.HasFinallyTimedOut(ctx, c.Clock) </span><span class="cov8" title="1">{
                tasksToTimeOut := sets.NewString()
                for _, pt := range pipelineRunFacts.State </span><span class="cov8" title="1">{
                        if pt.IsFinalTask(pipelineRunFacts) &amp;&amp; pt.IsRunning() </span><span class="cov8" title="1">{
                                tasksToTimeOut.Insert(pt.PipelineTask.Name)
                        }</span>
                }
                <span class="cov8" title="1">if tasksToTimeOut.Len() &gt; 0 </span><span class="cov8" title="1">{
                        logger.Debugf("PipelineRun finally timeout of %s reached, cancelling finally tasks", finallyTimeout)
                        errs := timeoutPipelineTasksForTaskNames(ctx, logger, pr, c.PipelineClientSet, tasksToTimeOut)
                        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                errString := strings.Join(errs, "\n")
                                logger.Errorf("Failed to timeout finally tasks for PipelineRun %s/%s: %s", pr.Namespace, pr.Name, errString)
                                return fmt.Errorf("error(s) from cancelling TaskRun(s) from PipelineRun %s: %s", pr.Name, errString)
                        }</span>
                }
        }

        <span class="cov8" title="1">if err := c.runNextSchedulableTask(ctx, pr, pipelineRunFacts); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Reset the skipped status to trigger recalculation
        <span class="cov8" title="1">pipelineRunFacts.ResetSkippedCache()

        // If the pipelinerun has timed out, mark tasks as timed out and update status
        if pr.HasTimedOut(ctx, c.Clock) </span><span class="cov8" title="1">{
                if err := timeoutPipelineRun(ctx, logger, pr, c.PipelineClientSet); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">after := pipelineRunFacts.GetPipelineConditionStatus(ctx, pr, logger, c.Clock)
        switch after.Status </span>{
        case corev1.ConditionTrue:<span class="cov8" title="1">
                pr.Status.MarkSucceeded(after.Reason, after.Message)</span>
        case corev1.ConditionFalse:<span class="cov8" title="1">
                pr.Status.MarkFailed(after.Reason, after.Message)</span>
        case corev1.ConditionUnknown:<span class="cov8" title="1">
                pr.Status.MarkRunning(after.Reason, after.Message)</span>
        }
        // Read the condition the way it was set by the Mark* helpers
        <span class="cov8" title="1">after = pr.Status.GetCondition(apis.ConditionSucceeded)
        pr.Status.StartTime = pipelineRunFacts.State.AdjustStartTime(pr.Status.StartTime)

        pr.Status.ChildReferences = pipelineRunFacts.GetChildReferences()

        pr.Status.SkippedTasks = pipelineRunFacts.GetSkippedTasks()
        pipelineTaskStatus := pipelineRunFacts.GetPipelineTaskStatus()
        finalPipelineTaskStatus := pipelineRunFacts.GetPipelineFinalTaskStatus()
        pipelineTaskStatus = kmap.Union(pipelineTaskStatus, finalPipelineTaskStatus)

        if after.Status == corev1.ConditionTrue || after.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                pr.Status.Results, err = resources.ApplyTaskResultsToPipelineResults(
                        ctx,
                        pipelineSpec.Results,
                        pipelineRunFacts.State.GetTaskRunsResults(),
                        pipelineRunFacts.State.GetRunsResults(),
                        pipelineTaskStatus,
                )
                if err != nil </span><span class="cov0" title="0">{
                        pr.Status.MarkFailed(v1.PipelineRunReasonCouldntGetPipelineResult.String(),
                                "Failed to get PipelineResult from TaskRun Results for PipelineRun %s: %s",
                                pr.Name, err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">logger.Infof("PipelineRun %s status is being set to %s", pr.Name, after)
        return nil</span>
}

// runNextSchedulableTask gets the next schedulable Tasks from the dag based on the current
// pipeline run state, and starts them
// after all DAG tasks are done, it's responsible for scheduling final tasks and start executing them
func (c *Reconciler) runNextSchedulableTask(ctx context.Context, pr *v1.PipelineRun, pipelineRunFacts *resources.PipelineRunFacts) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "runNextSchedulableTask")
        defer span.End()

        logger := logging.FromContext(ctx)
        recorder := controller.GetEventRecorder(ctx)

        // nextRpts holds a list of pipeline tasks which should be executed next
        nextRpts, err := pipelineRunFacts.DAGExecutionQueue()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting potential next tasks for valid pipelinerun %s: %v", pr.Name, err)
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">for _, rpt := range nextRpts </span><span class="cov8" title="1">{
                // Check for Missing Result References
                // if error found, present rpt will be
                // added to the validationFailedTask list
                err := resources.CheckMissingResultReferences(pipelineRunFacts.State, rpt)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Infof("Failed to resolve task result reference for %q with error %v", pr.Name, err)
                        // If there is an error encountered, no new task
                        // will be scheduled, hence nextRpts should be empty
                        // If finally tasks are found, then those tasks will
                        // be added to the nextRpts
                        nextRpts = nil
                        logger.Infof("Adding the task %q to the validation failed list", rpt.ResolvedTask)
                        pipelineRunFacts.ValidationFailedTask = append(pipelineRunFacts.ValidationFailedTask, rpt)
                }</span>
        }
        // GetFinalTasks only returns final tasks when a DAG is complete
        <span class="cov8" title="1">fNextRpts := pipelineRunFacts.GetFinalTasks()
        if len(fNextRpts) != 0 </span><span class="cov8" title="1">{
                // apply the runtime context just before creating taskRuns for final tasks in queue
                resources.ApplyPipelineTaskStateContext(fNextRpts, pipelineRunFacts.GetPipelineTaskStatus())

                // Before creating TaskRun for scheduled final task, check if it's consuming a task result
                // Resolve and apply task result wherever applicable, report warning in case resolution fails
                for _, rpt := range fNextRpts </span><span class="cov8" title="1">{
                        resolvedResultRefs, _, err := resources.ResolveResultRef(pipelineRunFacts.State, rpt)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Infof("Final task %q is not executed as it could not resolve task params for %q: %v", rpt.PipelineTask.Name, pr.Name, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">resources.ApplyTaskResults(resources.PipelineRunState{rpt}, resolvedResultRefs)

                        if err := rpt.EvaluateCEL(); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Final task %q is not executed, due to error evaluating CEL %s: %v", rpt.PipelineTask.Name, pr.Name, err)
                                pr.Status.MarkFailed(string(v1.PipelineRunReasonCELEvaluationFailed),
                                        "Error evaluating CEL %s: %w", pr.Name, pipelineErrors.WrapUserError(err))
                                return controller.NewPermanentError(err)
                        }</span>

                        <span class="cov8" title="1">nextRpts = append(nextRpts, rpt)</span>
                }
        }

        // If FinallyStartTime is not set, and one or more final tasks has been created
        // Try to set the FinallyStartTime of this PipelineRun
        <span class="cov8" title="1">if pr.Status.FinallyStartTime == nil &amp;&amp; pipelineRunFacts.IsFinalTaskStarted() </span><span class="cov8" title="1">{
                c.setFinallyStartedTimeIfNeeded(pr, pipelineRunFacts)
        }</span>

        <span class="cov8" title="1">resources.ApplyResultsToWorkspaceBindings(pipelineRunFacts.State.GetTaskRunsResults(), pr)

        for _, rpt := range nextRpts </span><span class="cov8" title="1">{
                if rpt.IsFinalTask(pipelineRunFacts) </span><span class="cov8" title="1">{
                        c.setFinallyStartedTimeIfNeeded(pr, pipelineRunFacts)
                }</span>

                <span class="cov8" title="1">if rpt == nil || rpt.Skip(pipelineRunFacts).IsSkipped || rpt.IsFinallySkipped(pipelineRunFacts).IsSkipped </span><span class="cov8" title="1">{
                        continue</span>
                }

                // propagate previous task results
                <span class="cov8" title="1">resources.PropagateResults(rpt, pipelineRunFacts.State)

                // propagate previous task artifacts
                err = resources.PropagateArtifacts(rpt, pipelineRunFacts.State)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to propagate artifacts due to error: %v", err)
                        return controller.NewPermanentError(err)
                }</span>

                // Validate parameter types in matrix after apply substitutions from Task Results
                <span class="cov8" title="1">if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                        if err := resources.ValidateParameterTypesInMatrix(pipelineRunFacts.State); err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to validate matrix %q with error %w", pr.Name, err)
                                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidMatrixParameterTypes.String(),
                                        "Failed to validate matrix %q with error %w", pipelineErrors.WrapUserError(err))
                                return controller.NewPermanentError(err)
                        }</span>
                }

                <span class="cov8" title="1">if rpt.IsCustomTask() </span><span class="cov8" title="1">{
                        rpt.CustomRuns, err = c.createCustomRuns(ctx, rpt, pr, pipelineRunFacts)
                        if err != nil </span><span class="cov8" title="1">{
                                recorder.Eventf(pr, corev1.EventTypeWarning, "RunsCreationFailed", "Failed to create CustomRuns %q: %v", rpt.CustomRunNames, err)
                                err = fmt.Errorf("error creating CustomRuns called %s for PipelineTask %s from PipelineRun %s: %w", rpt.CustomRunNames, rpt.PipelineTask.Name, pr.Name, err)
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        rpt.TaskRuns, err = c.createTaskRuns(ctx, rpt, pr, pipelineRunFacts)
                        if err != nil </span><span class="cov8" title="1">{
                                recorder.Eventf(pr, corev1.EventTypeWarning, "TaskRunsCreationFailed", "Failed to create TaskRuns %q: %v", rpt.TaskRunNames, err)
                                err = fmt.Errorf("error creating TaskRuns called %s for PipelineTask %s from PipelineRun %s: %w", rpt.TaskRunNames, rpt.PipelineTask.Name, pr.Name, err)
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// setFinallyStartedTimeIfNeeded sets the PipelineRun.Status.FinallyStartedTime to the current time if it's nil.
func (c *Reconciler) setFinallyStartedTimeIfNeeded(pr *v1.PipelineRun, facts *resources.PipelineRunFacts) <span class="cov8" title="1">{
        if pr.Status.FinallyStartTime == nil </span><span class="cov8" title="1">{
                pr.Status.FinallyStartTime = &amp;metav1.Time{Time: c.Clock.Now()}
        }</span>
        <span class="cov8" title="1">if facts.TimeoutsState.FinallyStartTime == nil </span><span class="cov8" title="1">{
                facts.TimeoutsState.FinallyStartTime = &amp;pr.Status.FinallyStartTime.Time
        }</span>
}

func (c *Reconciler) createTaskRuns(ctx context.Context, rpt *resources.ResolvedPipelineTask, pr *v1.PipelineRun, facts *resources.PipelineRunFacts) ([]*v1.TaskRun, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "createTaskRuns")
        defer span.End()

        var matrixCombinations []v1.Params
        if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                matrixCombinations = rpt.PipelineTask.Matrix.FanOut()
        }</span>

        // validate the param values meet resolved Task Param Enum requirements before creating TaskRuns
        <span class="cov8" title="1">if config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                for i := range rpt.TaskRunNames </span><span class="cov8" title="1">{
                        var params v1.Params
                        if len(matrixCombinations) &gt; i </span><span class="cov8" title="1">{
                                params = matrixCombinations[i]
                        }</span>
                        <span class="cov8" title="1">params = append(params, rpt.PipelineTask.Params...)
                        if err := taskrun.ValidateEnumParam(ctx, params, rpt.ResolvedTask.TaskSpec.Params); err != nil </span><span class="cov8" title="1">{
                                pr.Status.MarkFailed(v1.PipelineRunReasonInvalidParamValue.String(),
                                        "Invalid param value from PipelineTask \"%s\": %w",
                                        rpt.PipelineTask.Name, pipelineErrors.WrapUserError(err))
                                return nil, controller.NewPermanentError(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">var taskRuns []*v1.TaskRun
        for i, taskRunName := range rpt.TaskRunNames </span><span class="cov8" title="1">{
                var params v1.Params
                if len(matrixCombinations) &gt; i </span><span class="cov8" title="1">{
                        params = matrixCombinations[i]
                }</span>
                <span class="cov8" title="1">taskRun, err := c.createTaskRun(ctx, taskRunName, params, rpt, pr, facts)
                if err != nil </span><span class="cov8" title="1">{
                        err := c.handleRunCreationError(ctx, pr, err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">taskRuns = append(taskRuns, taskRun)</span>
        }

        <span class="cov8" title="1">return taskRuns, nil</span>
}

func (c *Reconciler) createTaskRun(ctx context.Context, taskRunName string, params v1.Params, rpt *resources.ResolvedPipelineTask, pr *v1.PipelineRun, facts *resources.PipelineRunFacts) (*v1.TaskRun, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "createTaskRun")
        defer span.End()
        logger := logging.FromContext(ctx)
        rpt.PipelineTask = resources.ApplyPipelineTaskContexts(rpt.PipelineTask, pr.Status, facts)
        taskRunSpec := pr.GetTaskRunSpec(rpt.PipelineTask.Name)
        params = append(params, rpt.PipelineTask.Params...)
        tr := &amp;v1.TaskRun{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            taskRunName,
                        Namespace:       pr.Namespace,
                        OwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(pr)},
                        Labels:          combineTaskRunAndTaskSpecLabels(pr, rpt.PipelineTask),
                        Annotations:     combineTaskRunAndTaskSpecAnnotations(pr, rpt.PipelineTask),
                },
                Spec: v1.TaskRunSpec{
                        Retries:            rpt.PipelineTask.Retries,
                        Params:             params,
                        ServiceAccountName: taskRunSpec.ServiceAccountName,
                        PodTemplate:        taskRunSpec.PodTemplate,
                        StepSpecs:          taskRunSpec.StepSpecs,
                        SidecarSpecs:       taskRunSpec.SidecarSpecs,
                        ComputeResources:   taskRunSpec.ComputeResources,
                },
        }

        // Add current spanContext as annotations to TaskRun
        // so that tracing can be continued under the same traceId
        if spanContext, err := getMarshalledSpanFromContext(ctx); err == nil </span><span class="cov0" title="0">{
                tr.Annotations[TaskRunSpanContextAnnotation] = spanContext
        }</span>
        <span class="cov8" title="1">if rpt.PipelineTask.OnError == v1.PipelineTaskContinue </span><span class="cov0" title="0">{
                tr.Annotations[v1.PipelineTaskOnErrorAnnotation] = string(v1.PipelineTaskContinue)
        }</span>

        <span class="cov8" title="1">if rpt.PipelineTask.Timeout != nil </span><span class="cov8" title="1">{
                tr.Spec.Timeout = rpt.PipelineTask.Timeout
        }</span>

        // taskRunSpec timeout overrides pipeline task timeout
        <span class="cov8" title="1">if taskRunSpec.Timeout != nil </span><span class="cov8" title="1">{
                tr.Spec.Timeout = taskRunSpec.Timeout
        }</span>

        <span class="cov8" title="1">if rpt.ResolvedTask.TaskName != "" </span><span class="cov8" title="1">{
                // We pass the entire, original task ref because it may contain additional references like a Bundle url.
                tr.Spec.TaskRef = rpt.PipelineTask.TaskRef
        }</span> else<span class="cov8" title="1"> if rpt.ResolvedTask.TaskSpec != nil </span><span class="cov8" title="1">{
                tr.Spec.TaskSpec = rpt.ResolvedTask.TaskSpec
        }</span>

        <span class="cov8" title="1">var pipelinePVCWorkspaceName string
        var err error
        tr.Spec.Workspaces, pipelinePVCWorkspaceName, err = c.getTaskrunWorkspaces(ctx, pr, rpt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">aaBehavior, err := affinityassistant.GetAffinityAssistantBehavior(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if aaAnnotationVal := getAffinityAssistantAnnotationVal(aaBehavior, pipelinePVCWorkspaceName, pr.Name); aaAnnotationVal != "" </span><span class="cov8" title="1">{
                tr.Annotations[workspace.AnnotationAffinityAssistantName] = aaAnnotationVal
        }</span>

        <span class="cov8" title="1">logger.Infof("Creating a new TaskRun object %s for pipeline task %s", taskRunName, rpt.PipelineTask.Name)

        cfg := config.FromContextOrDefaults(ctx)
        if !cfg.FeatureFlags.EnableWaitExponentialBackoff </span><span class="cov8" title="1">{
                return c.PipelineClientSet.TektonV1().TaskRuns(pr.Namespace).Create(ctx, tr, metav1.CreateOptions{})
        }</span>

        <span class="cov8" title="1">backoff := wait.Backoff{
                Duration: cfg.WaitExponentialBackoff.Duration, // Initial delay before retry
                Factor:   cfg.WaitExponentialBackoff.Factor,   // Multiplier for exponential growth
                Steps:    cfg.WaitExponentialBackoff.Steps,    // Maximum number of retry attempts
                Cap:      cfg.WaitExponentialBackoff.Cap,      // Maximum time spent before giving up
        }
        var result *v1.TaskRun
        err = wait.ExponentialBackoff(backoff, func() (bool, error) </span><span class="cov8" title="1">{
                result = nil
                result, err = c.PipelineClientSet.TektonV1().TaskRuns(pr.Namespace).Create(ctx, tr, metav1.CreateOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        if ctrl.IsWebhookTimeout(err) </span><span class="cov8" title="1">{
                                return false, nil // retry
                        }</span>
                        <span class="cov8" title="1">return false, err</span> // do not retry
                }
                <span class="cov8" title="1">return true, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// handleRunCreationError marks the PipelineRun as failed and returns a permanent error if the run creation error is not retryable
func (c *Reconciler) handleRunCreationError(ctx context.Context, pr *v1.PipelineRun, err error) error <span class="cov8" title="1">{
        if controller.IsPermanentError(err) </span><span class="cov8" title="1">{
                pr.Status.MarkFailed(v1.PipelineRunReasonCreateRunFailed.String(), err.Error())
                return err
        }</span>
        // This is not a complete list of permanent errors. Any permanent error with TaskRun/CustomRun creation can be added here.
        <span class="cov8" title="1">if apierrors.IsInvalid(err) || apierrors.IsBadRequest(err) </span><span class="cov8" title="1">{
                pr.Status.MarkFailed(v1.PipelineRunReasonCreateRunFailed.String(), err.Error())
                return controller.NewPermanentError(err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *Reconciler) createCustomRuns(ctx context.Context, rpt *resources.ResolvedPipelineTask, pr *v1.PipelineRun, facts *resources.PipelineRunFacts) ([]*v1beta1.CustomRun, error) <span class="cov8" title="1">{
        var customRuns []*v1beta1.CustomRun
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "createCustomRuns")
        defer span.End()
        var matrixCombinations []v1.Params

        if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                matrixCombinations = rpt.PipelineTask.Matrix.FanOut()
        }</span>
        <span class="cov8" title="1">for i, customRunName := range rpt.CustomRunNames </span><span class="cov8" title="1">{
                var params v1.Params
                if len(matrixCombinations) &gt; i </span><span class="cov8" title="1">{
                        params = matrixCombinations[i]
                }</span>
                <span class="cov8" title="1">customRun, err := c.createCustomRun(ctx, customRunName, params, rpt, pr, facts)
                if err != nil </span><span class="cov8" title="1">{
                        err := c.handleRunCreationError(ctx, pr, err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">customRuns = append(customRuns, customRun)</span>
        }
        <span class="cov8" title="1">return customRuns, nil</span>
}

func (c *Reconciler) createCustomRun(ctx context.Context, runName string, params v1.Params, rpt *resources.ResolvedPipelineTask, pr *v1.PipelineRun, facts *resources.PipelineRunFacts) (*v1beta1.CustomRun, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "createCustomRun")
        defer span.End()
        logger := logging.FromContext(ctx)
        rpt.PipelineTask = resources.ApplyPipelineTaskContexts(rpt.PipelineTask, pr.Status, facts)
        taskRunSpec := pr.GetTaskRunSpec(rpt.PipelineTask.Name)
        params = append(params, rpt.PipelineTask.Params...)

        taskTimeout := rpt.PipelineTask.Timeout
        // taskRunSpec timeout overrides pipeline task timeout
        if taskRunSpec.Timeout != nil </span><span class="cov8" title="1">{
                taskTimeout = taskRunSpec.Timeout
        }</span>

        <span class="cov8" title="1">var pipelinePVCWorkspaceName string
        var err error
        var workspaces []v1.WorkspaceBinding
        workspaces, pipelinePVCWorkspaceName, err = c.getTaskrunWorkspaces(ctx, pr, rpt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">objectMeta := metav1.ObjectMeta{
                Name:            runName,
                Namespace:       pr.Namespace,
                OwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(pr)},
                Labels:          getTaskrunLabels(pr, rpt.PipelineTask.Name, true),
                Annotations:     getTaskrunAnnotations(pr),
        }

        // TaskRef, Params and Workspaces are converted to v1beta1 since CustomRuns
        // is still in v1beta1 apiVersion
        var customRef *v1beta1.TaskRef
        if rpt.PipelineTask.TaskRef != nil </span><span class="cov8" title="1">{
                customRef = &amp;v1beta1.TaskRef{}
                customRef.ConvertFrom(ctx, *rpt.PipelineTask.TaskRef)
        }</span>

        <span class="cov8" title="1">customRunParams := v1beta1.Params{}
        for _, p := range params </span><span class="cov8" title="1">{
                v1beta1Param := v1beta1.Param{}
                v1beta1Param.ConvertFrom(ctx, p)
                customRunParams = append(customRunParams, v1beta1Param)
        }</span>

        <span class="cov8" title="1">customRunWorkspaces := []v1beta1.WorkspaceBinding{}
        for _, w := range workspaces </span><span class="cov8" title="1">{
                v1beta1WorkspaceBinding := v1beta1.WorkspaceBinding{}
                v1beta1WorkspaceBinding.ConvertFrom(ctx, w)
                customRunWorkspaces = append(customRunWorkspaces, v1beta1WorkspaceBinding)
        }</span>

        <span class="cov8" title="1">r := &amp;v1beta1.CustomRun{
                ObjectMeta: objectMeta,
                Spec: v1beta1.CustomRunSpec{
                        Retries:            rpt.PipelineTask.Retries,
                        CustomRef:          customRef,
                        Params:             customRunParams,
                        ServiceAccountName: taskRunSpec.ServiceAccountName,
                        Timeout:            taskTimeout,
                        Workspaces:         customRunWorkspaces,
                },
        }

        if rpt.PipelineTask.TaskSpec != nil </span><span class="cov8" title="1">{
                j, err := json.Marshal(rpt.PipelineTask.TaskSpec.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">r.Spec.CustomSpec = &amp;v1beta1.EmbeddedCustomRunSpec{
                        TypeMeta: runtime.TypeMeta{
                                APIVersion: rpt.PipelineTask.TaskSpec.APIVersion,
                                Kind:       rpt.PipelineTask.TaskSpec.Kind,
                        },
                        Metadata: v1beta1.PipelineTaskMetadata(rpt.PipelineTask.TaskSpec.Metadata),
                        Spec: runtime.RawExtension{
                                Raw: j,
                        },
                }</span>
        }

        // Set the affinity assistant annotation in case the custom task creates TaskRuns or Pods
        // that can take advantage of it.
        <span class="cov8" title="1">aaBehavior, err := affinityassistant.GetAffinityAssistantBehavior(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if aaAnnotationVal := getAffinityAssistantAnnotationVal(aaBehavior, pipelinePVCWorkspaceName, pr.Name); aaAnnotationVal != "" </span><span class="cov8" title="1">{
                r.Annotations[workspace.AnnotationAffinityAssistantName] = aaAnnotationVal
        }</span>

        <span class="cov8" title="1">logger.Infof("Creating a new CustomRun object %s", runName)

        cfg := config.FromContextOrDefaults(ctx)
        if !cfg.FeatureFlags.EnableWaitExponentialBackoff </span><span class="cov8" title="1">{
                return c.PipelineClientSet.TektonV1beta1().CustomRuns(pr.Namespace).Create(ctx, r, metav1.CreateOptions{})
        }</span>

        <span class="cov8" title="1">backoff := wait.Backoff{
                Duration: cfg.WaitExponentialBackoff.Duration, // Initial delay before retry
                Factor:   cfg.WaitExponentialBackoff.Factor,   // Multiplier for exponential growth
                Steps:    cfg.WaitExponentialBackoff.Steps,    // Maximum number of retry attempts
                Cap:      cfg.WaitExponentialBackoff.Cap,      // Maximum time spent before giving up
        }
        var result *v1beta1.CustomRun
        err = wait.ExponentialBackoff(backoff, func() (bool, error) </span><span class="cov8" title="1">{
                result = nil
                result, err = c.PipelineClientSet.TektonV1beta1().CustomRuns(pr.Namespace).Create(ctx, r, metav1.CreateOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        if ctrl.IsWebhookTimeout(err) </span><span class="cov8" title="1">{
                                return false, nil // retry
                        }</span>
                        <span class="cov8" title="1">return false, err</span> // do not retry
                }
                <span class="cov8" title="1">return true, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// propagateWorkspaces identifies the workspaces that the pipeline task usess
// It adds the additional workspaces to the pipeline task's workspaces after
// creating workspace bindings. Finally, it returns the updated resolved pipeline task.
func propagateWorkspaces(rpt *resources.ResolvedPipelineTask) (*resources.ResolvedPipelineTask, error) <span class="cov8" title="1">{
        ts := rpt.PipelineTask.TaskSpec.TaskSpec

        workspacesUsedInSteps, err := workspace.FindWorkspacesUsedByTask(ts)
        if err != nil </span><span class="cov0" title="0">{
                return rpt, err
        }</span>

        <span class="cov8" title="1">ptw := sets.NewString()
        for _, ws := range rpt.PipelineTask.Workspaces </span><span class="cov8" title="1">{
                ptw.Insert(ws.Name)
        }</span>

        <span class="cov8" title="1">for wSpace := range workspacesUsedInSteps </span><span class="cov8" title="1">{
                if !ptw.Has(wSpace) </span><span class="cov8" title="1">{
                        rpt.PipelineTask.Workspaces = append(rpt.PipelineTask.Workspaces, v1.WorkspacePipelineTaskBinding{Name: wSpace})
                }</span>
        }
        <span class="cov8" title="1">return rpt, nil</span>
}

func (c *Reconciler) getTaskrunWorkspaces(ctx context.Context, pr *v1.PipelineRun, rpt *resources.ResolvedPipelineTask) ([]v1.WorkspaceBinding, string, error) <span class="cov8" title="1">{
        var err error
        var workspaces []v1.WorkspaceBinding
        var pipelinePVCWorkspaceName string
        pipelineRunWorkspaces := make(map[string]v1.WorkspaceBinding)
        for _, binding := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                pipelineRunWorkspaces[binding.Name] = binding
        }</span>

        // Propagate required workspaces from pipelineRun to the pipelineTasks
        <span class="cov8" title="1">if rpt.PipelineTask.TaskSpec != nil </span><span class="cov8" title="1">{
                rpt, err = propagateWorkspaces(rpt)
                if err != nil </span><span class="cov0" title="0">{
                        // This error cannot be recovered without modifying the TaskSpec
                        return nil, "", controller.NewPermanentError(err)
                }</span>
        }

        <span class="cov8" title="1">for _, ws := range rpt.PipelineTask.Workspaces </span><span class="cov8" title="1">{
                taskWorkspaceName, pipelineTaskSubPath, pipelineWorkspaceName := ws.Name, ws.SubPath, ws.Workspace
                pipelineWorkspace := pipelineWorkspaceName

                if pipelineWorkspaceName == "" </span><span class="cov8" title="1">{
                        pipelineWorkspace = taskWorkspaceName
                }</span>

                <span class="cov8" title="1">if b, hasBinding := pipelineRunWorkspaces[pipelineWorkspace]; hasBinding </span><span class="cov8" title="1">{
                        if b.PersistentVolumeClaim != nil || b.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                                pipelinePVCWorkspaceName = pipelineWorkspace
                        }</span>

                        <span class="cov8" title="1">aaBehavior, err := affinityassistant.GetAffinityAssistantBehavior(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", err
                        }</span>

                        <span class="cov8" title="1">workspace := c.taskWorkspaceByWorkspaceVolumeSource(ctx, pipelinePVCWorkspaceName, pr.Name, b, taskWorkspaceName, pipelineTaskSubPath, *kmeta.NewControllerRef(pr), aaBehavior)
                        workspaces = append(workspaces, workspace)</span>
                } else<span class="cov8" title="1"> {
                        workspaceIsOptional := false
                        if rpt.ResolvedTask != nil &amp;&amp; rpt.ResolvedTask.TaskSpec != nil </span><span class="cov8" title="1">{
                                for _, taskWorkspaceDeclaration := range rpt.ResolvedTask.TaskSpec.Workspaces </span><span class="cov8" title="1">{
                                        if taskWorkspaceDeclaration.Name == taskWorkspaceName &amp;&amp; taskWorkspaceDeclaration.Optional </span><span class="cov8" title="1">{
                                                workspaceIsOptional = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if !workspaceIsOptional </span><span class="cov8" title="1">{
                                err = fmt.Errorf("expected workspace %q to be provided by pipelinerun for pipeline task %q", pipelineWorkspace, rpt.PipelineTask.Name)
                                // This error cannot be recovered without modifying the PipelineRun
                                return nil, "", controller.NewPermanentError(err)
                        }</span>
                }
        }

        // replace pipelineRun context variables in workspace subPath in the workspace binding
        <span class="cov8" title="1">var p string
        if pr.Spec.PipelineRef != nil </span><span class="cov8" title="1">{
                p = pr.Spec.PipelineRef.Name
        }</span>
        <span class="cov8" title="1">for j := range workspaces </span><span class="cov8" title="1">{
                workspaces[j].SubPath = substitution.ApplyReplacements(workspaces[j].SubPath, resources.GetContextReplacements(p, pr))
        }</span>

        <span class="cov8" title="1">return workspaces, pipelinePVCWorkspaceName, nil</span>
}

// taskWorkspaceByWorkspaceVolumeSource returns the WorkspaceBinding to be bound to each TaskRun in the Pipeline Task.
// If the PipelineRun WorkspaceBinding is a volumeClaimTemplate, the returned WorkspaceBinding references a PersistentVolumeClaim created for the PipelineRun WorkspaceBinding based on the PipelineRun as OwnerReference.
// Otherwise, the returned WorkspaceBinding references the same volume as the PipelineRun WorkspaceBinding, with the file path joined with pipelineTaskSubPath as the binding subpath.
func (c *Reconciler) taskWorkspaceByWorkspaceVolumeSource(ctx context.Context, pipelineWorkspaceName string, prName string, wb v1.WorkspaceBinding, taskWorkspaceName string, pipelineTaskSubPath string, owner metav1.OwnerReference, aaBehavior affinityassistant.AffinityAssistantBehavior) v1.WorkspaceBinding <span class="cov8" title="1">{
        if wb.VolumeClaimTemplate == nil </span><span class="cov8" title="1">{
                binding := *wb.DeepCopy()
                binding.Name = taskWorkspaceName
                binding.SubPath = combinedSubPath(wb.SubPath, pipelineTaskSubPath)
                return binding
        }</span>

        <span class="cov8" title="1">binding := v1.WorkspaceBinding{
                SubPath:               combinedSubPath(wb.SubPath, pipelineTaskSubPath),
                PersistentVolumeClaim: &amp;corev1.PersistentVolumeClaimVolumeSource{},
        }
        binding.Name = taskWorkspaceName

        switch aaBehavior </span>{
        case affinityassistant.AffinityAssistantPerWorkspace, affinityassistant.AffinityAssistantDisabled:<span class="cov8" title="1">
                binding.PersistentVolumeClaim.ClaimName = volumeclaim.GeneratePVCNameFromWorkspaceBinding(wb.VolumeClaimTemplate.Name, wb, owner)</span>
        case affinityassistant.AffinityAssistantPerPipelineRun, affinityassistant.AffinityAssistantPerPipelineRunWithIsolation:<span class="cov0" title="0">
                binding.PersistentVolumeClaim.ClaimName = getPersistentVolumeClaimNameWithAffinityAssistant("", prName, wb, owner)</span>
        }

        <span class="cov8" title="1">return binding</span>
}

// combinedSubPath returns the combined value of the optional subPath from workspaceBinding and the optional
// subPath from pipelineTask. If both is set, they are joined with a slash.
func combinedSubPath(workspaceSubPath string, pipelineTaskSubPath string) string <span class="cov8" title="1">{
        if workspaceSubPath == "" </span><span class="cov8" title="1">{
                return pipelineTaskSubPath
        }</span> else<span class="cov8" title="1"> if pipelineTaskSubPath == "" </span><span class="cov8" title="1">{
                return workspaceSubPath
        }</span>
        <span class="cov8" title="1">return filepath.Join(workspaceSubPath, pipelineTaskSubPath)</span>
}

func getTaskrunAnnotations(pr *v1.PipelineRun) map[string]string <span class="cov8" title="1">{
        // Propagate annotations from PipelineRun to TaskRun.
        annotations := make(map[string]string, len(pr.ObjectMeta.Annotations)+1)
        for key, val := range pr.ObjectMeta.Annotations </span><span class="cov8" title="1">{
                annotations[key] = val
        }</span>
        <span class="cov8" title="1">return kmap.Filter(annotations, func(s string) bool </span><span class="cov8" title="1">{
                return filterReservedAnnotationRegexp.MatchString(s)
        }</span>)
}

func propagatePipelineNameLabelToPipelineRun(pr *v1.PipelineRun) error <span class="cov8" title="1">{
        if pr.ObjectMeta.Labels == nil </span><span class="cov8" title="1">{
                pr.ObjectMeta.Labels = make(map[string]string)
        }</span>

        <span class="cov8" title="1">if _, ok := pr.ObjectMeta.Labels[pipeline.PipelineLabelKey]; ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch </span>{
        case pr.Spec.PipelineRef != nil &amp;&amp; pr.Spec.PipelineRef.Name != "":<span class="cov8" title="1">
                pr.ObjectMeta.Labels[pipeline.PipelineLabelKey] = pr.Spec.PipelineRef.Name</span>
        case pr.Spec.PipelineSpec != nil:<span class="cov8" title="1">
                pr.ObjectMeta.Labels[pipeline.PipelineLabelKey] = pr.Name</span>
        case pr.Spec.PipelineRef != nil &amp;&amp; pr.Spec.PipelineRef.Resolver != "":<span class="cov8" title="1">
                pr.ObjectMeta.Labels[pipeline.PipelineLabelKey] = pr.Name

                // https://tekton.dev/docs/pipelines/cluster-resolver/#pipeline-resolution
                var kind, name string
                for _, param := range pr.Spec.PipelineRef.Params </span><span class="cov8" title="1">{
                        if param.Name == "kind" </span><span class="cov8" title="1">{
                                kind = param.Value.StringVal
                        }</span>
                        <span class="cov8" title="1">if param.Name == "name" </span><span class="cov8" title="1">{
                                name = param.Value.StringVal
                        }</span>
                }
                <span class="cov8" title="1">if kind == "pipeline" </span><span class="cov8" title="1">{
                        pr.ObjectMeta.Labels[pipeline.PipelineLabelKey] = name
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("pipelineRun %s not providing PipelineRef or PipelineSpec", pr.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getTaskrunLabels(pr *v1.PipelineRun, pipelineTaskName string, includePipelineLabels bool) map[string]string <span class="cov8" title="1">{
        // Propagate labels from PipelineRun to TaskRun.
        labels := make(map[string]string, len(pr.ObjectMeta.Labels)+1)
        if includePipelineLabels </span><span class="cov8" title="1">{
                for key, val := range pr.ObjectMeta.Labels </span><span class="cov8" title="1">{
                        labels[key] = val
                }</span>
        }
        <span class="cov8" title="1">labels[pipeline.PipelineRunLabelKey] = pr.Name
        labels[pipeline.PipelineRunUIDLabelKey] = string(pr.UID)
        if pipelineTaskName != "" </span><span class="cov8" title="1">{
                labels[pipeline.PipelineTaskLabelKey] = pipelineTaskName
        }</span>
        <span class="cov8" title="1">if pr.Status.PipelineSpec != nil </span><span class="cov8" title="1">{
                // check if a task is part of the "tasks" section, add a label to identify it during the runtime
                for _, f := range pr.Status.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                        if pipelineTaskName == f.Name </span><span class="cov8" title="1">{
                                labels[pipeline.MemberOfLabelKey] = v1.PipelineTasks
                                break</span>
                        }
                }
                // check if a task is part of the "finally" section, add a label to identify it during the runtime
                <span class="cov8" title="1">for _, f := range pr.Status.PipelineSpec.Finally </span><span class="cov8" title="1">{
                        if pipelineTaskName == f.Name </span><span class="cov8" title="1">{
                                labels[pipeline.MemberOfLabelKey] = v1.PipelineFinallyTasks
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return labels</span>
}

func combineTaskRunAndTaskSpecLabels(pr *v1.PipelineRun, pipelineTask *v1.PipelineTask) map[string]string <span class="cov8" title="1">{
        labels := make(map[string]string)

        taskRunSpec := pr.GetTaskRunSpec(pipelineTask.Name)
        if taskRunSpec.Metadata != nil </span><span class="cov8" title="1">{
                addMetadataByPrecedence(labels, taskRunSpec.Metadata.Labels)
        }</span>

        <span class="cov8" title="1">addMetadataByPrecedence(labels, getTaskrunLabels(pr, pipelineTask.Name, true))

        if pipelineTask.TaskSpec != nil </span><span class="cov8" title="1">{
                addMetadataByPrecedence(labels, pipelineTask.TaskSpecMetadata().Labels)
        }</span>

        <span class="cov8" title="1">return labels</span>
}

func combineTaskRunAndTaskSpecAnnotations(pr *v1.PipelineRun, pipelineTask *v1.PipelineTask) map[string]string <span class="cov8" title="1">{
        annotations := make(map[string]string)

        taskRunSpec := pr.GetTaskRunSpec(pipelineTask.Name)
        if taskRunSpec.Metadata != nil </span><span class="cov8" title="1">{
                addMetadataByPrecedence(annotations, taskRunSpec.Metadata.Annotations)
        }</span>

        <span class="cov8" title="1">addMetadataByPrecedence(annotations, getTaskrunAnnotations(pr))

        if pipelineTask.TaskSpec != nil </span><span class="cov8" title="1">{
                addMetadataByPrecedence(annotations, pipelineTask.TaskSpecMetadata().Annotations)
        }</span>

        <span class="cov8" title="1">return annotations</span>
}

// addMetadataByPrecedence() adds the elements in addedMetadata to metadata. If the same key is present in both maps, the value from metadata will be used.
func addMetadataByPrecedence(metadata map[string]string, addedMetadata map[string]string) <span class="cov8" title="1">{
        for key, value := range addedMetadata </span><span class="cov8" title="1">{
                // add new annotations/labels  if the key not exists in current ones
                if _, ok := metadata[key]; !ok </span><span class="cov8" title="1">{
                        metadata[key] = value
                }</span>
        }
}

func (c *Reconciler) updateLabelsAndAnnotations(ctx context.Context, pr *v1.PipelineRun) (*v1.PipelineRun, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "updateLabelsAndAnnotations")
        defer span.End()
        newPr, err := c.pipelineRunLister.PipelineRuns(pr.Namespace).Get(pr.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting PipelineRun %s when updating labels/annotations: %w", pr.Name, err)
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(pr.ObjectMeta.Labels, newPr.ObjectMeta.Labels) || !reflect.DeepEqual(pr.ObjectMeta.Annotations, newPr.ObjectMeta.Annotations) </span><span class="cov8" title="1">{
                // Note that this uses Update vs. Patch because the former is significantly easier to test.
                // If we want to switch this to Patch, then we will need to teach the utilities in test/controller.go
                // to deal with Patch (setting resourceVersion, and optimistic concurrency checks).
                newPr = newPr.DeepCopy()
                // Properly merge labels and annotations, as the labels *might* have changed during the reconciliation
                newPr.Labels = kmap.Union(newPr.Labels, pr.Labels)
                newPr.Annotations = kmap.Union(newPr.Annotations, pr.Annotations)
                return c.PipelineClientSet.TektonV1().PipelineRuns(pr.Namespace).Update(ctx, newPr, metav1.UpdateOptions{})
        }</span>
        <span class="cov8" title="1">return newPr, nil</span>
}

func storePipelineSpecAndMergeMeta(ctx context.Context, pr *v1.PipelineRun, ps *v1.PipelineSpec, meta *resolutionutil.ResolvedObjectMeta) error <span class="cov8" title="1">{
        // Only store the PipelineSpec once, if it has never been set before.
        if pr.Status.PipelineSpec == nil </span><span class="cov8" title="1">{
                pr.Status.PipelineSpec = ps
                if meta == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Propagate labels from Pipeline to PipelineRun. PipelineRun labels take precedences over Pipeline.
                <span class="cov8" title="1">pr.ObjectMeta.Labels = kmap.Union(meta.Labels, pr.ObjectMeta.Labels)
                if len(meta.Name) &gt; 0 </span><span class="cov8" title="1">{
                        pr.ObjectMeta.Labels[pipeline.PipelineLabelKey] = meta.Name
                }</span>

                // Propagate annotations from Pipeline to PipelineRun. PipelineRun annotations take precedences over Pipeline.
                <span class="cov8" title="1">pr.ObjectMeta.Annotations = kmap.Union(kmap.ExcludeKeys(meta.Annotations, tknreconciler.KubectlLastAppliedAnnotationKey), pr.ObjectMeta.Annotations)</span>
        }

        // Propagate refSource from remote resolution to PipelineRun Status
        // This lives outside of the status.spec check to avoid the case where only the spec is available in the first reconcile and source comes in next reconcile.
        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)
        if cfg.FeatureFlags.EnableProvenanceInStatus </span><span class="cov8" title="1">{
                if pr.Status.Provenance == nil </span><span class="cov8" title="1">{
                        pr.Status.Provenance = &amp;v1.Provenance{}
                }</span>
                // Store FeatureFlags in the Provenance.
                <span class="cov8" title="1">pr.Status.Provenance.FeatureFlags = cfg.FeatureFlags

                if meta != nil &amp;&amp; meta.RefSource != nil &amp;&amp; pr.Status.Provenance.RefSource == nil </span><span class="cov8" title="1">{
                        pr.Status.Provenance.RefSource = meta.RefSource
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *Reconciler) updatePipelineRunStatusFromInformer(ctx context.Context, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "updatePipelineRunStatusFromInformer")
        defer span.End()
        logger := logging.FromContext(ctx)

        // Get the pipelineRun label that is set on each TaskRun.  Do not include the propagated labels from the
        // Pipeline and PipelineRun.  The user could change them during the lifetime of the PipelineRun so the
        // current labels may not be set on the previously created TaskRuns.
        pipelineRunLabels := getTaskrunLabels(pr, "", false)
        taskRuns, err := c.taskRunLister.TaskRuns(pr.Namespace).List(k8slabels.SelectorFromSet(pipelineRunLabels))
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Could not list TaskRuns %#v", err)
                return err
        }</span>

        <span class="cov8" title="1">customRuns, err := c.customRunLister.CustomRuns(pr.Namespace).List(k8slabels.SelectorFromSet(pipelineRunLabels))
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Could not list CustomRuns %#v", err)
                return err
        }</span>
        <span class="cov8" title="1">return updatePipelineRunStatusFromChildObjects(ctx, logger, pr, taskRuns, customRuns)</span>
}

func updatePipelineRunStatusFromChildObjects(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, taskRuns []*v1.TaskRun, customRuns []*v1beta1.CustomRun) error <span class="cov8" title="1">{
        updatePipelineRunStatusFromChildRefs(logger, pr, taskRuns, customRuns)

        return validateChildObjectsInPipelineRunStatus(ctx, pr.Status)
}</span>

func validateChildObjectsInPipelineRunStatus(ctx context.Context, prs v1.PipelineRunStatus) error <span class="cov8" title="1">{
        var err error

        for _, cr := range prs.ChildReferences </span><span class="cov8" title="1">{
                switch cr.Kind </span>{
                case taskRun, customRun:<span class="cov8" title="1">
                        continue</span>
                default:<span class="cov8" title="1">
                        err = errors.Join(err, fmt.Errorf("child with name %s has unknown kind %s", cr.Name, cr.Kind))</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}

// filterTaskRunsForPipelineRunStatus returns TaskRuns owned by the PipelineRun.
func filterTaskRunsForPipelineRunStatus(logger *zap.SugaredLogger, pr *v1.PipelineRun, trs []*v1.TaskRun) []*v1.TaskRun <span class="cov8" title="1">{
        var ownedTaskRuns []*v1.TaskRun

        for _, tr := range trs </span><span class="cov8" title="1">{
                // Only process TaskRuns that are owned by this PipelineRun.
                // This skips TaskRuns that are indirectly created by the PipelineRun (e.g. by custom tasks).
                if len(tr.OwnerReferences) &lt; 1 || tr.OwnerReferences[0].UID != pr.ObjectMeta.UID </span><span class="cov8" title="1">{
                        logger.Debugf("Found a TaskRun %s that is not owned by this PipelineRun", tr.Name)
                        continue</span>
                }
                <span class="cov8" title="1">ownedTaskRuns = append(ownedTaskRuns, tr)</span>
        }

        <span class="cov8" title="1">return ownedTaskRuns</span>
}

// filterCustomRunsForPipelineRunStatus filters the given slice of customRuns, returning information only those owned by the given PipelineRun.
func filterCustomRunsForPipelineRunStatus(logger *zap.SugaredLogger, pr *v1.PipelineRun, customRuns []*v1beta1.CustomRun) ([]string, []string, []schema.GroupVersionKind, []*v1beta1.CustomRunStatus) <span class="cov8" title="1">{
        var names []string
        var taskLabels []string
        var gvks []schema.GroupVersionKind
        var statuses []*v1beta1.CustomRunStatus

        // Loop over all the customRuns associated to Tasks
        for _, cr := range customRuns </span><span class="cov8" title="1">{
                // Only process customRuns that are owned by this PipelineRun.
                // This skips customRuns that are indirectly created by the PipelineRun (e.g. by custom tasks).
                if len(cr.GetObjectMeta().GetOwnerReferences()) &lt; 1 || cr.GetObjectMeta().GetOwnerReferences()[0].UID != pr.ObjectMeta.UID </span><span class="cov8" title="1">{
                        logger.Debugf("Found a %s %s that is not owned by this PipelineRun", cr.GetObjectKind().GroupVersionKind().Kind, cr.GetObjectMeta().GetName())
                        continue</span>
                }

                <span class="cov8" title="1">names = append(names, cr.GetObjectMeta().GetName())
                taskLabels = append(taskLabels, cr.GetObjectMeta().GetLabels()[pipeline.PipelineTaskLabelKey])

                statuses = append(statuses, &amp;cr.Status)
                // We can't just get the gvk from the customRun's TypeMeta because that isn't populated for resources created through the fake client.
                gvks = append(gvks, v1beta1.SchemeGroupVersion.WithKind(customRun))</span>
        }

        // NAMES are names

        <span class="cov8" title="1">return names, taskLabels, gvks, statuses</span>
}

func updatePipelineRunStatusFromChildRefs(logger *zap.SugaredLogger, pr *v1.PipelineRun, trs []*v1.TaskRun, customRuns []*v1beta1.CustomRun) <span class="cov8" title="1">{
        // If no TaskRun or CustomRun was found, nothing to be done. We never remove child references from the status.
        // We do still return an empty map of TaskRun/Run names keyed by PipelineTask name for later functions.
        if len(trs) == 0 &amp;&amp; len(customRuns) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Map PipelineTask names to TaskRun child references that were already in the status
        <span class="cov8" title="1">childRefByName := make(map[string]*v1.ChildStatusReference)

        for i := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                childRefByName[pr.Status.ChildReferences[i].Name] = &amp;pr.Status.ChildReferences[i]
        }</span>

        <span class="cov8" title="1">taskRuns := filterTaskRunsForPipelineRunStatus(logger, pr, trs)

        // Loop over all the TaskRuns associated to Tasks
        for _, tr := range taskRuns </span><span class="cov8" title="1">{
                lbls := tr.GetLabels()
                pipelineTaskName := lbls[pipeline.PipelineTaskLabelKey]

                if _, ok := childRefByName[tr.Name]; !ok </span><span class="cov8" title="1">{
                        // This tr was missing from the status.
                        // Add it without conditions, which are handled in the next loop
                        logger.Infof("Found a TaskRun %s that was missing from the PipelineRun status", tr.Name)

                        // Since this was recovered now, add it to the map, or it might be overwritten
                        childRefByName[tr.Name] = &amp;v1.ChildStatusReference{
                                TypeMeta: runtime.TypeMeta{
                                        APIVersion: v1.SchemeGroupVersion.String(),
                                        Kind:       taskRun,
                                },
                                Name:             tr.Name,
                                PipelineTaskName: pipelineTaskName,
                        }
                }</span>
        }

        // Get the names, their task label values, and their group/version/kind info for all CustomRuns or Runs associated with the PipelineRun
        <span class="cov8" title="1">names, taskLabels, gvks, _ := filterCustomRunsForPipelineRunStatus(logger, pr, customRuns)

        // Loop over that data and populate the child references
        for idx := range names </span><span class="cov8" title="1">{
                name := names[idx]
                taskLabel := taskLabels[idx]
                gvk := gvks[idx]

                if _, ok := childRefByName[name]; !ok </span><span class="cov8" title="1">{
                        // This run was missing from the status.
                        // Add it without conditions, which are handled in the next loop
                        logger.Infof("Found a %s %s that was missing from the PipelineRun status", gvk.Kind, name)

                        // Since this was recovered now, add it to the map, or it might be overwritten
                        childRefByName[name] = &amp;v1.ChildStatusReference{
                                TypeMeta: runtime.TypeMeta{
                                        APIVersion: gvk.GroupVersion().String(),
                                        Kind:       gvk.Kind,
                                },
                                Name:             name,
                                PipelineTaskName: taskLabel,
                        }
                }</span>
        }

        <span class="cov8" title="1">var newChildRefs []v1.ChildStatusReference
        for k := range childRefByName </span><span class="cov8" title="1">{
                newChildRefs = append(newChildRefs, *childRefByName[k])
        }</span>
        <span class="cov8" title="1">pr.Status.ChildReferences = newChildRefs</span>
}

// conditionFromVerificationResult returns the ConditionTrustedResourcesVerified condition based on the VerificationResult, err is returned when the VerificationResult type is VerificationError
func conditionFromVerificationResult(verificationResult *trustedresources.VerificationResult, pr *v1.PipelineRun, resourceName string) (*apis.Condition, error) <span class="cov8" title="1">{
        var condition *apis.Condition
        var err error
        switch verificationResult.VerificationResultType </span>{
        case trustedresources.VerificationError:<span class="cov8" title="1">
                err = fmt.Errorf("pipelineRun %s/%s referred resource %s failed signature verification: %w", pr.Namespace, pr.Name, resourceName, verificationResult.Err)
                condition = &amp;apis.Condition{
                        Type:    trustedresources.ConditionTrustedResourcesVerified,
                        Status:  corev1.ConditionFalse,
                        Message: err.Error(),
                }</span>
        case trustedresources.VerificationWarn:<span class="cov8" title="1">
                condition = &amp;apis.Condition{
                        Type:    trustedresources.ConditionTrustedResourcesVerified,
                        Status:  corev1.ConditionFalse,
                        Message: verificationResult.Err.Error(),
                }</span>
        case trustedresources.VerificationPass:<span class="cov8" title="1">
                condition = &amp;apis.Condition{
                        Type:   trustedresources.ConditionTrustedResourcesVerified,
                        Status: corev1.ConditionTrue,
                }</span>
        case trustedresources.VerificationSkip:<span class="cov8" title="1"></span>
                // do nothing
        }
        <span class="cov8" title="1">return condition, err</span>
}

// validatePipelineSpecAfterApplyParameters validates the PipelineSpec after apply parameters
// Maybe some fields are modified during apply parameters, need to validate again. For example, tasks[].OnError.
func validatePipelineSpecAfterApplyParameters(ctx context.Context, pipelineSpec *v1.PipelineSpec) (errs *apis.FieldError) <span class="cov8" title="1">{
        if pipelineSpec == nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrMissingField("PipelineSpec"))
                return
        }</span>
        <span class="cov8" title="1">tasks := make([]v1.PipelineTask, 0, len(pipelineSpec.Tasks)+len(pipelineSpec.Finally))
        tasks = append(tasks, pipelineSpec.Tasks...)
        tasks = append(tasks, pipelineSpec.Finally...)
        for _, t := range tasks </span><span class="cov8" title="1">{
                errs = errs.Also(t.ValidateOnError(ctx))
        }</span>
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file441" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinespec

import (
        "context"
        "errors"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        resolutionutil "github.com/tektoncd/pipeline/pkg/internal/resolution"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// GetPipeline is a function used to retrieve Pipelines.
// VerificationResult is the result from trusted resources if the feature is enabled.
type GetPipeline func(context.Context, string) (*v1.Pipeline, *v1.RefSource, *trustedresources.VerificationResult, error)

// GetPipelineData will retrieve the Pipeline metadata and Spec associated with the
// provided PipelineRun. This can come from a reference Pipeline or from the PipelineRun's
// metadata and embedded PipelineSpec.
func GetPipelineData(ctx context.Context, pipelineRun *v1.PipelineRun, getPipeline GetPipeline) (*resolutionutil.ResolvedObjectMeta, *v1.PipelineSpec, error) <span class="cov8" title="1">{
        pipelineMeta := metav1.ObjectMeta{}
        var refSource *v1.RefSource
        var verificationResult *trustedresources.VerificationResult
        pipelineSpec := v1.PipelineSpec{}
        switch </span>{
        case pipelineRun.Spec.PipelineRef != nil &amp;&amp; pipelineRun.Spec.PipelineRef.Name != "":<span class="cov8" title="1">
                // Get related pipeline for pipelinerun
                p, source, vr, err := getPipeline(ctx, pipelineRun.Spec.PipelineRef.Name)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("error when getting Pipeline for PipelineRun %s: %w", pipelineRun.Name, err)
                }</span>
                <span class="cov8" title="1">pipelineMeta = p.PipelineMetadata()
                pipelineSpec = p.PipelineSpec()
                refSource = source
                verificationResult = vr</span>
        case pipelineRun.Spec.PipelineSpec != nil:<span class="cov8" title="1">
                pipelineMeta = pipelineRun.ObjectMeta
                pipelineSpec = *pipelineRun.Spec.PipelineSpec</span>
                // TODO: if we want to set RefSource for embedded pipeline, set it here.
                // https://github.com/tektoncd/pipeline/issues/5522
        case pipelineRun.Spec.PipelineRef != nil &amp;&amp; pipelineRun.Spec.PipelineRef.Resolver != "":<span class="cov8" title="1">
                pipeline, source, vr, err := getPipeline(ctx, "")
                switch </span>{
                case err != nil:<span class="cov8" title="1">
                        return nil, nil, err</span>
                case pipeline == nil:<span class="cov8" title="1">
                        return nil, nil, errors.New("resolution of remote resource completed successfully but no pipeline was returned")</span>
                default:<span class="cov8" title="1">
                        pipelineMeta = pipeline.PipelineMetadata()
                        pipelineSpec = pipeline.PipelineSpec()</span>
                }
                <span class="cov8" title="1">refSource = source
                verificationResult = vr</span>
        default:<span class="cov8" title="1">
                return nil, nil, fmt.Errorf("pipelineRun %s not providing PipelineRef or PipelineSpec", pipelineRun.Name)</span>
        }

        <span class="cov8" title="1">pipelineSpec.SetDefaults(ctx)
        return &amp;resolutionutil.ResolvedObjectMeta{
                ObjectMeta:         &amp;pipelineMeta,
                RefSource:          refSource,
                VerificationResult: verificationResult,
        }, &amp;pipelineSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file442" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "github.com/tektoncd/pipeline/pkg/workspace"
)

const (
        // resultsParseNumber is the value of how many parts we split from result reference. e.g.  tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;
        resultsParseNumber = 4
        // objectElementResultsParseNumber is the value of how many parts we split from
        // object attribute result reference. e.g.  tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;
        objectElementResultsParseNumber = 5
        // objectIndividualVariablePattern is the reference pattern for object individual keys params.&lt;object_param_name&gt;.&lt;key_name&gt;
        objectIndividualVariablePattern = "params.%s.%s"
)

var paramPatterns = []string{
        "params.%s",
        "params[%q]",
        "params['%s']",
}

// ApplyParameters applies the params from a PipelineRun.Params to a PipelineSpec.
func ApplyParameters(ctx context.Context, p *v1.PipelineSpec, pr *v1.PipelineRun) *v1.PipelineSpec <span class="cov8" title="1">{
        // This assumes that the PipelineRun inputs have been validated against what the Pipeline requests.

        // stringReplacements is used for standard single-string stringReplacements,
        // while arrayReplacements/objectReplacements contains arrays/objects that need to be further processed.
        stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        objectReplacements := map[string]map[string]string{}

        // Set all the default stringReplacements
        for _, p := range p.Params </span><span class="cov8" title="1">{
                if p.Default != nil </span><span class="cov8" title="1">{
                        switch p.Default.Type </span>{
                        case v1.ParamTypeArray:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        for i := range len(p.Default.ArrayVal) </span><span class="cov8" title="1">{
                                                stringReplacements[fmt.Sprintf(pattern+"[%d]", p.Name, i)] = p.Default.ArrayVal[i]
                                        }</span>
                                        <span class="cov8" title="1">arrayReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.ArrayVal</span>
                                }
                        case v1.ParamTypeObject:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        objectReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.ObjectVal
                                }</span>
                                <span class="cov8" title="1">for k, v := range p.Default.ObjectVal </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(objectIndividualVariablePattern, p.Name, k)] = v
                                }</span>
                        case v1.ParamTypeString:<span class="cov8" title="1">
                                fallthrough</span>
                        default:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.StringVal
                                }</span>
                        }
                }
        }
        // Set and overwrite params with the ones from the PipelineRun
        <span class="cov8" title="1">prStrings, prArrays, prObjects := paramsFromPipelineRun(ctx, pr)

        for k, v := range prStrings </span><span class="cov8" title="1">{
                stringReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range prArrays </span><span class="cov8" title="1">{
                arrayReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range prObjects </span><span class="cov8" title="1">{
                objectReplacements[k] = v
        }</span>

        <span class="cov8" title="1">return ApplyReplacements(p, stringReplacements, arrayReplacements, objectReplacements)</span>
}

func paramsFromPipelineRun(ctx context.Context, pr *v1.PipelineRun) (map[string]string, map[string][]string, map[string]map[string]string) <span class="cov8" title="1">{
        // stringReplacements is used for standard single-string stringReplacements,
        // while arrayReplacements/objectReplacements contains arrays/objects that need to be further processed.
        stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        objectReplacements := map[string]map[string]string{}

        for _, p := range pr.Spec.Params </span><span class="cov8" title="1">{
                switch p.Value.Type </span>{
                case v1.ParamTypeArray:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                for i := range len(p.Value.ArrayVal) </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(pattern+"[%d]", p.Name, i)] = p.Value.ArrayVal[i]
                                }</span>
                                <span class="cov8" title="1">arrayReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.ArrayVal</span>
                        }
                case v1.ParamTypeObject:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                objectReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.ObjectVal
                        }</span>
                        <span class="cov8" title="1">for k, v := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                                stringReplacements[fmt.Sprintf(objectIndividualVariablePattern, p.Name, k)] = v
                        }</span>
                case v1.ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                stringReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.StringVal
                        }</span>
                }
        }

        <span class="cov8" title="1">return stringReplacements, arrayReplacements, objectReplacements</span>
}

// GetContextReplacements returns the pipelineRun context which can be used to replace context variables in the specifications
func GetContextReplacements(pipelineName string, pr *v1.PipelineRun) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "context.pipelineRun.name":      pr.Name,
                "context.pipeline.name":         pipelineName,
                "context.pipelineRun.namespace": pr.Namespace,
                "context.pipelineRun.uid":       string(pr.ObjectMeta.UID),
        }
}</span>

// ApplyContexts applies the substitution from $(context.(pipelineRun|pipeline).*) with the specified values.
// Currently supports only name substitution. Uses "" as a default if name is not specified.
func ApplyContexts(spec *v1.PipelineSpec, pipelineName string, pr *v1.PipelineRun) *v1.PipelineSpec <span class="cov8" title="1">{
        for i := range spec.Tasks </span><span class="cov8" title="1">{
                spec.Tasks[i].DisplayName = substitution.ApplyReplacements(spec.Tasks[i].DisplayName, GetContextReplacements(pipelineName, pr))
        }</span>
        <span class="cov8" title="1">for i := range spec.Finally </span><span class="cov8" title="1">{
                spec.Finally[i].DisplayName = substitution.ApplyReplacements(spec.Finally[i].DisplayName, GetContextReplacements(pipelineName, pr))
        }</span>
        <span class="cov8" title="1">return ApplyReplacements(spec, GetContextReplacements(pipelineName, pr), map[string][]string{}, map[string]map[string]string{})</span>
}

// filterMatrixContextVar returns a list of params which contain any matrix context variables such as
// $(tasks.&lt;pipelineTaskName&gt;.matrix.length) and $(tasks.&lt;pipelineTaskName&gt;.matrix.&lt;resultName&gt;.length)
func filterMatrixContextVar(params v1.Params) v1.Params <span class="cov8" title="1">{
        var filteredParams v1.Params
        for _, param := range params </span><span class="cov8" title="1">{
                if expressions, ok := param.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        for _, expression := range expressions </span><span class="cov8" title="1">{
                                // tasks.&lt;pipelineTaskName&gt;.matrix.length
                                // tasks.&lt;pipelineTaskName&gt;.matrix.&lt;resultName&gt;.length
                                subExpressions := strings.Split(expression, ".")
                                if len(subExpressions) &gt;= 4 &amp;&amp; subExpressions[2] == "matrix" &amp;&amp; subExpressions[len(subExpressions)-1] == "length" </span><span class="cov8" title="1">{
                                        filteredParams = append(filteredParams, param)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return filteredParams</span>
}

// ApplyPipelineTaskContexts applies the substitution from $(context.pipelineTask.*) with the specified values.
// Uses "0" as a default if a value is not available as well as matrix context variables
// $(tasks.&lt;pipelineTaskName&gt;.matrix.length) and $(tasks.&lt;pipelineTaskName&gt;.matrix.&lt;resultName&gt;.length)
func ApplyPipelineTaskContexts(pt *v1.PipelineTask, pipelineRunStatus v1.PipelineRunStatus, facts *PipelineRunFacts) *v1.PipelineTask <span class="cov8" title="1">{
        pt = pt.DeepCopy()
        var pipelineTaskName string
        var resultName string
        var matrixLength int

        replacements := map[string]string{
                "context.pipelineTask.retries": strconv.Itoa(pt.Retries),
        }

        filteredParams := filterMatrixContextVar(pt.Params)

        for _, p := range filteredParams </span><span class="cov8" title="1">{
                pipelineTaskName, resultName = p.ParseTaskandResultName()
                // find the referenced pipelineTask to count the matrix combinations
                if pipelineTaskName != "" &amp;&amp; pipelineRunStatus.PipelineSpec != nil </span><span class="cov8" title="1">{
                        for _, task := range pipelineRunStatus.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                                if task.Name == pipelineTaskName </span><span class="cov8" title="1">{
                                        matrixLength = task.Matrix.CountCombinations()
                                        replacements["tasks."+pipelineTaskName+".matrix.length"] = strconv.Itoa(matrixLength)
                                        continue</span>
                                }
                        }
                }
                // find the resultName from the ResultsCache
                <span class="cov8" title="1">if pipelineTaskName != "" &amp;&amp; resultName != "" </span><span class="cov8" title="1">{
                        for _, pt := range facts.State </span><span class="cov8" title="1">{
                                if pt.PipelineTask.Name == pipelineTaskName </span><span class="cov8" title="1">{
                                        if len(pt.ResultsCache) == 0 </span><span class="cov8" title="1">{
                                                pt.ResultsCache = createResultsCacheMatrixedTaskRuns(pt)
                                        }</span>
                                        <span class="cov8" title="1">resultLength := len(pt.ResultsCache[resultName])
                                        replacements["tasks."+pipelineTaskName+".matrix."+resultName+".length"] = strconv.Itoa(resultLength)
                                        continue</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">pt.Params = pt.Params.ReplaceVariables(replacements, map[string][]string{}, map[string]map[string]string{})
        if pt.IsMatrixed() </span><span class="cov8" title="1">{
                pt.Matrix.Params = pt.Matrix.Params.ReplaceVariables(replacements, map[string][]string{}, map[string]map[string]string{})
                for i := range pt.Matrix.Include </span><span class="cov8" title="1">{
                        pt.Matrix.Include[i].Params = pt.Matrix.Include[i].Params.ReplaceVariables(replacements, map[string][]string{}, map[string]map[string]string{})
                }</span>
        }
        <span class="cov8" title="1">pt.DisplayName = substitution.ApplyReplacements(pt.DisplayName, replacements)
        return pt</span>
}

// ApplyTaskResults applies the ResolvedResultRef to each PipelineTask.Params and Pipeline.When in targets
func ApplyTaskResults(targets PipelineRunState, resolvedResultRefs ResolvedResultRefs) <span class="cov8" title="1">{
        stringReplacements := resolvedResultRefs.getStringReplacements()
        arrayReplacements := resolvedResultRefs.getArrayReplacements()
        objectReplacements := resolvedResultRefs.getObjectReplacements()
        for _, resolvedPipelineRunTask := range targets </span><span class="cov8" title="1">{
                if resolvedPipelineRunTask.PipelineTask != nil </span><span class="cov8" title="1">{
                        pipelineTask := resolvedPipelineRunTask.PipelineTask.DeepCopy()
                        pipelineTask.Params = pipelineTask.Params.ReplaceVariables(stringReplacements, arrayReplacements, objectReplacements)
                        if pipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                                // Matrixed pipeline results replacements support:
                                // 1. String replacements from string, array or object results
                                // 2. array replacements from array results are supported
                                pipelineTask.Matrix.Params = pipelineTask.Matrix.Params.ReplaceVariables(stringReplacements, arrayReplacements, nil)
                                for i := range pipelineTask.Matrix.Include </span><span class="cov8" title="1">{
                                        // matrix include parameters can only be type string
                                        pipelineTask.Matrix.Include[i].Params = pipelineTask.Matrix.Include[i].Params.ReplaceVariables(stringReplacements, nil, nil)
                                }</span>
                        }
                        <span class="cov8" title="1">pipelineTask.When = pipelineTask.When.ReplaceVariables(stringReplacements, arrayReplacements)
                        if pipelineTask.TaskRef != nil </span><span class="cov8" title="1">{
                                if pipelineTask.TaskRef.Params != nil </span><span class="cov8" title="1">{
                                        pipelineTask.TaskRef.Params = pipelineTask.TaskRef.Params.ReplaceVariables(stringReplacements, arrayReplacements, objectReplacements)
                                }</span>
                                <span class="cov8" title="1">pipelineTask.TaskRef.Name = substitution.ApplyReplacements(pipelineTask.TaskRef.Name, stringReplacements)</span>
                        }
                        <span class="cov8" title="1">pipelineTask.DisplayName = substitution.ApplyReplacements(pipelineTask.DisplayName, stringReplacements)
                        for i, workspace := range pipelineTask.Workspaces </span><span class="cov8" title="1">{
                                pipelineTask.Workspaces[i].SubPath = substitution.ApplyReplacements(workspace.SubPath, stringReplacements)
                        }</span>
                        <span class="cov8" title="1">resolvedPipelineRunTask.PipelineTask = pipelineTask</span>
                }
        }
}

// ApplyPipelineTaskStateContext replaces context variables referring to execution status with the specified status
func ApplyPipelineTaskStateContext(state PipelineRunState, replacements map[string]string) <span class="cov8" title="1">{
        for _, resolvedPipelineRunTask := range state </span><span class="cov8" title="1">{
                if resolvedPipelineRunTask.PipelineTask != nil </span><span class="cov8" title="1">{
                        pipelineTask := resolvedPipelineRunTask.PipelineTask.DeepCopy()
                        pipelineTask.Params = pipelineTask.Params.ReplaceVariables(replacements, nil, nil)
                        pipelineTask.When = pipelineTask.When.ReplaceVariables(replacements, nil)
                        if pipelineTask.TaskRef != nil </span><span class="cov8" title="1">{
                                if pipelineTask.TaskRef.Params != nil </span><span class="cov0" title="0">{
                                        pipelineTask.TaskRef.Params = pipelineTask.TaskRef.Params.ReplaceVariables(replacements, nil, nil)
                                }</span>
                                <span class="cov8" title="1">pipelineTask.TaskRef.Name = substitution.ApplyReplacements(pipelineTask.TaskRef.Name, replacements)</span>
                        }
                        <span class="cov8" title="1">pipelineTask.DisplayName = substitution.ApplyReplacements(pipelineTask.DisplayName, replacements)
                        resolvedPipelineRunTask.PipelineTask = pipelineTask</span>
                }
        }
}

// ApplyWorkspaces replaces workspace variables in the given pipeline spec with their
// concrete values.
func ApplyWorkspaces(p *v1.PipelineSpec, pr *v1.PipelineRun) *v1.PipelineSpec <span class="cov8" title="1">{
        p = p.DeepCopy()
        replacements := map[string]string{}
        for _, declaredWorkspace := range p.Workspaces </span><span class="cov8" title="1">{
                key := fmt.Sprintf("workspaces.%s.bound", declaredWorkspace.Name)
                replacements[key] = "false"
        }</span>
        <span class="cov8" title="1">for _, boundWorkspace := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                key := fmt.Sprintf("workspaces.%s.bound", boundWorkspace.Name)
                replacements[key] = "true"
        }</span>
        <span class="cov8" title="1">return ApplyReplacements(p, replacements, map[string][]string{}, map[string]map[string]string{})</span>
}

// replaceVariablesInPipelineTasks handles variable replacement for a slice of PipelineTasks in-place
func replaceVariablesInPipelineTasks(tasks []v1.PipelineTask, replacements map[string]string,
        arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) <span class="cov8" title="1">{
        for i := range tasks </span><span class="cov8" title="1">{
                tasks[i].Params = tasks[i].Params.ReplaceVariables(replacements, arrayReplacements, objectReplacements)
                if tasks[i].IsMatrixed() </span><span class="cov8" title="1">{
                        tasks[i].Matrix.Params = tasks[i].Matrix.Params.ReplaceVariables(replacements, arrayReplacements, nil)
                        for j := range tasks[i].Matrix.Include </span><span class="cov8" title="1">{
                                tasks[i].Matrix.Include[j].Params = tasks[i].Matrix.Include[j].Params.ReplaceVariables(replacements, nil, nil)
                        }</span>
                } else<span class="cov8" title="1"> {
                        tasks[i].DisplayName = substitution.ApplyReplacements(tasks[i].DisplayName, replacements)
                }</span>
                <span class="cov8" title="1">for j := range tasks[i].Workspaces </span><span class="cov8" title="1">{
                        tasks[i].Workspaces[j].SubPath = substitution.ApplyReplacements(tasks[i].Workspaces[j].SubPath, replacements)
                }</span>
                <span class="cov8" title="1">tasks[i].When = tasks[i].When.ReplaceVariables(replacements, arrayReplacements)
                if tasks[i].TaskRef != nil </span><span class="cov8" title="1">{
                        if tasks[i].TaskRef.Params != nil </span><span class="cov8" title="1">{
                                tasks[i].TaskRef.Params = tasks[i].TaskRef.Params.ReplaceVariables(replacements, arrayReplacements, objectReplacements)
                        }</span>
                        <span class="cov8" title="1">tasks[i].TaskRef.Name = substitution.ApplyReplacements(tasks[i].TaskRef.Name, replacements)</span>
                }
                <span class="cov8" title="1">tasks[i].OnError = v1.PipelineTaskOnErrorType(substitution.ApplyReplacements(string(tasks[i].OnError), replacements))
                tasks[i] = propagateParams(tasks[i], replacements, arrayReplacements, objectReplacements)</span>
        }
}

// ApplyReplacements replaces placeholders for declared parameters with the specified replacements.
func ApplyReplacements(p *v1.PipelineSpec, replacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) *v1.PipelineSpec <span class="cov8" title="1">{
        p = p.DeepCopy()

        // Replace variables in Tasks and Finally tasks
        replaceVariablesInPipelineTasks(p.Tasks, replacements, arrayReplacements, objectReplacements)
        replaceVariablesInPipelineTasks(p.Finally, replacements, arrayReplacements, objectReplacements)

        return p
}</span>

// propagateParams returns a Pipeline Task spec that is the same as the input Pipeline Task spec, but with
// all parameter replacements from `stringReplacements`, `arrayReplacements`, and `objectReplacements` substituted.
// It does not modify `stringReplacements`, `arrayReplacements`, or `objectReplacements`.
func propagateParams(t v1.PipelineTask, stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) v1.PipelineTask <span class="cov8" title="1">{
        if t.TaskSpec == nil </span><span class="cov8" title="1">{
                return t
        }</span>
        // check if there are task parameters defined that match the params at pipeline level
        <span class="cov8" title="1">if len(t.Params) &gt; 0 </span><span class="cov8" title="1">{
                stringReplacementsDup := make(map[string]string)
                arrayReplacementsDup := make(map[string][]string)
                objectReplacementsDup := make(map[string]map[string]string)
                for k, v := range stringReplacements </span><span class="cov8" title="1">{
                        stringReplacementsDup[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range arrayReplacements </span><span class="cov8" title="1">{
                        arrayReplacementsDup[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range objectReplacements </span><span class="cov8" title="1">{
                        objectReplacementsDup[k] = v
                }</span>
                <span class="cov8" title="1">for _, par := range t.Params </span><span class="cov8" title="1">{
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                checkName := fmt.Sprintf(pattern, par.Name)
                                // Scoping. Task Params will replace Pipeline Params
                                if _, ok := stringReplacementsDup[checkName]; ok </span><span class="cov8" title="1">{
                                        stringReplacementsDup[checkName] = par.Value.StringVal
                                }</span>
                                <span class="cov8" title="1">if _, ok := arrayReplacementsDup[checkName]; ok </span><span class="cov8" title="1">{
                                        arrayReplacementsDup[checkName] = par.Value.ArrayVal
                                }</span>
                                <span class="cov8" title="1">if _, ok := objectReplacementsDup[checkName]; ok </span><span class="cov8" title="1">{
                                        objectReplacementsDup[checkName] = par.Value.ObjectVal
                                        for k, v := range par.Value.ObjectVal </span><span class="cov8" title="1">{
                                                stringReplacementsDup[fmt.Sprintf(objectIndividualVariablePattern, par.Name, k)] = v
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">t.TaskSpec.TaskSpec = *resources.ApplyReplacements(&amp;t.TaskSpec.TaskSpec, stringReplacementsDup, arrayReplacementsDup, objectReplacementsDup)</span>
        } else<span class="cov8" title="1"> {
                t.TaskSpec.TaskSpec = *resources.ApplyReplacements(&amp;t.TaskSpec.TaskSpec, stringReplacements, arrayReplacements, objectReplacements)
        }</span>
        <span class="cov8" title="1">return t</span>
}

// ApplyResultsToWorkspaceBindings applies results from TaskRuns to  WorkspaceBindings in a PipelineRun. It replaces placeholders in
// various binding types with values from TaskRun results.
func ApplyResultsToWorkspaceBindings(trResults map[string][]v1.TaskRunResult, pr *v1.PipelineRun) <span class="cov8" title="1">{
        stringReplacements := map[string]string{}
        for taskName, taskResults := range trResults </span><span class="cov8" title="1">{
                for _, res := range taskResults </span><span class="cov8" title="1">{
                        switch res.Type </span>{
                        case v1.ResultsTypeString:<span class="cov8" title="1">
                                stringReplacements[fmt.Sprintf("tasks.%s.results.%s", taskName, res.Name)] = res.Value.StringVal</span>
                        case v1.ResultsTypeArray:<span class="cov8" title="1">
                                continue</span>
                        case v1.ResultsTypeObject:<span class="cov8" title="1">
                                for k, v := range res.Value.ObjectVal </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf("tasks.%s.results.%s.%s", taskName, res.Name, k)] = v
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">pr.Spec.Workspaces = workspace.ReplaceWorkspaceBindingsVars(pr.Spec.Workspaces, stringReplacements)</span>
}

// PropagateResults propagate the result of the completed task to the unfinished task that is not explicitly specify in the params
func PropagateResults(rpt *ResolvedPipelineTask, runStates PipelineRunState) <span class="cov8" title="1">{
        if rpt.ResolvedTask == nil || rpt.ResolvedTask.TaskSpec == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        for taskName, taskResults := range runStates.GetTaskRunsResults() </span><span class="cov8" title="1">{
                for _, res := range taskResults </span><span class="cov8" title="1">{
                        switch res.Type </span>{
                        case v1.ResultsTypeString:<span class="cov8" title="1">
                                stringReplacements[fmt.Sprintf("tasks.%s.results.%s", taskName, res.Name)] = res.Value.StringVal</span>
                        case v1.ResultsTypeArray:<span class="cov8" title="1">
                                arrayReplacements[fmt.Sprintf("tasks.%s.results.%s", taskName, res.Name)] = res.Value.ArrayVal</span>
                        case v1.ResultsTypeObject:<span class="cov8" title="1">
                                for k, v := range res.Value.ObjectVal </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf("tasks.%s.results.%s.%s", taskName, res.Name, k)] = v
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">rpt.ResolvedTask.TaskSpec = resources.ApplyReplacements(rpt.ResolvedTask.TaskSpec, stringReplacements, arrayReplacements, map[string]map[string]string{})</span>
}

// PropagateArtifacts propagates artifact values from previous task runs into the TaskSpec of the current task.
func PropagateArtifacts(rpt *ResolvedPipelineTask, runStates PipelineRunState) error <span class="cov8" title="1">{
        if rpt.ResolvedTask == nil || rpt.ResolvedTask.TaskSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">stringReplacements := map[string]string{}
        for taskName, artifacts := range runStates.GetTaskRunsArtifacts() </span><span class="cov8" title="1">{
                if artifacts != nil </span><span class="cov8" title="1">{
                        for i, input := range artifacts.Inputs </span><span class="cov8" title="1">{
                                ib, err := json.Marshal(input.Values)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">stringReplacements[fmt.Sprintf("tasks.%s.inputs.%s", taskName, input.Name)] = string(ib)
                                if i == 0 </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf("tasks.%s.inputs", taskName)] = string(ib)
                                }</span>
                        }
                        <span class="cov8" title="1">for i, output := range artifacts.Outputs </span><span class="cov8" title="1">{
                                ob, err := json.Marshal(output.Values)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">stringReplacements[fmt.Sprintf("tasks.%s.outputs.%s", taskName, output.Name)] = string(ob)
                                if i == 0 </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf("tasks.%s.outputs", taskName)] = string(ob)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">rpt.ResolvedTask.TaskSpec = resources.ApplyReplacements(rpt.ResolvedTask.TaskSpec, stringReplacements, map[string][]string{}, map[string]map[string]string{})
        return nil</span>
}

// ApplyTaskResultsToPipelineResults applies the results of completed TasksRuns and Runs to a Pipeline's
// list of PipelineResults, returning the computed set of PipelineRunResults. References to
// non-existent TaskResults or failed TaskRuns or Runs result in a PipelineResult being considered invalid
// and omitted from the returned slice. A nil slice is returned if no results are passed in or all
// results are invalid.
func ApplyTaskResultsToPipelineResults(
        _ context.Context,
        results []v1.PipelineResult,
        taskRunResults map[string][]v1.TaskRunResult,
        customTaskResults map[string][]v1beta1.CustomRunResult,
        taskstatus map[string]string,
) ([]v1.PipelineRunResult, error) <span class="cov8" title="1">{
        var runResults []v1.PipelineRunResult
        var invalidPipelineResults []string

        stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        objectReplacements := map[string]map[string]string{}
        for _, pipelineResult := range results </span><span class="cov8" title="1">{
                variablesInPipelineResult, _ := pipelineResult.GetVarSubstitutionExpressions()
                if len(variablesInPipelineResult) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">validPipelineResult := true
                for _, variable := range variablesInPipelineResult </span><span class="cov8" title="1">{
                        if _, isMemoized := stringReplacements[variable]; isMemoized </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, isMemoized := arrayReplacements[variable]; isMemoized </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, isMemoized := objectReplacements[variable]; isMemoized </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">variableParts := strings.Split(variable, ".")

                        if (variableParts[0] != v1.ResultTaskPart &amp;&amp; variableParts[0] != v1.ResultFinallyPart) || variableParts[2] != v1beta1.ResultResultPart </span><span class="cov8" title="1">{
                                validPipelineResult = false
                                invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">switch len(variableParts) </span>{
                        // For string result: tasks.&lt;taskName&gt;.results.&lt;stringResultName&gt;
                        // For array result: tasks.&lt;taskName&gt;.results.&lt;arrayResultName&gt;[*], tasks.&lt;taskName&gt;.results.&lt;arrayResultName&gt;[i]
                        // For object result: tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;[*],
                        case resultsParseNumber:<span class="cov8" title="1">
                                taskName, resultName := variableParts[1], variableParts[3]
                                resultName, stringIdx := v1.ParseResultName(resultName)
                                if resultValue := taskResultValue(taskName, resultName, taskRunResults); resultValue != nil </span><span class="cov8" title="1">{
                                        switch resultValue.Type </span>{
                                        case v1.ParamTypeString:<span class="cov8" title="1">
                                                stringReplacements[variable] = resultValue.StringVal</span>
                                        case v1.ParamTypeArray:<span class="cov8" title="1">
                                                if stringIdx != "*" </span><span class="cov8" title="1">{
                                                        intIdx, _ := strconv.Atoi(stringIdx)
                                                        if intIdx &lt; len(resultValue.ArrayVal) </span><span class="cov8" title="1">{
                                                                stringReplacements[variable] = resultValue.ArrayVal[intIdx]
                                                        }</span> else<span class="cov8" title="1"> {
                                                                // referred array index out of bound
                                                                invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                                                validPipelineResult = false
                                                        }</span>
                                                } else<span class="cov8" title="1"> {
                                                        arrayReplacements[substitution.StripStarVarSubExpression(variable)] = resultValue.ArrayVal
                                                }</span>
                                        case v1.ParamTypeObject:<span class="cov8" title="1">
                                                objectReplacements[substitution.StripStarVarSubExpression(variable)] = resultValue.ObjectVal</span>
                                        }
                                } else<span class="cov8" title="1"> if resultValue := runResultValue(taskName, resultName, customTaskResults); resultValue != nil </span><span class="cov8" title="1">{
                                        stringReplacements[variable] = *resultValue
                                }</span> else<span class="cov8" title="1"> {
                                        // if the task is not successful (e.g. skipped or failed) and the results is missing, don't return error
                                        if status, ok := taskstatus[PipelineTaskStatusPrefix+taskName+PipelineTaskStatusSuffix]; ok </span><span class="cov8" title="1">{
                                                if status != v1.TaskRunReasonSuccessful.String() </span><span class="cov8" title="1">{
                                                        validPipelineResult = false
                                                        continue</span>
                                                }
                                        }
                                        // referred result name is not existent
                                        <span class="cov8" title="1">invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                        validPipelineResult = false</span>
                                }
                        // For object type result: tasks.&lt;taskName&gt;.results.&lt;objectResultName&gt;.&lt;individualAttribute&gt;
                        case objectElementResultsParseNumber:<span class="cov8" title="1">
                                taskName, resultName, objectKey := variableParts[1], variableParts[3], variableParts[4]
                                resultName, _ = v1.ParseResultName(resultName)
                                if resultValue := taskResultValue(taskName, resultName, taskRunResults); resultValue != nil </span><span class="cov8" title="1">{
                                        if _, ok := resultValue.ObjectVal[objectKey]; ok </span><span class="cov8" title="1">{
                                                stringReplacements[variable] = resultValue.ObjectVal[objectKey]
                                        }</span> else<span class="cov8" title="1"> {
                                                // referred object key is not existent
                                                invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                                validPipelineResult = false
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // if the task is not successful (e.g. skipped or failed) and the results is missing, don't return error
                                        if status, ok := taskstatus[PipelineTaskStatusPrefix+taskName+PipelineTaskStatusSuffix]; ok </span><span class="cov8" title="1">{
                                                if status != v1.TaskRunReasonSuccessful.String() </span><span class="cov8" title="1">{
                                                        validPipelineResult = false
                                                        continue</span>
                                                }
                                        }
                                        // referred result name is not existent
                                        <span class="cov8" title="1">invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                        validPipelineResult = false</span>
                                }
                        default:<span class="cov8" title="1">
                                invalidPipelineResults = append(invalidPipelineResults, pipelineResult.Name)
                                validPipelineResult = false</span>
                        }
                }
                <span class="cov8" title="1">if validPipelineResult </span><span class="cov8" title="1">{
                        finalValue := pipelineResult.Value
                        finalValue.ApplyReplacements(stringReplacements, arrayReplacements, objectReplacements)
                        runResults = append(runResults, v1.PipelineRunResult{
                                Name:  pipelineResult.Name,
                                Value: finalValue,
                        })
                }</span>
        }

        <span class="cov8" title="1">if len(invalidPipelineResults) &gt; 0 </span><span class="cov8" title="1">{
                return runResults, fmt.Errorf("invalid pipelineresults %v, the referenced results don't exist", invalidPipelineResults)
        }</span>

        <span class="cov8" title="1">return runResults, nil</span>
}

// taskResultValue returns the result value for a given pipeline task name and result name in a map of TaskRunResults for
// pipeline task names. It returns nil if either the pipeline task name isn't present in the map, or if there is no
// result with the result name in the pipeline task name's slice of results.
func taskResultValue(taskName string, resultName string, taskResults map[string][]v1.TaskRunResult) *v1.ResultValue <span class="cov8" title="1">{
        for _, trResult := range taskResults[taskName] </span><span class="cov8" title="1">{
                if trResult.Name == resultName </span><span class="cov8" title="1">{
                        return &amp;trResult.Value
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// runResultValue returns the result value for a given pipeline task name and result name in a map of RunResults for
// pipeline task names. It returns nil if either the pipeline task name isn't present in the map, or if there is no
// result with the result name in the pipeline task name's slice of results.
func runResultValue(taskName string, resultName string, runResults map[string][]v1beta1.CustomRunResult) *string <span class="cov8" title="1">{
        for _, runResult := range runResults[taskName] </span><span class="cov8" title="1">{
                if runResult.Name == resultName </span><span class="cov8" title="1">{
                        return &amp;runResult.Value
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ApplyParametersToWorkspaceBindings applies parameters from PipelineSpec and  PipelineRun to the WorkspaceBindings in a PipelineRun. It replaces
// placeholders in various binding types with values from provided parameters.
func ApplyParametersToWorkspaceBindings(ctx context.Context, pr *v1.PipelineRun) <span class="cov8" title="1">{
        parameters, _, _ := paramsFromPipelineRun(ctx, pr)
        pr.Spec.Workspaces = workspace.ReplaceWorkspaceBindingsVars(pr.Spec.Workspaces, parameters)
}</span>
</pre>
		
		<pre class="file" id="file443" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "errors"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        resolutionV1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "github.com/tektoncd/pipeline/pkg/reconciler/apiserver"
        rprp "github.com/tektoncd/pipeline/pkg/reconciler/pipelinerun/pipelinespec"
        "github.com/tektoncd/pipeline/pkg/remote"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/remote/resolution"
        remoteresource "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
)

// GetPipelineFunc is a factory function that will use the given PipelineRef to return a valid GetPipeline function that
// looks up the pipeline. It uses as context a k8s client, tekton client, namespace, and service account name to return
// the pipeline. It knows whether it needs to look in the cluster or in a remote location to fetch the reference.
// OCI bundle and remote resolution pipelines will be verified by trusted resources if the feature is enabled
func GetPipelineFunc(ctx context.Context, k8s kubernetes.Interface, tekton clientset.Interface, requester remoteresource.Requester, pipelineRun *v1.PipelineRun, verificationPolicies []*v1alpha1.VerificationPolicy) rprp.GetPipeline <span class="cov8" title="1">{
        pr := pipelineRun.Spec.PipelineRef
        namespace := pipelineRun.Namespace
        // if the spec is already in the status, do not try to fetch it again, just use it as source of truth.
        // Same for the RefSource field in the Status.Provenance.
        if pipelineRun.Status.PipelineSpec != nil </span><span class="cov8" title="1">{
                return func(_ context.Context, name string) (*v1.Pipeline, *v1.RefSource, *trustedresources.VerificationResult, error) </span><span class="cov8" title="1">{
                        var refSource *v1.RefSource
                        if pipelineRun.Status.Provenance != nil </span><span class="cov8" title="1">{
                                refSource = pipelineRun.Status.Provenance.RefSource
                        }</span>
                        <span class="cov8" title="1">return &amp;v1.Pipeline{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      name,
                                        Namespace: namespace,
                                },
                                Spec: *pipelineRun.Status.PipelineSpec,
                        }, refSource, nil, nil</span>
                }
        }

        <span class="cov8" title="1">switch </span>{
        case pr != nil &amp;&amp; pr.Resolver != "" &amp;&amp; requester != nil:<span class="cov8" title="1">
                return func(ctx context.Context, name string) (*v1.Pipeline, *v1.RefSource, *trustedresources.VerificationResult, error) </span><span class="cov8" title="1">{
                        stringReplacements, arrayReplacements, objectReplacements := paramsFromPipelineRun(ctx, pipelineRun)
                        for k, v := range GetContextReplacements("", pipelineRun) </span><span class="cov8" title="1">{
                                stringReplacements[k] = v
                        }</span>
                        <span class="cov8" title="1">replacedParams := pr.Params.ReplaceVariables(stringReplacements, arrayReplacements, objectReplacements)
                        var url string
                        // The name is url-like so its not a local reference.
                        if err := v1.RefNameLikeUrl(pr.Name); err == nil </span><span class="cov8" title="1">{
                                // apply variable replacements in the name.
                                pr.Name = substitution.ApplyReplacements(pr.Name, stringReplacements)
                                url = pr.Name
                        }</span>
                        <span class="cov8" title="1">resolverPayload := remoteresource.ResolverPayload{
                                ResolutionSpec: &amp;resolutionV1beta1.ResolutionRequestSpec{
                                        Params: replacedParams,
                                        URL:    url,
                                },
                        }
                        resolver := resolution.NewResolver(requester, pipelineRun, string(pr.Resolver), resolverPayload)
                        return resolvePipeline(ctx, resolver, name, namespace, k8s, tekton, verificationPolicies)</span>
                }
        default:<span class="cov8" title="1">
                // Even if there is no pipeline ref, we should try to return a local resolver.
                local := &amp;LocalPipelineRefResolver{
                        Namespace:    namespace,
                        Tektonclient: tekton,
                }
                return local.GetPipeline</span>
        }
}

// LocalPipelineRefResolver uses the current cluster to resolve a pipeline reference.
type LocalPipelineRefResolver struct {
        Namespace    string
        Tektonclient clientset.Interface
}

// GetPipeline will resolve a Pipeline from the local cluster using a versioned Tekton client. It will
// return an error if it can't find an appropriate Pipeline for any reason.
// TODO: if we want to set RefSource for in-cluster pipeline, set it here.
// https://github.com/tektoncd/pipeline/issues/5522
// TODO(#6666): Support local resources verification
func (l *LocalPipelineRefResolver) GetPipeline(ctx context.Context, name string) (*v1.Pipeline, *v1.RefSource, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        // If we are going to resolve this reference locally, we need a namespace scope.
        if l.Namespace == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("must specify namespace to resolve reference to pipeline %s", name)
        }</span>

        <span class="cov8" title="1">pipeline, err := l.Tektonclient.TektonV1().Pipelines(l.Namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, fmt.Errorf("tekton client cannot get pipeline %s from local cluster: %w", name, err)
        }</span>
        <span class="cov8" title="1">return pipeline, nil, nil, nil</span>
}

// resolvePipeline accepts an impl of remote.Resolver and attempts to
// fetch a pipeline with given name and verify the v1beta1 pipeline if trusted resources is enabled.
// An error is returned if the remoteresource doesn't work
// A VerificationResult is returned if trusted resources is enabled, VerificationResult contains the result type and err.
// or the returned data isn't a valid *v1.Pipeline.
func resolvePipeline(ctx context.Context, resolver remote.Resolver, name string, namespace string, k8s kubernetes.Interface, tekton clientset.Interface, verificationPolicies []*v1alpha1.VerificationPolicy) (*v1.Pipeline, *v1.RefSource, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        obj, refSource, err := resolver.Get(ctx, "pipeline", name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, fmt.Errorf("resolver failed to get Pipeline %s: %w", name, err)
        }</span>
        <span class="cov8" title="1">pipelineObj, vr, err := readRuntimeObjectAsPipeline(ctx, namespace, obj, k8s, tekton, refSource, verificationPolicies)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, fmt.Errorf("failed to read runtime object as Pipeline: %w", err)
        }</span>
        <span class="cov8" title="1">return pipelineObj, refSource, vr, nil</span>
}

// readRuntimeObjectAsPipeline tries to convert a generic runtime.Object
// into a *v1.Pipeline type so that its meta and spec fields
// can be read. v1 object will be converted to v1beta1 and returned.
// v1beta1 Pipeline will be verified if trusted resources is enabled
// A VerificationResult is returned if trusted resources is enabled, VerificationResult contains the result type and err.
// An error is returned if the given object is not a
// PipelineObject or if there is an error validating or upgrading an
// older PipelineObject into its v1beta1 equivalent.
// TODO(#5541): convert v1beta1 obj to v1 once we use v1 as the stored version
func readRuntimeObjectAsPipeline(ctx context.Context, namespace string, obj runtime.Object, k8s kubernetes.Interface, tekton clientset.Interface, refSource *v1.RefSource, verificationPolicies []*v1alpha1.VerificationPolicy) (*v1.Pipeline, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        switch obj := obj.(type) </span>{
        case *v1beta1.Pipeline:<span class="cov8" title="1">
                obj.SetDefaults(ctx)
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                // Verify the Pipeline once we fetch from the remote resolution, mutating, validation and conversion of the pipeline should happen after the verification, since signatures are based on the remote pipeline contents
                vr := trustedresources.VerifyResource(ctx, obj, k8s, refSource, verificationPolicies)
                // Issue a dry-run request to create the remote Pipeline, so that it can undergo validation from validating admission webhooks
                // and mutation from mutating admission webhooks without actually creating the Pipeline on the cluster
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedPipeline, ok := o.(*v1beta1.Pipeline); ok </span><span class="cov8" title="1">{
                        mutatedPipeline.ObjectMeta = obj.ObjectMeta
                        p := &amp;v1.Pipeline{
                                TypeMeta: metav1.TypeMeta{
                                        Kind:       "Pipeline",
                                        APIVersion: "tekton.dev/v1",
                                },
                        }
                        if err := mutatedPipeline.ConvertTo(ctx, p); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("failed to convert v1beta1 obj %s into v1 Pipeline", mutatedPipeline.GetObjectKind().GroupVersionKind().String())
                        }</span>
                        <span class="cov8" title="1">return p, &amp;vr, nil</span>
                }
        case *v1.Pipeline:<span class="cov8" title="1">
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                // This SetDefaults is currently not necessary, but for consistency, it is recommended to add it.
                // Avoid forgetting to add it in the future when there is a v2 version, causing similar problems.
                obj.SetDefaults(ctx)
                vr := trustedresources.VerifyResource(ctx, obj, k8s, refSource, verificationPolicies)
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedPipeline, ok := o.(*v1.Pipeline); ok </span><span class="cov8" title="1">{
                        mutatedPipeline.ObjectMeta = obj.ObjectMeta
                        return mutatedPipeline, &amp;vr, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, nil, errors.New("resource is not a pipeline")</span>
}
</pre>
		
		<pre class="file" id="file444" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"
        "github.com/tektoncd/pipeline/pkg/remote"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resource"
        "github.com/tektoncd/pipeline/pkg/substitution"
        kerrors "k8s.io/apimachinery/pkg/api/errors"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmeta"
)

const (
        // ReasonConditionCheckFailed indicates that the reason for the failure status is that the
        // condition check associated to the pipeline task evaluated to false
        ReasonConditionCheckFailed = "ConditionCheckFailed"
)

// TaskSkipStatus stores whether a task was skipped and why
type TaskSkipStatus struct {
        IsSkipped      bool
        SkippingReason v1.SkippingReason
}

// TaskNotFoundError indicates that the resolution failed because a referenced Task couldn't be retrieved
type TaskNotFoundError struct {
        Name string
        Msg  string
}

func (e *TaskNotFoundError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Couldn't retrieve Task %q: %s", e.Name, e.Msg)
}</span>

// ResolvedPipelineTask contains a PipelineTask and its associated TaskRun(s) or CustomRuns, if they exist.
type ResolvedPipelineTask struct {
        TaskRunNames []string
        TaskRuns     []*v1.TaskRun
        ResolvedTask *resources.ResolvedTask

        // If the PipelineTask is a Custom Task, CustomRunName and CustomRun will be set.
        CustomTask     bool
        CustomRunNames []string
        CustomRuns     []*v1beta1.CustomRun

        PipelineTask *v1.PipelineTask
        ResultsCache map[string][]string

        // EvaluatedCEL is used to store the results of evaluated CEL expression
        EvaluatedCEL map[string]bool
}

// EvaluateCEL evaluate the CEL expressions, and store the evaluated results in EvaluatedCEL
func (t *ResolvedPipelineTask) EvaluateCEL() error <span class="cov8" title="1">{
        if t.PipelineTask != nil </span><span class="cov8" title="1">{
                // Each call to this function will reset this field to prevent additional CELs.
                t.EvaluatedCEL = make(map[string]bool)
                for _, we := range t.PipelineTask.When </span><span class="cov8" title="1">{
                        if we.CEL == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">_, ok := t.EvaluatedCEL[we.CEL]
                        if !ok </span><span class="cov8" title="1">{
                                // Create a program environment configured with the standard library of CEL functions and macros
                                // The error is omitted because not environment declarations are passed in.
                                env, _ := cel.NewEnv()
                                // Parse and Check the CEL to get the Abstract Syntax Tree
                                ast, iss := env.Compile(we.CEL)
                                if iss.Err() != nil </span><span class="cov8" title="1">{
                                        return iss.Err()
                                }</span>
                                // Generate an evaluatable instance of the Ast within the environment
                                <span class="cov8" title="1">prg, err := env.Program(ast)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                // Evaluate the CEL expression
                                <span class="cov8" title="1">out, _, err := prg.Eval(map[string]interface{}{})
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">b, ok := out.Value().(bool)
                                if ok </span><span class="cov8" title="1">{
                                        t.EvaluatedCEL[we.CEL] = b
                                }</span> else<span class="cov8" title="1"> {
                                        return fmt.Errorf("The CEL expression %s is not evaluated to a boolean", we.CEL)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isDone returns true only if the task is skipped, succeeded or failed
func (t ResolvedPipelineTask) isDone(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        return t.Skip(facts).IsSkipped || t.isSuccessful() || t.isFailure() || t.isValidationFailed(facts.ValidationFailedTask)
}</span>

// IsRunning returns true only if the task is neither succeeded, cancelled nor failed
func (t ResolvedPipelineTask) IsRunning() bool <span class="cov8" title="1">{
        if t.IsCustomTask() &amp;&amp; len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !t.IsCustomTask() &amp;&amp; len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !t.isSuccessful() &amp;&amp; !t.isFailure()</span>
}

// IsCustomTask returns true if the PipelineTask references a Custom Task.
func (t ResolvedPipelineTask) IsCustomTask() bool <span class="cov8" title="1">{
        return t.CustomTask
}</span>

// getReason returns the latest reason if the run has completed successfully
// If the PipelineTask has a Matrix, getReason returns the failure reason for any failure
// otherwise, it returns an empty string
func (t ResolvedPipelineTask) getReason() string <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                if len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">for _, run := range t.CustomRuns </span><span class="cov8" title="1">{
                        if !run.IsSuccessful() &amp;&amp; len(run.Status.Conditions) &gt;= 1 </span><span class="cov8" title="1">{
                                return run.Status.Conditions[0].Reason
                        }</span>
                }
                <span class="cov8" title="1">if len(t.CustomRuns) &gt;= 1 &amp;&amp; len(t.CustomRuns[0].Status.Conditions) &gt;= 1 </span><span class="cov8" title="1">{
                        return t.CustomRuns[0].Status.Conditions[0].Reason
                }</span>
        }

        <span class="cov8" title="1">if len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                if !taskRun.IsSuccessful() &amp;&amp; len(taskRun.Status.Conditions) &gt;= 1 </span><span class="cov8" title="1">{
                        return taskRun.Status.Conditions[0].Reason
                }</span>
        }
        <span class="cov8" title="1">if len(t.TaskRuns) &gt;= 1 &amp;&amp; len(t.TaskRuns[0].Status.Conditions) &gt;= 1 </span><span class="cov8" title="1">{
                return t.TaskRuns[0].Status.Conditions[0].Reason
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// isSuccessful returns true only if the run has completed successfully
// If the PipelineTask has a Matrix, isSuccessful returns true if all runs have completed successfully
func (t ResolvedPipelineTask) isSuccessful() bool <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                if len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">for _, run := range t.CustomRuns </span><span class="cov8" title="1">{
                        if !run.IsSuccessful() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">if len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                if !taskRun.IsSuccessful() </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// isFailure returns true only if the run has failed (if it has ConditionSucceeded = False).
// If the PipelineTask has a Matrix, isFailure returns true if any run has failed and all other runs are done.
func (t ResolvedPipelineTask) isFailure() bool <span class="cov8" title="1">{
        var isDone bool
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                if len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">isDone = true
                for _, run := range t.CustomRuns </span><span class="cov8" title="1">{
                        isDone = isDone &amp;&amp; run.IsDone()
                }</span>
                <span class="cov8" title="1">return t.haveAnyRunsFailed() &amp;&amp; isDone</span>
        }
        <span class="cov8" title="1">if len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">isDone = true
        for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                isDone = isDone &amp;&amp; taskRun.IsDone()
        }</span>
        <span class="cov8" title="1">return t.haveAnyTaskRunsFailed() &amp;&amp; isDone</span>
}

// isValidationFailed return true if the task is failed at the validation step
func (t ResolvedPipelineTask) isValidationFailed(ftasks []*ResolvedPipelineTask) bool <span class="cov8" title="1">{
        for _, ftask := range ftasks </span><span class="cov0" title="0">{
                if ftask.ResolvedTask == t.ResolvedTask </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isCancelledForTimeOut returns true only if the run is cancelled due to PipelineRun-controlled timeout
// If the PipelineTask has a Matrix, isCancelled returns true if any run is cancelled due to PipelineRun-controlled timeout and all other runs are done.
func (t ResolvedPipelineTask) isCancelledForTimeOut() bool <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                if len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">isDone := true
                atLeastOneCancelled := false
                for _, run := range t.CustomRuns </span><span class="cov8" title="1">{
                        isDone = isDone &amp;&amp; run.IsDone()
                        c := run.GetStatusCondition().GetCondition(apis.ConditionSucceeded)
                        runCancelled := c.IsFalse() &amp;&amp;
                                c.Reason == v1beta1.CustomRunReasonCancelled.String() &amp;&amp;
                                isCustomRunCancelledByPipelineRunTimeout(run)
                        atLeastOneCancelled = atLeastOneCancelled || runCancelled
                }</span>
                <span class="cov8" title="1">return atLeastOneCancelled &amp;&amp; isDone</span>
        }
        <span class="cov8" title="1">if len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">isDone := true
        atLeastOneCancelled := false
        for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                isDone = isDone &amp;&amp; taskRun.IsDone()
                c := taskRun.Status.GetCondition(apis.ConditionSucceeded)
                taskRunCancelled := c.IsFalse() &amp;&amp;
                        c.Reason == v1beta1.TaskRunReasonCancelled.String() &amp;&amp;
                        taskRun.Spec.StatusMessage == v1.TaskRunCancelledByPipelineTimeoutMsg
                atLeastOneCancelled = atLeastOneCancelled || taskRunCancelled
        }</span>
        <span class="cov8" title="1">return atLeastOneCancelled &amp;&amp; isDone</span>
}

// isCancelled returns true only if the run is cancelled
// If the PipelineTask has a Matrix, isCancelled returns true if any run is cancelled and all other runs are done.
func (t ResolvedPipelineTask) isCancelled() bool <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                if len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">isDone := true
                atLeastOneCancelled := false
                for _, run := range t.CustomRuns </span><span class="cov8" title="1">{
                        isDone = isDone &amp;&amp; run.IsDone()
                        c := run.GetStatusCondition().GetCondition(apis.ConditionSucceeded)
                        runCancelled := c.IsFalse() &amp;&amp; c.Reason == v1beta1.CustomRunReasonCancelled.String()
                        atLeastOneCancelled = atLeastOneCancelled || runCancelled
                }</span>
                <span class="cov8" title="1">return atLeastOneCancelled &amp;&amp; isDone</span>
        }
        <span class="cov8" title="1">if len(t.TaskRuns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">isDone := true
        atLeastOneCancelled := false
        for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                isDone = isDone &amp;&amp; taskRun.IsDone()
                c := taskRun.Status.GetCondition(apis.ConditionSucceeded)
                taskRunCancelled := c.IsFalse() &amp;&amp; c.Reason == v1beta1.TaskRunReasonCancelled.String()
                atLeastOneCancelled = atLeastOneCancelled || taskRunCancelled
        }</span>
        <span class="cov8" title="1">return atLeastOneCancelled &amp;&amp; isDone</span>
}

// isScheduled returns true when the PipelineRunTask itself has any TaskRuns/CustomRuns
// or a singular TaskRun/CustomRun associated.
func (t ResolvedPipelineTask) isScheduled() bool <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                return len(t.CustomRuns) &gt; 0
        }</span>
        <span class="cov8" title="1">return len(t.TaskRuns) &gt; 0</span>
}

// haveAnyRunsFailed returns true when any of the taskRuns/customRuns have succeeded condition with status set to false
func (t ResolvedPipelineTask) haveAnyRunsFailed() bool <span class="cov8" title="1">{
        if t.IsCustomTask() </span><span class="cov8" title="1">{
                return t.haveAnyCustomRunsFailed()
        }</span>

        <span class="cov8" title="1">return t.haveAnyTaskRunsFailed()</span>
}

// haveAnyTaskRunsFailed returns true when any of the TaskRuns have succeeded condition with status set to false
func (t ResolvedPipelineTask) haveAnyTaskRunsFailed() bool <span class="cov8" title="1">{
        for _, taskRun := range t.TaskRuns </span><span class="cov8" title="1">{
                if taskRun.IsFailure() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// haveAnyCustomRunsFailed returns true when any of the CustomRuns have succeeded condition with status set to false
func (t ResolvedPipelineTask) haveAnyCustomRunsFailed() bool <span class="cov8" title="1">{
        for _, customRun := range t.CustomRuns </span><span class="cov8" title="1">{
                if customRun.IsFailure() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (t *ResolvedPipelineTask) checkParentsDone(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if facts.isFinalTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">stateMap := facts.State.ToMap()
        node := facts.TasksGraph.Nodes[t.PipelineTask.Name]
        for _, p := range node.Prev </span><span class="cov8" title="1">{
                if !stateMap[p.Key].isDone(facts) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (t *ResolvedPipelineTask) skip(facts *PipelineRunFacts) TaskSkipStatus <span class="cov8" title="1">{
        var skippingReason v1.SkippingReason

        switch </span>{
        case facts.isFinalTask(t.PipelineTask.Name) || t.isScheduled() || t.isValidationFailed(facts.ValidationFailedTask):<span class="cov8" title="1">
                skippingReason = v1.None</span>
        case facts.IsStopping():<span class="cov8" title="1">
                skippingReason = v1.StoppingSkip</span>
        case facts.IsGracefullyCancelled():<span class="cov8" title="1">
                skippingReason = v1.GracefullyCancelledSkip</span>
        case facts.IsGracefullyStopped():<span class="cov8" title="1">
                skippingReason = v1.GracefullyStoppedSkip</span>
        case t.skipBecauseWhenExpressionsEvaluatedToFalse(facts):<span class="cov8" title="1">
                skippingReason = v1.WhenExpressionsSkip</span>
        case t.skipBecauseParentTaskWasSkipped(facts):<span class="cov8" title="1">
                skippingReason = v1.ParentTasksSkip</span>
        case t.skipBecauseResultReferencesAreMissing(facts):<span class="cov8" title="1">
                skippingReason = v1.MissingResultsSkip</span>
        case t.skipBecausePipelineRunPipelineTimeoutReached(facts):<span class="cov8" title="1">
                skippingReason = v1.PipelineTimedOutSkip</span>
        case t.skipBecausePipelineRunTasksTimeoutReached(facts):<span class="cov8" title="1">
                skippingReason = v1.TasksTimedOutSkip</span>
        case t.skipBecauseEmptyArrayInMatrixParams():<span class="cov8" title="1">
                skippingReason = v1.EmptyArrayInMatrixParams</span>
        default:<span class="cov8" title="1">
                skippingReason = v1.None</span>
        }

        <span class="cov8" title="1">return TaskSkipStatus{
                IsSkipped:      skippingReason != v1.None,
                SkippingReason: skippingReason,
        }</span>
}

// Skip returns true if a PipelineTask will not be run because
// (1) its When Expressions evaluated to false
// (2) its Condition Checks failed
// (3) its parent task was skipped
// (4) Pipeline is in stopping state (one of the PipelineTasks failed)
// (5) Pipeline is gracefully cancelled or stopped
func (t *ResolvedPipelineTask) Skip(facts *PipelineRunFacts) TaskSkipStatus <span class="cov8" title="1">{
        if facts.SkipCache == nil </span><span class="cov8" title="1">{
                facts.SkipCache = make(map[string]TaskSkipStatus)
        }</span>
        <span class="cov8" title="1">if _, cached := facts.SkipCache[t.PipelineTask.Name]; !cached </span><span class="cov8" title="1">{
                facts.SkipCache[t.PipelineTask.Name] = t.skip(facts)
        }</span>
        <span class="cov8" title="1">return facts.SkipCache[t.PipelineTask.Name]</span>
}

// skipBecauseWhenExpressionsEvaluatedToFalse confirms that the when expressions have completed evaluating, and
// it returns true if any of the when expressions evaluate to false
func (t *ResolvedPipelineTask) skipBecauseWhenExpressionsEvaluatedToFalse(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if t.checkParentsDone(facts) </span><span class="cov8" title="1">{
                if !t.PipelineTask.When.AllowsExecution(t.EvaluatedCEL) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// skipBecauseParentTaskWasSkipped loops through the parent tasks and checks if the parent task skipped:
//
//        if yes, is it because of when expressions?
//            if yes, it ignores this parent skip and continue evaluating other parent tasks
//            if no, it returns true to skip the current task because this parent task was skipped
//        if no, it continues checking the other parent tasks
func (t *ResolvedPipelineTask) skipBecauseParentTaskWasSkipped(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        stateMap := facts.State.ToMap()
        node := facts.TasksGraph.Nodes[t.PipelineTask.Name]
        for _, p := range node.Prev </span><span class="cov8" title="1">{
                parentTask := stateMap[p.Key]
                if parentSkipStatus := parentTask.Skip(facts); parentSkipStatus.IsSkipped </span><span class="cov8" title="1">{
                        // if the parent task was skipped due to its `when` expressions,
                        // then we should ignore that and continue evaluating if we should skip because of other parent tasks
                        if parentSkipStatus.SkippingReason == v1.WhenExpressionsSkip </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// skipBecauseResultReferencesAreMissing checks if the task references results that cannot be resolved, which is a
// reason for skipping the task, and applies result references if found
func (t *ResolvedPipelineTask) skipBecauseResultReferencesAreMissing(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if t.checkParentsDone(facts) &amp;&amp; t.hasResultReferences() </span><span class="cov8" title="1">{
                resolvedResultRefs, pt, err := ResolveResultRefs(facts.State, PipelineRunState{t})
                rpt := facts.State.ToMap()[pt]
                if rpt != nil </span><span class="cov8" title="1">{
                        if err != nil &amp;&amp;
                                (t.PipelineTask.OnError == v1.PipelineTaskContinue ||
                                        (t.IsFinalTask(facts) || rpt.Skip(facts).SkippingReason == v1.WhenExpressionsSkip)) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">ApplyTaskResults(PipelineRunState{t}, resolvedResultRefs)
                facts.ResetSkippedCache()</span>
        }
        <span class="cov8" title="1">return false</span>
}

// skipBecausePipelineRunPipelineTimeoutReached returns true if the task shouldn't be launched because the elapsed time since
// the PipelineRun started is greater than the PipelineRun's pipeline timeout
func (t *ResolvedPipelineTask) skipBecausePipelineRunPipelineTimeoutReached(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if t.checkParentsDone(facts) </span><span class="cov8" title="1">{
                if facts.TimeoutsState.PipelineTimeout != nil &amp;&amp; *facts.TimeoutsState.PipelineTimeout != config.NoTimeoutDuration &amp;&amp; facts.TimeoutsState.StartTime != nil </span><span class="cov8" title="1">{
                        // If the elapsed time since the PipelineRun's start time is greater than the PipelineRun's Pipeline timeout, skip.
                        return facts.TimeoutsState.Clock.Since(*facts.TimeoutsState.StartTime) &gt; *facts.TimeoutsState.PipelineTimeout
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// skipBecausePipelineRunTasksTimeoutReached returns true if the task shouldn't be launched because the elapsed time since
// the PipelineRun started is greater than the PipelineRun's tasks timeout
func (t *ResolvedPipelineTask) skipBecausePipelineRunTasksTimeoutReached(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if t.checkParentsDone(facts) &amp;&amp; !t.IsFinalTask(facts) </span><span class="cov8" title="1">{
                if facts.TimeoutsState.TasksTimeout != nil &amp;&amp; *facts.TimeoutsState.TasksTimeout != config.NoTimeoutDuration &amp;&amp; facts.TimeoutsState.StartTime != nil </span><span class="cov8" title="1">{
                        // If the elapsed time since the PipelineRun's start time is greater than the PipelineRun's Tasks timeout, skip.
                        return facts.TimeoutsState.Clock.Since(*facts.TimeoutsState.StartTime) &gt; *facts.TimeoutsState.TasksTimeout
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// skipBecausePipelineRunFinallyTimeoutReached returns true if the task shouldn't be launched because the elapsed time since
// finally tasks started being executed is greater than the PipelineRun's finally timeout
func (t *ResolvedPipelineTask) skipBecausePipelineRunFinallyTimeoutReached(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        if t.checkParentsDone(facts) &amp;&amp; t.IsFinalTask(facts) </span><span class="cov8" title="1">{
                if facts.TimeoutsState.FinallyTimeout != nil &amp;&amp; *facts.TimeoutsState.FinallyTimeout != config.NoTimeoutDuration &amp;&amp; facts.TimeoutsState.FinallyStartTime != nil </span><span class="cov8" title="1">{
                        // If the elapsed time since the PipelineRun's finally start time is greater than the PipelineRun's finally timeout, skip.
                        return facts.TimeoutsState.Clock.Since(*facts.TimeoutsState.FinallyStartTime) &gt; *facts.TimeoutsState.FinallyTimeout
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// skipBecauseEmptyArrayInMatrixParams returns true if the matrix parameters contain an empty array
func (t *ResolvedPipelineTask) skipBecauseEmptyArrayInMatrixParams() bool <span class="cov8" title="1">{
        if t.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                for _, ps := range t.PipelineTask.Matrix.Params </span><span class="cov8" title="1">{
                        if ps.Value.Type == v1.ParamTypeArray &amp;&amp; len(ps.Value.ArrayVal) == 0 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// IsFinalTask returns true if a task is a finally task
func (t *ResolvedPipelineTask) IsFinalTask(facts *PipelineRunFacts) bool <span class="cov8" title="1">{
        return facts.isFinalTask(t.PipelineTask.Name)
}</span>

// IsFinallySkipped returns true if a finally task is not executed and skipped due to task result validation failure
func (t *ResolvedPipelineTask) IsFinallySkipped(facts *PipelineRunFacts) TaskSkipStatus <span class="cov8" title="1">{
        var skippingReason v1.SkippingReason

        switch </span>{
        case t.isScheduled():<span class="cov8" title="1">
                skippingReason = v1.None</span>
        case facts.checkDAGTasksDone() &amp;&amp; facts.isFinalTask(t.PipelineTask.Name):<span class="cov8" title="1">
                switch </span>{
                case t.skipBecauseResultReferencesAreMissing(facts):<span class="cov8" title="1">
                        skippingReason = v1.MissingResultsSkip</span>
                case t.skipBecauseWhenExpressionsEvaluatedToFalse(facts):<span class="cov8" title="1">
                        skippingReason = v1.WhenExpressionsSkip</span>
                case t.skipBecausePipelineRunPipelineTimeoutReached(facts):<span class="cov8" title="1">
                        skippingReason = v1.PipelineTimedOutSkip</span>
                case t.skipBecausePipelineRunFinallyTimeoutReached(facts):<span class="cov8" title="1">
                        skippingReason = v1.FinallyTimedOutSkip</span>
                case t.skipBecauseEmptyArrayInMatrixParams():<span class="cov8" title="1">
                        skippingReason = v1.EmptyArrayInMatrixParams</span>
                default:<span class="cov8" title="1">
                        skippingReason = v1.None</span>
                }
        default:<span class="cov8" title="1">
                skippingReason = v1.None</span>
        }

        <span class="cov8" title="1">return TaskSkipStatus{
                IsSkipped:      skippingReason != v1.None,
                SkippingReason: skippingReason,
        }</span>
}

// GetRun is a function that will retrieve a CustomRun by name.
type GetRun func(name string) (*v1beta1.CustomRun, error)

// ValidateWorkspaceBindings validates that the Workspaces expected by a Pipeline are provided by a PipelineRun.
func ValidateWorkspaceBindings(p *v1.PipelineSpec, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        pipelineRunWorkspaces := make(map[string]v1.WorkspaceBinding)
        for _, binding := range pr.Spec.Workspaces </span><span class="cov8" title="1">{
                pipelineRunWorkspaces[binding.Name] = binding
        }</span>

        <span class="cov8" title="1">for _, ws := range p.Workspaces </span><span class="cov8" title="1">{
                if ws.Optional </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := pipelineRunWorkspaces[ws.Name]; !ok </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("pipeline requires workspace with name %q be provided by pipelinerun", ws.Name))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateTaskRunSpecs that the TaskRunSpecs defined by a PipelineRun are correct.
func ValidateTaskRunSpecs(p *v1.PipelineSpec, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        pipelineTasks := make(map[string]string)
        for _, task := range p.Tasks </span><span class="cov8" title="1">{
                pipelineTasks[task.Name] = task.Name
        }</span>

        <span class="cov8" title="1">for _, task := range p.Finally </span><span class="cov8" title="1">{
                pipelineTasks[task.Name] = task.Name
        }</span>

        <span class="cov8" title="1">for _, taskrunSpec := range pr.Spec.TaskRunSpecs </span><span class="cov8" title="1">{
                if _, ok := pipelineTasks[taskrunSpec.PipelineTaskName]; !ok </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("pipelineRun's taskrunSpecs defined wrong taskName: %q, does not exist in Pipeline", taskrunSpec.PipelineTaskName))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ResolvePipelineTask returns a new ResolvedPipelineTask representing any TaskRuns or CustomRuns
// associated with this Pipeline Task, if they exist.
//
// If the Pipeline Task is a Task, it retrieves any TaskRuns, plus the Task spec, and updates the ResolvedPipelineTask
// with this information. It also sets the ResolvedPipelineTask's TaskRunName(s) with the names of TaskRuns
// that should be or already have been created.
//
// If the Pipeline Task is a Custom Task, it retrieves any CustomRuns and updates the ResolvedPipelineTask with this information.
// It also sets the ResolvedPipelineTask's RunName(s) with the names of CustomRuns that should be or already have been created.
func ResolvePipelineTask(
        ctx context.Context,
        pipelineRun v1.PipelineRun,
        getTask resources.GetTask,
        getTaskRun resources.GetTaskRun,
        getRun GetRun,
        pipelineTask v1.PipelineTask,
        pst PipelineRunState,
) (*ResolvedPipelineTask, error) <span class="cov8" title="1">{
        rpt := ResolvedPipelineTask{
                PipelineTask: &amp;pipelineTask,
        }
        rpt.CustomTask = rpt.PipelineTask.TaskRef.IsCustomTask() || rpt.PipelineTask.TaskSpec.IsCustomTask()
        numCombinations := 1
        // We want to resolve all of the result references and ignore any errors at this point since there could be
        // instances where result references are missing here, but will be later skipped and resolved in
        // skipBecauseResultReferencesAreMissing. The final validation is handled in CheckMissingResultReferences.
        resolvedResultRefs, _, _ := ResolveResultRefs(pst, PipelineRunState{&amp;rpt})
        if err := validateArrayResultsIndex(resolvedResultRefs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ApplyTaskResults(PipelineRunState{&amp;rpt}, resolvedResultRefs)

        if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                numCombinations = rpt.PipelineTask.Matrix.CountCombinations()
        }</span>
        <span class="cov8" title="1">if rpt.IsCustomTask() </span><span class="cov8" title="1">{
                rpt.CustomRunNames = getNamesOfCustomRuns(pipelineRun.Status.ChildReferences, pipelineTask.Name, pipelineRun.Name, numCombinations)
                for _, runName := range rpt.CustomRunNames </span><span class="cov8" title="1">{
                        run, err := getRun(runName)
                        if err != nil &amp;&amp; !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error retrieving CustomRun %s: %w", runName, err)
                        }</span>
                        <span class="cov8" title="1">if run != nil </span><span class="cov8" title="1">{
                                rpt.CustomRuns = append(rpt.CustomRuns, run)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                rpt.TaskRunNames = GetNamesOfTaskRuns(pipelineRun.Status.ChildReferences, pipelineTask.Name, pipelineRun.Name, numCombinations)
                for _, taskRunName := range rpt.TaskRunNames </span><span class="cov8" title="1">{
                        if err := rpt.setTaskRunsAndResolvedTask(ctx, taskRunName, getTask, getTaskRun, pipelineTask); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;rpt, nil</span>
}

// setTaskRunsAndResolvedTask fetches the named TaskRun using the input function getTaskRun,
// and the resolved Task spec of the Pipeline Task using the input function getTask.
// It updates the ResolvedPipelineTask with the ResolvedTask and a pointer to the fetched TaskRun.
func (t *ResolvedPipelineTask) setTaskRunsAndResolvedTask(
        ctx context.Context,
        taskRunName string,
        getTask resources.GetTask,
        getTaskRun resources.GetTaskRun,
        pipelineTask v1.PipelineTask,
) error <span class="cov8" title="1">{
        taskRun, err := getTaskRun(taskRunName)
        if err != nil </span><span class="cov8" title="1">{
                if !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("error retrieving TaskRun %s: %w", taskRunName, err)
                }</span>
        }
        <span class="cov8" title="1">if taskRun != nil </span><span class="cov8" title="1">{
                t.TaskRuns = append(t.TaskRuns, taskRun)
        }</span>

        <span class="cov8" title="1">rt, err := resolveTask(ctx, taskRun, getTask, pipelineTask)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">t.ResolvedTask = rt
        return nil</span>
}

// resolveTask fetches the Task spec for the PipelineTask and sets its default values.
// It returns a ResolvedTask with the defaulted spec, name, and kind (namespaced Task or Cluster Task) of the Task.
// Returns an error if the Task could not be found because resolution was in progress or any other reason.
func resolveTask(
        ctx context.Context,
        taskRun *v1.TaskRun,
        getTask resources.GetTask,
        pipelineTask v1.PipelineTask,
) (*resources.ResolvedTask, error) <span class="cov8" title="1">{
        rt := &amp;resources.ResolvedTask{}
        switch </span>{
        case pipelineTask.TaskRef != nil:<span class="cov8" title="1">
                // If the TaskRun has already a stored TaskSpec in its status, use it as source of truth
                if taskRun != nil &amp;&amp; taskRun.Status.TaskSpec != nil </span><span class="cov0" title="0">{
                        rt.TaskSpec = taskRun.Status.TaskSpec
                        rt.TaskName = pipelineTask.TaskRef.Name
                }</span> else<span class="cov8" title="1"> {
                        // Following minimum status principle (TEP-0100), no need to propagate the RefSource about PipelineTask up to PipelineRun status.
                        // Instead, the child TaskRun's status will be the place recording the RefSource of individual task.
                        t, _, vr, err := getTask(ctx, pipelineTask.TaskRef.Name)
                        switch </span>{
                        case errors.Is(err, remote.ErrRequestInProgress) || (err != nil &amp;&amp; resolutioncommon.IsErrTransient(err)):<span class="cov8" title="1">
                                return rt, err</span>
                        case err != nil:<span class="cov8" title="1">
                                // some of the resolvers obtain the name from the parameters instead of from the TaskRef.Name field,
                                // so we account for both locations when constructing the error
                                name := pipelineTask.TaskRef.Name
                                if len(strings.TrimSpace(name)) == 0 </span><span class="cov8" title="1">{
                                        name = resource.GenerateErrorLogString(string(pipelineTask.TaskRef.Resolver), pipelineTask.TaskRef.Params)
                                }</span>
                                <span class="cov8" title="1">return rt, &amp;TaskNotFoundError{
                                        Name: name,
                                        Msg:  err.Error(),
                                }</span>
                        default:<span class="cov8" title="1">
                                spec := t.Spec
                                rt.TaskSpec = &amp;spec
                                rt.TaskName = t.Name
                                rt.VerificationResult = vr</span>
                        }
                }
                <span class="cov8" title="1">rt.Kind = pipelineTask.TaskRef.Kind</span>
        case pipelineTask.TaskSpec != nil:<span class="cov8" title="1">
                rt.TaskSpec = &amp;pipelineTask.TaskSpec.TaskSpec</span>
        default:<span class="cov8" title="1">
                // If the alpha feature is enabled, and the user has configured pipelineSpec or pipelineRef, it will enter here.
                // Currently, the controller is not yet adapted, and to avoid a panic, an error message is provided here.
                // TODO: Adjust the logic here once the feature is supported in the future.
                return nil, fmt.Errorf("Currently, Task %q does not support PipelineRef or PipelineSpec, please use TaskRef or TaskSpec instead", pipelineTask.Name)</span>
        }
        <span class="cov8" title="1">rt.TaskSpec.SetDefaults(ctx)
        return rt, nil</span>
}

// GetTaskRunName should return a unique name for a `TaskRun` if one has not already been defined, and the existing one otherwise.
func GetTaskRunName(childRefs []v1.ChildStatusReference, ptName, prName string) string <span class="cov8" title="1">{
        for _, cr := range childRefs </span><span class="cov8" title="1">{
                if cr.Kind == pipeline.TaskRunControllerName &amp;&amp; cr.PipelineTaskName == ptName </span><span class="cov8" title="1">{
                        return cr.Name
                }</span>
        }
        <span class="cov8" title="1">return kmeta.ChildName(prName, "-"+ptName)</span>
}

// GetNamesOfTaskRuns should return unique names for `TaskRuns` if one has not already been defined, and the existing one otherwise.
func GetNamesOfTaskRuns(childRefs []v1.ChildStatusReference, ptName, prName string, numberOfTaskRuns int) []string <span class="cov8" title="1">{
        if taskRunNames := getTaskRunNamesFromChildRefs(childRefs, ptName); taskRunNames != nil </span><span class="cov8" title="1">{
                return taskRunNames
        }</span>
        <span class="cov8" title="1">return getNewRunNames(ptName, prName, numberOfTaskRuns)</span>
}

// getTaskRunNamesFromChildRefs returns the names of TaskRuns defined in childRefs that are associated with the named Pipeline Task.
func getTaskRunNamesFromChildRefs(childRefs []v1.ChildStatusReference, ptName string) []string <span class="cov8" title="1">{
        var taskRunNames []string
        for _, cr := range childRefs </span><span class="cov8" title="1">{
                if cr.Kind == pipeline.TaskRunControllerName &amp;&amp; cr.PipelineTaskName == ptName </span><span class="cov8" title="1">{
                        taskRunNames = append(taskRunNames, cr.Name)
                }</span>
        }
        <span class="cov8" title="1">return taskRunNames</span>
}

func getNewRunNames(ptName, prName string, numberOfRuns int) []string <span class="cov8" title="1">{
        var runNames []string
        // If it is a singular TaskRun/CustomRun, we only append the ptName
        if numberOfRuns == 1 </span><span class="cov8" title="1">{
                runName := kmeta.ChildName(prName, "-"+ptName)
                return append(runNames, runName)
        }</span>
        // For a matrix we append i to the end of the fanned out TaskRuns/CustomRun "matrixed-pr-taskrun-0"
        <span class="cov8" title="1">for i := range numberOfRuns </span><span class="cov8" title="1">{
                runName := kmeta.ChildName(prName, fmt.Sprintf("-%s-%d", ptName, i))
                // check if the taskRun name ends with a matrix instance count
                if !strings.HasSuffix(runName, fmt.Sprintf("-%d", i)) </span><span class="cov8" title="1">{
                        runName = kmeta.ChildName(prName, "-"+ptName)
                        // kmeta.ChildName limits the size of a name to max of 63 characters based on k8s guidelines
                        // truncate the name such that "-&lt;matrix-id&gt;" can be appended to the TaskRun/CustomRun name
                        longest := 63 - len(fmt.Sprintf("-%d", numberOfRuns))
                        runName = runName[0:longest]
                        runName = fmt.Sprintf("%s-%d", runName, i)
                }</span>
                <span class="cov8" title="1">runNames = append(runNames, runName)</span>
        }
        <span class="cov8" title="1">return runNames</span>
}

// getCustomRunName should return a unique name for a `Run` if one has not already
// been defined, and the existing one otherwise.
func getCustomRunName(childRefs []v1.ChildStatusReference, ptName, prName string) string <span class="cov8" title="1">{
        for _, cr := range childRefs </span><span class="cov8" title="1">{
                if cr.PipelineTaskName == ptName </span><span class="cov8" title="1">{
                        if cr.Kind == pipeline.CustomRunControllerName </span><span class="cov8" title="1">{
                                return cr.Name
                        }</span>
                }
        }

        <span class="cov8" title="1">return kmeta.ChildName(prName, "-"+ptName)</span>
}

// getNamesOfCustomRuns should return a unique names for `CustomRuns` if they have not already been defined,
// and the existing ones otherwise.
func getNamesOfCustomRuns(childRefs []v1.ChildStatusReference, ptName, prName string, numberOfRuns int) []string <span class="cov8" title="1">{
        if customRunNames := getRunNamesFromChildRefs(childRefs, ptName); customRunNames != nil </span><span class="cov0" title="0">{
                return customRunNames
        }</span>
        <span class="cov8" title="1">return getNewRunNames(ptName, prName, numberOfRuns)</span>
}

// getRunNamesFromChildRefs returns the names of CustomRuns defined in childRefs that are associated with the named Pipeline Task.
func getRunNamesFromChildRefs(childRefs []v1.ChildStatusReference, ptName string) []string <span class="cov8" title="1">{
        var runNames []string
        for _, cr := range childRefs </span><span class="cov8" title="1">{
                if cr.PipelineTaskName == ptName </span><span class="cov8" title="1">{
                        if cr.Kind == pipeline.CustomRunControllerName </span><span class="cov0" title="0">{
                                runNames = append(runNames, cr.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return runNames</span>
}

func (t *ResolvedPipelineTask) hasResultReferences() bool <span class="cov8" title="1">{
        var matrixParams v1.Params
        if t.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                matrixParams = t.PipelineTask.Params
        }</span>
        <span class="cov8" title="1">for _, param := range append(t.PipelineTask.Params, matrixParams...) </span><span class="cov8" title="1">{
                if ps, ok := param.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        if v1.LooksLikeContainsResultRefs(ps) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, we := range t.PipelineTask.When </span><span class="cov8" title="1">{
                if ps, ok := we.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                        if v1.LooksLikeContainsResultRefs(ps) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func isCustomRunCancelledByPipelineRunTimeout(cr *v1beta1.CustomRun) bool <span class="cov8" title="1">{
        return cr.Spec.StatusMessage == v1beta1.CustomRunCancelledByPipelineTimeoutMsg
}</span>

// CheckMissingResultReferences returns an error if it is missing any result references.
// Missing result references can occur if task fails to produce a result but has
// OnError: continue (ie TestMissingResultWhenStepErrorIsIgnored)
func CheckMissingResultReferences(pipelineRunState PipelineRunState, target *ResolvedPipelineTask) error <span class="cov8" title="1">{
        for _, resultRef := range v1.PipelineTaskResultRefs(target.PipelineTask) </span><span class="cov8" title="1">{
                referencedPipelineTask, ok := pipelineRunState.ToMap()[resultRef.PipelineTask]
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("Result reference error: Could not find ref \"%s\" in internal pipelineRunState", resultRef.PipelineTask)
                }</span>
                <span class="cov8" title="1">if referencedPipelineTask.IsCustomTask() </span><span class="cov8" title="1">{
                        if len(referencedPipelineTask.CustomRuns) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("Result reference error: Internal result ref \"%s\" has zero-length CustomRuns", resultRef.PipelineTask)
                        }</span>
                        <span class="cov8" title="1">customRun := referencedPipelineTask.CustomRuns[0]
                        _, err := findRunResultForParam(customRun, resultRef)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if len(referencedPipelineTask.TaskRuns) == 0 </span><span class="cov8" title="1">{
                                return fmt.Errorf("Result reference error: Internal result ref \"%s\" has zero-length TaskRuns", resultRef.PipelineTask)
                        }</span>
                        <span class="cov8" title="1">taskRun := referencedPipelineTask.TaskRuns[0]
                        _, err := findTaskResultForParam(taskRun, resultRef)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// createResultsCacheMatrixedTaskRuns creates a cache of results that have been fanned out from a
// referenced matrixed PipelineTask so that you can easily access these results in subsequent Pipeline Tasks
func createResultsCacheMatrixedTaskRuns(rpt *ResolvedPipelineTask) (resultsCache map[string][]string) <span class="cov8" title="1">{
        if len(rpt.ResultsCache) == 0 </span><span class="cov8" title="1">{
                resultsCache = make(map[string][]string)
        }</span>
        // Sort the taskRuns by name to ensure the order is deterministic
        <span class="cov8" title="1">sort.Slice(rpt.TaskRuns, func(i, j int) bool </span><span class="cov8" title="1">{
                return rpt.TaskRuns[i].Name &lt; rpt.TaskRuns[j].Name
        }</span>)
        <span class="cov8" title="1">for _, taskRun := range rpt.TaskRuns </span><span class="cov8" title="1">{
                results := taskRun.Status.Results
                for _, result := range results </span><span class="cov8" title="1">{
                        resultsCache[result.Name] = append(resultsCache[result.Name], result.Value.StringVal)
                }</span>
        }
        <span class="cov8" title="1">return resultsCache</span>
}

// ValidateParamEnumSubset finds the referenced pipeline-level params in the resolved pipelineTask.
// It then validates if the referenced pipeline-level param enums are subsets of the resolved pipelineTask-level param enums
func ValidateParamEnumSubset(pipelineTaskParams []v1.Param, pipelineParamSpecs []v1.ParamSpec, rt *resources.ResolvedTask) error <span class="cov8" title="1">{
        // When the matrix Task has no TaskRun, the rt will be nil, we should skip the validation.
        if rt == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, p := range pipelineTaskParams </span><span class="cov8" title="1">{
                // calculate referenced param enums
                res, present, errString := substitution.ExtractVariablesFromString(p.Value.StringVal, "params")
                if errString != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("unexpected error in ExtractVariablesFromString: %s", errString)
                }</span>

                // if multiple params are extracted, that means the task-level param is a compounded value, skip subset validation
                <span class="cov8" title="1">if !present || len(res) &gt; 1 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // resolve pipeline-level and pipelineTask-level enums
                <span class="cov8" title="1">paramName := substitution.TrimArrayIndex(res[0])
                pipelineParam := getParamFromName(paramName, pipelineParamSpecs)
                resolvedTaskParam := getParamFromName(p.Name, rt.TaskSpec.Params)

                // param enum is only supported for string param type,
                // we only validate the enum subset requirement for string typed param.
                // If there is no task-level enum (allowing any value), any pipeline-level enum is allowed
                if pipelineParam.Type != v1.ParamTypeString || len(resolvedTaskParam.Enum) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // if pipelin-level enum is empty (allowing any value) but task-level enum is not, it is not a "subset"
                <span class="cov8" title="1">if len(pipelineParam.Enum) == 0 &amp;&amp; len(resolvedTaskParam.Enum) &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("pipeline param \"%s\" has no enum, but referenced in \"%s\" task has enums: %v", pipelineParam.Name, rt.TaskName, resolvedTaskParam.Enum)
                }</span>

                // validate if pipeline-level enum is a subset of pipelineTask-level enum
                <span class="cov8" title="1">if isValid := isSubset(pipelineParam.Enum, resolvedTaskParam.Enum); !isValid </span><span class="cov8" title="1">{
                        return fmt.Errorf("pipeline param \"%s\" enum: %v is not a subset of the referenced in \"%s\" task param enum: %v", pipelineParam.Name, pipelineParam.Enum, rt.TaskName, resolvedTaskParam.Enum)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func isSubset(pipelineEnum, taskEnum []string) bool <span class="cov8" title="1">{
        pipelineEnumMap := make(map[string]bool)
        TaskEnumMap := make(map[string]bool)
        for _, e := range pipelineEnum </span><span class="cov8" title="1">{
                pipelineEnumMap[e] = true
        }</span>
        <span class="cov8" title="1">for _, e := range taskEnum </span><span class="cov8" title="1">{
                TaskEnumMap[e] = true
        }</span>

        <span class="cov8" title="1">for e := range pipelineEnumMap </span><span class="cov8" title="1">{
                if !TaskEnumMap[e] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func getParamFromName(name string, pss v1.ParamSpecs) v1.ParamSpec <span class="cov8" title="1">{
        for _, ps := range pss </span><span class="cov8" title="1">{
                if ps.Name == name </span><span class="cov8" title="1">{
                        return ps
                }</span>
        }
        <span class="cov0" title="0">return v1.ParamSpec{}</span>
}
</pre>
		
		<pre class="file" id="file445" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/pipeline/dag"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
)

const (
        // PipelineTaskStateNone indicates that the execution status of a pipelineTask is unknown
        PipelineTaskStateNone = "None"
        // PipelineTaskStatusPrefix is a prefix of the param representing execution state of pipelineTask
        PipelineTaskStatusPrefix = "tasks."
        // PipelineTaskStatusSuffix is a suffix of the param representing execution state of pipelineTask
        PipelineTaskStatusSuffix = ".status"
        PipelineTaskReasonSuffix = ".reason"
)

// PipelineRunState is a slice of ResolvedPipelineRunTasks the represents the current execution
// state of the PipelineRun.
type PipelineRunState []*ResolvedPipelineTask

// PipelineRunFacts holds the state of all the components that make up the Pipeline graph that are used to track the
// PipelineRun state without passing all these components separately. It helps simplify our implementation for getting
// and scheduling the next tasks. It is a collection of list of ResolvedPipelineTask, graph of DAG tasks, graph of
// finally tasks, cache of skipped tasks.
type PipelineRunFacts struct {
        State           PipelineRunState
        SpecStatus      v1.PipelineRunSpecStatus
        TasksGraph      *dag.Graph
        FinalTasksGraph *dag.Graph
        TimeoutsState   PipelineRunTimeoutsState

        // SkipCache is a hash of PipelineTask names that stores whether a task will be
        // executed or not, because it's either not reachable via the DAG due to the pipeline
        // state, or because it was skipped due to when expressions.
        // We cache this data along the state, because it's expensive to compute, it requires
        // traversing potentially the whole graph; this way it can built incrementally, when
        // needed, via the `Skip` method in pipelinerunresolution.go
        // The skip data is sensitive to changes in the state. The ResetSkippedCache method
        // can be used to clean the cache and force re-computation when needed.
        SkipCache map[string]TaskSkipStatus

        // ValidationFailedTask are the tasks for which taskrun is not created as they
        // never got added to the execution i.e. they failed in the validation step. One of
        // the case of failing at the validation is during CheckMissingResultReferences method
        // Tasks in ValidationFailedTask is added in method runNextSchedulableTask
        ValidationFailedTask []*ResolvedPipelineTask
}

// PipelineRunTimeoutsState records information about start times and timeouts for the PipelineRun, so that the PipelineRunFacts
// can reference those values in its functions.
type PipelineRunTimeoutsState struct {
        StartTime        *time.Time
        FinallyStartTime *time.Time
        PipelineTimeout  *time.Duration
        TasksTimeout     *time.Duration
        FinallyTimeout   *time.Duration
        Clock            clock.PassiveClock
}

// pipelineRunStatusCount holds the count of successful, failed, cancelled, skipped, and incomplete tasks
type pipelineRunStatusCount struct {
        // skipped tasks count
        Skipped int
        // successful tasks count
        Succeeded int
        // failed tasks count
        Failed int
        // failed but ignored tasks count
        IgnoredFailed int
        // cancelled tasks count
        Cancelled int
        // number of tasks which are still pending, have not executed
        Incomplete int
        // count of tasks skipped due to the relevant timeout having elapsed before the task is launched
        SkippedDueToTimeout int
        // count of validation failed task and taskrun not created
        ValidationFailed int
}

// ResetSkippedCache resets the skipped cache in the facts map
func (facts *PipelineRunFacts) ResetSkippedCache() <span class="cov8" title="1">{
        facts.SkipCache = make(map[string]TaskSkipStatus)
}</span>

// ToMap returns a map that maps pipeline task name to the resolved pipeline run task
func (state PipelineRunState) ToMap() map[string]*ResolvedPipelineTask <span class="cov8" title="1">{
        m := make(map[string]*ResolvedPipelineTask)
        for _, rpt := range state </span><span class="cov8" title="1">{
                m[rpt.PipelineTask.Name] = rpt
        }</span>
        <span class="cov8" title="1">return m</span>
}

// IsBeforeFirstTaskRun returns true if the PipelineRun has not yet started its first TaskRun
func (state PipelineRunState) IsBeforeFirstTaskRun() bool <span class="cov8" title="1">{
        for _, t := range state </span><span class="cov8" title="1">{
                if len(t.CustomRuns) &gt; 0 || len(t.TaskRuns) &gt; 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AdjustStartTime adjusts potential drift in the PipelineRun's start time.
//
// The StartTime will only adjust earlier, so that the PipelineRun's StartTime
// is no later than any of its constituent TaskRuns.
//
// This drift could be due to us either failing to record the Run's start time
// previously, or our own failure to observe a prior update before reconciling
// the resource again.
func (state PipelineRunState) AdjustStartTime(unadjustedStartTime *metav1.Time) *metav1.Time <span class="cov8" title="1">{
        adjustedStartTime := unadjustedStartTime
        for _, rpt := range state </span><span class="cov8" title="1">{
                for _, customRun := range rpt.CustomRuns </span><span class="cov8" title="1">{
                        creationTime := customRun.GetObjectMeta().GetCreationTimestamp()
                        if creationTime.Time.Before(adjustedStartTime.Time) </span><span class="cov8" title="1">{
                                adjustedStartTime = &amp;creationTime
                        }</span>
                }

                <span class="cov8" title="1">for _, taskRun := range rpt.TaskRuns </span><span class="cov8" title="1">{
                        if taskRun.CreationTimestamp.Time.Before(adjustedStartTime.Time) </span><span class="cov8" title="1">{
                                adjustedStartTime = &amp;taskRun.CreationTimestamp
                        }</span>
                }
        }

        <span class="cov8" title="1">return adjustedStartTime.DeepCopy()</span>
}

// GetTaskRunsResults returns a map of all successfully completed TaskRuns in the state, with the pipeline task name as
// the key and the results from the corresponding TaskRun as the value. It only includes tasks which have completed successfully.
func (state PipelineRunState) GetTaskRunsResults() map[string][]v1.TaskRunResult <span class="cov8" title="1">{
        results := make(map[string][]v1.TaskRunResult)
        for _, rpt := range state </span><span class="cov8" title="1">{
                if rpt.IsCustomTask() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !rpt.isSuccessful() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                        taskRunResults := ConvertResultsMapToTaskRunResults(rpt.ResultsCache)
                        if len(taskRunResults) &gt; 0 </span><span class="cov8" title="1">{
                                results[rpt.PipelineTask.Name] = taskRunResults
                        }</span>
                } else<span class="cov8" title="1"> {
                        results[rpt.PipelineTask.Name] = rpt.TaskRuns[0].Status.Results
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

// GetTaskRunsArtifacts returns a map of all successfully completed TaskRuns in the state, with the pipeline task name as
// the key and the artifacts from the corresponding TaskRun as the value. It only includes tasks which have completed successfully.
func (state PipelineRunState) GetTaskRunsArtifacts() map[string]*v1.Artifacts <span class="cov8" title="1">{
        results := make(map[string]*v1.Artifacts)
        for _, rpt := range state </span><span class="cov8" title="1">{
                if rpt.IsCustomTask() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !rpt.isSuccessful() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if rpt.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                        var ars v1.Artifacts
                        for _, tr := range rpt.TaskRuns </span><span class="cov8" title="1">{
                                ars.Merge(tr.Status.Artifacts)
                        }</span>
                        <span class="cov8" title="1">results[rpt.PipelineTask.Name] = &amp;ars</span>
                } else<span class="cov8" title="1"> {
                        results[rpt.PipelineTask.Name] = rpt.TaskRuns[0].Status.Artifacts
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

// ConvertResultsMapToTaskRunResults converts the map of results from Matrixed PipelineTasks to a list
// of TaskRunResults to standard the format
func ConvertResultsMapToTaskRunResults(resultsMap map[string][]string) []v1.TaskRunResult <span class="cov8" title="1">{
        var taskRunResults []v1.TaskRunResult
        for result, val := range resultsMap </span><span class="cov8" title="1">{
                taskRunResult := v1.TaskRunResult{
                        Name: result,
                        Type: v1.ResultsTypeArray,
                        Value: v1.ParamValue{
                                Type:     v1.ParamTypeArray,
                                ArrayVal: val,
                        },
                }
                taskRunResults = append(taskRunResults, taskRunResult)
        }</span>
        <span class="cov8" title="1">return taskRunResults</span>
}

// GetRunsResults returns a map of all successfully completed Runs in the state, with the pipeline task name as the key
// and the results from the corresponding TaskRun as the value. It only includes runs which have completed successfully.
func (state PipelineRunState) GetRunsResults() map[string][]v1beta1.CustomRunResult <span class="cov8" title="1">{
        results := make(map[string][]v1beta1.CustomRunResult)
        for _, rpt := range state </span><span class="cov8" title="1">{
                if !rpt.IsCustomTask() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !rpt.isSuccessful() </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Currently a Matrix cannot produce results so this is for a singular CustomRun
                <span class="cov8" title="1">if len(rpt.CustomRuns) == 1 </span><span class="cov8" title="1">{
                        cr := rpt.CustomRuns[0]
                        results[rpt.PipelineTask.Name] = cr.Status.Results
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// GetChildReferences returns a slice of references, including version, kind, name, and pipeline task name, for all
// TaskRuns and Runs in the state.
func (facts *PipelineRunFacts) GetChildReferences() []v1.ChildStatusReference <span class="cov8" title="1">{
        var childRefs []v1.ChildStatusReference

        for _, rpt := range facts.State </span><span class="cov8" title="1">{
                // try to replace the parameters of the reference result of when expression in the TaskRun that has ended
                if rpt.isDone(facts) </span><span class="cov8" title="1">{
                        resolvedResultRefs, _, err := ResolveResultRefs(facts.State, PipelineRunState{rpt})
                        if err == nil </span><span class="cov8" title="1">{
                                ApplyTaskResults(facts.State, resolvedResultRefs)
                        }</span>
                }

                <span class="cov8" title="1">switch </span>{
                case len(rpt.TaskRuns) != 0:<span class="cov8" title="1">
                        for _, taskRun := range rpt.TaskRuns </span><span class="cov8" title="1">{
                                if taskRun != nil </span><span class="cov8" title="1">{
                                        childRefs = append(childRefs, rpt.getChildRefForTaskRun(taskRun))
                                }</span>
                        }
                case len(rpt.CustomRuns) != 0:<span class="cov8" title="1">
                        for _, run := range rpt.CustomRuns </span><span class="cov8" title="1">{
                                childRefs = append(childRefs, rpt.getChildRefForRun(run))
                        }</span>
                }
        }
        <span class="cov8" title="1">return childRefs</span>
}

func (t *ResolvedPipelineTask) getDisplayName(customRun *v1beta1.CustomRun, taskRun *v1.TaskRun, c v1.ChildStatusReference) v1.ChildStatusReference <span class="cov8" title="1">{
        replacements := make(map[string]string)
        if taskRun != nil </span><span class="cov8" title="1">{
                for _, p := range taskRun.Spec.Params </span><span class="cov8" title="1">{
                        if p.Value.Type == v1.ParamTypeString </span><span class="cov8" title="1">{
                                replacements[fmt.Sprintf("%s.%s", v1.ParamsPrefix, p.Name)] = p.Value.StringVal
                        }</span>
                }
        }

        <span class="cov8" title="1">if customRun != nil </span><span class="cov8" title="1">{
                for _, p := range customRun.Spec.Params </span><span class="cov8" title="1">{
                        if p.Value.Type == v1beta1.ParamTypeString </span><span class="cov8" title="1">{
                                replacements[fmt.Sprintf("%s.%s", v1.ParamsPrefix, p.Name)] = p.Value.StringVal
                        }</span>
                }
        }

        <span class="cov8" title="1">if t.PipelineTask.DisplayName != "" </span><span class="cov8" title="1">{
                c.DisplayName = substitution.ApplyReplacements(t.PipelineTask.DisplayName, replacements)
        }</span>
        <span class="cov8" title="1">if t.PipelineTask.Matrix != nil </span><span class="cov8" title="1">{
                var dn string
                for _, i := range t.PipelineTask.Matrix.Include </span><span class="cov8" title="1">{
                        if i.Name == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">match := true
                        for _, ip := range i.Params </span><span class="cov8" title="1">{
                                v, ok := replacements[fmt.Sprintf("%s.%s", v1.ParamsPrefix, ip.Name)]
                                if !ok || (ip.Value.Type == v1.ParamTypeString &amp;&amp; ip.Value.StringVal != v) </span><span class="cov8" title="1">{
                                        match = false
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                dn = fmt.Sprintf("%s %s", dn, substitution.ApplyReplacements(i.Name, replacements))
                        }</span>
                }
                <span class="cov8" title="1">if dn != "" </span><span class="cov8" title="1">{
                        c.DisplayName = strings.TrimSpace(dn)
                }</span>
        }
        <span class="cov8" title="1">return c</span>
}

func (t *ResolvedPipelineTask) getChildRefForRun(customRun *v1beta1.CustomRun) v1.ChildStatusReference <span class="cov8" title="1">{
        c := v1.ChildStatusReference{
                TypeMeta: runtime.TypeMeta{
                        APIVersion: v1beta1.SchemeGroupVersion.String(),
                        Kind:       pipeline.CustomRunControllerName,
                },
                Name:             customRun.GetObjectMeta().GetName(),
                PipelineTaskName: t.PipelineTask.Name,
                WhenExpressions:  t.PipelineTask.When,
        }
        return t.getDisplayName(customRun, nil, c)
}</span>

func (t *ResolvedPipelineTask) getChildRefForTaskRun(taskRun *v1.TaskRun) v1.ChildStatusReference <span class="cov8" title="1">{
        c := v1.ChildStatusReference{
                TypeMeta: runtime.TypeMeta{
                        APIVersion: v1.SchemeGroupVersion.String(),
                        Kind:       pipeline.TaskRunControllerName,
                },
                Name:             taskRun.Name,
                PipelineTaskName: t.PipelineTask.Name,
                WhenExpressions:  t.PipelineTask.When,
        }
        return t.getDisplayName(nil, taskRun, c)
}</span>

// getNextTasks returns a list of tasks which should be executed next i.e.
// a list of tasks from candidateTasks which aren't yet indicated in state to be running and
// a list of cancelled/failed tasks from candidateTasks which haven't exhausted their retries
func (state PipelineRunState) getNextTasks(candidateTasks sets.String) []*ResolvedPipelineTask <span class="cov8" title="1">{
        tasks := []*ResolvedPipelineTask{}
        for _, t := range state </span><span class="cov8" title="1">{
                if _, ok := candidateTasks[t.PipelineTask.Name]; ok </span><span class="cov8" title="1">{
                        if len(t.TaskRuns) == 0 &amp;&amp; len(t.CustomRuns) == 0 </span><span class="cov8" title="1">{
                                tasks = append(tasks, t)
                        }</span>
                }
        }
        <span class="cov8" title="1">return tasks</span>
}

// IsStopping returns true if the PipelineRun won't be scheduling any new Task because
// at least one task already failed (with onError: stopAndFail) or was cancelled in the specified dag
func (facts *PipelineRunFacts) IsStopping() bool <span class="cov8" title="1">{
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isDAGTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        if (t.isFailure() || t.isValidationFailed(facts.ValidationFailedTask)) &amp;&amp; t.PipelineTask.OnError != v1.PipelineTaskContinue </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// IsRunning returns true if the PipelineRun is still running tasks in the specified dag
func (facts *PipelineRunFacts) IsRunning() bool <span class="cov8" title="1">{
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isDAGTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        if t.IsRunning() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// IsCancelled returns true if the PipelineRun was cancelled
func (facts *PipelineRunFacts) IsCancelled() bool <span class="cov8" title="1">{
        return facts.SpecStatus == v1.PipelineRunSpecStatusCancelled
}</span>

// IsGracefullyCancelled returns true if the PipelineRun was gracefully cancelled
func (facts *PipelineRunFacts) IsGracefullyCancelled() bool <span class="cov8" title="1">{
        return facts.SpecStatus == v1.PipelineRunSpecStatusCancelledRunFinally
}</span>

// IsGracefullyStopped returns true if the PipelineRun was gracefully stopped
func (facts *PipelineRunFacts) IsGracefullyStopped() bool <span class="cov8" title="1">{
        return facts.SpecStatus == v1.PipelineRunSpecStatusStoppedRunFinally
}</span>

// DAGExecutionQueue returns a list of DAG tasks which needs to be scheduled next
func (facts *PipelineRunFacts) DAGExecutionQueue() (PipelineRunState, error) <span class="cov8" title="1">{
        var tasks PipelineRunState
        // when pipelinerun is cancelled or gracefully cancelled, do not schedule any new tasks,
        // and only wait for all running tasks to complete (without exhausting retries).
        if facts.IsCancelled() || facts.IsGracefullyCancelled() </span><span class="cov8" title="1">{
                return tasks, nil
        }</span>
        // candidateTasks is initialized to DAG root nodes to start pipeline execution
        // candidateTasks is derived based on successfully finished tasks and/or skipped tasks
        <span class="cov8" title="1">candidateTasks, err := dag.GetCandidateTasks(facts.TasksGraph, facts.completedOrSkippedDAGTasks()...)
        if err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>
        <span class="cov8" title="1">if !facts.IsStopping() &amp;&amp; !facts.IsGracefullyStopped() </span><span class="cov8" title="1">{
                tasks = facts.State.getNextTasks(candidateTasks)
        }</span>
        <span class="cov8" title="1">return tasks, nil</span>
}

// GetFinalTaskNames returns a list of all final task names
func (facts *PipelineRunFacts) GetFinalTaskNames() sets.String <span class="cov8" title="1">{
        names := sets.NewString()
        // return list of tasks with all final tasks
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isFinalTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        names.Insert(t.PipelineTask.Name)
                }</span>
        }
        <span class="cov8" title="1">return names</span>
}

// GetTaskNames returns a list of all non-final task names
func (facts *PipelineRunFacts) GetTaskNames() sets.String <span class="cov8" title="1">{
        names := sets.NewString()
        // return list of tasks with all final tasks
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if !facts.isFinalTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        names.Insert(t.PipelineTask.Name)
                }</span>
        }
        <span class="cov8" title="1">return names</span>
}

// GetFinalTasks returns a list of final tasks which needs to be executed next
// GetFinalTasks returns final tasks only when all DAG tasks have finished executing or have been skipped
func (facts *PipelineRunFacts) GetFinalTasks() PipelineRunState <span class="cov8" title="1">{
        tasks := PipelineRunState{}
        finalCandidates := sets.NewString()
        // check either pipeline has finished executing all DAG pipelineTasks,
        // where "finished executing" means succeeded, failed, or skipped.
        if facts.checkDAGTasksDone() </span><span class="cov8" title="1">{
                // return list of tasks with all final tasks
                for _, t := range facts.State </span><span class="cov8" title="1">{
                        if facts.isFinalTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                                finalCandidates.Insert(t.PipelineTask.Name)
                        }</span>
                }
                <span class="cov8" title="1">tasks = facts.State.getNextTasks(finalCandidates)</span>
        }
        <span class="cov8" title="1">return tasks</span>
}

// IsFinalTaskStarted returns true if all DAG pipelineTasks is finished and one or more final tasks have been created.
func (facts *PipelineRunFacts) IsFinalTaskStarted() bool <span class="cov8" title="1">{
        // check either pipeline has finished executing all DAG pipelineTasks,
        // where "finished executing" means succeeded, failed, or skipped.
        if facts.checkDAGTasksDone() </span><span class="cov8" title="1">{
                // return list of tasks with all final tasks
                for _, t := range facts.State </span><span class="cov8" title="1">{
                        if facts.isFinalTask(t.PipelineTask.Name) &amp;&amp; t.isScheduled() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// GetPipelineConditionStatus will return the Condition that the PipelineRun prName should be
// updated with, based on the status of the TaskRuns in state.
func (facts *PipelineRunFacts) GetPipelineConditionStatus(ctx context.Context, pr *v1.PipelineRun, logger *zap.SugaredLogger, c clock.PassiveClock) *apis.Condition <span class="cov8" title="1">{
        // We have 4 different states here:
        // 1. Timed out -&gt; Failed
        // 2. All tasks are done and at least one has failed or has been cancelled -&gt; Failed
        // 3. All tasks are done or are skipped (i.e. condition check failed).-&gt; Success
        // 4. A Task or Condition is running right now or there are things left to run -&gt; Running
        if pr.HasTimedOut(ctx, c) </span><span class="cov8" title="1">{
                return &amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionFalse,
                        Reason:  v1.PipelineRunReasonTimedOut.String(),
                        Message: fmt.Sprintf("PipelineRun %q failed to finish within %q", pr.Name, pr.PipelineTimeout(ctx).String()),
                }
        }</span>

        <span class="cov8" title="1">if pr.HaveTasksTimedOut(ctx, c) </span><span class="cov8" title="1">{
                return &amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionFalse,
                        Reason:  v1.PipelineRunReasonTimedOut.String(),
                        Message: fmt.Sprintf("PipelineRun %q failed due to tasks failed to finish within %q", pr.Name, pr.TasksTimeout().Duration.String()),
                }
        }</span>

        // report the count in PipelineRun Status
        // get the count of successful tasks, failed tasks, cancelled tasks, skipped task, and incomplete tasks
        <span class="cov8" title="1">s := facts.getPipelineTasksCount()
        // completed task is a collection of successful, failed, cancelled tasks
        // (skipped tasks and validation failed tasks are reported separately)
        cmTasks := s.Succeeded + s.Failed + s.Cancelled + s.IgnoredFailed
        totalFailedTasks := s.Failed + s.IgnoredFailed

        // The completion reason is set from the TaskRun completion reason
        // by default, set it to ReasonRunning
        reason := v1.PipelineRunReasonRunning.String()

        // check if the pipeline is finished executing all tasks i.e. no incomplete tasks
        if s.Incomplete == 0 </span><span class="cov8" title="1">{
                status := corev1.ConditionTrue
                reason := v1.PipelineRunReasonSuccessful.String()
                var message string
                if s.IgnoredFailed &gt; 0 </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("Tasks Completed: %d (Failed: %d (Ignored: %d), Cancelled %d), Skipped: %d",
                                cmTasks, totalFailedTasks, s.IgnoredFailed, s.Cancelled, s.Skipped)
                }</span> else<span class="cov8" title="1"> {
                        message = fmt.Sprintf("Tasks Completed: %d (Failed: %d, Cancelled %d), Skipped: %d",
                                cmTasks, totalFailedTasks, s.Cancelled, s.Skipped)
                }</span>
                // append validation failed count in the message
                <span class="cov8" title="1">if s.ValidationFailed &gt; 0 </span><span class="cov0" title="0">{
                        message += fmt.Sprintf(", Failed Validation: %d", s.ValidationFailed)
                }</span>
                // Set reason to ReasonCompleted - At least one is skipped
                <span class="cov8" title="1">if s.Skipped &gt; 0 </span><span class="cov8" title="1">{
                        reason = v1.PipelineRunReasonCompleted.String()
                }</span>

                <span class="cov8" title="1">switch </span>{
                case s.ValidationFailed &gt; 0:<span class="cov0" title="0">
                        reason = v1.PipelineRunReasonFailedValidation.String()
                        status = corev1.ConditionFalse</span>
                case s.Failed &gt; 0 || s.SkippedDueToTimeout &gt; 0:<span class="cov8" title="1">
                        // Set reason to ReasonFailed - At least one failed
                        reason = v1.PipelineRunReasonFailed.String()
                        status = corev1.ConditionFalse</span>
                case pr.IsGracefullyCancelled() || pr.IsGracefullyStopped():<span class="cov8" title="1">
                        // Set reason to ReasonCancelled - Cancellation requested
                        reason = v1.PipelineRunReasonCancelled.String()
                        status = corev1.ConditionFalse
                        message = fmt.Sprintf("PipelineRun %q was cancelled", pr.Name)</span>
                case s.Cancelled &gt; 0:<span class="cov8" title="1">
                        // Set reason to ReasonCancelled - At least one is cancelled and no failure yet
                        reason = v1.PipelineRunReasonCancelled.String()
                        status = corev1.ConditionFalse</span>
                }
                <span class="cov8" title="1">logger.Infof("All TaskRuns have finished for PipelineRun %s so it has finished", pr.Name)
                return &amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  status,
                        Reason:  reason,
                        Message: message,
                }</span>
        }

        // Hasn't timed out; not all tasks have finished.... Must keep running then....
        <span class="cov8" title="1">switch </span>{
        case pr.IsGracefullyCancelled():<span class="cov8" title="1">
                // Transition pipeline into running finally state, when graceful cancel is in progress
                reason = v1.PipelineRunReasonCancelledRunningFinally.String()</span>
        case pr.IsGracefullyStopped():<span class="cov8" title="1">
                // Transition pipeline into running finally state, when graceful stop is in progress
                reason = v1.PipelineRunReasonStoppedRunningFinally.String()</span>
        case s.Cancelled &gt; 0 || (s.Failed &gt; 0 &amp;&amp; facts.checkFinalTasksDone()):<span class="cov8" title="1">
                // Transition pipeline into stopping state when one of the tasks(dag/final) cancelled or one of the dag tasks failed
                // for a pipeline with final tasks, single dag task failure does not transition to interim stopping state
                // pipeline stays in running state until all final tasks are done before transitioning to failed state
                reason = v1.PipelineRunReasonStopping.String()</span>
        }

        // return the status
        <span class="cov8" title="1">return &amp;apis.Condition{
                Type:   apis.ConditionSucceeded,
                Status: corev1.ConditionUnknown,
                Reason: reason,
                Message: fmt.Sprintf("Tasks Completed: %d (Failed: %d, Cancelled %d), Incomplete: %d, Skipped: %d",
                        cmTasks, s.Failed, s.Cancelled, s.Incomplete, s.Skipped),
        }</span>
}

// GetSkippedTasks constructs a list of SkippedTask struct to be included in the PipelineRun Status
func (facts *PipelineRunFacts) GetSkippedTasks() []v1.SkippedTask <span class="cov8" title="1">{
        var skipped []v1.SkippedTask
        for _, rpt := range facts.State </span><span class="cov8" title="1">{
                if rpt.Skip(facts).IsSkipped </span><span class="cov8" title="1">{
                        skippedTask := v1.SkippedTask{
                                Name:            rpt.PipelineTask.Name,
                                Reason:          rpt.Skip(facts).SkippingReason,
                                WhenExpressions: rpt.PipelineTask.When,
                        }
                        skipped = append(skipped, skippedTask)
                }</span>
                <span class="cov8" title="1">if rpt.IsFinallySkipped(facts).IsSkipped </span><span class="cov8" title="1">{
                        skippedTask := v1.SkippedTask{
                                Name:   rpt.PipelineTask.Name,
                                Reason: rpt.IsFinallySkipped(facts).SkippingReason,
                        }
                        // include the when expressions only when the finally task was skipped because
                        // its when expressions evaluated to false (not because results variables were missing)
                        if rpt.IsFinallySkipped(facts).SkippingReason == v1.WhenExpressionsSkip </span><span class="cov8" title="1">{
                                skippedTask.WhenExpressions = rpt.PipelineTask.When
                        }</span>
                        <span class="cov8" title="1">skipped = append(skipped, skippedTask)</span>
                }
        }
        <span class="cov8" title="1">return skipped</span>
}

// GetPipelineTaskStatus returns the status of a PipelineTask depending on its taskRun
// the checks are implemented such that the finally tasks are requesting status of the dag tasks
func (facts *PipelineRunFacts) GetPipelineTaskStatus() map[string]string <span class="cov8" title="1">{
        // construct a map of tasks.&lt;pipelineTask&gt;.status and its state
        tStatus := make(map[string]string)
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isDAGTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        var s string
                        switch </span>{
                        // execution status is Succeeded when a task has succeeded condition with status set to true
                        case t.isSuccessful():<span class="cov8" title="1">
                                s = v1.TaskRunReasonSuccessful.String()</span>
                        // execution status is Failed when a task has succeeded condition with status set to false
                        case t.haveAnyRunsFailed():<span class="cov8" title="1">
                                s = v1.TaskRunReasonFailed.String()</span>
                        default:<span class="cov8" title="1">
                                // None includes skipped as well
                                s = PipelineTaskStateNone</span>
                        }
                        <span class="cov8" title="1">tStatus[PipelineTaskStatusPrefix+t.PipelineTask.Name+PipelineTaskStatusSuffix] = s
                        tStatus[PipelineTaskStatusPrefix+t.PipelineTask.Name+PipelineTaskReasonSuffix] = t.getReason()</span>
                }
        }

        // initialize aggregate status of all dag tasks to None
        <span class="cov8" title="1">aggregateStatus := PipelineTaskStateNone
        if facts.checkDAGTasksDone() </span><span class="cov8" title="1">{
                // all dag tasks are done, change the aggregate status to succeeded
                // will reset it to failed/skipped if needed
                aggregateStatus = v1.PipelineRunReasonSuccessful.String()
                for _, t := range facts.State </span><span class="cov8" title="1">{
                        if facts.isDAGTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                                // if any of the dag task failed, change the aggregate status to failed and return
                                if !t.IsCustomTask() &amp;&amp; t.haveAnyTaskRunsFailed() || t.IsCustomTask() &amp;&amp; t.haveAnyCustomRunsFailed() </span><span class="cov8" title="1">{
                                        aggregateStatus = v1.PipelineRunReasonFailed.String()
                                        break</span>
                                }
                                // if any of the dag task skipped, change the aggregate status to completed
                                // but continue checking for any other failure
                                <span class="cov8" title="1">if t.Skip(facts).IsSkipped </span><span class="cov8" title="1">{
                                        aggregateStatus = v1.PipelineRunReasonCompleted.String()
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">tStatus[v1.PipelineTasksAggregateStatus] = aggregateStatus
        return tStatus</span>
}

// GetPipelineFinalTaskStatus returns the status of a PipelineFinalTask depending on its taskRun
func (facts *PipelineRunFacts) GetPipelineFinalTaskStatus() map[string]string <span class="cov8" title="1">{
        // construct a map of tasks.&lt;pipelineTask&gt;.status and its state
        tStatus := make(map[string]string)
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isFinalTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        var s string
                        switch </span>{
                        // execution status is Succeeded when a task has succeeded condition with status set to true
                        case t.isSuccessful():<span class="cov8" title="1">
                                s = v1.TaskRunReasonSuccessful.String()</span>
                        // execution status is Failed when a task has succeeded condition with status set to false
                        case t.haveAnyRunsFailed():<span class="cov8" title="1">
                                s = v1.TaskRunReasonFailed.String()</span>
                        default:<span class="cov8" title="1">
                                // None includes skipped as well
                                s = PipelineTaskStateNone</span>
                        }
                        <span class="cov8" title="1">tStatus[PipelineTaskStatusPrefix+t.PipelineTask.Name+PipelineTaskStatusSuffix] = s</span>
                }
        }
        <span class="cov8" title="1">return tStatus</span>
}

// completedOrSkippedTasks returns a list of the names of all of the PipelineTasks in state
// which have completed or skipped
func (facts *PipelineRunFacts) completedOrSkippedDAGTasks() []string <span class="cov8" title="1">{
        tasks := []string{}
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if facts.isDAGTask(t.PipelineTask.Name) </span><span class="cov8" title="1">{
                        if t.isDone(facts) </span><span class="cov8" title="1">{
                                tasks = append(tasks, t.PipelineTask.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return tasks</span>
}

// checkTasksDone returns true if all tasks from the specified graph are finished executing
// a task is considered done if it has failed/succeeded/skipped
func (facts *PipelineRunFacts) checkTasksDone(d *dag.Graph) bool <span class="cov8" title="1">{
        for _, t := range facts.State </span><span class="cov8" title="1">{
                if isTaskInGraph(t.PipelineTask.Name, d) </span><span class="cov8" title="1">{
                        if !t.isDone(facts) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// check if all DAG tasks done executing (succeeded, failed, or skipped)
func (facts *PipelineRunFacts) checkDAGTasksDone() bool <span class="cov8" title="1">{
        return facts.checkTasksDone(facts.TasksGraph)
}</span>

// check if all finally tasks done executing (succeeded or failed)
func (facts *PipelineRunFacts) checkFinalTasksDone() bool <span class="cov8" title="1">{
        return facts.checkTasksDone(facts.FinalTasksGraph)
}</span>

// getPipelineTasksCount returns the count of successful tasks, failed tasks, cancelled tasks, skipped task, and incomplete tasks
func (facts *PipelineRunFacts) getPipelineTasksCount() pipelineRunStatusCount <span class="cov8" title="1">{
        s := pipelineRunStatusCount{
                Skipped:             0,
                Succeeded:           0,
                Failed:              0,
                Cancelled:           0,
                Incomplete:          0,
                SkippedDueToTimeout: 0,
                IgnoredFailed:       0,
                ValidationFailed:    0,
        }
        for _, t := range facts.State </span><span class="cov8" title="1">{
                switch </span>{
                // increment success counter since the task is successful
                case t.isSuccessful():<span class="cov8" title="1">
                        s.Succeeded++</span>
                // increment failure counter since the task is cancelled due to a timeout
                case t.isCancelledForTimeOut():<span class="cov8" title="1">
                        s.Failed++</span>
                // increment cancelled counter since the task is cancelled
                case t.isCancelled():<span class="cov8" title="1">
                        s.Cancelled++</span>
                // increment failure counter based on Task OnError type since the task has failed
                case t.isFailure():<span class="cov8" title="1">
                        if t.PipelineTask.OnError == v1.PipelineTaskContinue </span><span class="cov8" title="1">{
                                s.IgnoredFailed++
                        }</span> else<span class="cov8" title="1"> {
                                s.Failed++
                        }</span>
                case t.isValidationFailed(facts.ValidationFailedTask):<span class="cov0" title="0">
                        s.ValidationFailed++</span>
                // increment skipped and skipped due to timeout counters since the task was skipped due to the pipeline, tasks, or finally timeout being reached before the task was launched
                case t.Skip(facts).SkippingReason == v1.PipelineTimedOutSkip ||
                        t.Skip(facts).SkippingReason == v1.TasksTimedOutSkip ||
                        t.IsFinallySkipped(facts).SkippingReason == v1.FinallyTimedOutSkip:<span class="cov8" title="1">
                        s.Skipped++
                        s.SkippedDueToTimeout++</span>
                // increment skip counter since the task is skipped
                case t.Skip(facts).IsSkipped:<span class="cov8" title="1">
                        s.Skipped++</span>
                // checking if any finally tasks were referring to invalid/missing task results
                case t.IsFinallySkipped(facts).IsSkipped:<span class="cov8" title="1">
                        s.Skipped++</span>
                // increment incomplete counter since the task is pending and not executed yet
                default:<span class="cov8" title="1">
                        s.Incomplete++</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

// check if a specified pipelineTask is defined under tasks(DAG) section
func (facts *PipelineRunFacts) isDAGTask(pipelineTaskName string) bool <span class="cov8" title="1">{
        if _, ok := facts.TasksGraph.Nodes[pipelineTaskName]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// check if a specified pipelineTask is defined under finally section
func (facts *PipelineRunFacts) isFinalTask(pipelineTaskName string) bool <span class="cov8" title="1">{
        if _, ok := facts.FinalTasksGraph.Nodes[pipelineTaskName]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Check if a PipelineTask belongs to the specified Graph
func isTaskInGraph(pipelineTaskName string, d *dag.Graph) bool <span class="cov8" title="1">{
        if _, ok := d.Nodes[pipelineTaskName]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file446" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "sort"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
)

// ErrInvalidTaskResultReference indicates that the reason for the failure status is that there
// is an invalid task result reference
var ErrInvalidTaskResultReference = pipelineErrors.WrapUserError(errors.New("Invalid task result reference"))

// ResolvedResultRefs represents all of the ResolvedResultRef for a pipeline task
type ResolvedResultRefs []*ResolvedResultRef

// ResolvedResultRef represents a result ref reference that has been fully resolved (value has been populated).
// If the value is from a Result, then the ResultReference will be populated to point to the ResultReference
// which resulted in the value
type ResolvedResultRef struct {
        Value           v1.ResultValue
        ResultReference v1.ResultRef
        FromTaskRun     string
        FromRun         string
}

// ResolveResultRef resolves any ResultReference that are found in the target ResolvedPipelineTask
func ResolveResultRef(pipelineRunState PipelineRunState, target *ResolvedPipelineTask) (ResolvedResultRefs, string, error) <span class="cov8" title="1">{
        resolvedResultRefs, pt, err := convertToResultRefs(pipelineRunState, target)
        if err != nil </span><span class="cov8" title="1">{
                return nil, pt, err
        }</span>
        <span class="cov8" title="1">return removeDup(resolvedResultRefs), "", nil</span>
}

// ResolveResultRefs resolves any ResultReference that are found in the target ResolvedPipelineTask
func ResolveResultRefs(pipelineRunState PipelineRunState, targets PipelineRunState) (ResolvedResultRefs, string, error) <span class="cov8" title="1">{
        var allResolvedResultRefs ResolvedResultRefs
        for _, target := range targets </span><span class="cov8" title="1">{
                resolvedResultRefs, pt, err := convertToResultRefs(pipelineRunState, target)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, pt, err
                }</span>
                <span class="cov8" title="1">allResolvedResultRefs = append(allResolvedResultRefs, resolvedResultRefs...)</span>
        }
        <span class="cov8" title="1">return removeDup(allResolvedResultRefs), "", nil</span>
}

// validateArrayResultsIndex checks if the result array indexing reference is out of bound of the array size
func validateArrayResultsIndex(allResolvedResultRefs ResolvedResultRefs) error <span class="cov8" title="1">{
        for _, r := range allResolvedResultRefs </span><span class="cov8" title="1">{
                if r.Value.Type == v1.ParamTypeArray </span><span class="cov8" title="1">{
                        if r.ResultReference.ResultsIndex != nil &amp;&amp; *r.ResultReference.ResultsIndex &gt;= len(r.Value.ArrayVal) </span><span class="cov8" title="1">{
                                return fmt.Errorf("array Result Index %d for Task %s Result %s is out of bound of size %d", *r.ResultReference.ResultsIndex, r.ResultReference.PipelineTask, r.ResultReference.Result, len(r.Value.ArrayVal))
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func removeDup(refs ResolvedResultRefs) ResolvedResultRefs <span class="cov8" title="1">{
        if refs == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">resolvedResultRefByRef := make(map[v1.ResultRef]*ResolvedResultRef, len(refs))
        for _, resolvedResultRef := range refs </span><span class="cov8" title="1">{
                resolvedResultRefByRef[resolvedResultRef.ResultReference] = resolvedResultRef
        }</span>
        <span class="cov8" title="1">deduped := make([]*ResolvedResultRef, 0, len(resolvedResultRefByRef))

        // Sort the resulting keys to produce a deterministic ordering.
        order := make([]v1.ResultRef, 0, len(refs))
        for key := range resolvedResultRefByRef </span><span class="cov8" title="1">{
                order = append(order, key)
        }</span>
        <span class="cov8" title="1">sort.Slice(order, func(i, j int) bool </span><span class="cov8" title="1">{
                if order[i].PipelineTask &gt; order[j].PipelineTask </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if order[i].Result &gt; order[j].Result </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return true</span>
        })

        <span class="cov8" title="1">for _, key := range order </span><span class="cov8" title="1">{
                deduped = append(deduped, resolvedResultRefByRef[key])
        }</span>
        <span class="cov8" title="1">return deduped</span>
}

// convertToResultRefs walks a PipelineTask looking for result references. If any are
// found they are resolved to a value by searching pipelineRunState. The list of resolved
// references are returned. If an error is encountered due to an invalid result reference
// then a nil list and error is returned instead.
func convertToResultRefs(pipelineRunState PipelineRunState, target *ResolvedPipelineTask) (ResolvedResultRefs, string, error) <span class="cov8" title="1">{
        var resolvedResultRefs ResolvedResultRefs
        for _, resultRef := range v1.PipelineTaskResultRefs(target.PipelineTask) </span><span class="cov8" title="1">{
                referencedPipelineTask := pipelineRunState.ToMap()[resultRef.PipelineTask]
                if referencedPipelineTask == nil </span><span class="cov8" title="1">{
                        return nil, resultRef.PipelineTask, fmt.Errorf("could not find task %q referenced by result", resultRef.PipelineTask)
                }</span>

                <span class="cov8" title="1">if !referencedPipelineTask.isSuccessful() &amp;&amp; !referencedPipelineTask.isFailure() </span><span class="cov8" title="1">{
                        return nil, resultRef.PipelineTask, fmt.Errorf("task %q referenced by result was not finished", referencedPipelineTask.PipelineTask.Name)
                }</span>
                // Custom Task
                <span class="cov8" title="1">switch </span>{
                case referencedPipelineTask.IsCustomTask():<span class="cov8" title="1">
                        resolved, err := resolveCustomResultRef(referencedPipelineTask.CustomRuns, resultRef)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, resultRef.PipelineTask, err
                        }</span>
                        <span class="cov8" title="1">resolvedResultRefs = append(resolvedResultRefs, resolved)</span>
                default:<span class="cov8" title="1">
                        // Matrixed referenced Pipeline Task
                        if referencedPipelineTask.PipelineTask.IsMatrixed() </span><span class="cov8" title="1">{
                                arrayValues, err := findResultValuesForMatrix(referencedPipelineTask, resultRef)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, resultRef.PipelineTask, err
                                }</span>
                                <span class="cov8" title="1">for _, taskRun := range referencedPipelineTask.TaskRuns </span><span class="cov8" title="1">{
                                        resolved := createMatrixedTaskResultForParam(taskRun.Name, arrayValues, resultRef)
                                        resolvedResultRefs = append(resolvedResultRefs, resolved)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Regular PipelineTask
                                resolved, err := resolveResultRef(referencedPipelineTask.TaskRuns, resultRef)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, resultRef.PipelineTask, err
                                }</span>
                                <span class="cov8" title="1">resolvedResultRefs = append(resolvedResultRefs, resolved)</span>
                        }
                }
        }
        <span class="cov8" title="1">return resolvedResultRefs, "", nil</span>
}

func resolveCustomResultRef(customRuns []*v1beta1.CustomRun, resultRef *v1.ResultRef) (*ResolvedResultRef, error) <span class="cov8" title="1">{
        customRun := customRuns[0]
        runName := customRun.GetObjectMeta().GetName()
        runValue, err := findRunResultForParam(customRun, resultRef)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ResolvedResultRef{
                Value:           *paramValueFromCustomRunResult(runValue),
                FromTaskRun:     "",
                FromRun:         runName,
                ResultReference: *resultRef,
        }, nil</span>
}

func paramValueFromCustomRunResult(result string) *v1.ParamValue <span class="cov8" title="1">{
        var arrayResult []string
        // for fan out array result, which is represented as string, we should make it to array type param value
        if err := json.Unmarshal([]byte(result), &amp;arrayResult); err == nil &amp;&amp; len(arrayResult) &gt; 0 </span><span class="cov8" title="1">{
                if len(arrayResult) &gt; 1 </span><span class="cov8" title="1">{
                        return v1.NewStructuredValues(arrayResult[0], arrayResult[1:]...)
                }</span>
                <span class="cov8" title="1">return &amp;v1.ParamValue{
                        Type:     v1.ParamTypeArray,
                        ArrayVal: []string{arrayResult[0]},
                }</span>
        }
        <span class="cov8" title="1">return v1.NewStructuredValues(result)</span>
}

func resolveResultRef(taskRuns []*v1.TaskRun, resultRef *v1.ResultRef) (*ResolvedResultRef, error) <span class="cov8" title="1">{
        taskRun := taskRuns[0]
        taskRunName := taskRun.Name
        resultValue, err := findTaskResultForParam(taskRun, resultRef)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ResolvedResultRef{
                Value:           resultValue,
                FromTaskRun:     taskRunName,
                FromRun:         "",
                ResultReference: *resultRef,
        }, nil</span>
}

func findRunResultForParam(customRun *v1beta1.CustomRun, reference *v1.ResultRef) (string, error) <span class="cov8" title="1">{
        for _, result := range customRun.Status.Results </span><span class="cov8" title="1">{
                if result.Name == reference.Result </span><span class="cov8" title="1">{
                        return result.Value, nil
                }</span>
        }
        <span class="cov8" title="1">err := fmt.Errorf("%w: Could not find result with name %s for pipeline task %s", ErrInvalidTaskResultReference, reference.Result, reference.PipelineTask)
        return "", err</span>
}

func findTaskResultForParam(taskRun *v1.TaskRun, reference *v1.ResultRef) (v1.ResultValue, error) <span class="cov8" title="1">{
        results := taskRun.Status.TaskRunStatusFields.Results
        for _, result := range results </span><span class="cov8" title="1">{
                if result.Name == reference.Result </span><span class="cov8" title="1">{
                        return result.Value, nil
                }</span>
        }
        <span class="cov8" title="1">err := fmt.Errorf("%w: Could not find result with name %s for pipeline task %s", ErrInvalidTaskResultReference, reference.Result, reference.PipelineTask)
        return v1.ResultValue{}, err</span>
}

// findResultValuesForMatrix checks the resultsCache of the referenced Matrixed TaskRun to retrieve the resultValues and aggregate them into
// arrayValues. If the resultCache is empty, it will create the ResultCache so that the results can be accessed in subsequent tasks.
func findResultValuesForMatrix(referencedPipelineTask *ResolvedPipelineTask, resultRef *v1.ResultRef) (v1.ParamValue, error) <span class="cov8" title="1">{
        var resultsCache *map[string][]string
        if len(referencedPipelineTask.ResultsCache) == 0 </span><span class="cov8" title="1">{
                cache := createResultsCacheMatrixedTaskRuns(referencedPipelineTask)
                resultsCache = &amp;cache
                referencedPipelineTask.ResultsCache = *resultsCache
        }</span>
        <span class="cov8" title="1">if arrayValues, ok := referencedPipelineTask.ResultsCache[resultRef.Result]; ok </span><span class="cov8" title="1">{
                return v1.ParamValue{
                        Type:     v1.ParamTypeArray,
                        ArrayVal: arrayValues,
                }, nil
        }</span>
        <span class="cov8" title="1">err := fmt.Errorf("%w: Could not find result with name %s for task %s", ErrInvalidTaskResultReference, resultRef.Result, resultRef.PipelineTask)
        return v1.ParamValue{}, err</span>
}

func createMatrixedTaskResultForParam(taskRunName string, paramValue v1.ParamValue, resultRef *v1.ResultRef) *ResolvedResultRef <span class="cov8" title="1">{
        return &amp;ResolvedResultRef{
                Value:           paramValue,
                FromTaskRun:     taskRunName,
                FromRun:         "",
                ResultReference: *resultRef,
        }
}</span>

func (rs ResolvedResultRefs) getStringReplacements() map[string]string <span class="cov8" title="1">{
        replacements := map[string]string{}
        for _, r := range rs </span><span class="cov8" title="1">{
                switch r.Value.Type </span>{
                case v1.ParamTypeArray:<span class="cov8" title="1">
                        for i := range len(r.Value.ArrayVal) </span><span class="cov8" title="1">{
                                for _, target := range r.getReplaceTargetfromArrayIndex(i) </span><span class="cov8" title="1">{
                                        replacements[target] = r.Value.ArrayVal[i]
                                }</span>
                        }
                case v1.ParamTypeObject:<span class="cov8" title="1">
                        for key, element := range r.Value.ObjectVal </span><span class="cov8" title="1">{
                                for _, target := range r.getReplaceTargetfromObjectKey(key) </span><span class="cov8" title="1">{
                                        replacements[target] = element
                                }</span>
                        }

                case v1.ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        for _, target := range r.getReplaceTarget() </span><span class="cov8" title="1">{
                                replacements[target] = r.Value.StringVal
                        }</span>
                }
        }
        <span class="cov8" title="1">return replacements</span>
}

func (rs ResolvedResultRefs) getArrayReplacements() map[string][]string <span class="cov8" title="1">{
        replacements := map[string][]string{}
        for _, r := range rs </span><span class="cov8" title="1">{
                if r.Value.Type == v1.ParamType(v1.ResultsTypeArray) </span><span class="cov8" title="1">{
                        for _, target := range r.getReplaceTarget() </span><span class="cov8" title="1">{
                                replacements[target] = r.Value.ArrayVal
                        }</span>
                }
        }
        <span class="cov8" title="1">return replacements</span>
}

func (rs ResolvedResultRefs) getObjectReplacements() map[string]map[string]string <span class="cov8" title="1">{
        replacements := map[string]map[string]string{}
        for _, r := range rs </span><span class="cov8" title="1">{
                if r.Value.Type == v1.ParamType(v1.ResultsTypeObject) </span><span class="cov8" title="1">{
                        for _, target := range r.getReplaceTarget() </span><span class="cov8" title="1">{
                                replacements[target] = r.Value.ObjectVal
                        }</span>
                }
        }
        <span class="cov8" title="1">return replacements</span>
}

func (r *ResolvedResultRef) getReplaceTarget() []string <span class="cov8" title="1">{
        return []string{
                fmt.Sprintf("%s.%s.%s.%s", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result),
                fmt.Sprintf("%s.%s.%s[%q]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result),
                fmt.Sprintf("%s.%s.%s['%s']", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result),
        }
}</span>

func (r *ResolvedResultRef) getReplaceTargetfromArrayIndex(idx int) []string <span class="cov8" title="1">{
        return []string{
                fmt.Sprintf("%s.%s.%s.%s[%d]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, idx),
                fmt.Sprintf("%s.%s.%s[%q][%d]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, idx),
                fmt.Sprintf("%s.%s.%s['%s'][%d]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, idx),
        }
}</span>

func (r *ResolvedResultRef) getReplaceTargetfromObjectKey(key string) []string <span class="cov8" title="1">{
        return []string{
                fmt.Sprintf("%s.%s.%s.%s.%s", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, key),
                fmt.Sprintf("%s.%s.%s[%q][%s]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, key),
                fmt.Sprintf("%s.%s.%s['%s'][%s]", v1.ResultTaskPart, r.ResultReference.PipelineTask, v1.ResultResultPart, r.ResultReference.Result, key),
        }
}</span>
</pre>
		
		<pre class="file" id="file447" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "fmt"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/util/sets"
)

// ValidatePipelineTaskResults ensures that any result references used by pipeline tasks
// resolve to valid results. This prevents a situation where a PipelineTask references
// a result in another PipelineTask that doesn't exist or where the user has either misspelled
// a result name or the referenced task just doesn't return a result with that name.
func ValidatePipelineTaskResults(state PipelineRunState) error <span class="cov8" title="1">{
        ptMap := state.ToMap()
        for _, rpt := range state </span><span class="cov8" title="1">{
                for _, ref := range v1.PipelineTaskResultRefs(rpt.PipelineTask) </span><span class="cov8" title="1">{
                        if err := validateResultRef(ref, ptMap); err != nil </span><span class="cov8" title="1">{
                                return pipelineErrors.WrapUserError(fmt.Errorf("invalid result reference in pipeline task %q: %w", rpt.PipelineTask.Name, err))
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidatePipelineResults ensures that any result references used by PipelineResults
// resolve to valid results. This prevents a situation where a PipelineResult references
// a result in a PipelineTask that doesn't exist or where the user has either misspelled
// a result name or the referenced task just doesn't return a result with that name.
func ValidatePipelineResults(ps *v1.PipelineSpec, state PipelineRunState) error <span class="cov8" title="1">{
        ptMap := state.ToMap()
        for _, result := range ps.Results </span><span class="cov8" title="1">{
                expressions, _ := result.GetVarSubstitutionExpressions()
                refs := v1.NewResultRefs(expressions)
                for _, ref := range refs </span><span class="cov8" title="1">{
                        if err := validateResultRef(ref, ptMap); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid pipeline result %q: %w", result.Name, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateResultRef takes a ResultRef and searches for the result using the given
// map of PipelineTask name to ResolvedPipelineTask. If the ResultRef does not point
// to a pipeline task or named result then an error is returned.
func validateResultRef(ref *v1.ResultRef, ptMap map[string]*ResolvedPipelineTask) error <span class="cov8" title="1">{
        if _, ok := ptMap[ref.PipelineTask]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("referenced pipeline task %q does not exist", ref.PipelineTask)
        }</span>
        <span class="cov8" title="1">taskProvidesResult := false
        if ptMap[ref.PipelineTask].CustomTask </span><span class="cov8" title="1">{
                // We're not able to validate results pointing to custom tasks because
                // there's no facility to check what the result names will be before the
                // custom task executes.
                return nil
        }</span>
        <span class="cov8" title="1">if ptMap[ref.PipelineTask].ResolvedTask == nil || ptMap[ref.PipelineTask].ResolvedTask.TaskSpec == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to validate result referencing pipeline task %q: task spec not found", ref.PipelineTask)
        }</span>
        <span class="cov8" title="1">for _, taskResult := range ptMap[ref.PipelineTask].ResolvedTask.TaskSpec.Results </span><span class="cov8" title="1">{
                if taskResult.Name == ref.Result </span><span class="cov8" title="1">{
                        taskProvidesResult = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !taskProvidesResult </span><span class="cov8" title="1">{
                return fmt.Errorf("%q is not a named result returned by pipeline task %q", ref.Result, ref.PipelineTask)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateOptionalWorkspaces validates that any workspaces in the Pipeline that are
// marked as optional are also marked optional in the Tasks that receive them. This
// prevents a situation where a Task requires a workspace but a Pipeline does not offer
// the same guarantee the workspace will be provided at runtime.
func ValidateOptionalWorkspaces(pipelineWorkspaces []v1.PipelineWorkspaceDeclaration, state PipelineRunState) error <span class="cov8" title="1">{
        optionalWorkspaces := sets.NewString()
        for _, ws := range pipelineWorkspaces </span><span class="cov8" title="1">{
                if ws.Optional </span><span class="cov8" title="1">{
                        optionalWorkspaces.Insert(ws.Name)
                }</span>
        }

        <span class="cov8" title="1">for _, rpt := range state </span><span class="cov8" title="1">{
                for _, pws := range rpt.PipelineTask.Workspaces </span><span class="cov8" title="1">{
                        if rpt.ResolvedTask != nil &amp;&amp; rpt.ResolvedTask.TaskSpec != nil &amp;&amp; optionalWorkspaces.Has(pws.Workspace) </span><span class="cov8" title="1">{
                                for _, tws := range rpt.ResolvedTask.TaskSpec.Workspaces </span><span class="cov8" title="1">{
                                        if tws.Name == pws.Name &amp;&amp; !tws.Optional </span><span class="cov8" title="1">{
                                                return fmt.Errorf("pipeline workspace %q is marked optional but pipeline task %q requires it be provided", pws.Workspace, rpt.PipelineTask.Name)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file448" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "fmt"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/list"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun"
        trresources "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"
)

// ValidateParamTypesMatching validate that parameters in PipelineRun override corresponding parameters in Pipeline of the same type.
func ValidateParamTypesMatching(p *v1.PipelineSpec, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        // Build a map of parameter names/types declared in p.
        paramTypes := make(map[string]v1.ParamType)
        for _, param := range p.Params </span><span class="cov8" title="1">{
                paramTypes[param.Name] = param.Type
        }</span>

        // Build a list of parameter names from pr that have mismatching types with the map created above.
        <span class="cov8" title="1">var wrongTypeParamNames []string
        for _, param := range pr.Spec.Params </span><span class="cov8" title="1">{
                if paramType, ok := paramTypes[param.Name]; ok </span><span class="cov8" title="1">{
                        if param.Value.Type != paramType </span><span class="cov8" title="1">{
                                wrongTypeParamNames = append(wrongTypeParamNames, param.Name)
                        }</span>
                }
        }

        // Return an error with the misconfigured parameters' names, or return nil if there are none.
        <span class="cov8" title="1">if len(wrongTypeParamNames) != 0 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("parameters have inconsistent types : %s", wrongTypeParamNames))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateRequiredParametersProvided validates that all the parameters expected by the Pipeline are provided by the PipelineRun.
// Extra Parameters are allowed, the Pipeline will use the Parameters it needs and ignore the other Parameters.
func ValidateRequiredParametersProvided(pipelineParameters *v1.ParamSpecs, pipelineRunParameters *v1.Params) error <span class="cov8" title="1">{
        // Build a list of parameter names declared in pr.
        var providedParams []string
        for _, param := range *pipelineRunParameters </span><span class="cov8" title="1">{
                providedParams = append(providedParams, param.Name)
        }</span>

        <span class="cov8" title="1">var requiredParams []string
        for _, param := range *pipelineParameters </span><span class="cov8" title="1">{
                if param.Default == nil </span><span class="cov8" title="1">{ // include only parameters that don't have default values specified in the Pipeline
                        requiredParams = append(requiredParams, param.Name)
                }</span>
        }

        // Build a list of parameter names in p that are missing from pr.
        <span class="cov8" title="1">missingParams := list.DiffLeft(requiredParams, providedParams)

        // Return an error with the missing parameters' names, or return nil if there are none.
        if len(missingParams) != 0 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("pipelineRun missing parameters: %s", missingParams))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateObjectParamRequiredKeys validates that the required keys of all the object parameters expected by the Pipeline are provided by the PipelineRun.
func ValidateObjectParamRequiredKeys(pipelineParameters []v1.ParamSpec, pipelineRunParameters []v1.Param) error <span class="cov8" title="1">{
        missings := taskrun.MissingKeysObjectParamNames(pipelineParameters, pipelineRunParameters)
        if len(missings) != 0 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("pipelineRun missing object keys for parameters: %v", missings))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateParameterTypesInMatrix validates the type of Parameter for Matrix.Params
// and Matrix.Include.Params after any replacements are made from Task parameters or results
// Matrix.Params must be of type array. Matrix.Include.Params must be of type string.
func ValidateParameterTypesInMatrix(state PipelineRunState) error <span class="cov8" title="1">{
        for _, rpt := range state </span><span class="cov8" title="1">{
                m := rpt.PipelineTask.Matrix
                if m.HasInclude() </span><span class="cov8" title="1">{
                        for _, include := range m.Include </span><span class="cov8" title="1">{
                                for _, param := range include.Params </span><span class="cov8" title="1">{
                                        if param.Value.Type != v1.ParamTypeString </span><span class="cov8" title="1">{
                                                return fmt.Errorf("parameters of type string only are allowed, but param \"%s\" has type \"%s\" in pipelineTask \"%s\"",
                                                        param.Name, string(param.Value.Type), rpt.PipelineTask.Name)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if m.HasParams() </span><span class="cov8" title="1">{
                        for _, param := range m.Params </span><span class="cov8" title="1">{
                                if param.Value.Type != v1.ParamTypeArray </span><span class="cov8" title="1">{
                                        // If it's an array type that contains result references because it's consuming results
                                        // from a Matrixed PipelineTask continue
                                        if ps, ok := param.GetVarSubstitutionExpressions(); ok </span><span class="cov8" title="1">{
                                                if v1.LooksLikeContainsResultRefs(ps) </span><span class="cov8" title="1">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov8" title="1">return fmt.Errorf("parameters of type array only are allowed, but param \"%s\" has type \"%s\" in pipelineTask \"%s\"",
                                                param.Name, string(param.Value.Type), rpt.PipelineTask.Name)</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateParamArrayIndex validates if the param reference to an array param is out of bound.
// error is returned when the array indexing reference is out of bound of the array param
// e.g. if a param reference of $(params.array-param[2]) and the array param is of length 2.
func ValidateParamArrayIndex(ps *v1.PipelineSpec, params v1.Params) error <span class="cov8" title="1">{
        return trresources.ValidateOutOfBoundArrayParams(ps.Params, params, ps.GetIndexingReferencesToArrayParams())
}</span>
</pre>
		
		<pre class="file" id="file449" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        "gomodules.xyz/jsonpatch/v2"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var timeoutTaskRunPatchBytes, timeoutCustomRunPatchBytes []byte

func init() <span class="cov8" title="1">{
        var err error
        timeoutTaskRunPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{
                {
                        Operation: "add",
                        Path:      "/spec/status",
                        Value:     v1.TaskRunSpecStatusCancelled,
                },
                {
                        Operation: "add",
                        Path:      "/spec/statusMessage",
                        Value:     v1.TaskRunCancelledByPipelineTimeoutMsg,
                }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal TaskRun timeout patch bytes: %v", err)
        }</span>
        <span class="cov8" title="1">timeoutCustomRunPatchBytes, err = json.Marshal([]jsonpatch.JsonPatchOperation{
                {
                        Operation: "add",
                        Path:      "/spec/status",
                        Value:     v1beta1.CustomRunSpecStatusCancelled,
                },
                {
                        Operation: "add",
                        Path:      "/spec/statusMessage",
                        Value:     v1beta1.CustomRunCancelledByPipelineTimeoutMsg,
                }})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal CustomRun timeout patch bytes: %v", err)
        }</span>
}

// timeoutPipelineRun marks the PipelineRun as timed out and any resolved TaskRun(s) too.
func timeoutPipelineRun(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface) error <span class="cov8" title="1">{
        errs := timeoutPipelineTasks(ctx, logger, pr, clientSet)

        // If we successfully timed out all the TaskRuns and Runs, we can consider the PipelineRun timed out.
        if len(errs) == 0 </span><span class="cov8" title="1">{
                pr.SetTimeoutCondition(ctx)
                // update pr completed time
                pr.Status.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        }</span> else<span class="cov8" title="1"> {
                e := strings.Join(errs, "\n")
                // Indicate that we failed to time out the PipelineRun
                pr.Status.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  corev1.ConditionUnknown,
                        Reason:  v1.PipelineRunReasonCouldntTimeOut.String(),
                        Message: fmt.Sprintf("PipelineRun %q was timed out but had errors trying to time out TaskRuns and/or Runs: %s", pr.Name, e),
                })
                return fmt.Errorf("error(s) from timing out TaskRun(s) from PipelineRun %s: %s", pr.Name, e)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func timeoutCustomRun(ctx context.Context, customRunName string, namespace string, clientSet clientset.Interface) error <span class="cov8" title="1">{
        _, err := clientSet.TektonV1beta1().CustomRuns(namespace).Patch(ctx, customRunName, types.JSONPatchType, timeoutCustomRunPatchBytes, metav1.PatchOptions{}, "")
        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func timeoutTaskRun(ctx context.Context, taskRunName string, namespace string, clientSet clientset.Interface) error <span class="cov8" title="1">{
        _, err := clientSet.TektonV1().TaskRuns(namespace).Patch(ctx, taskRunName, types.JSONPatchType, timeoutTaskRunPatchBytes, metav1.PatchOptions{}, "")
        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

// timeoutPipelineTaskRuns patches `TaskRun` and `Run` with canceled status and an appropriate message
func timeoutPipelineTasks(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface) []string <span class="cov8" title="1">{
        return timeoutPipelineTasksForTaskNames(ctx, logger, pr, clientSet, sets.NewString())
}</span>

// timeoutPipelineTasksForTaskNames patches `TaskRun`s and `Run`s for the given task names, or all if no task names are given, with canceled status and appropriate message
func timeoutPipelineTasksForTaskNames(ctx context.Context, logger *zap.SugaredLogger, pr *v1.PipelineRun, clientSet clientset.Interface, taskNames sets.String) []string <span class="cov8" title="1">{
        errs := []string{}

        trNames, customRunNames, err := getChildObjectsFromPRStatusForTaskNames(ctx, pr.Status, taskNames)
        if err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err.Error())
        }</span>

        <span class="cov8" title="1">for _, taskRunName := range trNames </span><span class="cov8" title="1">{
                logger.Infof("patching TaskRun %s for timeout", taskRunName)

                if err := timeoutTaskRun(ctx, taskRunName, pr.Namespace, clientSet); err != nil </span><span class="cov8" title="1">{
                        if pipelineErrors.IsImmutableTaskRunSpecError(err) </span><span class="cov0" title="0">{
                                // The TaskRun may have completed and the spec field is immutable, we should ignore this error.
                                continue</span>
                        }
                        <span class="cov8" title="1">errs = append(errs, fmt.Errorf("failed to patch TaskRun `%s` with timeout: %w", taskRunName, err).Error())
                        continue</span>
                }
        }

        <span class="cov8" title="1">for _, custonRunName := range customRunNames </span><span class="cov8" title="1">{
                logger.Infof("patching CustomRun %s for timeout", custonRunName)

                if err := timeoutCustomRun(ctx, custonRunName, pr.Namespace, clientSet); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to patch CustomRun `%s` with timeout: %w", custonRunName, err).Error())
                        continue</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file450" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "encoding/json"
        "errors"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
        "knative.dev/pkg/logging"
)

const (
        // TracerName is the name of the tracer
        TracerName = "PipelineRunReconciler"
        // SpanContextAnnotation is the name of the Annotation for storing SpanContext
        SpanContextAnnotation = "tekton.dev/pipelinerunSpanContext"
        // TaskRunSpanContextAnnotation is the name of the Annotation used for propagating SpanContext to TaskRun
        TaskRunSpanContextAnnotation = "tekton.dev/taskrunSpanContext"
)

// initialize tracing by creating the root span and injecting the
// spanContext is propagated through annotations in the CR
func initTracing(ctx context.Context, tracerProvider trace.TracerProvider, pr *v1.PipelineRun) context.Context <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        pro := otel.GetTextMapPropagator()

        // SpanContext was created already
        if len(pr.Status.SpanContext) &gt; 0 </span><span class="cov0" title="0">{
                return pro.Extract(ctx, propagation.MapCarrier(pr.Status.SpanContext))
        }</span>

        <span class="cov8" title="1">spanContext := make(map[string]string)

        // SpanContext was propagated through annotations
        if pr.Annotations != nil &amp;&amp; pr.Annotations[SpanContextAnnotation] != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(pr.Annotations[SpanContextAnnotation]), &amp;spanContext)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("unable to unmarshal spancontext, err: %s", err)
                }</span>

                <span class="cov8" title="1">pr.Status.SpanContext = spanContext
                return pro.Extract(ctx, propagation.MapCarrier(pr.Status.SpanContext))</span>
        }

        // Create a new root span since there was no parent spanContext provided through annotations
        <span class="cov8" title="1">ctxWithTrace, span := tracerProvider.Tracer(TracerName).Start(ctx, "PipelineRun:Reconciler")
        defer span.End()
        span.SetAttributes(attribute.String("pipelinerun", pr.Name), attribute.String("namespace", pr.Namespace))

        pro.Inject(ctxWithTrace, propagation.MapCarrier(spanContext))

        logger.Debug("got tracing carrier", spanContext)
        if len(spanContext) == 0 </span><span class="cov8" title="1">{
                logger.Debug("tracerProvider doesn't provide a traceId, tracing is disabled")
                return ctx
        }</span>

        <span class="cov8" title="1">span.AddEvent("updating PipelineRun status with SpanContext")
        pr.Status.SpanContext = spanContext
        return ctxWithTrace</span>
}

// Extract spanContext from the context and return it as json encoded string
func getMarshalledSpanFromContext(ctx context.Context) (string, error) <span class="cov8" title="1">{
        carrier := make(map[string]string)
        pro := otel.GetTextMapPropagator()

        pro.Inject(ctx, propagation.MapCarrier(carrier))

        if len(carrier) == 0 </span><span class="cov8" title="1">{
                return "", errors.New("spanContext not present in the context, unable to marshall")
        }</span>

        <span class="cov0" title="0">marshalled, err := json.Marshal(carrier)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(marshalled) &gt;= 1024 </span><span class="cov0" title="0">{
                return "", errors.New("marshalled spanContext size is too big")
        }</span>
        <span class="cov0" title="0">return string(marshalled), nil</span>
}
</pre>
		
		<pre class="file" id="file451" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolutionrequest

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        resolutionrequestinformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        resolutionrequestreconciler "github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1beta1/resolutionrequest"
        "k8s.io/utils/clock"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController returns a func that returns a knative controller for processing
// ResolutionRequest objects.
func NewController(clock clock.PassiveClock) func(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)

                configStore := config.NewStore(logger.Named("config-store"))
                configStore.WatchConfigs(cmw)

                r := &amp;Reconciler{
                        clock: clock,
                }
                impl := resolutionrequestreconciler.NewImpl(ctx, r, func(impl *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        return controller.Options{
                                ConfigStore: configStore,
                        }
                }</span>)

                <span class="cov8" title="1">reqinformer := resolutionrequestinformer.Get(ctx)
                if _, err := reqinformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ResolutionRequest informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file452" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolutionrequest

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        rrreconciler "github.com/tektoncd/pipeline/pkg/client/resolution/injection/reconciler/resolution/v1beta1/resolutionrequest"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/reconciler"
)

// Reconciler is a knative reconciler for processing ResolutionRequest
// objects
type Reconciler struct {
        clock clock.PassiveClock
}

var _ rrreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind processes updates to ResolutionRequests, sets status
// fields on it, and returns any errors experienced along the way.
func (r *Reconciler) ReconcileKind(ctx context.Context, rr *v1beta1.ResolutionRequest) reconciler.Event <span class="cov8" title="1">{
        if rr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if rr.IsDone() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if rr.Status.GetCondition(apis.ConditionSucceeded) == nil </span><span class="cov0" title="0">{
                rr.Status.InitializeConditions()
        }</span>

        <span class="cov8" title="1">maximumResolutionDuration := config.FromContextOrDefaults(ctx).Defaults.DefaultMaximumResolutionTimeout
        switch </span>{
        case rr.Status.Data != "":<span class="cov8" title="1">
                rr.Status.MarkSucceeded()</span>
        case requestDuration(rr) &gt; maximumResolutionDuration:<span class="cov8" title="1">
                rr.Status.MarkFailed(resolutioncommon.ReasonResolutionTimedOut, timeoutMessage(maximumResolutionDuration))</span>
        default:<span class="cov8" title="1">
                rr.Status.MarkInProgress(resolutioncommon.MessageWaitingForResolver)
                return controller.NewRequeueAfter(maximumResolutionDuration - requestDuration(rr))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// requestDuration returns the amount of time that has passed since a
// given ResolutionRequest was created.
func requestDuration(rr *v1beta1.ResolutionRequest) time.Duration <span class="cov8" title="1">{
        creationTime := rr.ObjectMeta.CreationTimestamp.DeepCopy().Time.UTC()
        return time.Now().UTC().Sub(creationTime)
}</span>

func timeoutMessage(timeout time.Duration) string <span class="cov8" title="1">{
        return fmt.Sprintf("resolution took longer than global timeout of %s", timeout)
}</span>
</pre>
		
		<pre class="file" id="file453" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package reconciler

import (
        "time"

        "knative.dev/pkg/kmeta"
)

const (
        // minimumResourceAge is the age at which resources stop being IsYoungResource.
        minimumResourceAge = 5 * time.Second
)

// IsYoungResource checks whether the resource is younger than minimumResourceAge, based on its creation timestamp.
func IsYoungResource(obj kmeta.Accessor) bool <span class="cov8" title="1">{
        return time.Since(obj.GetCreationTimestamp().Time) &lt; minimumResourceAge
}</span>
</pre>
		
		<pre class="file" id="file454" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        verificationpolicyinformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        resolutionclient "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        resolutioninformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        "github.com/tektoncd/pipeline/pkg/pod"
        cloudeventclient "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim"
        resolution "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        "github.com/tektoncd/pipeline/pkg/spire"
        "github.com/tektoncd/pipeline/pkg/taskrunmetrics"
        "github.com/tektoncd/pipeline/pkg/tracing"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        limitrangeinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/limitrange"
        filteredpodinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/pod/filtered"
        secretinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/secret"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

const (
        // TracerProviderName is the name of TraceProvider
        TracerProviderName = "taskrun-reconciler"
)

// NewController instantiates a new controller.Impl from knative.dev/pkg/controller
func NewController(opts *pipeline.Options, clock clock.PassiveClock) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                kubeclientset := kubeclient.Get(ctx)
                pipelineclientset := pipelineclient.Get(ctx)
                taskRunInformer := taskruninformer.Get(ctx)
                podInformer := filteredpodinformer.Get(ctx, v1.ManagedByLabelKey)
                limitrangeInformer := limitrangeinformer.Get(ctx)
                verificationpolicyInformer := verificationpolicyinformer.Get(ctx)
                resolutionInformer := resolutioninformer.Get(ctx)
                secretinformer := secretinformer.Get(ctx)
                spireClient := spire.GetControllerAPIClient(ctx)
                tracerProvider := tracing.New(TracerProviderName, logger.Named("tracing"))
                taskrunmetricsRecorder := taskrunmetrics.Get(ctx)
                //nolint:contextcheck // OnStore methods does not support context as a parameter
                configStore := config.NewStore(logger.Named("config-store"),
                        taskrunmetrics.OnStore(logger, taskrunmetricsRecorder),
                        spire.OnStore(ctx, logger),
                        tracerProvider.OnStore(secretinformer.Lister()),
                )
                configStore.WatchConfigs(cmw)

                entrypointCache, err := pod.NewEntrypointCache(kubeclientset)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("Error creating entrypoint cache: %v", err)
                }</span>

                <span class="cov8" title="1">c := &amp;Reconciler{
                        KubeClientSet:            kubeclientset,
                        PipelineClientSet:        pipelineclientset,
                        Images:                   opts.Images,
                        Clock:                    clock,
                        spireClient:              spireClient,
                        taskRunLister:            taskRunInformer.Lister(),
                        limitrangeLister:         limitrangeInformer.Lister(),
                        verificationPolicyLister: verificationpolicyInformer.Lister(),
                        cloudEventClient:         cloudeventclient.Get(ctx),
                        metrics:                  taskrunmetricsRecorder,
                        entrypointCache:          entrypointCache,
                        podLister:                podInformer.Lister(),
                        pvcHandler:               volumeclaim.NewPVCHandler(kubeclientset, logger),
                        resolutionRequester:      resolution.NewCRDRequester(resolutionclient.Get(ctx), resolutionInformer.Lister()),
                        tracerProvider:           tracerProvider,
                }
                impl := taskrunreconciler.NewImpl(ctx, c, func(impl *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        return controller.Options{
                                AgentName:   pipeline.TaskRunControllerName,
                                ConfigStore: configStore,
                        }
                }</span>)

                <span class="cov8" title="1">if _, err := secretinformer.Informer().AddEventHandler(controller.HandleAll(tracerProvider.Handler)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Secret informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := taskRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register TaskRun informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := podInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1.TaskRun{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Pod informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file455" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "errors"
        "fmt"
        "path/filepath"
        "regexp"
        "sort"
        "strconv"
        "strings"

        "github.com/tektoncd/pipeline/internal/artifactref"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        podtpl "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/container"
        "github.com/tektoncd/pipeline/pkg/internal/resultref"
        "github.com/tektoncd/pipeline/pkg/pod"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "github.com/tektoncd/pipeline/pkg/workspace"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/sets"
)

const (
        // objectIndividualVariablePattern is the reference pattern for object individual keys params.&lt;object_param_name&gt;.&lt;key_name&gt;
        objectIndividualVariablePattern = "params.%s.%s"
)

var (
        paramPatterns = []string{
                "params.%s",
                "params[%q]",
                "params['%s']",
                // FIXME(vdemeester) Remove that with deprecating v1beta1
                "inputs.params.%s",
        }

        substitutionToParamNamePatterns = []string{
                `^params\.(\w+)$`,
                `^params\["([^"]+)"\]$`,
                `^params\['([^']+)'\]$`,
                // FIXME(vdemeester) Remove that with deprecating v1beta1
                `^inputs\.params\.(\w+)$`,
        }

        paramIndexRegexPatterns = []string{
                `\$\(params.%s\[([0-9]*)*\*?\]\)`,
                `\$\(params\[%q\]\[([0-9]*)*\*?\]\)`,
                `\$\(params\['%s'\]\[([0-9]*)*\*?\]\)`,
        }
)

// applyStepActionParameters applies the params from the task and the underlying step to the referenced stepaction.
// substitution order:
// 1. taskrun parameter values in step parameters
// 2. step-provided parameter values
// 3. default values that reference other parameters
// 4. simple default values
// 5. step result references
func applyStepActionParameters(step *v1.Step, spec *v1.TaskSpec, tr *v1.TaskRun, stepParams v1.Params, defaults []v1.ParamSpec) (*v1.Step, error) <span class="cov8" title="1">{
        // 1. taskrun parameter substitutions to step parameters
        if stepParams != nil </span><span class="cov8" title="1">{
                stringR, arrayR, objectR := getTaskParameters(spec, tr, spec.Params...)
                stepParams = stepParams.ReplaceVariables(stringR, arrayR, objectR)
        }</span>

        // 2. step provided parameters
        <span class="cov8" title="1">stepProvidedParams := make(map[string]v1.ParamValue)
        for _, sp := range stepParams </span><span class="cov8" title="1">{
                stepProvidedParams[sp.Name] = sp.Value
        }</span>
        // 3,4. get replacements from default params (both referenced and simple)
        <span class="cov8" title="1">stringReplacements, arrayReplacements, objectReplacements := replacementsFromDefaultParams(defaults)
        // process parameter values in order of substitution (2,3,4)
        processedParams := make([]v1.Param, 0, len(defaults))
        // keep track of parameters that need resolution and their references
        paramsNeedingResolution := make(map[string]bool)
        paramReferenceMap := make(map[string][]string) // maps param name to names of params it references

        // collect parameter references and handle parameters without references
        for _, p := range defaults </span><span class="cov8" title="1">{
                // 2. step provided parameters
                if value, exists := stepProvidedParams[p.Name]; exists </span><span class="cov8" title="1">{
                        // parameter provided by step, add it to processed
                        processedParams = append(processedParams, v1.Param{
                                Name:  p.Name,
                                Value: value,
                        })
                        continue</span>
                }

                // 3. default params
                <span class="cov8" title="1">if p.Default != nil </span><span class="cov8" title="1">{
                        if !strings.Contains(p.Default.StringVal, "$(params.") </span><span class="cov8" title="1">{
                                // parameter has no references, add it to processed
                                processedParams = append(processedParams, v1.Param{
                                        Name:  p.Name,
                                        Value: *p.Default,
                                })
                                continue</span>
                        }

                        // parameter has references to other parameters, track them &gt;:(
                        <span class="cov8" title="1">paramsNeedingResolution[p.Name] = true
                        matches, _ := substitution.ExtractVariableExpressions(p.Default.StringVal, "params")
                        referencedParams := make([]string, 0, len(matches))
                        for _, match := range matches </span><span class="cov8" title="1">{
                                paramName := strings.TrimSuffix(strings.TrimPrefix(match, "$(params."), ")")
                                referencedParams = append(referencedParams, paramName)
                        }</span>
                        <span class="cov8" title="1">paramReferenceMap[p.Name] = referencedParams</span>
                }
        }

        // process parameters until no more can be resolved
        <span class="cov8" title="1">for len(paramsNeedingResolution) &gt; 0 </span><span class="cov8" title="1">{
                paramWasResolved := false
                // track unresolved params and their references
                unresolvedParams := make(map[string][]string)

                for paramName := range paramsNeedingResolution </span><span class="cov8" title="1">{
                        canResolveParam := true
                        for _, referencedParam := range paramReferenceMap[paramName] </span><span class="cov8" title="1">{
                                // Check if referenced parameter is processed
                                isReferenceResolved := false
                                for _, pp := range processedParams </span><span class="cov8" title="1">{
                                        if pp.Name == referencedParam </span><span class="cov8" title="1">{
                                                isReferenceResolved = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !isReferenceResolved </span><span class="cov8" title="1">{
                                        canResolveParam = false
                                        unresolvedParams[paramName] = append(unresolvedParams[paramName], referencedParam)
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if canResolveParam </span><span class="cov8" title="1">{
                                // process this parameter as all its references have been resolved
                                for _, p := range defaults </span><span class="cov8" title="1">{
                                        if p.Name == paramName </span><span class="cov8" title="1">{
                                                defaultValue := *p.Default
                                                resolvedValue := defaultValue.StringVal
                                                // hydrate parameter references
                                                for _, referencedParam := range paramReferenceMap[paramName] </span><span class="cov8" title="1">{
                                                        for _, pp := range processedParams </span><span class="cov8" title="1">{
                                                                if pp.Name == referencedParam </span><span class="cov8" title="1">{
                                                                        resolvedValue = strings.ReplaceAll(
                                                                                resolvedValue,
                                                                                fmt.Sprintf("$(params.%s)", referencedParam),
                                                                                pp.Value.StringVal,
                                                                        )
                                                                        break</span>
                                                                }
                                                        }
                                                }
                                                <span class="cov8" title="1">defaultValue.StringVal = resolvedValue
                                                processedParams = append(processedParams, v1.Param{
                                                        Name:  paramName,
                                                        Value: defaultValue,
                                                })
                                                delete(paramsNeedingResolution, paramName)
                                                paramWasResolved = true
                                                break</span>
                                        }
                                }
                        }
                }

                // unresolvable parameters or circular dependencies
                <span class="cov8" title="1">if !paramWasResolved </span><span class="cov8" title="1">{
                        // check parameter references to a non-existent parameter
                        for param, unresolvedRefs := range unresolvedParams </span><span class="cov8" title="1">{
                                // check referenced parameters in defaults
                                for _, ref := range unresolvedRefs </span><span class="cov8" title="1">{
                                        exists := false
                                        for _, p := range defaults </span><span class="cov8" title="1">{
                                                if p.Name == ref </span><span class="cov8" title="1">{
                                                        exists = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("parameter %q references non-existent parameter %q", param, ref)
                                        }</span>
                                }
                                // parameters exist but can't be resolved hence it's a circular dependency
                                <span class="cov8" title="1">return nil, errors.New("circular dependency detected in parameter references")</span>
                        }
                }
        }

        // apply the processed parameters and merge all replacements (2,3,4)
        <span class="cov8" title="1">procStringReplacements, procArrayReplacements, procObjectReplacements := replacementsFromParams(processedParams)
        // merge replacements from defaults and processed params
        for k, v := range procStringReplacements </span><span class="cov8" title="1">{
                stringReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range procArrayReplacements </span><span class="cov8" title="1">{
                arrayReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range procObjectReplacements </span><span class="cov8" title="1">{
                if objectReplacements[k] == nil </span><span class="cov8" title="1">{
                        objectReplacements[k] = v
                }</span> else<span class="cov8" title="1"> {
                        for key, val := range v </span><span class="cov8" title="1">{
                                objectReplacements[k][key] = val
                        }</span>
                }
        }

        // 5. set step result replacements last
        <span class="cov8" title="1">if stepResultReplacements, err := replacementsFromStepResults(step, stepParams, defaults); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                // merge step result replacements into string replacements last
                for k, v := range stepResultReplacements </span><span class="cov8" title="1">{
                        stringReplacements[k] = v
                }</span>
        }

        // check if there are duplicate keys in the replacements
        // if the same key is present in both stringReplacements and arrayReplacements, it means
        // that the default value and the passed value have different types.
        <span class="cov8" title="1">if err := checkForDuplicateKeys(stringReplacements, arrayReplacements); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">container.ApplyStepReplacements(step, stringReplacements, arrayReplacements)

        return step, nil</span>
}

// checkForDuplicateKeys checks if there are duplicate keys in the replacements
func checkForDuplicateKeys(stringReplacements map[string]string, arrayReplacements map[string][]string) error <span class="cov8" title="1">{
        keys := make([]string, 0, len(stringReplacements))
        for k := range stringReplacements </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        for _, k := range keys </span><span class="cov8" title="1">{
                if _, ok := arrayReplacements[k]; ok </span><span class="cov8" title="1">{
                        paramName := paramNameFromReplacementKey(k)
                        return fmt.Errorf("invalid parameter substitution: %s. Please check the types of the default value and the passed value", paramName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// paramNameFromReplacementKey returns the param name from the replacement key in best effort
func paramNameFromReplacementKey(key string) string <span class="cov8" title="1">{
        for _, regexPattern := range substitutionToParamNamePatterns </span><span class="cov8" title="1">{
                re := regexp.MustCompile(regexPattern)
                if matches := re.FindStringSubmatch(key); matches != nil </span><span class="cov8" title="1">{
                        return matches[1]
                }</span>
        }
        // If no match is found, return the key
        <span class="cov0" title="0">return key</span>
}

// findArrayIndexParamUsage finds the array index in a string using array param substitution
func findArrayIndexParamUsage(s string, paramName string, stepName string, resultName string, stringReplacements map[string]string) map[string]string <span class="cov8" title="1">{
        for _, pattern := range paramIndexRegexPatterns </span><span class="cov8" title="1">{
                arrayIndexingRegex := regexp.MustCompile(fmt.Sprintf(pattern, paramName))
                matches := arrayIndexingRegex.FindAllStringSubmatch(s, -1)
                for _, match := range matches </span><span class="cov8" title="1">{
                        if len(match) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSuffix(strings.TrimPrefix(match[0], "$("), ")")
                                if match[1] != "" </span><span class="cov8" title="1">{
                                        stringReplacements[key] = fmt.Sprintf("$(steps.%s.results.%s[%s])", stepName, resultName, match[1])
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return stringReplacements</span>
}

// replacementsArrayIdxStepResults looks for Step Result array usage with index in the Step's command, args, env and script.
func replacementsArrayIdxStepResults(step *v1.Step, paramName string, stepName string, resultName string) map[string]string <span class="cov8" title="1">{
        stringReplacements := map[string]string{}
        for _, c := range step.Command </span><span class="cov8" title="1">{
                stringReplacements = findArrayIndexParamUsage(c, paramName, stepName, resultName, stringReplacements)
        }</span>
        <span class="cov8" title="1">for _, a := range step.Args </span><span class="cov8" title="1">{
                stringReplacements = findArrayIndexParamUsage(a, paramName, stepName, resultName, stringReplacements)
        }</span>
        <span class="cov8" title="1">for _, e := range step.Env </span><span class="cov8" title="1">{
                stringReplacements = findArrayIndexParamUsage(e.Value, paramName, stepName, resultName, stringReplacements)
        }</span>
        <span class="cov8" title="1">return stringReplacements</span>
}

// replacementsFromStepResults generates string replacements for params whose values is a variable substitution of a step result.
func replacementsFromStepResults(step *v1.Step, stepParams v1.Params, defaults []v1.ParamSpec) (map[string]string, error) <span class="cov8" title="1">{
        stringReplacements := map[string]string{}
        for _, sp := range stepParams </span><span class="cov8" title="1">{
                if sp.Value.StringVal != "" &amp;&amp; strings.HasPrefix(sp.Value.StringVal, "$(steps.") </span><span class="cov8" title="1">{
                        // eg: when parameter p1 references a step result, replace:
                        // $(params.p1) with $(steps.step1.results.foo)
                        value := strings.TrimSuffix(strings.TrimPrefix(sp.Value.StringVal, "$("), ")")
                        pr, err := resultref.ParseStepExpression(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">for _, d := range defaults </span><span class="cov8" title="1">{
                                if d.Name == sp.Name </span><span class="cov8" title="1">{
                                        switch d.Type </span>{
                                        case v1.ParamTypeObject:<span class="cov8" title="1">
                                                for k := range d.Properties </span><span class="cov8" title="1">{
                                                        stringReplacements[fmt.Sprintf("params.%s.%s", d.Name, k)] = fmt.Sprintf("$(steps.%s.results.%s.%s)", pr.ResourceName, pr.ResultName, k)
                                                }</span>
                                        case v1.ParamTypeArray:<span class="cov8" title="1">
                                                // for array parameters

                                                // with star notation, replace:
                                                // $(params.p1[*]) with $(steps.step1.results.foo[*])
                                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                                        stringReplacements[fmt.Sprintf(pattern+"[*]", d.Name)] = fmt.Sprintf("$(steps.%s.results.%s[*])", pr.ResourceName, pr.ResultName)
                                                }</span>
                                                // with index notation, replace:
                                                // $(params.p1[idx]) with $(steps.step1.results.foo[idx])
                                                <span class="cov8" title="1">for k, v := range replacementsArrayIdxStepResults(step, d.Name, pr.ResourceName, pr.ResultName) </span><span class="cov8" title="1">{
                                                        stringReplacements[k] = v
                                                }</span>
                                        case v1.ParamTypeString:<span class="cov8" title="1">
                                                fallthrough</span>
                                        default:<span class="cov8" title="1">
                                                // for string parameters and default case,
                                                // replace any reference to the parameter with the step result reference
                                                // since both use simple value substitution
                                                // eg: replace $(params.p1) with $(steps.step1.results.foo)
                                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                                        stringReplacements[fmt.Sprintf(pattern, d.Name)] = sp.Value.StringVal
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return stringReplacements, nil</span>
}

// getTaskParameters gets the string, array and object parameter variable replacements needed in the Task
func getTaskParameters(spec *v1.TaskSpec, tr *v1.TaskRun, defaults ...v1.ParamSpec) (map[string]string, map[string][]string, map[string]map[string]string) <span class="cov8" title="1">{
        // This assumes that the TaskRun inputs have been validated against what the Task requests.
        // Set params from Task defaults
        stringReplacements, arrayReplacements, objectReplacements := replacementsFromDefaultParams(defaults)

        // Set and overwrite params with the ones from the TaskRun
        trStrings, trArrays, trObjects := replacementsFromParams(tr.Spec.Params)
        for k, v := range trStrings </span><span class="cov8" title="1">{
                stringReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range trArrays </span><span class="cov8" title="1">{
                arrayReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range trObjects </span><span class="cov8" title="1">{
                for key, val := range v </span><span class="cov8" title="1">{
                        if objectReplacements != nil </span><span class="cov8" title="1">{
                                if objectReplacements[k] != nil </span><span class="cov8" title="1">{
                                        objectReplacements[k][key] = val
                                }</span> else<span class="cov8" title="1"> {
                                        objectReplacements[k] = v
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return stringReplacements, arrayReplacements, objectReplacements</span>
}

// ApplyParameters applies the params from a TaskRun.Parameters to a TaskSpec
func ApplyParameters(spec *v1.TaskSpec, tr *v1.TaskRun, defaults ...v1.ParamSpec) *v1.TaskSpec <span class="cov8" title="1">{
        stringReplacements, arrayReplacements, objectReplacements := getTaskParameters(spec, tr, defaults...)
        return ApplyReplacements(spec, stringReplacements, arrayReplacements, objectReplacements)
}</span>

func replacementsFromDefaultParams(defaults v1.ParamSpecs) (map[string]string, map[string][]string, map[string]map[string]string) <span class="cov8" title="1">{
        stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        objectReplacements := map[string]map[string]string{}

        // First pass: collect all non-reference default values
        for _, p := range defaults </span><span class="cov8" title="1">{
                if p.Default != nil &amp;&amp; !strings.Contains(p.Default.StringVal, "$(params.") </span><span class="cov8" title="1">{
                        switch p.Default.Type </span>{
                        case v1.ParamTypeArray:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        for i := range len(p.Default.ArrayVal) </span><span class="cov8" title="1">{
                                                stringReplacements[fmt.Sprintf(pattern+"[%d]", p.Name, i)] = p.Default.ArrayVal[i]
                                        }</span>
                                        <span class="cov8" title="1">arrayReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.ArrayVal</span>
                                }
                        case v1.ParamTypeObject:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        objectReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.ObjectVal
                                }</span>
                                <span class="cov8" title="1">for k, v := range p.Default.ObjectVal </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(objectIndividualVariablePattern, p.Name, k)] = v
                                }</span>
                        case v1.ParamTypeString:<span class="cov8" title="1">
                                fallthrough</span>
                        default:<span class="cov8" title="1">
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(pattern, p.Name)] = p.Default.StringVal
                                }</span>
                        }
                }
        }

        // Second pass: handle parameter references in default values
        <span class="cov8" title="1">for _, p := range defaults </span><span class="cov8" title="1">{
                if p.Default != nil &amp;&amp; strings.Contains(p.Default.StringVal, "$(params.") </span><span class="cov8" title="1">{
                        // extract referenced parameter name
                        matches, _ := substitution.ExtractVariableExpressions(p.Default.StringVal, "params")
                        for _, match := range matches </span><span class="cov8" title="1">{
                                paramName := strings.TrimPrefix(match, "$(params.")
                                paramName = strings.TrimSuffix(paramName, ")")

                                // find referenced parameter value
                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                        key := fmt.Sprintf(pattern, paramName)
                                        if value, exists := stringReplacements[key]; exists </span><span class="cov8" title="1">{
                                                // Apply the value to this parameter's default
                                                resolvedValue := strings.ReplaceAll(p.Default.StringVal, match, value)
                                                for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                                        stringReplacements[fmt.Sprintf(pattern, p.Name)] = resolvedValue
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return stringReplacements, arrayReplacements, objectReplacements</span>
}

func replacementsFromParams(params v1.Params) (map[string]string, map[string][]string, map[string]map[string]string) <span class="cov8" title="1">{
        // stringReplacements is used for standard single-string stringReplacements, while arrayReplacements contains arrays
        // and objectReplacements contains objects that need to be further processed.
        stringReplacements := map[string]string{}
        arrayReplacements := map[string][]string{}
        objectReplacements := map[string]map[string]string{}

        for _, p := range params </span><span class="cov8" title="1">{
                switch p.Value.Type </span>{
                case v1.ParamTypeArray:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                for i := range len(p.Value.ArrayVal) </span><span class="cov8" title="1">{
                                        stringReplacements[fmt.Sprintf(pattern+"[%d]", p.Name, i)] = p.Value.ArrayVal[i]
                                }</span>
                                <span class="cov8" title="1">arrayReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.ArrayVal</span>
                        }
                case v1.ParamTypeObject:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                objectReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.ObjectVal
                        }</span>
                        <span class="cov8" title="1">for k, v := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                                stringReplacements[fmt.Sprintf(objectIndividualVariablePattern, p.Name, k)] = v
                        }</span>
                case v1.ParamTypeString:<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        for _, pattern := range paramPatterns </span><span class="cov8" title="1">{
                                stringReplacements[fmt.Sprintf(pattern, p.Name)] = p.Value.StringVal
                        }</span>
                }
        }

        <span class="cov8" title="1">return stringReplacements, arrayReplacements, objectReplacements</span>
}

func getContextReplacements(taskName string, tr *v1.TaskRun) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "context.taskRun.name":      tr.Name,
                "context.task.name":         taskName,
                "context.taskRun.namespace": tr.Namespace,
                "context.taskRun.uid":       string(tr.ObjectMeta.UID),
                "context.task.retry-count":  strconv.Itoa(len(tr.Status.RetriesStatus)),
        }
}</span>

// ApplyContexts applies the substitution from $(context.(taskRun|task).*) with the specified values.
// Uses "" as a default if a value is not available.
func ApplyContexts(spec *v1.TaskSpec, taskName string, tr *v1.TaskRun) *v1.TaskSpec <span class="cov8" title="1">{
        return ApplyReplacements(spec, getContextReplacements(taskName, tr), map[string][]string{}, map[string]map[string]string{})
}</span>

// ApplyWorkspaces applies the substitution from paths that the workspaces in declarations mounted to, the
// volumes that bindings are realized with in the task spec and the PersistentVolumeClaim names for the
// workspaces.
func ApplyWorkspaces(ctx context.Context, spec *v1.TaskSpec, declarations []v1.WorkspaceDeclaration, bindings []v1.WorkspaceBinding, vols map[string]corev1.Volume) *v1.TaskSpec <span class="cov8" title="1">{
        stringReplacements := map[string]string{}

        bindNames := sets.NewString()
        for _, binding := range bindings </span><span class="cov8" title="1">{
                bindNames.Insert(binding.Name)
        }</span>

        <span class="cov8" title="1">for _, declaration := range declarations </span><span class="cov8" title="1">{
                prefix := fmt.Sprintf("workspaces.%s.", declaration.Name)
                if declaration.Optional &amp;&amp; !bindNames.Has(declaration.Name) </span><span class="cov8" title="1">{
                        stringReplacements[prefix+"bound"] = "false"
                        stringReplacements[prefix+"path"] = ""
                }</span> else<span class="cov8" title="1"> {
                        stringReplacements[prefix+"bound"] = "true"
                        spec = applyWorkspaceMountPath(prefix+"path", spec, declaration)
                }</span>
        }

        <span class="cov8" title="1">for name, vol := range vols </span><span class="cov8" title="1">{
                stringReplacements[fmt.Sprintf("workspaces.%s.volume", name)] = vol.Name
        }</span>
        <span class="cov8" title="1">for _, binding := range bindings </span><span class="cov8" title="1">{
                if binding.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        stringReplacements[fmt.Sprintf("workspaces.%s.claim", binding.Name)] = binding.PersistentVolumeClaim.ClaimName
                }</span> else<span class="cov8" title="1"> {
                        stringReplacements[fmt.Sprintf("workspaces.%s.claim", binding.Name)] = ""
                }</span>
        }
        <span class="cov8" title="1">return ApplyReplacements(spec, stringReplacements, map[string][]string{}, map[string]map[string]string{})</span>
}

// ApplyParametersToWorkspaceBindings applies parameters to the WorkspaceBindings of a TaskRun. It takes a TaskSpec and a TaskRun as input and returns the modified TaskRun.
func ApplyParametersToWorkspaceBindings(ts *v1.TaskSpec, tr *v1.TaskRun) *v1.TaskRun <span class="cov8" title="1">{
        tsCopy := ts.DeepCopy()
        parameters, _, _ := getTaskParameters(tsCopy, tr, tsCopy.Params...)
        tr.Spec.Workspaces = workspace.ReplaceWorkspaceBindingsVars(tr.Spec.Workspaces, parameters)
        return tr
}</span>

// applyWorkspaceMountPath accepts a workspace path variable of the form $(workspaces.foo.path) and replaces
// it in the fields of the TaskSpec. A new updated TaskSpec is returned. Steps or Sidecars in the TaskSpec
// that override the mountPath will receive that mountPath in place of the variable's value. Other Steps and
// Sidecars will see either the workspace's declared mountPath or the default of /workspaces/&lt;name&gt;.
func applyWorkspaceMountPath(variable string, spec *v1.TaskSpec, declaration v1.WorkspaceDeclaration) *v1.TaskSpec <span class="cov8" title="1">{
        stringReplacements := map[string]string{variable: ""}
        emptyArrayReplacements := map[string][]string{}
        defaultMountPath := declaration.GetMountPath()
        // Replace instances of the workspace path variable that are overridden per-Step
        for i := range spec.Steps </span><span class="cov8" title="1">{
                step := &amp;spec.Steps[i]
                for _, usage := range step.Workspaces </span><span class="cov8" title="1">{
                        if usage.Name == declaration.Name &amp;&amp; usage.MountPath != "" </span><span class="cov8" title="1">{
                                stringReplacements[variable] = usage.MountPath
                                container.ApplyStepReplacements(step, stringReplacements, emptyArrayReplacements)
                        }</span>
                }
        }
        // Replace instances of the workspace path variable that are overridden per-Sidecar
        <span class="cov8" title="1">for i := range spec.Sidecars </span><span class="cov8" title="1">{
                sidecar := &amp;spec.Sidecars[i]
                for _, usage := range sidecar.Workspaces </span><span class="cov8" title="1">{
                        if usage.Name == declaration.Name &amp;&amp; usage.MountPath != "" </span><span class="cov8" title="1">{
                                stringReplacements[variable] = usage.MountPath
                                container.ApplySidecarReplacements(sidecar, stringReplacements, emptyArrayReplacements)
                        }</span>
                }
        }
        // Replace any remaining instances of the workspace path variable, which should fall
        // back to the mount path specified in the declaration.
        <span class="cov8" title="1">stringReplacements[variable] = defaultMountPath
        return ApplyReplacements(spec, stringReplacements, emptyArrayReplacements, map[string]map[string]string{})</span>
}

// ApplyResults applies the substitution from values in results and step results which are referenced in spec as subitems
// of the replacementStr.
func ApplyResults(spec *v1.TaskSpec) *v1.TaskSpec <span class="cov8" title="1">{
        // Apply all the Step Result replacements
        for i := range spec.Steps </span><span class="cov8" title="1">{
                stringReplacements := getStepResultReplacements(spec.Steps[i], i)
                container.ApplyStepReplacements(&amp;spec.Steps[i], stringReplacements, map[string][]string{})
        }</span>
        <span class="cov8" title="1">stringReplacements := getTaskResultReplacements(spec)
        return ApplyReplacements(spec, stringReplacements, map[string][]string{}, map[string]map[string]string{})</span>
}

// getStepResultReplacements creates all combinations of string replacements from Step Results.
func getStepResultReplacements(step v1.Step, idx int) map[string]string <span class="cov8" title="1">{
        stringReplacements := map[string]string{}

        patterns := []string{
                "step.results.%s.path",
                "step.results[%q].path",
                "step.results['%s'].path",
        }
        stepName := pod.StepName(step.Name, idx)
        for _, result := range step.Results </span><span class="cov8" title="1">{
                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        stringReplacements[fmt.Sprintf(pattern, result.Name)] = filepath.Join(pipeline.StepsDir, stepName, "results", result.Name)
                }</span>
        }
        <span class="cov8" title="1">return stringReplacements</span>
}

// getTaskResultReplacements creates all combinations of string replacements from TaskResults.
func getTaskResultReplacements(spec *v1.TaskSpec) map[string]string <span class="cov8" title="1">{
        stringReplacements := map[string]string{}

        patterns := []string{
                "results.%s.path",
                "results[%q].path",
                "results['%s'].path",
        }

        for _, result := range spec.Results </span><span class="cov8" title="1">{
                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        stringReplacements[fmt.Sprintf(pattern, result.Name)] = filepath.Join(pipeline.DefaultResultPath, result.Name)
                }</span>
        }
        <span class="cov8" title="1">return stringReplacements</span>
}

// ApplyArtifacts replaces the occurrences of artifacts.path and step.artifacts.path with the absolute tekton internal path
func ApplyArtifacts(spec *v1.TaskSpec) *v1.TaskSpec <span class="cov8" title="1">{
        for i := range spec.Steps </span><span class="cov8" title="1">{
                stringReplacements := getArtifactReplacements(spec.Steps[i], i)
                container.ApplyStepReplacements(&amp;spec.Steps[i], stringReplacements, map[string][]string{})
        }</span>
        <span class="cov8" title="1">return spec</span>
}

func getArtifactReplacements(step v1.Step, idx int) map[string]string <span class="cov8" title="1">{
        stringReplacements := map[string]string{}
        stepName := pod.StepName(step.Name, idx)
        stringReplacements[artifactref.StepArtifactPathPattern] = filepath.Join(pipeline.StepsDir, stepName, "artifacts", "provenance.json")
        stringReplacements[artifactref.TaskArtifactPathPattern] = filepath.Join(pipeline.ArtifactsDir, "provenance.json")

        return stringReplacements
}</span>

// ApplyStepExitCodePath replaces the occurrences of exitCode path with the absolute tekton internal path
// Replace $(steps.&lt;step-name&gt;.exitCode.path) with pipeline.StepPath/&lt;step-name&gt;/exitCode
func ApplyStepExitCodePath(spec *v1.TaskSpec) *v1.TaskSpec <span class="cov8" title="1">{
        stringReplacements := map[string]string{}

        for i, step := range spec.Steps </span><span class="cov8" title="1">{
                stringReplacements[fmt.Sprintf("steps.%s.exitCode.path", pod.StepName(step.Name, i))] = filepath.Join(pipeline.StepsDir, pod.StepName(step.Name, i), "exitCode")
        }</span>
        <span class="cov8" title="1">return ApplyReplacements(spec, stringReplacements, map[string][]string{}, map[string]map[string]string{})</span>
}

// ApplyCredentialsPath applies a substitution of the key $(credentials.path) with the path that credentials
// from annotated secrets are written to.
func ApplyCredentialsPath(spec *v1.TaskSpec, path string) *v1.TaskSpec <span class="cov8" title="1">{
        stringReplacements := map[string]string{
                "credentials.path": path,
        }
        return ApplyReplacements(spec, stringReplacements, map[string][]string{}, map[string]map[string]string{})
}</span>

// ApplyReplacements replaces placeholders for declared parameters with the specified replacements.
func ApplyReplacements(spec *v1.TaskSpec, stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) *v1.TaskSpec <span class="cov8" title="1">{
        spec = spec.DeepCopy()

        // Apply variable expansion to steps fields.
        steps := spec.Steps
        for i := range steps </span><span class="cov8" title="1">{
                if steps[i].Params != nil </span><span class="cov8" title="1">{
                        steps[i].Params = steps[i].Params.ReplaceVariables(stringReplacements, arrayReplacements, objectReplacements)
                }</span>
                <span class="cov8" title="1">container.ApplyStepReplacements(&amp;steps[i], stringReplacements, arrayReplacements)</span>
        }

        // Apply variable expansion to stepTemplate fields.
        <span class="cov8" title="1">if spec.StepTemplate != nil </span><span class="cov8" title="1">{
                container.ApplyStepTemplateReplacements(spec.StepTemplate, stringReplacements, arrayReplacements)
        }</span>

        // Apply variable expansion to the build's volumes
        <span class="cov8" title="1">for i, v := range spec.Volumes </span><span class="cov8" title="1">{
                spec.Volumes[i].Name = substitution.ApplyReplacements(v.Name, stringReplacements)
                if v.VolumeSource.ConfigMap != nil </span><span class="cov8" title="1">{
                        spec.Volumes[i].ConfigMap.Name = substitution.ApplyReplacements(v.ConfigMap.Name, stringReplacements)
                        for index, item := range v.ConfigMap.Items </span><span class="cov8" title="1">{
                                spec.Volumes[i].ConfigMap.Items[index].Key = substitution.ApplyReplacements(item.Key, stringReplacements)
                                spec.Volumes[i].ConfigMap.Items[index].Path = substitution.ApplyReplacements(item.Path, stringReplacements)
                        }</span>
                }
                <span class="cov8" title="1">if v.VolumeSource.Secret != nil </span><span class="cov8" title="1">{
                        spec.Volumes[i].Secret.SecretName = substitution.ApplyReplacements(v.Secret.SecretName, stringReplacements)
                        for index, item := range v.Secret.Items </span><span class="cov8" title="1">{
                                spec.Volumes[i].Secret.Items[index].Key = substitution.ApplyReplacements(item.Key, stringReplacements)
                                spec.Volumes[i].Secret.Items[index].Path = substitution.ApplyReplacements(item.Path, stringReplacements)
                        }</span>
                }
                <span class="cov8" title="1">if v.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        spec.Volumes[i].PersistentVolumeClaim.ClaimName = substitution.ApplyReplacements(v.PersistentVolumeClaim.ClaimName, stringReplacements)
                }</span>
                <span class="cov8" title="1">if v.Projected != nil </span><span class="cov8" title="1">{
                        for _, s := range spec.Volumes[i].Projected.Sources </span><span class="cov8" title="1">{
                                if s.ConfigMap != nil </span><span class="cov8" title="1">{
                                        s.ConfigMap.Name = substitution.ApplyReplacements(s.ConfigMap.Name, stringReplacements)
                                }</span>
                                <span class="cov8" title="1">if s.Secret != nil </span><span class="cov8" title="1">{
                                        s.Secret.Name = substitution.ApplyReplacements(s.Secret.Name, stringReplacements)
                                }</span>
                                <span class="cov8" title="1">if s.ServiceAccountToken != nil </span><span class="cov8" title="1">{
                                        s.ServiceAccountToken.Audience = substitution.ApplyReplacements(s.ServiceAccountToken.Audience, stringReplacements)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if v.CSI != nil </span><span class="cov8" title="1">{
                        if v.CSI.NodePublishSecretRef != nil </span><span class="cov8" title="1">{
                                spec.Volumes[i].CSI.NodePublishSecretRef.Name = substitution.ApplyReplacements(v.CSI.NodePublishSecretRef.Name, stringReplacements)
                        }</span>
                        <span class="cov8" title="1">if v.CSI.VolumeAttributes != nil </span><span class="cov8" title="1">{
                                for key, value := range v.CSI.VolumeAttributes </span><span class="cov8" title="1">{
                                        spec.Volumes[i].CSI.VolumeAttributes[key] = substitution.ApplyReplacements(value, stringReplacements)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for i, v := range spec.Workspaces </span><span class="cov0" title="0">{
                spec.Workspaces[i].MountPath = substitution.ApplyReplacements(v.MountPath, stringReplacements)
        }</span>

        // Apply variable substitution to the sidecar definitions
        <span class="cov8" title="1">sidecars := spec.Sidecars
        for i := range sidecars </span><span class="cov8" title="1">{
                container.ApplySidecarReplacements(&amp;sidecars[i], stringReplacements, arrayReplacements)
        }</span>

        <span class="cov8" title="1">return spec</span>
}

// ApplyPodTemplateParameters applies parameter substitution to a PodTemplate
func ApplyPodTemplateReplacements(podTemplate *podtpl.Template, tr *v1.TaskRun, defaults ...v1.ParamSpec) *podtpl.Template <span class="cov8" title="1">{
        if podTemplate == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := podTemplate.DeepCopy()

        stringReplacements, _, _ := getTaskParameters(nil, tr, defaults...)

        // Apply substitution to NodeSelector
        if result.NodeSelector != nil </span><span class="cov8" title="1">{
                newNodeSelector := make(map[string]string)
                for k, v := range result.NodeSelector </span><span class="cov8" title="1">{
                        newKey := substitution.ApplyReplacements(k, stringReplacements)
                        newValue := substitution.ApplyReplacements(v, stringReplacements)
                        newNodeSelector[newKey] = newValue
                }</span>
                <span class="cov8" title="1">result.NodeSelector = newNodeSelector</span>
        }

        // Apply substitution to Tolerations
        <span class="cov8" title="1">for i := range result.Tolerations </span><span class="cov8" title="1">{
                result.Tolerations[i].Key = substitution.ApplyReplacements(result.Tolerations[i].Key, stringReplacements)
                result.Tolerations[i].Value = substitution.ApplyReplacements(result.Tolerations[i].Value, stringReplacements)
                result.Tolerations[i].Operator = corev1.TolerationOperator(substitution.ApplyReplacements(string(result.Tolerations[i].Operator), stringReplacements))
                result.Tolerations[i].Effect = corev1.TaintEffect(substitution.ApplyReplacements(string(result.Tolerations[i].Effect), stringReplacements))
        }</span>

        // Apply substitution to Affinity
        <span class="cov8" title="1">if result.Affinity != nil </span><span class="cov8" title="1">{
                applyAffinityReplacements(result.Affinity, stringReplacements)
        }</span>

        // Apply substitution to SecurityContext labels and annotations
        <span class="cov8" title="1">if result.SecurityContext != nil </span><span class="cov8" title="1">{
                applySecurityContextReplacements(result.SecurityContext, stringReplacements)
        }</span>

        // Apply substitution to RuntimeClassName
        <span class="cov8" title="1">if result.RuntimeClassName != nil </span><span class="cov8" title="1">{
                runtimeClassName := substitution.ApplyReplacements(*result.RuntimeClassName, stringReplacements)
                result.RuntimeClassName = &amp;runtimeClassName
        }</span>

        // Apply substitution to SchedulerName
        <span class="cov8" title="1">if result.SchedulerName != "" </span><span class="cov8" title="1">{
                result.SchedulerName = substitution.ApplyReplacements(result.SchedulerName, stringReplacements)
        }</span>

        // Apply substitution to PriorityClassName
        <span class="cov8" title="1">if result.PriorityClassName != nil </span><span class="cov8" title="1">{
                priorityClassName := substitution.ApplyReplacements(*result.PriorityClassName, stringReplacements)
                result.PriorityClassName = &amp;priorityClassName
        }</span>

        // Apply substitution to ImagePullSecrets
        <span class="cov8" title="1">for i := range result.ImagePullSecrets </span><span class="cov8" title="1">{
                result.ImagePullSecrets[i].Name = substitution.ApplyReplacements(result.ImagePullSecrets[i].Name, stringReplacements)
        }</span>

        // Apply substitution to HostAliases
        <span class="cov8" title="1">for i := range result.HostAliases </span><span class="cov8" title="1">{
                result.HostAliases[i].IP = substitution.ApplyReplacements(result.HostAliases[i].IP, stringReplacements)
                for j := range result.HostAliases[i].Hostnames </span><span class="cov8" title="1">{
                        result.HostAliases[i].Hostnames[j] = substitution.ApplyReplacements(result.HostAliases[i].Hostnames[j], stringReplacements)
                }</span>
        }

        // Apply substitution to TopologySpreadConstraints
        <span class="cov8" title="1">for i := range result.TopologySpreadConstraints </span><span class="cov8" title="1">{
                result.TopologySpreadConstraints[i].TopologyKey = substitution.ApplyReplacements(result.TopologySpreadConstraints[i].TopologyKey, stringReplacements)
                if result.TopologySpreadConstraints[i].LabelSelector != nil </span><span class="cov8" title="1">{
                        applyLabelSelectorReplacements(result.TopologySpreadConstraints[i].LabelSelector, stringReplacements)
                }</span>
        }

        // Apply substitution to DNSPolicy
        <span class="cov8" title="1">if result.DNSPolicy != nil </span><span class="cov8" title="1">{
                dnsPolicy := corev1.DNSPolicy(substitution.ApplyReplacements(string(*result.DNSPolicy), stringReplacements))
                result.DNSPolicy = &amp;dnsPolicy
        }</span>

        // Apply substitution to DNSConfig
        <span class="cov8" title="1">if result.DNSConfig != nil </span><span class="cov8" title="1">{
                applyDNSConfigReplacements(result.DNSConfig, stringReplacements)
        }</span>

        // Apply substitution to Volumes
        <span class="cov8" title="1">for i := range result.Volumes </span><span class="cov8" title="1">{
                applyVolumeReplacements(&amp;result.Volumes[i], stringReplacements)
        }</span>

        // Apply substitution to Env
        <span class="cov8" title="1">for i := range result.Env </span><span class="cov8" title="1">{
                result.Env[i].Name = substitution.ApplyReplacements(result.Env[i].Name, stringReplacements)
                result.Env[i].Value = substitution.ApplyReplacements(result.Env[i].Value, stringReplacements)
                if result.Env[i].ValueFrom != nil </span><span class="cov8" title="1">{
                        applyEnvVarSourceReplacements(result.Env[i].ValueFrom, stringReplacements)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func applyAffinityReplacements(affinity *corev1.Affinity, stringReplacements map[string]string) <span class="cov8" title="1">{
        if affinity.NodeAffinity != nil </span><span class="cov8" title="1">{
                applyNodeAffinityReplacements(affinity.NodeAffinity, stringReplacements)
        }</span>
        <span class="cov8" title="1">if affinity.PodAffinity != nil </span><span class="cov8" title="1">{
                applyPodAffinityReplacements(affinity.PodAffinity, stringReplacements)
        }</span>
        <span class="cov8" title="1">if affinity.PodAntiAffinity != nil </span><span class="cov8" title="1">{
                applyPodAntiAffinityReplacements(affinity.PodAntiAffinity, stringReplacements)
        }</span>
}

func applyNodeAffinityReplacements(nodeAffinity *corev1.NodeAffinity, stringReplacements map[string]string) <span class="cov8" title="1">{
        if nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != nil </span><span class="cov8" title="1">{
                for i := range nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms </span><span class="cov8" title="1">{
                        applyNodeSelectorTermReplacements(&amp;nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms[i], stringReplacements)
                }</span>
        }
        <span class="cov8" title="1">for i := range nodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution </span><span class="cov8" title="1">{
                applyNodeSelectorTermReplacements(&amp;nodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i].Preference, stringReplacements)
        }</span>
}

func applyNodeSelectorTermReplacements(term *corev1.NodeSelectorTerm, stringReplacements map[string]string) <span class="cov8" title="1">{
        for i := range term.MatchExpressions </span><span class="cov8" title="1">{
                term.MatchExpressions[i].Key = substitution.ApplyReplacements(term.MatchExpressions[i].Key, stringReplacements)
                for j := range term.MatchExpressions[i].Values </span><span class="cov8" title="1">{
                        term.MatchExpressions[i].Values[j] = substitution.ApplyReplacements(term.MatchExpressions[i].Values[j], stringReplacements)
                }</span>
        }
        <span class="cov8" title="1">for i := range term.MatchFields </span><span class="cov8" title="1">{
                term.MatchFields[i].Key = substitution.ApplyReplacements(term.MatchFields[i].Key, stringReplacements)
                for j := range term.MatchFields[i].Values </span><span class="cov8" title="1">{
                        term.MatchFields[i].Values[j] = substitution.ApplyReplacements(term.MatchFields[i].Values[j], stringReplacements)
                }</span>
        }
}

func applyPodAffinityReplacements(podAffinity *corev1.PodAffinity, stringReplacements map[string]string) <span class="cov8" title="1">{
        for i := range podAffinity.RequiredDuringSchedulingIgnoredDuringExecution </span><span class="cov8" title="1">{
                applyPodAffinityTermReplacements(&amp;podAffinity.RequiredDuringSchedulingIgnoredDuringExecution[i], stringReplacements)
        }</span>
        <span class="cov8" title="1">for i := range podAffinity.PreferredDuringSchedulingIgnoredDuringExecution </span><span class="cov8" title="1">{
                applyPodAffinityTermReplacements(&amp;podAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i].PodAffinityTerm, stringReplacements)
        }</span>
}

func applyPodAntiAffinityReplacements(podAntiAffinity *corev1.PodAntiAffinity, stringReplacements map[string]string) <span class="cov8" title="1">{
        for i := range podAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution </span><span class="cov8" title="1">{
                applyPodAffinityTermReplacements(&amp;podAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution[i], stringReplacements)
        }</span>
        <span class="cov8" title="1">for i := range podAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution </span><span class="cov0" title="0">{
                applyPodAffinityTermReplacements(&amp;podAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i].PodAffinityTerm, stringReplacements)
        }</span>
}

func applyPodAffinityTermReplacements(term *corev1.PodAffinityTerm, stringReplacements map[string]string) <span class="cov8" title="1">{
        if term.LabelSelector != nil </span><span class="cov8" title="1">{
                applyLabelSelectorReplacements(term.LabelSelector, stringReplacements)
        }</span>
        <span class="cov8" title="1">term.TopologyKey = substitution.ApplyReplacements(term.TopologyKey, stringReplacements)
        if term.NamespaceSelector != nil </span><span class="cov8" title="1">{
                applyLabelSelectorReplacements(term.NamespaceSelector, stringReplacements)
        }</span>
        <span class="cov8" title="1">for i := range term.Namespaces </span><span class="cov8" title="1">{
                term.Namespaces[i] = substitution.ApplyReplacements(term.Namespaces[i], stringReplacements)
        }</span>
}

func applyLabelSelectorReplacements(selector *metav1.LabelSelector, stringReplacements map[string]string) <span class="cov8" title="1">{
        if selector.MatchLabels != nil </span><span class="cov8" title="1">{
                newMatchLabels := make(map[string]string)
                for k, v := range selector.MatchLabels </span><span class="cov8" title="1">{
                        newKey := substitution.ApplyReplacements(k, stringReplacements)
                        newValue := substitution.ApplyReplacements(v, stringReplacements)
                        newMatchLabels[newKey] = newValue
                }</span>
                <span class="cov8" title="1">selector.MatchLabels = newMatchLabels</span>
        }
        <span class="cov8" title="1">for i := range selector.MatchExpressions </span><span class="cov8" title="1">{
                selector.MatchExpressions[i].Key = substitution.ApplyReplacements(selector.MatchExpressions[i].Key, stringReplacements)
                for j := range selector.MatchExpressions[i].Values </span><span class="cov8" title="1">{
                        selector.MatchExpressions[i].Values[j] = substitution.ApplyReplacements(selector.MatchExpressions[i].Values[j], stringReplacements)
                }</span>
        }
}

func applySecurityContextReplacements(securityContext *corev1.PodSecurityContext, stringReplacements map[string]string) <span class="cov8" title="1">{
        // Apply substitution to SELinuxOptions
        if securityContext.SELinuxOptions != nil </span><span class="cov8" title="1">{
                securityContext.SELinuxOptions.User = substitution.ApplyReplacements(securityContext.SELinuxOptions.User, stringReplacements)
                securityContext.SELinuxOptions.Role = substitution.ApplyReplacements(securityContext.SELinuxOptions.Role, stringReplacements)
                securityContext.SELinuxOptions.Type = substitution.ApplyReplacements(securityContext.SELinuxOptions.Type, stringReplacements)
                securityContext.SELinuxOptions.Level = substitution.ApplyReplacements(securityContext.SELinuxOptions.Level, stringReplacements)
        }</span>

        // Apply substitution to WindowsOptions
        <span class="cov8" title="1">if securityContext.WindowsOptions != nil </span><span class="cov8" title="1">{
                if securityContext.WindowsOptions.GMSACredentialSpecName != nil </span><span class="cov8" title="1">{
                        gmsaCredentialSpecName := substitution.ApplyReplacements(*securityContext.WindowsOptions.GMSACredentialSpecName, stringReplacements)
                        securityContext.WindowsOptions.GMSACredentialSpecName = &amp;gmsaCredentialSpecName
                }</span>
                <span class="cov8" title="1">if securityContext.WindowsOptions.GMSACredentialSpec != nil </span><span class="cov8" title="1">{
                        gmsaCredentialSpec := substitution.ApplyReplacements(*securityContext.WindowsOptions.GMSACredentialSpec, stringReplacements)
                        securityContext.WindowsOptions.GMSACredentialSpec = &amp;gmsaCredentialSpec
                }</span>
                <span class="cov8" title="1">if securityContext.WindowsOptions.RunAsUserName != nil </span><span class="cov8" title="1">{
                        runAsUserName := substitution.ApplyReplacements(*securityContext.WindowsOptions.RunAsUserName, stringReplacements)
                        securityContext.WindowsOptions.RunAsUserName = &amp;runAsUserName
                }</span>
        }

        // Apply substitution to SupplementalGroupsPolicy
        <span class="cov8" title="1">if securityContext.SupplementalGroupsPolicy != nil </span><span class="cov8" title="1">{
                supplementalGroupsPolicy := corev1.SupplementalGroupsPolicy(substitution.ApplyReplacements(string(*securityContext.SupplementalGroupsPolicy), stringReplacements))
                securityContext.SupplementalGroupsPolicy = &amp;supplementalGroupsPolicy
        }</span>

        // Apply substitution to Sysctls
        <span class="cov8" title="1">for i := range securityContext.Sysctls </span><span class="cov8" title="1">{
                securityContext.Sysctls[i].Name = substitution.ApplyReplacements(securityContext.Sysctls[i].Name, stringReplacements)
                securityContext.Sysctls[i].Value = substitution.ApplyReplacements(securityContext.Sysctls[i].Value, stringReplacements)
        }</span>

        // Apply substitution to FSGroupChangePolicy
        <span class="cov8" title="1">if securityContext.FSGroupChangePolicy != nil </span><span class="cov8" title="1">{
                fsGroupChangePolicy := corev1.PodFSGroupChangePolicy(substitution.ApplyReplacements(string(*securityContext.FSGroupChangePolicy), stringReplacements))
                securityContext.FSGroupChangePolicy = &amp;fsGroupChangePolicy
        }</span>

        // Apply substitution to SeccompProfile
        <span class="cov8" title="1">if securityContext.SeccompProfile != nil </span><span class="cov8" title="1">{
                securityContext.SeccompProfile.Type = corev1.SeccompProfileType(substitution.ApplyReplacements(string(securityContext.SeccompProfile.Type), stringReplacements))
                if securityContext.SeccompProfile.LocalhostProfile != nil </span><span class="cov8" title="1">{
                        localhostProfile := substitution.ApplyReplacements(*securityContext.SeccompProfile.LocalhostProfile, stringReplacements)
                        securityContext.SeccompProfile.LocalhostProfile = &amp;localhostProfile
                }</span>
        }

        // Apply substitution to AppArmorProfile
        <span class="cov8" title="1">if securityContext.AppArmorProfile != nil </span><span class="cov8" title="1">{
                securityContext.AppArmorProfile.Type = corev1.AppArmorProfileType(substitution.ApplyReplacements(string(securityContext.AppArmorProfile.Type), stringReplacements))
                if securityContext.AppArmorProfile.LocalhostProfile != nil </span><span class="cov8" title="1">{
                        localhostProfile := substitution.ApplyReplacements(*securityContext.AppArmorProfile.LocalhostProfile, stringReplacements)
                        securityContext.AppArmorProfile.LocalhostProfile = &amp;localhostProfile
                }</span>
        }

        // Apply substitution to SELinuxChangePolicy
        <span class="cov8" title="1">if securityContext.SELinuxChangePolicy != nil </span><span class="cov8" title="1">{
                seLinuxChangePolicy := corev1.PodSELinuxChangePolicy(substitution.ApplyReplacements(string(*securityContext.SELinuxChangePolicy), stringReplacements))
                securityContext.SELinuxChangePolicy = &amp;seLinuxChangePolicy
        }</span>
}

func applyDNSConfigReplacements(dnsConfig *corev1.PodDNSConfig, stringReplacements map[string]string) <span class="cov8" title="1">{
        for i := range dnsConfig.Nameservers </span><span class="cov8" title="1">{
                dnsConfig.Nameservers[i] = substitution.ApplyReplacements(dnsConfig.Nameservers[i], stringReplacements)
        }</span>
        <span class="cov8" title="1">for i := range dnsConfig.Searches </span><span class="cov8" title="1">{
                dnsConfig.Searches[i] = substitution.ApplyReplacements(dnsConfig.Searches[i], stringReplacements)
        }</span>
        <span class="cov8" title="1">for i := range dnsConfig.Options </span><span class="cov8" title="1">{
                dnsConfig.Options[i].Name = substitution.ApplyReplacements(dnsConfig.Options[i].Name, stringReplacements)
                if dnsConfig.Options[i].Value != nil </span><span class="cov8" title="1">{
                        value := substitution.ApplyReplacements(*dnsConfig.Options[i].Value, stringReplacements)
                        dnsConfig.Options[i].Value = &amp;value
                }</span>
        }
}

func applyVolumeReplacements(volume *corev1.Volume, stringReplacements map[string]string) <span class="cov8" title="1">{
        volume.Name = substitution.ApplyReplacements(volume.Name, stringReplacements)
        if volume.ConfigMap != nil </span><span class="cov8" title="1">{
                volume.ConfigMap.Name = substitution.ApplyReplacements(volume.ConfigMap.Name, stringReplacements)
                for i := range volume.ConfigMap.Items </span><span class="cov8" title="1">{
                        volume.ConfigMap.Items[i].Key = substitution.ApplyReplacements(volume.ConfigMap.Items[i].Key, stringReplacements)
                        volume.ConfigMap.Items[i].Path = substitution.ApplyReplacements(volume.ConfigMap.Items[i].Path, stringReplacements)
                }</span>
        }
        <span class="cov8" title="1">if volume.Secret != nil </span><span class="cov8" title="1">{
                volume.Secret.SecretName = substitution.ApplyReplacements(volume.Secret.SecretName, stringReplacements)
                for i := range volume.Secret.Items </span><span class="cov8" title="1">{
                        volume.Secret.Items[i].Key = substitution.ApplyReplacements(volume.Secret.Items[i].Key, stringReplacements)
                        volume.Secret.Items[i].Path = substitution.ApplyReplacements(volume.Secret.Items[i].Path, stringReplacements)
                }</span>
        }
        <span class="cov8" title="1">if volume.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                volume.PersistentVolumeClaim.ClaimName = substitution.ApplyReplacements(volume.PersistentVolumeClaim.ClaimName, stringReplacements)
        }</span>
        <span class="cov8" title="1">if volume.Projected != nil </span><span class="cov8" title="1">{
                for _, s := range volume.Projected.Sources </span><span class="cov8" title="1">{
                        if s.ConfigMap != nil </span><span class="cov8" title="1">{
                                s.ConfigMap.Name = substitution.ApplyReplacements(s.ConfigMap.Name, stringReplacements)
                        }</span>
                        <span class="cov8" title="1">if s.Secret != nil </span><span class="cov8" title="1">{
                                s.Secret.Name = substitution.ApplyReplacements(s.Secret.Name, stringReplacements)
                        }</span>
                        <span class="cov8" title="1">if s.ServiceAccountToken != nil </span><span class="cov8" title="1">{
                                s.ServiceAccountToken.Audience = substitution.ApplyReplacements(s.ServiceAccountToken.Audience, stringReplacements)
                        }</span>
                }
        }
        <span class="cov8" title="1">if volume.CSI != nil </span><span class="cov8" title="1">{
                if volume.CSI.NodePublishSecretRef != nil </span><span class="cov8" title="1">{
                        volume.CSI.NodePublishSecretRef.Name = substitution.ApplyReplacements(volume.CSI.NodePublishSecretRef.Name, stringReplacements)
                }</span>
                <span class="cov8" title="1">if volume.CSI.VolumeAttributes != nil </span><span class="cov8" title="1">{
                        for key, value := range volume.CSI.VolumeAttributes </span><span class="cov8" title="1">{
                                volume.CSI.VolumeAttributes[key] = substitution.ApplyReplacements(value, stringReplacements)
                        }</span>
                }
        }
}

func applyEnvVarSourceReplacements(valueFrom *corev1.EnvVarSource, stringReplacements map[string]string) <span class="cov8" title="1">{
        if valueFrom.ConfigMapKeyRef != nil </span><span class="cov8" title="1">{
                valueFrom.ConfigMapKeyRef.Name = substitution.ApplyReplacements(valueFrom.ConfigMapKeyRef.Name, stringReplacements)
                valueFrom.ConfigMapKeyRef.Key = substitution.ApplyReplacements(valueFrom.ConfigMapKeyRef.Key, stringReplacements)
        }</span>
        <span class="cov8" title="1">if valueFrom.SecretKeyRef != nil </span><span class="cov8" title="1">{
                valueFrom.SecretKeyRef.Name = substitution.ApplyReplacements(valueFrom.SecretKeyRef.Name, stringReplacements)
                valueFrom.SecretKeyRef.Key = substitution.ApplyReplacements(valueFrom.SecretKeyRef.Key, stringReplacements)
        }</span>
        <span class="cov8" title="1">if valueFrom.FieldRef != nil </span><span class="cov8" title="1">{
                valueFrom.FieldRef.FieldPath = substitution.ApplyReplacements(valueFrom.FieldRef.FieldPath, stringReplacements)
        }</span>
        <span class="cov8" title="1">if valueFrom.ResourceFieldRef != nil </span><span class="cov8" title="1">{
                valueFrom.ResourceFieldRef.Resource = substitution.ApplyReplacements(valueFrom.ResourceFieldRef.Resource, stringReplacements)
                valueFrom.ResourceFieldRef.ContainerName = substitution.ApplyReplacements(valueFrom.ResourceFieldRef.ContainerName, stringReplacements)
        }</span>
}
</pre>
		
		<pre class="file" id="file456" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "errors"
        "fmt"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        resolutionV1beta1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "github.com/tektoncd/pipeline/pkg/reconciler/apiserver"
        "github.com/tektoncd/pipeline/pkg/remote"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/remote/resolution"
        remoteresource "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/kmeta"
)

// GetTaskKind returns the referenced Task kind (Task, ...) if the TaskRun is using TaskRef.
func GetTaskKind(taskrun *v1.TaskRun) v1.TaskKind <span class="cov8" title="1">{
        kind := v1.NamespacedTaskKind
        if taskrun.Spec.TaskRef != nil &amp;&amp; taskrun.Spec.TaskRef.Kind != "" </span><span class="cov8" title="1">{
                kind = taskrun.Spec.TaskRef.Kind
        }</span>
        <span class="cov8" title="1">return kind</span>
}

// GetTaskFuncFromTaskRun is a factory function that will use the given TaskRef as context to return a valid GetTask function.
// It also requires a kubeclient, tektonclient, namespace, and service account in case it needs to find that task in
// cluster or authorize against an external repository. It will figure out whether it needs to look in the cluster or in
// a remote image to fetch the  reference. It will also return the "kind" of the task being referenced.
// OCI bundle and remote resolution tasks will be verified by trusted resources if the feature is enabled
func GetTaskFuncFromTaskRun(ctx context.Context, k8s kubernetes.Interface, tekton clientset.Interface, requester remoteresource.Requester, taskrun *v1.TaskRun, verificationPolicies []*v1alpha1.VerificationPolicy) GetTask <span class="cov8" title="1">{
        // if the spec is already in the status, do not try to fetch it again, just use it as source of truth.
        // Same for the RefSource field in the Status.Provenance.
        if taskrun.Status.TaskSpec != nil </span><span class="cov8" title="1">{
                return func(_ context.Context, name string) (*v1.Task, *v1.RefSource, *trustedresources.VerificationResult, error) </span><span class="cov8" title="1">{
                        var refSource *v1.RefSource
                        if taskrun.Status.Provenance != nil </span><span class="cov8" title="1">{
                                refSource = taskrun.Status.Provenance.RefSource
                        }</span>
                        <span class="cov8" title="1">return &amp;v1.Task{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      name,
                                        Namespace: taskrun.Namespace,
                                },
                                Spec: *taskrun.Status.TaskSpec,
                        }, refSource, nil, nil</span>
                }
        }
        <span class="cov0" title="0">return GetTaskFunc(ctx, k8s, tekton, requester, taskrun, taskrun.Spec.TaskRef, taskrun.Name, taskrun.Namespace, taskrun.Spec.ServiceAccountName, verificationPolicies)</span>
}

// GetTaskFunc is a factory function that will use the given TaskRef as context to return a valid GetTask function.
// It also requires a kubeclient, tektonclient, namespace, and service account in case it needs to find that task in
// cluster or authorize against an external repository. It will figure out whether it needs to look in the cluster or in
// a remote image to fetch the  reference. It will also return the "kind" of the task being referenced.
// OCI bundle and remote resolution tasks will be verified by trusted resources if the feature is enabled
func GetTaskFunc(ctx context.Context, k8s kubernetes.Interface, tekton clientset.Interface, requester remoteresource.Requester,
        owner kmeta.OwnerRefable, tr *v1.TaskRef, trName string, namespace, saName string, verificationPolicies []*v1alpha1.VerificationPolicy,
) GetTask <span class="cov8" title="1">{
        kind := v1.NamespacedTaskKind
        if tr != nil &amp;&amp; tr.Kind != "" </span><span class="cov0" title="0">{
                kind = tr.Kind
        }</span>

        <span class="cov8" title="1">switch </span>{
        case tr != nil &amp;&amp; tr.Resolver != "" &amp;&amp; requester != nil:<span class="cov8" title="1">
                // Return an inline function that implements GetTask by calling Resolver.Get with the specified task type and
                // casting it to a TaskObject.
                return func(ctx context.Context, name string) (*v1.Task, *v1.RefSource, *trustedresources.VerificationResult, error) </span><span class="cov8" title="1">{
                        var replacedParams v1.Params
                        var url string
                        if ownerAsTR, ok := owner.(*v1.TaskRun); ok </span><span class="cov8" title="1">{
                                stringReplacements, arrayReplacements, _ := replacementsFromParams(ownerAsTR.Spec.Params)
                                for k, v := range getContextReplacements("", ownerAsTR) </span><span class="cov8" title="1">{
                                        stringReplacements[k] = v
                                }</span>
                                <span class="cov8" title="1">for _, p := range tr.Params </span><span class="cov8" title="1">{
                                        p.Value.ApplyReplacements(stringReplacements, arrayReplacements, nil)
                                        replacedParams = append(replacedParams, p)
                                }</span>
                                <span class="cov8" title="1">if err := v1.RefNameLikeUrl(tr.Name); err == nil </span><span class="cov8" title="1">{
                                        // The name is url-like so its not a local reference.
                                        tr.Name = substitution.ApplyReplacements(tr.Name, stringReplacements)
                                        url = tr.Name
                                }</span>
                        } else<span class="cov0" title="0"> {
                                replacedParams = append(replacedParams, tr.Params...)
                        }</span>
                        <span class="cov8" title="1">resolverPayload := remoteresource.ResolverPayload{
                                Name:      trName,
                                Namespace: namespace,
                                ResolutionSpec: &amp;resolutionV1beta1.ResolutionRequestSpec{
                                        Params: replacedParams,
                                        URL:    url,
                                },
                        }
                        resolver := resolution.NewResolver(requester, owner, string(tr.Resolver), resolverPayload)
                        return resolveTask(ctx, resolver, name, namespace, kind, k8s, tekton, verificationPolicies)</span>
                }

        default:<span class="cov8" title="1">
                // Even if there is no task ref, we should try to return a local resolver.
                local := &amp;LocalTaskRefResolver{
                        Namespace:    namespace,
                        Kind:         kind,
                        Tektonclient: tekton,
                }
                return local.GetTask</span>
        }
}

// GetStepActionFunc is a factory function that will use the given Ref as context to return a valid GetStepAction function.
// It also requires a kubeclient, tektonclient, requester in case it needs to find that task in
// cluster or authorize against an external repository. It will figure out whether it needs to look in the cluster or in
// a remote location to fetch the reference.
func GetStepActionFunc(tekton clientset.Interface, k8s kubernetes.Interface, requester remoteresource.Requester, tr *v1.TaskRun, taskSpec v1.TaskSpec, step *v1.Step) GetStepAction <span class="cov8" title="1">{
        trName := tr.Name
        namespace := tr.Namespace
        if step.Ref != nil &amp;&amp; step.Ref.Resolver != "" &amp;&amp; requester != nil </span><span class="cov8" title="1">{
                // Return an inline function that implements GetStepAction by calling Resolver.Get with the specified StepAction type and
                // casting it to a StepAction.
                return func(ctx context.Context, name string) (*v1beta1.StepAction, *v1.RefSource, error) </span><span class="cov8" title="1">{
                        // Perform params replacements for StepAction resolver params
                        ApplyParameterSubstitutionInResolverParams(tr, taskSpec, step)
                        resolverPayload := remoteresource.ResolverPayload{
                                Name:      trName,
                                Namespace: namespace,
                                ResolutionSpec: &amp;resolutionV1beta1.ResolutionRequestSpec{
                                        Params: step.Ref.Params,
                                        URL:    step.Ref.Name,
                                },
                        }
                        resolver := resolution.NewResolver(requester, tr, string(step.Ref.Resolver), resolverPayload)
                        return resolveStepAction(ctx, resolver, name, namespace, k8s, tekton)
                }</span>
        }
        <span class="cov8" title="1">local := &amp;LocalStepActionRefResolver{
                Namespace:    namespace,
                Tektonclient: tekton,
        }
        return local.GetStepAction</span>
}

// ApplyParameterSubstitutionInResolverParams applies parameter substitutions in resolver params for Step Ref.
func ApplyParameterSubstitutionInResolverParams(tr *v1.TaskRun, taskSpec v1.TaskSpec, step *v1.Step) <span class="cov8" title="1">{
        stringReplacements := make(map[string]string)
        arrayReplacements := make(map[string][]string)
        objectReplacements := make(map[string]map[string]string)

        defaultSR, defaultAR, defaultOR := replacementsFromDefaultParams(taskSpec.Params)
        stringReplacements, arrayReplacements, objectReplacements = extendReplacements(stringReplacements, arrayReplacements, objectReplacements, defaultSR, defaultAR, defaultOR)

        paramSR, paramAR, paramOR := replacementsFromParams(tr.Spec.Params)
        stringReplacements, arrayReplacements, objectReplacements = extendReplacements(stringReplacements, arrayReplacements, objectReplacements, paramSR, paramAR, paramOR)
        step.Ref.Params = step.Ref.Params.ReplaceVariables(stringReplacements, arrayReplacements, objectReplacements)
}</span>

func extendReplacements(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string, stringReplacementsToAdd map[string]string, arrayReplacementsToAdd map[string][]string, objectReplacementsToAdd map[string]map[string]string) (map[string]string, map[string][]string, map[string]map[string]string) <span class="cov8" title="1">{
        for k, v := range stringReplacementsToAdd </span><span class="cov8" title="1">{
                stringReplacements[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range arrayReplacementsToAdd </span><span class="cov8" title="1">{
                arrayReplacements[k] = v
        }</span>
        <span class="cov8" title="1">objectReplacements = extendObjectReplacements(objectReplacements, objectReplacementsToAdd)
        return stringReplacements, arrayReplacements, objectReplacements</span>
}

func extendObjectReplacements(objectReplacements map[string]map[string]string, objectReplacementsToAdd map[string]map[string]string) map[string]map[string]string <span class="cov8" title="1">{
        for k, v := range objectReplacementsToAdd </span><span class="cov8" title="1">{
                for key, val := range v </span><span class="cov8" title="1">{
                        if objectReplacements != nil </span><span class="cov8" title="1">{
                                if objectReplacements[k] != nil </span><span class="cov8" title="1">{
                                        objectReplacements[k][key] = val
                                }</span> else<span class="cov8" title="1"> {
                                        objectReplacements[k] = v
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return objectReplacements</span>
}

// resolveTask accepts an impl of remote.Resolver and attempts to
// fetch a task with given name and verify the v1beta1 task if trusted resources is enabled.
// An error is returned if the remoteresource doesn't work
// A VerificationResult is returned if trusted resources is enabled, VerificationResult contains the result type and err.
// or the returned data isn't a valid *v1beta1.Task.
func resolveTask(ctx context.Context, resolver remote.Resolver, name, namespace string, kind v1.TaskKind, k8s kubernetes.Interface, tekton clientset.Interface, verificationPolicies []*v1alpha1.VerificationPolicy) (*v1.Task, *v1.RefSource, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        // Because the resolver will only return references with the same kind, this will ensure we
        // don't accidentally return a Task with the same name but different kind.
        obj, refSource, err := resolver.Get(ctx, strings.TrimSuffix(strings.ToLower(string(kind)), "s"), name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">taskObj, vr, err := readRuntimeObjectAsTask(ctx, namespace, obj, k8s, tekton, refSource, verificationPolicies)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">return taskObj, refSource, vr, nil</span>
}

func resolveStepAction(ctx context.Context, resolver remote.Resolver, name, namespace string, k8s kubernetes.Interface, tekton clientset.Interface) (*v1beta1.StepAction, *v1.RefSource, error) <span class="cov8" title="1">{
        obj, refSource, err := resolver.Get(ctx, "StepAction", name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">switch obj := obj.(type) </span>{
        case *v1beta1.StepAction:<span class="cov8" title="1">
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedStepAction, ok := o.(*v1beta1.StepAction); ok </span><span class="cov8" title="1">{
                        mutatedStepAction.ObjectMeta = obj.ObjectMeta
                        return mutatedStepAction, refSource, nil
                }</span>
        case *v1alpha1.StepAction:<span class="cov8" title="1">
                obj.SetDefaults(ctx)
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedStepAction, ok := o.(*v1alpha1.StepAction); ok </span><span class="cov8" title="1">{
                        mutatedStepAction.ObjectMeta = obj.ObjectMeta
                        v1BetaStepAction := v1beta1.StepAction{
                                TypeMeta: metav1.TypeMeta{
                                        Kind:       "StepAction",
                                        APIVersion: "tekton.dev/v1beta1",
                                },
                        }
                        err := mutatedStepAction.ConvertTo(ctx, &amp;v1BetaStepAction)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">return &amp;v1BetaStepAction, refSource, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, nil, errors.New("resource is not a StepAction")</span>
}

// readRuntimeObjectAsTask tries to convert a generic runtime.Object
// into a *v1.Task type so that its meta and spec fields
// can be read. v1beta1 object will be converted to v1 and returned.
// An error is returned if the given object is not a Task
// or if there is an error validating or upgrading an older TaskObject into
// its v1beta1 equivalent.
// A VerificationResult is returned if trusted resources is enabled, VerificationResult contains the result type and err.
// v1beta1 task will be verified by trusted resources if the feature is enabled
// TODO(#5541): convert v1beta1 obj to v1 once we use v1 as the stored version
func readRuntimeObjectAsTask(ctx context.Context, namespace string, obj runtime.Object, k8s kubernetes.Interface, tekton clientset.Interface, refSource *v1.RefSource, verificationPolicies []*v1alpha1.VerificationPolicy) (*v1.Task, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        switch obj := obj.(type) </span>{
        case *v1beta1.Task:<span class="cov8" title="1">
                obj.SetDefaults(ctx)
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                // Verify the Task once we fetch from the remote resolution, mutating, validation and conversion of the task should happen after the verification, since signatures are based on the remote task contents
                vr := trustedresources.VerifyResource(ctx, obj, k8s, refSource, verificationPolicies)
                // Issue a dry-run request to create the remote Task, so that it can undergo validation from validating admission webhooks
                // without actually creating the Task on the cluster.
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedTask, ok := o.(*v1beta1.Task); ok </span><span class="cov8" title="1">{
                        t := &amp;v1.Task{
                                TypeMeta: metav1.TypeMeta{
                                        Kind:       "Task",
                                        APIVersion: "tekton.dev/v1",
                                },
                        }
                        mutatedTask.ObjectMeta = obj.ObjectMeta
                        if err := mutatedTask.ConvertTo(ctx, t); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("failed to convert obj %s into Pipeline", mutatedTask.GetObjectKind().GroupVersionKind().String())
                        }</span>
                        <span class="cov8" title="1">return t, &amp;vr, nil</span>
                }
        case *v1.Task:<span class="cov8" title="1">
                // This SetDefaults is currently not necessary, but for consistency, it is recommended to add it.
                // Avoid forgetting to add it in the future when there is a v2 version, causing similar problems.
                obj.SetDefaults(ctx)
                // Cleanup object from things we don't care about
                // FIXME: extract this in a function
                obj.ObjectMeta.OwnerReferences = nil
                vr := trustedresources.VerifyResource(ctx, obj, k8s, refSource, verificationPolicies)
                // Issue a dry-run request to create the remote Task, so that it can undergo validation from validating admission webhooks
                // without actually creating the Task on the cluster
                o, err := apiserver.DryRunValidate(ctx, namespace, obj, tekton)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if mutatedTask, ok := o.(*v1.Task); ok </span><span class="cov8" title="1">{
                        mutatedTask.ObjectMeta = obj.ObjectMeta
                        return mutatedTask, &amp;vr, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, nil, errors.New("resource is not a task")</span>
}

// LocalTaskRefResolver uses the current cluster to resolve a task reference.
type LocalTaskRefResolver struct {
        Namespace    string
        Kind         v1.TaskKind
        Tektonclient clientset.Interface
}

// GetTask will resolve a Task from the local cluster using a versioned Tekton client. It will
// return an error if it can't find an appropriate Task for any reason.
// TODO(#6666): support local task verification
func (l *LocalTaskRefResolver) GetTask(ctx context.Context, name string) (*v1.Task, *v1.RefSource, *trustedresources.VerificationResult, error) <span class="cov8" title="1">{
        // If we are going to resolve this reference locally, we need a namespace scope.
        if l.Namespace == "" </span><span class="cov8" title="1">{
                return nil, nil, nil, fmt.Errorf("must specify namespace to resolve reference to task %s", name)
        }</span>
        <span class="cov8" title="1">task, err := l.Tektonclient.TektonV1().Tasks(l.Namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">return task, nil, nil, nil</span>
}

// LocalStepActionRefResolver uses the current cluster to resolve a StepAction reference.
type LocalStepActionRefResolver struct {
        Namespace    string
        Tektonclient clientset.Interface
}

// GetStepAction will resolve a StepAction from the local cluster using a versioned Tekton client.
// It will return an error if it can't find an appropriate StepAction for any reason.
func (l *LocalStepActionRefResolver) GetStepAction(ctx context.Context, name string) (*v1beta1.StepAction, *v1.RefSource, error) <span class="cov8" title="1">{
        // If we are going to resolve this reference locally, we need a namespace scope.
        if l.Namespace == "" </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("must specify namespace to resolve reference to step action %s", name)
        }</span>
        <span class="cov8" title="1">stepAction, err := l.Tektonclient.TektonV1beta1().StepActions(l.Namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return stepAction, nil, nil</span>
}
</pre>
		
		<pre class="file" id="file457" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "errors"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        resolutionutil "github.com/tektoncd/pipeline/pkg/internal/resolution"
        "github.com/tektoncd/pipeline/pkg/pod"
        remoteresource "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        "golang.org/x/sync/errgroup"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// ResolvedTask contains the data that is needed to execute
// the TaskRun.
type ResolvedTask struct {
        TaskName string
        Kind     v1.TaskKind
        TaskSpec *v1.TaskSpec
        // VerificationResult is the result from trusted resources if the feature is enabled.
        VerificationResult *trustedresources.VerificationResult
}

// GetStepAction is a function used to retrieve StepActions.
type GetStepAction func(context.Context, string) (*v1beta1.StepAction, *v1.RefSource, error)

// GetTask is a function used to retrieve Tasks.
// VerificationResult is the result from trusted resources if the feature is enabled.
type GetTask func(context.Context, string) (*v1.Task, *v1.RefSource, *trustedresources.VerificationResult, error)

// GetTaskRun is a function used to retrieve TaskRuns
type GetTaskRun func(string) (*v1.TaskRun, error)

// GetTaskData will retrieve the Task metadata and Spec associated with the
// provided TaskRun. This can come from a reference Task or from the TaskRun's
// metadata and embedded TaskSpec.
func GetTaskData(ctx context.Context, taskRun *v1.TaskRun, getTask GetTask) (*resolutionutil.ResolvedObjectMeta, *v1.TaskSpec, error) <span class="cov8" title="1">{
        taskMeta := metav1.ObjectMeta{}
        taskSpec := v1.TaskSpec{}
        var refSource *v1.RefSource
        var verificationResult *trustedresources.VerificationResult
        switch </span>{
        case taskRun.Spec.TaskRef != nil &amp;&amp; taskRun.Spec.TaskRef.Name != "":<span class="cov8" title="1">
                // Get related task for taskrun
                t, source, vr, err := getTask(ctx, taskRun.Spec.TaskRef.Name)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("error when listing tasks for taskRun %s: %w", taskRun.Name, err)
                }</span>
                <span class="cov8" title="1">taskMeta = t.ObjectMeta
                taskSpec = t.Spec
                refSource = source
                verificationResult = vr</span>
        case taskRun.Spec.TaskSpec != nil:<span class="cov8" title="1">
                taskMeta = taskRun.ObjectMeta
                taskSpec = *taskRun.Spec.TaskSpec</span>
                // TODO: if we want to set RefSource for embedded taskspec, set it here.
                // https://github.com/tektoncd/pipeline/issues/5522
        case taskRun.Spec.TaskRef != nil &amp;&amp; taskRun.Spec.TaskRef.Resolver != "":<span class="cov8" title="1">
                task, source, vr, err := getTask(ctx, taskRun.Name)
                switch </span>{
                case err != nil:<span class="cov8" title="1">
                        return nil, nil, err</span>
                case task == nil:<span class="cov8" title="1">
                        return nil, nil, errors.New("resolution of remote resource completed successfully but no task was returned")</span>
                default:<span class="cov8" title="1">
                        taskMeta = task.ObjectMeta
                        taskSpec = task.Spec</span>
                }
                <span class="cov8" title="1">refSource = source
                verificationResult = vr</span>
        default:<span class="cov8" title="1">
                return nil, nil, fmt.Errorf("taskRun %s not providing TaskRef or TaskSpec", taskRun.Name)</span>
        }

        <span class="cov8" title="1">taskSpec.SetDefaults(ctx)
        return &amp;resolutionutil.ResolvedObjectMeta{
                ObjectMeta:         &amp;taskMeta,
                RefSource:          refSource,
                VerificationResult: verificationResult,
        }, &amp;taskSpec, nil</span>
}

// stepRefResolution holds the outcome of resolving a step referencing a StepAction.
type stepRefResolution struct {
        resolvedStep *v1.Step
        source       *v1.RefSource
}

// hasStepRefs provides a fast check to see if any steps in a TaskSpec contain a reference to a StepAction.
func hasStepRefs(taskSpec *v1.TaskSpec) bool <span class="cov8" title="1">{
        for _, step := range taskSpec.Steps </span><span class="cov8" title="1">{
                if step.Ref != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// resolveStepRef resolves a step referecing a StepAction by fetching the remote StepAction, merging it with the Step's specification, and returning the resolved step.
func resolveStepRef(ctx context.Context, taskSpec v1.TaskSpec, taskRun *v1.TaskRun, tekton clientset.Interface, k8s kubernetes.Interface, requester remoteresource.Requester, step *v1.Step) (*v1.Step, *v1.RefSource, error) <span class="cov8" title="1">{
        resolvedStep := step.DeepCopy()

        getStepAction := GetStepActionFunc(tekton, k8s, requester, taskRun, taskSpec, resolvedStep)
        stepAction, source, err := getStepAction(ctx, resolvedStep.Ref.Name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">stepActionSpec := stepAction.StepActionSpec()
        stepActionSpec.SetDefaults(ctx)

        stepFromStepAction := stepActionSpec.ToStep()
        if err := validateStepHasStepActionParameters(resolvedStep.Params, stepActionSpec.Params); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">stepFromStepAction, err = applyStepActionParameters(stepFromStepAction, &amp;taskSpec, taskRun, resolvedStep.Params, stepActionSpec.Params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        // Merge fields from the resolved StepAction into the step
        <span class="cov8" title="1">resolvedStep.Image = stepFromStepAction.Image
        resolvedStep.SecurityContext = stepFromStepAction.SecurityContext
        if len(stepFromStepAction.Command) &gt; 0 </span><span class="cov8" title="1">{
                resolvedStep.Command = stepFromStepAction.Command
        }</span>
        <span class="cov8" title="1">if len(stepFromStepAction.Args) &gt; 0 </span><span class="cov8" title="1">{
                resolvedStep.Args = stepFromStepAction.Args
        }</span>
        <span class="cov8" title="1">if stepFromStepAction.Script != "" </span><span class="cov8" title="1">{
                resolvedStep.Script = stepFromStepAction.Script
        }</span>
        <span class="cov8" title="1">resolvedStep.WorkingDir = stepFromStepAction.WorkingDir
        if stepFromStepAction.Env != nil </span><span class="cov8" title="1">{
                resolvedStep.Env = stepFromStepAction.Env
        }</span>
        <span class="cov8" title="1">if len(stepFromStepAction.VolumeMounts) &gt; 0 </span><span class="cov8" title="1">{
                resolvedStep.VolumeMounts = stepFromStepAction.VolumeMounts
        }</span>
        <span class="cov8" title="1">if len(stepFromStepAction.Results) &gt; 0 </span><span class="cov8" title="1">{
                resolvedStep.Results = stepFromStepAction.Results
        }</span>

        // Finalize by clearing Ref and Params, as they have been resolved
        <span class="cov8" title="1">resolvedStep.Ref = nil
        resolvedStep.Params = nil

        return resolvedStep, source, nil</span>
}

// updateTaskRunProvenance update the TaskRun's status with source provenance information for a given step
func updateTaskRunProvenance(taskRun *v1.TaskRun, stepName string, stepIndex int, source *v1.RefSource, stepStatusIndex map[string]int) <span class="cov8" title="1">{
        // The StepState already exists. Update it in place
        if index, found := stepStatusIndex[stepName]; found </span><span class="cov8" title="1">{
                if taskRun.Status.Steps[index].Provenance == nil </span><span class="cov8" title="1">{
                        taskRun.Status.Steps[index].Provenance = &amp;v1.Provenance{}
                }</span>
                <span class="cov8" title="1">taskRun.Status.Steps[index].Provenance.RefSource = source
                return</span>
        }

        // No existing StepState found. Create and append a new one
        <span class="cov8" title="1">newState := v1.StepState{
                Name:       pod.TrimStepPrefix(pod.StepName(stepName, stepIndex)),
                Provenance: &amp;v1.Provenance{RefSource: source},
        }
        taskRun.Status.Steps = append(taskRun.Status.Steps, newState)</span>
}

// GetStepActionsData extracts the StepActions and merges them with the inlined Step specification.
func GetStepActionsData(ctx context.Context, taskSpec v1.TaskSpec, taskRun *v1.TaskRun, tekton clientset.Interface, k8s kubernetes.Interface, requester remoteresource.Requester) ([]v1.Step, error) <span class="cov8" title="1">{
        // If there are no step-ref to resolve, return immediately
        if !hasStepRefs(&amp;taskSpec) </span><span class="cov8" title="1">{
                return taskSpec.Steps, nil
        }</span>

        // Phase 1: Concurrently resolve all StepActions
        <span class="cov8" title="1">stepRefConcurrencyLimit := config.FromContextOrDefaults(ctx).Defaults.DefaultStepRefConcurrencyLimit
        g, ctx := errgroup.WithContext(ctx)
        // This limit prevents overwhelming the API server or remote git servers
        g.SetLimit(stepRefConcurrencyLimit)

        stepRefResolutions := make([]*stepRefResolution, len(taskSpec.Steps))
        for i, step := range taskSpec.Steps </span><span class="cov8" title="1">{
                if step.Ref == nil </span><span class="cov8" title="1">{ // Only process steps with a Ref
                        continue</span>
                }

                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        resolvedStep, source, err := resolveStepRef(ctx, taskSpec, taskRun, tekton, k8s, requester, &amp;step)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to resolve step ref for step %q (index %d): %w", step.Name, i, err)
                        }</span>
                        <span class="cov8" title="1">stepRefResolutions[i] = &amp;stepRefResolution{resolvedStep: resolvedStep, source: source}
                        return nil</span>
                })
        }

        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Phase 2: Sequentially merge results into the final step list and update status
        <span class="cov8" title="1">if taskRun.Status.Steps == nil </span><span class="cov8" title="1">{
                taskRun.Status.Steps = []v1.StepState{}
        }</span>
        <span class="cov8" title="1">stepStatusIndex := make(map[string]int, len(taskRun.Status.Steps))
        for i, stepState := range taskRun.Status.Steps </span><span class="cov8" title="1">{
                stepStatusIndex[stepState.Name] = i
        }</span>

        <span class="cov8" title="1">steps := make([]v1.Step, len(taskSpec.Steps))
        for i, step := range taskSpec.Steps </span><span class="cov8" title="1">{
                if step.Ref == nil </span><span class="cov8" title="1">{
                        steps[i] = step
                        continue</span>
                }

                <span class="cov8" title="1">stepRefResolution := stepRefResolutions[i]
                steps[i] = *stepRefResolution.resolvedStep

                if stepRefResolution.source != nil </span><span class="cov8" title="1">{
                        updateTaskRunProvenance(taskRun, stepRefResolution.resolvedStep.Name, i, stepRefResolution.source, stepStatusIndex)
                }</span>
        }

        <span class="cov8" title="1">return steps, nil</span>
}
</pre>
		
		<pre class="file" id="file458" style="display: none">package resources

import (
        "fmt"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/substitution"
        "k8s.io/apimachinery/pkg/util/sets"
)

// ValidateParamArrayIndex validates if the param reference to an array param is out of bound.
// error is returned when the array indexing reference is out of bound of the array param
// e.g. if a param reference of $(params.array-param[2]) and the array param is of length 2.
// - `params` are params from taskrun.
// - `ts` contains params declarations and references to array params.
func ValidateParamArrayIndex(ts *v1.TaskSpec, params v1.Params) error <span class="cov8" title="1">{
        return ValidateOutOfBoundArrayParams(ts.Params, params, ts.GetIndexingReferencesToArrayParams())
}</span>

// ValidateOutOfBoundArrayParams returns an error if the array indexing params are out of bounds,
// based on the param declarations, the parameters passed in at runtime, and the indexing references
// to array params from a task or pipeline spec.
// Example of arrayIndexingReferences: ["$(params.a-array-param[1])", "$(params.b-array-param[2])"]
func ValidateOutOfBoundArrayParams(declarations v1.ParamSpecs, params v1.Params, arrayIndexingReferences sets.String) error <span class="cov8" title="1">{
        arrayParamLengths := declarations.ExtractDefaultParamArrayLengths()
        for k, v := range params.ExtractParamArrayLengths() </span><span class="cov8" title="1">{
                arrayParamLengths[k] = v
        }</span>
        <span class="cov8" title="1">outofBoundParams := sets.String{}
        for val := range arrayIndexingReferences </span><span class="cov8" title="1">{
                indexString := substitution.ExtractIndexString(val)
                idx, _ := substitution.ExtractIndex(indexString)
                // this will extract the param name from reference
                // e.g. $(params.a-array-param[1]) -&gt; a-array-param
                paramName, _, _ := substitution.ExtractVariablesFromString(substitution.TrimArrayIndex(val), "params")

                if paramLength, ok := arrayParamLengths[paramName[0]]; ok </span><span class="cov8" title="1">{
                        if idx &gt;= paramLength </span><span class="cov8" title="1">{
                                outofBoundParams.Insert(val)
                        }</span>
                }
        }
        <span class="cov8" title="1">if outofBoundParams.Len() &gt; 0 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("non-existent param references:%v", outofBoundParams.List()))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateStepHasStepActionParameters(stepParams v1.Params, stepActionDefaults []v1.ParamSpec) error <span class="cov8" title="1">{
        stepActionParams := sets.String{}
        requiredStepActionParams := []string{}
        for _, sa := range stepActionDefaults </span><span class="cov8" title="1">{
                stepActionParams.Insert(sa.Name)
                if sa.Default == nil </span><span class="cov8" title="1">{
                        requiredStepActionParams = append(requiredStepActionParams, sa.Name)
                }</span>
        }

        <span class="cov8" title="1">stepProvidedParams := sets.String{}
        extra := []string{}
        for _, sp := range stepParams </span><span class="cov8" title="1">{
                stepProvidedParams.Insert(sp.Name)
                if !stepActionParams.Has(sp.Name) </span><span class="cov8" title="1">{
                        // Extra parameter that is not needed
                        extra = append(extra, sp.Name)
                }</span>
        }
        <span class="cov8" title="1">if len(extra) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("extra params passed by Step to StepAction: %v", extra)
        }</span>

        <span class="cov8" title="1">missing := []string{}

        for _, requiredParam := range requiredStepActionParams </span><span class="cov8" title="1">{
                if !stepProvidedParams.Has(requiredParam) </span><span class="cov8" title="1">{
                        // Missing required param
                        missing = append(missing, requiredParam)
                }</span>
        }
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("non-existent params in Step: %v", missing)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file459" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "slices"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/internal/sidecarlogresults"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        alphalisters "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        ctrl "github.com/tektoncd/pipeline/pkg/controller"
        "github.com/tektoncd/pipeline/pkg/internal/affinityassistant"
        "github.com/tektoncd/pipeline/pkg/internal/computeresources"
        "github.com/tektoncd/pipeline/pkg/internal/defaultresourcerequirements"
        resolutionutil "github.com/tektoncd/pipeline/pkg/internal/resolution"
        podconvert "github.com/tektoncd/pipeline/pkg/pod"
        tknreconciler "github.com/tektoncd/pipeline/pkg/reconciler"
        "github.com/tektoncd/pipeline/pkg/reconciler/apiserver"
        "github.com/tektoncd/pipeline/pkg/reconciler/events"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"
        "github.com/tektoncd/pipeline/pkg/reconciler/volumeclaim"
        "github.com/tektoncd/pipeline/pkg/remote"
        resolution "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/spire"
        "github.com/tektoncd/pipeline/pkg/taskrunmetrics"
        "github.com/tektoncd/pipeline/pkg/trustedresources"
        "github.com/tektoncd/pipeline/pkg/workspace"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/kubernetes"
        corev1Listers "k8s.io/client-go/listers/core/v1"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/changeset"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmap"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "sigs.k8s.io/yaml"
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        KubeClientSet     kubernetes.Interface
        PipelineClientSet clientset.Interface
        Images            pipeline.Images
        Clock             clock.PassiveClock

        // listers index properties about resources
        spireClient              spire.ControllerAPIClient
        taskRunLister            listers.TaskRunLister
        limitrangeLister         corev1Listers.LimitRangeLister
        podLister                corev1Listers.PodLister
        verificationPolicyLister alphalisters.VerificationPolicyLister
        cloudEventClient         cloudevent.CEClient
        entrypointCache          podconvert.EntrypointCache
        metrics                  *taskrunmetrics.Recorder
        pvcHandler               volumeclaim.PvcHandler
        resolutionRequester      resolution.Requester
        tracerProvider           trace.TracerProvider
}

const ImagePullBackOff = "ImagePullBackOff"

var (
        // Check that our Reconciler implements taskrunreconciler.Interface
        _ taskrunreconciler.Interface = (*Reconciler)(nil)

        // Pod failure reasons that trigger failure of the TaskRun
        podFailureReasons = map[string]struct{}{
                ImagePullBackOff:   {},
                "InvalidImageName": {},
        }
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two. It then updates the Status block of the Task Run
// resource with the current status of the resource.
func (c *Reconciler) ReconcileKind(ctx context.Context, tr *v1.TaskRun) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        ctx = cloudevent.ToContext(ctx, c.cloudEventClient)
        ctx = initTracing(ctx, c.tracerProvider, tr)
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "TaskRun:ReconcileKind")
        defer span.End()

        span.SetAttributes(attribute.String("taskrun", tr.Name), attribute.String("namespace", tr.Namespace))
        // Read the initial condition
        before := tr.Status.GetCondition(apis.ConditionSucceeded)

        // Record the duration and count after the reconcile cycle.
        defer c.durationAndCountMetrics(ctx, tr, before)

        // If the TaskRun is just starting, this will also set the starttime,
        // from which the timeout will immediately begin counting down.
        if !tr.HasStarted() </span><span class="cov8" title="1">{
                tr.Status.InitializeConditions()
                // In case node time was not synchronized, when controller has been scheduled to other nodes.
                if tr.Status.StartTime.Sub(tr.CreationTimestamp.Time) &lt; 0 </span><span class="cov0" title="0">{
                        logger.Warnf("TaskRun %s createTimestamp %s is after the taskRun started %s", tr.GetNamespacedName().String(), tr.CreationTimestamp, tr.Status.StartTime)
                        tr.Status.StartTime = &amp;tr.CreationTimestamp
                }</span>
                // Emit events. During the first reconcile the status of the TaskRun may change twice
                // from not Started to Started and then to Running, so we need to sent the event here
                // and at the end of 'Reconcile' again.
                // We also want to send the "Started" event as soon as possible for anyone who may be waiting
                // on the event to perform user facing initialisations, such has reset a CI check status
                <span class="cov8" title="1">afterCondition := tr.Status.GetCondition(apis.ConditionSucceeded)
                events.Emit(ctx, nil, afterCondition, tr)</span>
        }

        // If the TaskRun is complete, run some post run fixtures when applicable
        <span class="cov8" title="1">if tr.IsDone() </span><span class="cov8" title="1">{
                logger.Infof("taskrun done : %s \n", tr.Name)

                // We may be reading a version of the object that was stored at an older version
                // and may not have had all of the assumed default specified.
                tr.SetDefaults(ctx)

                useTektonSidecar := true
                if config.FromContextOrDefaults(ctx).FeatureFlags.EnableKubernetesSidecar </span><span class="cov0" title="0">{
                        dc := c.KubeClientSet.Discovery()
                        sv, err := dc.ServerVersion()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if podconvert.IsNativeSidecarSupport(sv) </span><span class="cov0" title="0">{
                                useTektonSidecar = false
                                logger.Infof("Using Kubernetes Native Sidecars \n")
                        }</span>
                }
                <span class="cov8" title="1">if useTektonSidecar </span><span class="cov8" title="1">{
                        if err := c.stopSidecars(ctx, tr); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return c.finishReconcileUpdateEmitEvents(ctx, tr, before, nil)</span>
        }

        // If the TaskRun is cancelled, kill resources and update status
        <span class="cov8" title="1">if tr.IsCancelled() </span><span class="cov8" title="1">{
                message := fmt.Sprintf("TaskRun %q was cancelled. %s", tr.Name, tr.Spec.StatusMessage)
                err := c.failTaskRun(ctx, tr, v1.TaskRunReasonCancelled, message)
                return c.finishReconcileUpdateEmitEvents(ctx, tr, before, err)
        }</span>

        // Check if the TaskRun has timed out; if it is, this will set its status
        // accordingly.
        <span class="cov8" title="1">if tr.HasTimedOut(ctx, c.Clock) </span><span class="cov8" title="1">{
                message := fmt.Sprintf("TaskRun %q failed to finish within %q", tr.Name, tr.GetTimeout(ctx))
                err := c.failTaskRun(ctx, tr, v1.TaskRunReasonTimedOut, message)
                return c.finishReconcileUpdateEmitEvents(ctx, tr, before, err)
        }</span>

        // Check for Pod Failures
        <span class="cov8" title="1">if failed, reason, message := c.checkPodFailed(ctx, tr); failed </span><span class="cov8" title="1">{
                err := c.failTaskRun(ctx, tr, reason, message)
                return c.finishReconcileUpdateEmitEvents(ctx, tr, before, err)
        }</span>

        // prepare fetches all required resources, validates them together with the
        // taskrun, runs API conversions. In case of error we update, emit events and return.
        <span class="cov8" title="1">_, rtr, err := c.prepare(ctx, tr)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("TaskRun prepare error: %v", err.Error())
                // We only return an error if update failed, otherwise we don't want to
                // reconcile an invalid TaskRun anymore
                span.SetStatus(codes.Error, "taskrun prepare error")
                span.RecordError(err)
                return c.finishReconcileUpdateEmitEvents(ctx, tr, nil, err)
        }</span>

        // Store the condition before reconcile
        <span class="cov8" title="1">before = tr.Status.GetCondition(apis.ConditionSucceeded)

        // Reconcile this copy of the task run and then write back any status
        // updates regardless of whether the reconciliation errored out.
        if err = c.reconcile(ctx, tr, rtr); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Reconcile: %v", err.Error())
                if errors.Is(err, sidecarlogresults.ErrSizeExceeded) </span><span class="cov8" title="1">{
                        cfg := config.FromContextOrDefaults(ctx)
                        message := fmt.Sprintf("%s TaskRun \"%q\" failed: results exceeded size limit %d bytes", pipelineErrors.UserErrorLabel, tr.Name, cfg.FeatureFlags.MaxResultSize)
                        err := c.failTaskRun(ctx, tr, v1.TaskRunReasonResultLargerThanAllowedLimit, message)
                        return c.finishReconcileUpdateEmitEvents(ctx, tr, before, err)
                }</span>
        }

        // Emit events (only when ConditionSucceeded was changed)
        <span class="cov8" title="1">if err = c.finishReconcileUpdateEmitEvents(ctx, tr, before, err); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if tr.Status.StartTime != nil </span><span class="cov8" title="1">{
                // Compute the time since the task started.
                elapsed := c.Clock.Since(tr.Status.StartTime.Time)
                // Snooze this resource until the timeout has elapsed.
                timeout := tr.GetTimeout(ctx)
                waitTime := timeout - elapsed
                if timeout == config.NoTimeoutDuration </span><span class="cov8" title="1">{
                        waitTime = time.Duration(config.FromContextOrDefaults(ctx).Defaults.DefaultTimeoutMinutes) * time.Minute
                }</span>
                <span class="cov8" title="1">return controller.NewRequeueAfter(waitTime)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Reconciler) checkPodFailed(ctx context.Context, tr *v1.TaskRun) (bool, v1.TaskRunReason, string) <span class="cov8" title="1">{
        imagePullBackOffTimeoutPodConditions := []string{string(corev1.PodInitialized), "PodReadyToStartContainers"}
        for _, step := range tr.Status.Steps </span><span class="cov8" title="1">{
                if step.Waiting != nil </span><span class="cov8" title="1">{
                        if _, found := podFailureReasons[step.Waiting.Reason]; found </span><span class="cov8" title="1">{
                                if step.Waiting.Reason == ImagePullBackOff </span><span class="cov8" title="1">{
                                        imagePullBackOffTimeOut := config.FromContextOrDefaults(ctx).Defaults.DefaultImagePullBackOffTimeout
                                        // only attempt to recover from the imagePullBackOff if specified
                                        if imagePullBackOffTimeOut.Seconds() != 0 </span><span class="cov8" title="1">{
                                                p, err := c.KubeClientSet.CoreV1().Pods(tr.Namespace).Get(ctx, tr.Status.PodName, metav1.GetOptions{})
                                                if err != nil </span><span class="cov8" title="1">{
                                                        message := fmt.Sprintf(`the step %q in TaskRun %q failed to pull the image %q and the pod with error: "%s."`, step.Name, tr.Name, step.ImageID, err)
                                                        return true, v1.TaskRunReasonImagePullFailed, message
                                                }</span>
                                                <span class="cov8" title="1">for _, condition := range p.Status.Conditions </span><span class="cov8" title="1">{
                                                        // check the pod condition to get the time when the pod was ready to start containers / initialized.
                                                        // keep trying until the pod schedule time has exceeded the specified imagePullBackOff timeout duration
                                                        if slices.Contains(imagePullBackOffTimeoutPodConditions, string(condition.Type)) </span><span class="cov8" title="1">{
                                                                if c.Clock.Since(condition.LastTransitionTime.Time) &lt; imagePullBackOffTimeOut </span><span class="cov8" title="1">{
                                                                        return false, "", ""
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov8" title="1">image := step.ImageID
                                message := fmt.Sprintf(`the step %q in TaskRun %q failed to pull the image %q. The pod errored with the message: "%s."`, step.Name, tr.Name, image, step.Waiting.Message)
                                return true, v1.TaskRunReasonImagePullFailed, message</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, sidecar := range tr.Status.Sidecars </span><span class="cov8" title="1">{
                if sidecar.Waiting != nil </span><span class="cov8" title="1">{
                        if _, found := podFailureReasons[sidecar.Waiting.Reason]; found </span><span class="cov8" title="1">{
                                if sidecar.Waiting.Reason == ImagePullBackOff </span><span class="cov8" title="1">{
                                        imagePullBackOffTimeOut := config.FromContextOrDefaults(ctx).Defaults.DefaultImagePullBackOffTimeout
                                        // only attempt to recover from the imagePullBackOff if specified
                                        if imagePullBackOffTimeOut.Seconds() != 0 </span><span class="cov8" title="1">{
                                                p, err := c.KubeClientSet.CoreV1().Pods(tr.Namespace).Get(ctx, tr.Status.PodName, metav1.GetOptions{})
                                                if err != nil </span><span class="cov8" title="1">{
                                                        message := fmt.Sprintf(`the sidecar %q in TaskRun %q failed to pull the image %q and the pod with error: "%s."`, sidecar.Name, tr.Name, sidecar.ImageID, err)
                                                        return true, v1.TaskRunReasonImagePullFailed, message
                                                }</span>
                                                <span class="cov8" title="1">for _, condition := range p.Status.Conditions </span><span class="cov8" title="1">{
                                                        // check the pod condition to get the time when the pod was ready to start containers / initialized.
                                                        // keep trying until the pod schedule time has exceeded the specified imagePullBackOff timeout duration
                                                        if slices.Contains(imagePullBackOffTimeoutPodConditions, string(condition.Type)) </span><span class="cov8" title="1">{
                                                                if c.Clock.Since(condition.LastTransitionTime.Time) &lt; imagePullBackOffTimeOut </span><span class="cov8" title="1">{
                                                                        return false, "", ""
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov8" title="1">image := sidecar.ImageID
                                message := fmt.Sprintf(`the sidecar %q in TaskRun %q failed to pull the image %q. The pod errored with the message: "%s."`, sidecar.Name, tr.Name, image, sidecar.Waiting.Message)
                                return true, v1.TaskRunReasonImagePullFailed, message</span>
                        }
                }
        }
        <span class="cov8" title="1">return false, "", ""</span>
}

func (c *Reconciler) durationAndCountMetrics(ctx context.Context, tr *v1.TaskRun, beforeCondition *apis.Condition) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "durationAndCountMetrics")
        defer span.End()
        logger := logging.FromContext(ctx)
        if tr.IsDone() </span><span class="cov8" title="1">{
                if err := c.metrics.DurationAndCount(ctx, tr, beforeCondition); err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to log the duration and count of taskruns : %v", err)
                }</span>
        }
}

func (c *Reconciler) stopSidecars(ctx context.Context, tr *v1.TaskRun) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "stopSidecars")
        defer span.End()
        logger := logging.FromContext(ctx)
        // do not continue without knowing the associated pod
        if tr.Status.PodName == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // do not continue if the TaskRun was canceled or timed out as this caused the pod to be deleted in failTaskRun
        <span class="cov8" title="1">condition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if condition != nil </span><span class="cov8" title="1">{
                reason := v1.TaskRunReason(condition.Reason)
                if reason == v1.TaskRunReasonCancelled || reason == v1.TaskRunReasonTimedOut </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">pod, err := podconvert.StopSidecars(ctx, c.Images.NopImage, c.KubeClientSet, tr.Namespace, tr.Status.PodName)
        if err == nil </span><span class="cov8" title="1">{
                // Check if any SidecarStatuses are still shown as Running after stopping
                // Sidecars. If any Running, update SidecarStatuses based on Pod ContainerStatuses.
                if podconvert.IsSidecarStatusRunning(tr) </span><span class="cov8" title="1">{
                        err = updateStoppedSidecarStatus(pod, tr)
                }</span>
        }
        <span class="cov8" title="1">if k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                // At this stage the TaskRun has been completed if the pod is not found, it won't come back,
                // it has probably evicted. We can return the error, but we consider it a permanent one.
                return controller.NewPermanentError(err)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                // It is admissible for Pods to fail with concurrentModification errors
                // when stopping sideCars. Instead of failing the TaskRun, we shall just
                // let the reconciler requeue.
                if isConcurrentModificationError(err) </span><span class="cov0" title="0">{
                        return controller.NewRequeueAfter(time.Second)
                }</span>
                <span class="cov0" title="0">logger.Errorf("Error stopping sidecars for TaskRun %q: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonStopSidecarFailed, err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *Reconciler) finishReconcileUpdateEmitEvents(ctx context.Context, tr *v1.TaskRun, beforeCondition *apis.Condition, previousError error) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "finishReconcileUpdateEmitEvents")
        defer span.End()
        logger := logging.FromContext(ctx)

        afterCondition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if afterCondition.IsFalse() &amp;&amp; !tr.IsCancelled() &amp;&amp; tr.IsRetriable() </span><span class="cov8" title="1">{
                retryTaskRun(tr, afterCondition.Message)
                afterCondition = tr.Status.GetCondition(apis.ConditionSucceeded)
        }</span>
        // Send k8s events and cloud events (when configured)
        <span class="cov8" title="1">events.Emit(ctx, beforeCondition, afterCondition, tr)

        errs := []error{previousError}

        // If the Run has been completed before and remains so at present,
        // no need to update the labels and annotations
        skipUpdateLabelsAndAnnotations := !afterCondition.IsUnknown() &amp;&amp; !beforeCondition.IsUnknown()
        if !skipUpdateLabelsAndAnnotations </span><span class="cov8" title="1">{
                _, err := c.updateLabelsAndAnnotations(ctx, tr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to update TaskRun labels/annotations", zap.Error(err))
                        events.EmitError(controller.GetEventRecorder(ctx), err, tr)
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">joinedErr := errors.Join(errs...)
        if controller.IsPermanentError(previousError) </span><span class="cov8" title="1">{
                return controller.NewPermanentError(joinedErr)
        }</span>
        <span class="cov8" title="1">return joinedErr</span>
}

// `prepare` fetches resources the taskrun depends on, runs validation and conversion
// It may report errors back to Reconcile, it updates the taskrun status in case of
// error but it does not sync updates back to etcd. It does not emit events.
// All errors returned by `prepare` are always handled by `Reconcile`, so they don't cause
// the key to be re-queued directly.
// `prepare` returns spec and resources. In future we might store
// them in the TaskRun.Status so we don't need to re-run `prepare` at every
// reconcile (see https://github.com/tektoncd/pipeline/issues/2473).
func (c *Reconciler) prepare(ctx context.Context, tr *v1.TaskRun) (*v1.TaskSpec, *resources.ResolvedTask, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "prepare")
        defer span.End()
        logger := logging.FromContext(ctx)
        tr.SetDefaults(ctx)

        // list VerificationPolicies for trusted resources
        vp, err := c.verificationPolicyLister.VerificationPolicies(tr.Namespace).List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to list VerificationPolicies from namespace %s with error %w", tr.Namespace, err)
        }</span>
        <span class="cov8" title="1">getTaskfunc := resources.GetTaskFuncFromTaskRun(ctx, c.KubeClientSet, c.PipelineClientSet, c.resolutionRequester, tr, vp)

        taskMeta, taskSpec, err := resources.GetTaskData(ctx, tr, getTaskfunc)
        switch </span>{
        case errors.Is(err, remote.ErrRequestInProgress):<span class="cov8" title="1">
                message := fmt.Sprintf("TaskRun %s/%s awaiting remote resource", tr.Namespace, tr.Name)
                tr.Status.MarkResourceOngoing(v1.TaskRunReasonResolvingTaskRef, message)
                return nil, nil, err</span>
        case errors.Is(err, apiserver.ErrReferencedObjectValidationFailed), errors.Is(err, apiserver.ErrCouldntValidateObjectPermanent):<span class="cov8" title="1">
                tr.Status.MarkResourceFailed(v1.TaskRunReasonTaskFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)</span>
        case errors.Is(err, apiserver.ErrCouldntValidateObjectRetryable):<span class="cov8" title="1">
                return nil, nil, err</span>
        case err != nil:<span class="cov8" title="1">
                logger.Errorf("Failed to determine Task spec to use for taskrun %s: %v", tr.Name, err)
                if resolutioncommon.IsErrTransient(err) </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedResolution, err)
                return nil, nil, controller.NewPermanentError(err)</span>
        default:<span class="cov8" title="1">
                // Store the fetched TaskSpec on the TaskRun for auditing
                if err := storeTaskSpecAndMergeMeta(ctx, tr, taskSpec, taskMeta); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store TaskSpec on TaskRun.Status for taskrun %s: %v", tr.Name, err)
                }</span>
        }

        <span class="cov8" title="1">steps, err := resources.GetStepActionsData(ctx, *taskSpec, tr, c.PipelineClientSet, c.KubeClientSet, c.resolutionRequester)
        switch </span>{
        case errors.Is(err, remote.ErrRequestInProgress):<span class="cov8" title="1">
                message := fmt.Sprintf("TaskRun %s/%s awaiting remote StepAction", tr.Namespace, tr.Name)
                tr.Status.MarkResourceOngoing(v1.TaskRunReasonResolvingStepActionRef, message)
                return nil, nil, err</span>
        case errors.Is(err, apiserver.ErrReferencedObjectValidationFailed), errors.Is(err, apiserver.ErrCouldntValidateObjectPermanent):<span class="cov8" title="1">
                tr.Status.MarkResourceFailed(v1.TaskRunReasonTaskFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)</span>
        case errors.Is(err, apiserver.ErrCouldntValidateObjectRetryable):<span class="cov8" title="1">
                return nil, nil, err</span>
        case err != nil:<span class="cov8" title="1">
                logger.Errorf("Failed to determine StepAction to use for TaskRun %s: %v", tr.Name, err)
                if resolutioncommon.IsErrTransient(err) </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedResolution, err)
                return nil, nil, controller.NewPermanentError(err)</span>
        default:<span class="cov8" title="1">
                // Store the fetched StepActions to TaskSpec, and update the stored TaskSpec again
                taskSpec.Steps = steps
                if err := storeTaskSpecAndMergeMeta(ctx, tr, taskSpec, taskMeta); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store TaskSpec on TaskRun.Status for taskrun %s: %v", tr.Name, err)
                }</span>
        }

        <span class="cov8" title="1">if taskMeta.VerificationResult != nil </span><span class="cov8" title="1">{
                switch taskMeta.VerificationResult.VerificationResultType </span>{
                case trustedresources.VerificationError:<span class="cov8" title="1">
                        logger.Errorf("TaskRun %s/%s referred task failed signature verification", tr.Namespace, tr.Name)
                        tr.Status.MarkResourceFailed(v1.TaskRunReasonResourceVerificationFailed, taskMeta.VerificationResult.Err)
                        tr.Status.SetCondition(&amp;apis.Condition{
                                Type:    trustedresources.ConditionTrustedResourcesVerified,
                                Status:  corev1.ConditionFalse,
                                Message: taskMeta.VerificationResult.Err.Error(),
                        })
                        return nil, nil, controller.NewPermanentError(taskMeta.VerificationResult.Err)</span>
                case trustedresources.VerificationSkip:<span class="cov8" title="1"></span>
                        // do nothing
                case trustedresources.VerificationWarn:<span class="cov8" title="1">
                        tr.Status.SetCondition(&amp;apis.Condition{
                                Type:    trustedresources.ConditionTrustedResourcesVerified,
                                Status:  corev1.ConditionFalse,
                                Message: taskMeta.VerificationResult.Err.Error(),
                        })</span>
                case trustedresources.VerificationPass:<span class="cov8" title="1">
                        tr.Status.SetCondition(&amp;apis.Condition{
                                Type:   trustedresources.ConditionTrustedResourcesVerified,
                                Status: corev1.ConditionTrue,
                        })</span>
                }
        }

        <span class="cov8" title="1">rtr := &amp;resources.ResolvedTask{
                TaskName: taskMeta.Name,
                TaskSpec: taskSpec,
                Kind:     resources.GetTaskKind(tr),
        }

        if err := validateTaskSpecRequestResources(taskSpec); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("TaskRun %s taskSpec request resources are invalid: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if err := ValidateResolvedTask(ctx, tr.Spec.Params, &amp;v1.Matrix{}, rtr); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("TaskRun %q resources are invalid: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum </span><span class="cov8" title="1">{
                if err := ValidateEnumParam(ctx, tr.Spec.Params, rtr.TaskSpec.Params); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("TaskRun %q Param Enum validation failed: %v", tr.Name, err)
                        tr.Status.MarkResourceFailed(v1.TaskRunReasonInvalidParamValue, err)
                        return nil, nil, controller.NewPermanentError(err)
                }</span>
        }

        <span class="cov8" title="1">if err := resources.ValidateParamArrayIndex(rtr.TaskSpec, tr.Spec.Params); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("TaskRun %q Param references are invalid: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if err := c.updateTaskRunWithDefaultWorkspaces(ctx, tr, taskSpec); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to update taskrun %s with default workspace: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedResolution, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">var workspaceDeclarations []v1.WorkspaceDeclaration
        // Propagating workspaces allows users to skip declarations
        // In order to validate the workspace bindings we create declarations based on
        // the workspaces provided in the task run spec. We only allow this feature for embedded taskSpec.
        if tr.Spec.TaskSpec != nil </span><span class="cov8" title="1">{
                for _, ws := range tr.Spec.Workspaces </span><span class="cov8" title="1">{
                        wspaceDeclaration := v1.WorkspaceDeclaration{Name: ws.Name}
                        workspaceDeclarations = append(workspaceDeclarations, wspaceDeclaration)
                }</span>
                <span class="cov8" title="1">workspaceDeclarations = append(workspaceDeclarations, taskSpec.Workspaces...)</span>
        } else<span class="cov8" title="1"> {
                workspaceDeclarations = taskSpec.Workspaces
        }</span>
        <span class="cov8" title="1">if err := workspace.ValidateBindings(ctx, workspaceDeclarations, tr.Spec.Workspaces); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("TaskRun %q workspaces are invalid: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">aaBehavior, err := affinityassistant.GetAffinityAssistantBehavior(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, controller.NewPermanentError(err)
        }</span>
        <span class="cov8" title="1">if aaBehavior == affinityassistant.AffinityAssistantPerWorkspace </span><span class="cov8" title="1">{
                if err := workspace.ValidateOnlyOnePVCIsUsed(tr.Spec.Workspaces); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("TaskRun %q workspaces incompatible with Affinity Assistant: %v", tr.Name, err)
                        tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                        return nil, nil, controller.NewPermanentError(err)
                }</span>
        }

        <span class="cov8" title="1">if err := validateOverrides(taskSpec, &amp;tr.Spec); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("TaskRun %q step or sidecar overrides are invalid: %v", tr.Name, err)
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return nil, nil, controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">return taskSpec, rtr, nil</span>
}

// `reconcile` creates the Pod associated to the TaskRun, and it pulls back status
// updates from the Pod to the TaskRun.
// It reports errors back to Reconcile, it updates the taskrun status in case of
// error but it does not sync updates back to etcd. It does not emit events.
// `reconcile` consumes spec and resources returned by `prepare`
func (c *Reconciler) reconcile(ctx context.Context, tr *v1.TaskRun, rtr *resources.ResolvedTask) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "reconcile")
        defer span.End()

        logger := logging.FromContext(ctx)
        recorder := controller.GetEventRecorder(ctx)
        var err error

        // Get the TaskRun's Pod if it should have one. Otherwise, create the Pod.
        var pod *corev1.Pod

        if tr.Status.PodName != "" </span><span class="cov8" title="1">{
                pod, err = c.podLister.Pods(tr.Namespace).Get(tr.Status.PodName)
                if k8serrors.IsNotFound(err) </span>{<span class="cov8" title="1">
                        // Keep going, this will result in the Pod being created below.
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        // This is considered a transient error, so we return error, do not update
                        // the task run condition, and return an error which will cause this key to
                        // be requeued for reconcile.
                        logger.Errorf("Error getting pod %q: %v", tr.Status.PodName, err)
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                // List pods that have a label with this TaskRun name.  Do not include other labels from the
                // TaskRun in this selector.  The user could change them during the lifetime of the TaskRun so the
                // current labels may not be set on a previously created Pod.
                labelSelector := labels.Set{pipeline.TaskRunLabelKey: tr.Name}
                pos, err := c.podLister.Pods(tr.Namespace).List(labelSelector.AsSelector())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error listing pods: %v", err)
                        return err
                }</span>
                <span class="cov8" title="1">for index := range pos </span><span class="cov8" title="1">{
                        po := pos[index]
                        if metav1.IsControlledBy(po, tr) &amp;&amp; !podconvert.DidTaskRunFail(po) &amp;&amp; !podconvert.IsPodArchived(po, &amp;tr.Status) </span><span class="cov8" title="1">{
                                pod = po
                        }</span>
                }
        }

        // Please note that this block is required to run before `applyParamsContextsResultsAndWorkspaces` is called the first time,
        // and that `applyParamsContextsResultsAndWorkspaces` _must_ be called on every reconcile.
        <span class="cov8" title="1">if pod == nil &amp;&amp; tr.HasVolumeClaimTemplate() </span><span class="cov8" title="1">{
                for _, ws := range tr.Spec.Workspaces </span><span class="cov8" title="1">{
                        if err := c.pvcHandler.CreatePVCFromVolumeClaimTemplate(ctx, ws, *kmeta.NewControllerRef(tr), tr.Namespace); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to create PVC for TaskRun %s: %v", tr.Name, err)
                                tr.Status.MarkResourceFailed(volumeclaim.ReasonCouldntCreateWorkspacePVC,
                                        fmt.Errorf("failed to create PVC for TaskRun %s workspaces correctly: %w",
                                                fmt.Sprintf("%s/%s", tr.Namespace, tr.Name), err))
                                return controller.NewPermanentError(err)
                        }</span>
                }

                <span class="cov8" title="1">taskRunWorkspaces := applyVolumeClaimTemplates(tr.Spec.Workspaces, *kmeta.NewControllerRef(tr))
                // This is used by createPod below. Changes to the Spec are not updated.
                tr.Spec.Workspaces = taskRunWorkspaces</span>
        }

        <span class="cov8" title="1">resources.ApplyParametersToWorkspaceBindings(rtr.TaskSpec, tr)
        // Get the randomized volume names assigned to workspace bindings
        workspaceVolumes := workspace.CreateVolumes(tr.Spec.Workspaces)

        ts, err := applyParamsContextsResultsAndWorkspaces(ctx, tr, rtr, workspaceVolumes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error updating task spec parameters, contexts, results and workspaces: %s", err)
                return err
        }</span>
        <span class="cov8" title="1">tr.Status.TaskSpec = ts

        if len(tr.Status.TaskSpec.Steps) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("set taskspec for %s/%s - script: %s", tr.Namespace, tr.Name, tr.Status.TaskSpec.Steps[0].Script)
        }</span>

        <span class="cov8" title="1">if pod == nil </span><span class="cov8" title="1">{
                pod, err = c.createPod(ctx, ts, tr, rtr, workspaceVolumes)
                if err != nil </span><span class="cov8" title="1">{
                        newErr := c.handlePodCreationError(tr, err)
                        logger.Errorf("Failed to create task run pod for taskrun %q: %v", tr.Name, newErr)
                        return newErr
                }</span>
        }

        <span class="cov8" title="1">if podconvert.IsPodExceedingNodeResources(pod) </span><span class="cov0" title="0">{
                recorder.Eventf(tr, corev1.EventTypeWarning, podconvert.ReasonExceededNodeResources, "Insufficient resources to schedule pod %q", pod.Name)
        }</span>

        <span class="cov8" title="1">if podconvert.SidecarsReady(pod.Status) </span><span class="cov0" title="0">{
                if err := podconvert.UpdateReady(ctx, c.KubeClientSet, *pod); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := c.metrics.RecordPodLatency(ctx, pod, tr); err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to log the metrics : %v", err)
                }</span>
        }

        // Convert the Pod's status to the equivalent TaskRun Status.
        <span class="cov8" title="1">tr.Status, err = podconvert.MakeTaskRunStatus(ctx, logger, *tr, pod, c.KubeClientSet, rtr.TaskSpec)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateTaskRunResults(tr, rtr.TaskSpec); err != nil </span><span class="cov8" title="1">{
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)
                return err
        }</span>

        <span class="cov8" title="1">logger.Infof("Successfully reconciled taskrun %s/%s with status: %#v", tr.Name, tr.Namespace, tr.Status.GetCondition(apis.ConditionSucceeded))
        return nil</span>
}

func (c *Reconciler) updateTaskRunWithDefaultWorkspaces(ctx context.Context, tr *v1.TaskRun, taskSpec *v1.TaskSpec) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "updateTaskRunWithDefaultWorkspaces")
        defer span.End()
        configMap := config.FromContextOrDefaults(ctx)
        defaults := configMap.Defaults
        if defaults.DefaultTaskRunWorkspaceBinding != "" </span><span class="cov8" title="1">{
                var defaultWS v1.WorkspaceBinding
                if err := yaml.Unmarshal([]byte(defaults.DefaultTaskRunWorkspaceBinding), &amp;defaultWS); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to unmarshal %v", defaults.DefaultTaskRunWorkspaceBinding)
                }</span>
                <span class="cov8" title="1">workspaceBindings := map[string]v1.WorkspaceBinding{}
                for _, tsWorkspace := range taskSpec.Workspaces </span><span class="cov8" title="1">{
                        if !tsWorkspace.Optional </span><span class="cov8" title="1">{
                                workspaceBindings[tsWorkspace.Name] = v1.WorkspaceBinding{
                                        Name:                  tsWorkspace.Name,
                                        SubPath:               defaultWS.SubPath,
                                        VolumeClaimTemplate:   defaultWS.VolumeClaimTemplate,
                                        PersistentVolumeClaim: defaultWS.PersistentVolumeClaim,
                                        EmptyDir:              defaultWS.EmptyDir,
                                        ConfigMap:             defaultWS.ConfigMap,
                                        Secret:                defaultWS.Secret,
                                }
                        }</span>
                }

                <span class="cov8" title="1">for _, trWorkspace := range tr.Spec.Workspaces </span><span class="cov0" title="0">{
                        workspaceBindings[trWorkspace.Name] = trWorkspace
                }</span>

                <span class="cov8" title="1">tr.Spec.Workspaces = []v1.WorkspaceBinding{}
                for _, wsBinding := range workspaceBindings </span><span class="cov8" title="1">{
                        tr.Spec.Workspaces = append(tr.Spec.Workspaces, wsBinding)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *Reconciler) updateLabelsAndAnnotations(ctx context.Context, tr *v1.TaskRun) (*v1.TaskRun, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "updateLabelsAndAnnotations")
        defer span.End()
        // Ensure the TaskRun is properly decorated with the version of the Tekton controller processing it.
        if tr.Annotations == nil </span><span class="cov8" title="1">{
                tr.Annotations = make(map[string]string, 1)
        }</span>
        <span class="cov8" title="1">tr.Annotations[podconvert.ReleaseAnnotation] = changeset.Get()

        newTr, err := c.taskRunLister.TaskRuns(tr.Namespace).Get(tr.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting TaskRun %s when updating labels/annotations: %w", tr.Name, err)
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(tr.ObjectMeta.Labels, newTr.ObjectMeta.Labels) || !reflect.DeepEqual(tr.ObjectMeta.Annotations, newTr.ObjectMeta.Annotations) </span><span class="cov8" title="1">{
                // Note that this uses Update vs. Patch because the former is significantly easier to test.
                // If we want to switch this to Patch, then we will need to teach the utilities in test/controller.go
                // to deal with Patch (setting resourceVersion, and optimistic concurrency checks).
                newTr = newTr.DeepCopy()
                newTr.Labels = kmap.Union(newTr.Labels, tr.Labels)
                newTr.Annotations = kmap.Union(kmap.ExcludeKeys(newTr.Annotations, tknreconciler.KubectlLastAppliedAnnotationKey), tr.Annotations)
                return c.PipelineClientSet.TektonV1().TaskRuns(tr.Namespace).Update(ctx, newTr, metav1.UpdateOptions{})
        }</span>
        <span class="cov8" title="1">return newTr, nil</span>
}

func (c *Reconciler) handlePodCreationError(tr *v1.TaskRun, err error) error <span class="cov8" title="1">{
        switch </span>{
        case isResourceQuotaConflictError(err):<span class="cov8" title="1">
                // Requeue if it runs into ResourceQuotaConflictError Error i.e https://github.com/kubernetes/kubernetes/issues/67761
                tr.Status.StartTime = nil
                tr.Status.MarkResourceOngoing(podconvert.ReasonPodPending, "tried to create pod, but it failed with ResourceQuotaConflictError")
                return controller.NewRequeueAfter(time.Second)</span>
        case isExceededResourceQuotaError(err):<span class="cov8" title="1">
                // If we are struggling to create the pod, then it hasn't started.
                tr.Status.StartTime = nil
                tr.Status.MarkResourceOngoing(podconvert.ReasonExceededResourceQuota, fmt.Sprint("TaskRun Pod exceeded available resources: ", err))
                return controller.NewRequeueAfter(time.Minute)</span>
        case isTaskRunValidationFailed(err):<span class="cov8" title="1">
                tr.Status.MarkResourceFailed(v1.TaskRunReasonFailedValidation, err)</span>
        case k8serrors.IsAlreadyExists(err):<span class="cov0" title="0">
                tr.Status.MarkResourceOngoing(podconvert.ReasonPodPending, "tried to create pod, but it already exists")</span>
        case isPodAdmissionFailed(err):<span class="cov8" title="1">
                tr.Status.MarkResourceFailed(podconvert.ReasonPodAdmissionFailed, err)</span>
        default:<span class="cov8" title="1">
                // The pod creation failed with unknown reason. The most likely
                // reason is that something is wrong with the spec of the Task, that we could
                // not check with validation before - i.e. pod template fields
                msg := fmt.Sprintf("failed to create task run pod %q: %v. Maybe ", tr.Name, err)
                if tr.Spec.TaskRef != nil </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("missing or invalid Task %s/%s", tr.Namespace, tr.Spec.TaskRef.Name)
                }</span> else<span class="cov8" title="1"> {
                        msg += "invalid TaskSpec"
                }</span>
                <span class="cov8" title="1">err = controller.NewPermanentError(errors.New(msg))
                tr.Status.MarkResourceFailed(podconvert.ReasonPodCreationFailed, err)</span>
        }
        <span class="cov8" title="1">return err</span>
}

// failTaskRun stops a TaskRun with the provided Reason
// If a pod is associated to the TaskRun, it stops it
// failTaskRun function may return an error in case the pod could not be deleted
// failTaskRun may update the local TaskRun status, but it won't push the updates to etcd
func (c *Reconciler) failTaskRun(ctx context.Context, tr *v1.TaskRun, reason v1.TaskRunReason, message string) error <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "failTaskRun")
        defer span.End()
        logger := logging.FromContext(ctx)

        logger.Warnf("stopping task run %q because of %q", tr.Name, reason)
        tr.Status.MarkResourceFailed(reason, errors.New(message))

        completionTime := metav1.Time{Time: c.Clock.Now()}
        // update tr completed time
        tr.Status.CompletionTime = &amp;completionTime

        if tr.Status.PodName == "" </span><span class="cov8" title="1">{
                logger.Warnf("task run %q has no pod running yet", tr.Name)
                return nil
        }</span>

        // When the TaskRun is failed, we mark all running/waiting steps as failed
        // This is regardless of what happens with the Pod, which may be cancelled,
        // deleted, non existing or fail to delete
        // See https://github.com/tektoncd/pipeline/issues/8293 for more details.
        <span class="cov8" title="1">terminateStepsInPod(tr, reason)

        var err error
        if reason == v1.TaskRunReasonCancelled &amp;&amp; (config.FromContextOrDefaults(ctx).FeatureFlags.EnableKeepPodOnCancel) </span><span class="cov0" title="0">{
                logger.Infof("Canceling task run %q by entrypoint", tr.Name)
                err = podconvert.CancelPod(ctx, c.KubeClientSet, tr.Namespace, tr.Status.PodName)
        }</span> else<span class="cov8" title="1"> {
                err = c.KubeClientSet.CoreV1().Pods(tr.Namespace).Delete(ctx, tr.Status.PodName, metav1.DeleteOptions{})
        }</span>
        <span class="cov8" title="1">if err != nil &amp;&amp; !k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Errorf("Failed to terminate pod %s: %v", tr.Status.PodName, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// terminateStepsInPod updates step states for TaskRun on TaskRun object since pod has been deleted for cancel or timeout
func terminateStepsInPod(tr *v1.TaskRun, taskRunReason v1.TaskRunReason) <span class="cov8" title="1">{
        for i, step := range tr.Status.Steps </span><span class="cov8" title="1">{
                // If running, include StartedAt for when step began running
                if step.Running != nil </span><span class="cov8" title="1">{
                        step.Terminated = &amp;corev1.ContainerStateTerminated{
                                ExitCode:   1,
                                StartedAt:  step.Running.StartedAt,
                                FinishedAt: *tr.Status.CompletionTime,
                                // TODO(#7385): replace with more pod/container termination reason instead of overloading taskRunReason
                                Reason:  taskRunReason.String(),
                                Message: fmt.Sprintf("Step %s terminated as pod %s is terminated", step.Name, tr.Status.PodName),
                        }
                        step.TerminationReason = taskRunReason.String()
                        step.Running = nil
                        tr.Status.Steps[i] = step
                }</span>

                <span class="cov8" title="1">if step.Waiting != nil </span><span class="cov8" title="1">{
                        step.Terminated = &amp;corev1.ContainerStateTerminated{
                                ExitCode:   1,
                                StartedAt:  tr.CreationTimestamp, // startedAt cannot be null due to CRD schema validation
                                FinishedAt: *tr.Status.CompletionTime,
                                // TODO(#7385): replace with more pod/container termination reason instead of overloading taskRunReason
                                Reason:  taskRunReason.String(),
                                Message: fmt.Sprintf("Step %s terminated as pod %s is terminated", step.Name, tr.Status.PodName),
                        }
                        step.TerminationReason = taskRunReason.String()
                        step.Waiting = nil
                        tr.Status.Steps[i] = step
                }</span>
        }
}

// createPod creates a Pod based on the Task's configuration, with pvcName as a volumeMount
// TODO(dibyom): Refactor resource setup/substitution logic to its own function in the resources package
func (c *Reconciler) createPod(ctx context.Context, ts *v1.TaskSpec, tr *v1.TaskRun, rtr *resources.ResolvedTask, workspaceVolumes map[string]corev1.Volume) (*corev1.Pod, error) <span class="cov8" title="1">{
        ctx, span := c.tracerProvider.Tracer(TracerName).Start(ctx, "createPod")
        defer span.End()
        logger := logging.FromContext(ctx)

        // We don't want to mutate tr.Status.TaskSpec inside
        // the createPod function. It's possible that pod will
        // be killed before running and when rescheduling it
        // will cause bugs. As this function could be called
        // multiple times, we copy tr.Status.TaskSpec to help
        // in scheduling Pod.
        ts = ts.DeepCopy()

        // By this time, params and workspaces should be propagated down so we can
        // validate that all parameter variables and workspaces used in the TaskSpec are declared by the Task.
        if validateErr := v1.ValidateUsageOfDeclaredParameters(ctx, ts.Steps, ts.Params); validateErr != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to create a pod for taskrun: %s due to task validation error %v", tr.Name, validateErr)
                return nil, validateErr
        }</span>
        <span class="cov8" title="1">if validateErr := ts.Validate(ctx); validateErr != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to create a pod for taskrun: %s due to task validation error %v", tr.Name, validateErr)
                return nil, validateErr
        }</span>

        <span class="cov8" title="1">var err error
        ts, err = workspace.Apply(ctx, *ts, tr.Spec.Workspaces, workspaceVolumes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to create a pod for taskrun: %s due to workspace error %v", tr.Name, err)
                return nil, err
        }</span>

        // Apply path substitutions for the legacy credentials helper (aka "creds-init")
        <span class="cov8" title="1">ts = resources.ApplyCredentialsPath(ts, pipeline.CredsDir)

        // Apply parameter substitution to PodTemplate if it exists
        if tr.Spec.PodTemplate != nil </span><span class="cov8" title="1">{
                var defaults []v1.ParamSpec
                if len(ts.Params) &gt; 0 </span><span class="cov8" title="1">{
                        defaults = append(defaults, ts.Params...)
                }</span>
                <span class="cov8" title="1">updatedPodTemplate := resources.ApplyPodTemplateReplacements(tr.Spec.PodTemplate, tr, defaults...)
                if updatedPodTemplate != nil </span><span class="cov8" title="1">{
                        trCopy := tr.DeepCopy()
                        trCopy.Spec.PodTemplate = updatedPodTemplate
                        tr = trCopy
                }</span>
        }

        <span class="cov8" title="1">podbuilder := podconvert.Builder{
                Images:          c.Images,
                KubeClient:      c.KubeClientSet,
                EntrypointCache: c.entrypointCache,
        }
        pod, err := podbuilder.Build(ctx, tr, *ts,
                defaultresourcerequirements.NewTransformer(ctx),
                computeresources.NewTransformer(ctx, tr.Namespace, c.limitrangeLister),
                affinityassistant.NewTransformer(ctx, tr.Annotations),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("translating TaskSpec to Pod: %w", err)
        }</span>

        // Stash the podname in case there's create conflict so that we can try
        // to fetch it.
        <span class="cov8" title="1">podName := pod.Name

        cfg := config.FromContextOrDefaults(ctx)
        if !cfg.FeatureFlags.EnableWaitExponentialBackoff </span><span class="cov8" title="1">{
                pod, err = c.KubeClientSet.CoreV1().Pods(tr.Namespace).Create(ctx, pod, metav1.CreateOptions{})
        }</span> else<span class="cov8" title="1"> {
                backoff := wait.Backoff{
                        Duration: cfg.WaitExponentialBackoff.Duration, // Initial delay before retry
                        Factor:   cfg.WaitExponentialBackoff.Factor,   // Multiplier for exponential growth
                        Steps:    cfg.WaitExponentialBackoff.Steps,    // Maximum number of retry attempts
                        Cap:      cfg.WaitExponentialBackoff.Cap,      // Maximum time spent before giving up
                }
                var result *corev1.Pod
                err = wait.ExponentialBackoff(backoff, func() (bool, error) </span><span class="cov8" title="1">{
                        result = nil
                        result, err = c.KubeClientSet.CoreV1().Pods(tr.Namespace).Create(ctx, pod, metav1.CreateOptions{})
                        if err != nil </span><span class="cov8" title="1">{
                                if ctrl.IsWebhookTimeout(err) </span><span class="cov8" title="1">{
                                        return false, nil // retry
                                }</span>
                                <span class="cov8" title="1">return false, err</span> // do not retry
                        }
                        <span class="cov8" title="1">pod = result
                        return true, nil</span>
                })
        }

        <span class="cov8" title="1">if err == nil &amp;&amp; willOverwritePodSetAffinity(tr) </span><span class="cov0" title="0">{
                if recorder := controller.GetEventRecorder(ctx); recorder != nil </span><span class="cov0" title="0">{
                        recorder.Eventf(tr, corev1.EventTypeWarning, "PodAffinityOverwrite", "Pod template affinity is overwritten by affinity assistant for pod %q", pod.Name)
                }</span>
        }
        // If the pod failed to be created because it already exists, try to fetch
        // from the informer and return if successful. Otherwise, return the
        // original error.
        <span class="cov8" title="1">if err != nil &amp;&amp; k8serrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                if p, getErr := c.podLister.Pods(tr.Namespace).Get(podName); getErr == nil </span><span class="cov0" title="0">{
                        return p, nil
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return pod, nil</span>
}

// applyParamsContextsResultsAndWorkspaces applies paramater, context, results and workspace substitutions to the TaskSpec.
func applyParamsContextsResultsAndWorkspaces(ctx context.Context, tr *v1.TaskRun, rtr *resources.ResolvedTask, workspaceVolumes map[string]corev1.Volume) (*v1.TaskSpec, error) <span class="cov8" title="1">{
        ts := rtr.TaskSpec.DeepCopy()
        var defaults []v1.ParamSpec
        if len(ts.Params) &gt; 0 </span><span class="cov8" title="1">{
                defaults = append(defaults, ts.Params...)
        }</span>
        // Apply parameter substitution from the taskrun.
        <span class="cov8" title="1">ts = resources.ApplyParameters(ts, tr, defaults...)

        // Apply context substitution from the taskrun
        ts = resources.ApplyContexts(ts, rtr.TaskName, tr)

        // Apply task result substitution
        ts = resources.ApplyResults(ts)

        // Apply step Artifacts substitution
        ts = resources.ApplyArtifacts(ts)
        // Apply step exitCode path substitution
        ts = resources.ApplyStepExitCodePath(ts)

        // Apply workspace resource substitution
        // propagate workspaces from taskrun to task.
        twn := []string{}
        for _, tw := range ts.Workspaces </span><span class="cov8" title="1">{
                twn = append(twn, tw.Name)
        }</span>

        <span class="cov8" title="1">for _, trw := range tr.Spec.Workspaces </span><span class="cov8" title="1">{
                skip := false
                for _, tw := range twn </span><span class="cov8" title="1">{
                        if tw == trw.Name </span><span class="cov8" title="1">{
                                skip = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !skip </span><span class="cov8" title="1">{
                        ts.Workspaces = append(ts.Workspaces, v1.WorkspaceDeclaration{Name: trw.Name})
                }</span>
        }
        <span class="cov8" title="1">ts = resources.ApplyWorkspaces(ctx, ts, ts.Workspaces, tr.Spec.Workspaces, workspaceVolumes)

        return ts, nil</span>
}

func isExceededResourceQuotaError(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; k8serrors.IsForbidden(err) &amp;&amp; strings.Contains(err.Error(), "exceeded quota")
}</span>

func isTaskRunValidationFailed(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; strings.Contains(err.Error(), "TaskRun validation failed")
}</span>

func isPodAdmissionFailed(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; k8serrors.IsForbidden(err) &amp;&amp; (strings.Contains(err.Error(), "violates PodSecurity") ||
                strings.Contains(err.Error(), "security context constraint"))
}</span>

// updateStoppedSidecarStatus updates SidecarStatus for sidecars that were
// terminated by nop image
func updateStoppedSidecarStatus(pod *corev1.Pod, tr *v1.TaskRun) error <span class="cov8" title="1">{
        tr.Status.Sidecars = []v1.SidecarState{}
        for _, s := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if podconvert.IsContainerSidecar(s.Name) </span><span class="cov8" title="1">{
                        var sidecarState corev1.ContainerState
                        if s.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                                // Sidecar has successfully by terminated by nop image
                                lastTerminatedState := s.LastTerminationState.Terminated
                                sidecarState = corev1.ContainerState{
                                        Terminated: &amp;corev1.ContainerStateTerminated{
                                                ExitCode:    lastTerminatedState.ExitCode,
                                                Reason:      "Completed",
                                                Message:     "Sidecar container successfully stopped by nop image",
                                                StartedAt:   lastTerminatedState.StartedAt,
                                                FinishedAt:  lastTerminatedState.FinishedAt,
                                                ContainerID: lastTerminatedState.ContainerID,
                                        },
                                }
                        }</span> else<span class="cov8" title="1"> {
                                // Sidecar has not been terminated
                                sidecarState = s.State
                        }</span>

                        <span class="cov8" title="1">tr.Status.Sidecars = append(tr.Status.Sidecars, v1.SidecarState{
                                ContainerState: *sidecarState.DeepCopy(),
                                Name:           podconvert.TrimSidecarPrefix(s.Name),
                                Container:      s.Name,
                                ImageID:        s.ImageID,
                        })</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// applyVolumeClaimTemplates and return WorkspaceBindings were templates is translated to PersistentVolumeClaims
func applyVolumeClaimTemplates(workspaceBindings []v1.WorkspaceBinding, owner metav1.OwnerReference) []v1.WorkspaceBinding <span class="cov8" title="1">{
        taskRunWorkspaceBindings := make([]v1.WorkspaceBinding, 0, len(workspaceBindings))
        for _, wb := range workspaceBindings </span><span class="cov8" title="1">{
                if wb.VolumeClaimTemplate == nil </span><span class="cov8" title="1">{
                        taskRunWorkspaceBindings = append(taskRunWorkspaceBindings, wb)
                        continue</span>
                }

                // apply template
                <span class="cov8" title="1">b := v1.WorkspaceBinding{
                        Name:    wb.Name,
                        SubPath: wb.SubPath,
                        PersistentVolumeClaim: &amp;corev1.PersistentVolumeClaimVolumeSource{
                                ClaimName: volumeclaim.GeneratePVCNameFromWorkspaceBinding(wb.VolumeClaimTemplate.Name, wb, owner),
                        },
                }
                taskRunWorkspaceBindings = append(taskRunWorkspaceBindings, b)</span>
        }
        <span class="cov8" title="1">return taskRunWorkspaceBindings</span>
}

func storeTaskSpecAndMergeMeta(ctx context.Context, tr *v1.TaskRun, ts *v1.TaskSpec, meta *resolutionutil.ResolvedObjectMeta) error <span class="cov8" title="1">{
        // Only store the TaskSpec once, if it has never been set before.
        if tr.Status.TaskSpec == nil </span><span class="cov8" title="1">{
                tr.Status.TaskSpec = ts
                if meta == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Propagate annotations from Task to TaskRun. TaskRun annotations take precedences over Task.
                <span class="cov8" title="1">tr.ObjectMeta.Annotations = kmap.Union(kmap.ExcludeKeys(meta.Annotations, tknreconciler.KubectlLastAppliedAnnotationKey), tr.ObjectMeta.Annotations)
                // Propagate labels from Task to TaskRun. TaskRun labels take precedences over Task.
                tr.ObjectMeta.Labels = kmap.Union(meta.Labels, tr.ObjectMeta.Labels)
                if tr.Spec.TaskRef != nil </span><span class="cov8" title="1">{
                        tr.ObjectMeta.Labels[pipeline.TaskLabelKey] = meta.Name
                }</span>
        }

        <span class="cov8" title="1">cfg := config.FromContextOrDefaults(ctx)
        if cfg.FeatureFlags.EnableProvenanceInStatus </span><span class="cov8" title="1">{
                if tr.Status.Provenance == nil </span><span class="cov8" title="1">{
                        tr.Status.Provenance = &amp;v1.Provenance{}
                }</span>
                // Store FeatureFlags in the Provenance.
                <span class="cov8" title="1">tr.Status.Provenance.FeatureFlags = cfg.FeatureFlags
                // Propagate RefSource from remote resolution to TaskRun Status
                // This lives outside of the status.spec check to avoid the case where only the spec is available in the first reconcile and refSource comes in next reconcile.
                if meta != nil &amp;&amp; meta.RefSource != nil &amp;&amp; tr.Status.Provenance.RefSource == nil </span><span class="cov8" title="1">{
                        tr.Status.Provenance.RefSource = meta.RefSource
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// willOverwritePodSetAffinity returns a bool indicating whether the
// affinity for pods will be overwritten with affinity assistant.
func willOverwritePodSetAffinity(taskRun *v1.TaskRun) bool <span class="cov8" title="1">{
        var podTemplate pod.Template
        if taskRun.Spec.PodTemplate != nil </span><span class="cov8" title="1">{
                podTemplate = *taskRun.Spec.PodTemplate
        }</span>
        <span class="cov8" title="1">return taskRun.Annotations[workspace.AnnotationAffinityAssistantName] != "" &amp;&amp; podTemplate.Affinity != nil</span>
}

// isResourceQuotaConflictError returns a bool indicating whether the
// k8 error is of kind resourcequotas or not
func isResourceQuotaConflictError(err error) bool <span class="cov8" title="1">{
        var k8Err k8serrors.APIStatus
        if !errors.As(err, &amp;k8Err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">k8ErrStatus := k8Err.Status()
        if k8ErrStatus.Reason != metav1.StatusReasonConflict </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return k8ErrStatus.Details != nil &amp;&amp; k8ErrStatus.Details.Kind == "resourcequotas"</span>
}

const (
        // optimisticLockErrorMsg is an error message exported from k8s.io/apiserver/pkg/registry/generic/registry.OptimisticLockErrorMsg
        // We made a tradeoff here because importing the package would introduce approximately 94klines
        // of code as a new dependency, and it would only be used to export one constant in one place.
        // In future we might find a better way to maintain consistency for this upstream error message.
        optimisticLockErrorMsg = "the object has been modified; please apply your changes to the latest version and try again"
)

// isConcurrentModificationError determines whether it is a concurrent
// modification  error depending on its error type and error message.
func isConcurrentModificationError(err error) bool <span class="cov8" title="1">{
        if !k8serrors.IsConflict(err) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var se *k8serrors.StatusError
        if !errors.As(err, &amp;se) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return strings.Contains(err.Error(), optimisticLockErrorMsg)</span>
}

// retryTaskRun archives taskRun.Status to taskRun.Status.RetriesStatus, and set
// taskRun status to Unknown with Reason v1.TaskRunReasonToBeRetried.
func retryTaskRun(tr *v1.TaskRun, message string) <span class="cov8" title="1">{
        newStatus := tr.Status.DeepCopy()
        newStatus.RetriesStatus = nil
        tr.Status.RetriesStatus = append(tr.Status.RetriesStatus, *newStatus)
        tr.Status.StartTime = nil
        tr.Status.CompletionTime = nil
        tr.Status.PodName = ""
        tr.Status.Results = nil
        taskRunCondSet := apis.NewBatchConditionSet()
        taskRunCondSet.Manage(&amp;tr.Status).MarkUnknown(apis.ConditionSucceeded, v1.TaskRunReasonToBeRetried.String(), message)
}</span>
</pre>
		
		<pre class="file" id="file460" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"
        "encoding/json"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
        "knative.dev/pkg/logging"
)

const (
        // TracerName is the name of the tracer
        TracerName = "TaskRunReconciler"
        // SpanContextAnnotation is the name of the Annotation used for propogating SpanContext
        SpanContextAnnotation = "tekton.dev/taskrunSpanContext"
)

// initialize tracing by creating the root span and injecting the
// spanContext is propogated through annotations in the CR
func initTracing(ctx context.Context, tracerProvider trace.TracerProvider, tr *v1.TaskRun) context.Context <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        pro := otel.GetTextMapPropagator()

        // SpanContext was created already
        if len(tr.Status.SpanContext) &gt; 0 </span><span class="cov0" title="0">{
                return pro.Extract(ctx, propagation.MapCarrier(tr.Status.SpanContext))
        }</span>

        <span class="cov8" title="1">spanContext := make(map[string]string)

        // SpanContext was propogated through annotations
        if tr.Annotations != nil &amp;&amp; tr.Annotations[SpanContextAnnotation] != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(tr.Annotations[SpanContextAnnotation]), &amp;spanContext)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("unable to unmarshal spancontext, err: %s", err)
                }</span>

                <span class="cov8" title="1">tr.Status.SpanContext = spanContext
                return pro.Extract(ctx, propagation.MapCarrier(tr.Status.SpanContext))</span>
        }

        // Create a new root span since there was no parent spanContext provided through annotations
        <span class="cov8" title="1">ctxWithTrace, span := tracerProvider.Tracer(TracerName).Start(ctx, "TaskRun:Reconciler")
        defer span.End()
        span.SetAttributes(attribute.String("taskrun", tr.Name), attribute.String("namespace", tr.Namespace))

        pro.Inject(ctxWithTrace, propagation.MapCarrier(spanContext))

        logger.Debug("got tracing carrier", spanContext)
        if len(spanContext) == 0 </span><span class="cov8" title="1">{
                logger.Debug("tracerProvider doesn't provide a traceId, tracing is disabled")
                return ctx
        }</span>

        <span class="cov8" title="1">span.AddEvent("updating TaskRun status with SpanContext")
        tr.Status.SpanContext = spanContext
        return ctxWithTrace</span>
}
</pre>
		
		<pre class="file" id="file461" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"
        "fmt"
        "sort"
        "strings"

        "errors"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/list"
        "github.com/tektoncd/pipeline/pkg/reconciler/taskrun/resources"

        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/utils/strings/slices"
)

// validateParams validates that all Pipeline Task, Matrix.Params and Matrix.Include parameters all have values, match the specified
// type and object params have all the keys required
func validateParams(ctx context.Context, paramSpecs []v1.ParamSpec, params v1.Params, matrixParams v1.Params) error <span class="cov8" title="1">{
        if paramSpecs == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">neededParamsNames, neededParamsTypes := neededParamsNamesAndTypes(paramSpecs)
        providedParams := params
        providedParams = append(providedParams, matrixParams...)
        providedParamsNames := providedParams.ExtractNames()
        if missingParamsNames := missingParamsNames(neededParamsNames, providedParamsNames, paramSpecs); len(missingParamsNames) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("missing values for these params which have no default values: %s", missingParamsNames)
        }</span>
        <span class="cov8" title="1">if wrongTypeParamNames := wrongTypeParamsNames(params, matrixParams, neededParamsTypes); len(wrongTypeParamNames) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("param types don't match the user-specified type: %s", wrongTypeParamNames)
        }</span>
        <span class="cov8" title="1">if missingKeysObjectParamNames := MissingKeysObjectParamNames(paramSpecs, params); len(missingKeysObjectParamNames) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("missing keys for these params which are required in ParamSpec's properties %v", missingKeysObjectParamNames)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// neededParamsNamesAndTypes returns the needed parameter names and types based on the paramSpec
func neededParamsNamesAndTypes(paramSpecs []v1.ParamSpec) (sets.String, map[string]v1.ParamType) <span class="cov8" title="1">{
        neededParamsNames := sets.String{}
        neededParamsTypes := make(map[string]v1.ParamType)
        for _, inputResourceParam := range paramSpecs </span><span class="cov8" title="1">{
                neededParamsNames.Insert(inputResourceParam.Name)
                neededParamsTypes[inputResourceParam.Name] = inputResourceParam.Type
        }</span>
        <span class="cov8" title="1">return neededParamsNames, neededParamsTypes</span>
}

// missingParamsNames returns a slice of missing parameter names that have not been declared with a default value
// in the paramSpec
func missingParamsNames(neededParams sets.String, providedParams sets.String, paramSpecs []v1.ParamSpec) []string <span class="cov8" title="1">{
        missingParamsNames := neededParams.Difference(providedParams)
        var missingParamsNamesWithNoDefaults []string
        for _, inputResourceParam := range paramSpecs </span><span class="cov8" title="1">{
                if missingParamsNames.Has(inputResourceParam.Name) &amp;&amp; inputResourceParam.Default == nil </span><span class="cov8" title="1">{
                        missingParamsNamesWithNoDefaults = append(missingParamsNamesWithNoDefaults, inputResourceParam.Name)
                }</span>
        }
        <span class="cov8" title="1">return missingParamsNamesWithNoDefaults</span>
}
func wrongTypeParamsNames(params []v1.Param, matrix v1.Params, neededParamsTypes map[string]v1.ParamType) []string <span class="cov8" title="1">{
        // TODO(#4723): validate that $(task.taskname.result.resultname) is invalid for array and object type.
        // It should be used to refer string and need to add [*] to refer to array or object.
        var wrongTypeParamNames []string
        for _, param := range params </span><span class="cov8" title="1">{
                if _, ok := neededParamsTypes[param.Name]; !ok </span><span class="cov8" title="1">{
                        // Ignore any missing params - this happens when extra params were
                        // passed to the task that aren't being used.
                        continue</span>
                }
                // This is needed to support array replacements in params. Users want to use $(tasks.taskName.results.resultname[*])
                // to pass array result to array param, yet in yaml format this will be
                // unmarshalled to string for ParamValues. So we need to check and skip this validation.
                // Please refer issue #4879 for more details and examples.
                <span class="cov8" title="1">if param.Value.Type == v1.ParamTypeString &amp;&amp; (neededParamsTypes[param.Name] == v1.ParamTypeArray || neededParamsTypes[param.Name] == v1.ParamTypeObject) &amp;&amp; v1.VariableSubstitutionRegex.MatchString(param.Value.StringVal) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if param.Value.Type != neededParamsTypes[param.Name] </span><span class="cov8" title="1">{
                        wrongTypeParamNames = append(wrongTypeParamNames, param.Name)
                }</span>
        }
        <span class="cov8" title="1">for _, param := range matrix </span><span class="cov8" title="1">{
                if _, ok := neededParamsTypes[param.Name]; !ok </span><span class="cov8" title="1">{
                        // Ignore any missing params - this happens when extra params were
                        // passed to the task that aren't being used.
                        continue</span>
                }
                // Matrix param replacements must be of type String
                <span class="cov8" title="1">if neededParamsTypes[param.Name] != v1.ParamTypeString </span><span class="cov8" title="1">{
                        wrongTypeParamNames = append(wrongTypeParamNames, param.Name)
                }</span>
        }
        <span class="cov8" title="1">return wrongTypeParamNames</span>
}

// MissingKeysObjectParamNames checks if all required keys of object type param definitions are provided in params or param definitions' defaults.
func MissingKeysObjectParamNames(paramSpecs []v1.ParamSpec, params v1.Params) map[string][]string <span class="cov8" title="1">{
        neededKeys := make(map[string][]string)
        providedKeys := make(map[string][]string)

        for _, spec := range paramSpecs </span><span class="cov8" title="1">{
                if spec.Type == v1.ParamTypeObject </span><span class="cov8" title="1">{
                        // collect required keys from properties section
                        for key := range spec.Properties </span><span class="cov8" title="1">{
                                neededKeys[spec.Name] = append(neededKeys[spec.Name], key)
                        }</span>

                        // collect provided keys from default
                        <span class="cov8" title="1">if spec.Default != nil &amp;&amp; spec.Default.ObjectVal != nil </span><span class="cov8" title="1">{
                                for key := range spec.Default.ObjectVal </span><span class="cov8" title="1">{
                                        providedKeys[spec.Name] = append(providedKeys[spec.Name], key)
                                }</span>
                        }
                }
        }

        // collect provided keys from run level value
        <span class="cov8" title="1">for _, p := range params </span><span class="cov8" title="1">{
                if p.Value.Type == v1.ParamTypeObject </span><span class="cov8" title="1">{
                        for key := range p.Value.ObjectVal </span><span class="cov8" title="1">{
                                providedKeys[p.Name] = append(providedKeys[p.Name], key)
                        }</span>
                }
        }

        <span class="cov8" title="1">return findMissingKeys(neededKeys, providedKeys)</span>
}

// findMissingKeys checks if objects have missing keys in its providers (taskrun value and default)
func findMissingKeys(neededKeys, providedKeys map[string][]string) map[string][]string <span class="cov8" title="1">{
        missings := map[string][]string{}
        for p, keys := range providedKeys </span><span class="cov8" title="1">{
                if _, ok := neededKeys[p]; !ok </span><span class="cov8" title="1">{
                        // Ignore any missing objects - this happens when object param is provided with default
                        continue</span>
                }
                <span class="cov8" title="1">missedKeys := list.DiffLeft(neededKeys[p], keys)
                if len(missedKeys) != 0 </span><span class="cov8" title="1">{
                        missings[p] = missedKeys
                }</span>
        }

        <span class="cov8" title="1">return missings</span>
}

// ValidateResolvedTask validates that all parameters declared in the TaskSpec are present in the taskrun
// It also validates that all parameters have values, parameter types match the specified type and
// object params have all the keys required
func ValidateResolvedTask(ctx context.Context, params []v1.Param, matrix *v1.Matrix, rtr *resources.ResolvedTask) error <span class="cov8" title="1">{
        var paramSpecs v1.ParamSpecs
        if rtr != nil </span><span class="cov8" title="1">{
                paramSpecs = rtr.TaskSpec.Params
        }</span>
        <span class="cov8" title="1">if err := validateParams(ctx, paramSpecs, params, matrix.GetAllParams()); err != nil </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("invalid input params for task %s: %w", rtr.TaskName, err))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateEnumParam validates the param values are in the defined enum list in the corresponding paramSpecs if provided.
// A validation error is returned otherwise.
func ValidateEnumParam(ctx context.Context, params []v1.Param, paramSpecs v1.ParamSpecs) error <span class="cov8" title="1">{
        paramSpecNameToEnum := map[string][]string{}
        for _, ps := range paramSpecs </span><span class="cov8" title="1">{
                if len(ps.Enum) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">paramSpecNameToEnum[ps.Name] = ps.Enum</span>
        }

        <span class="cov8" title="1">for _, p := range params </span><span class="cov8" title="1">{
                // skip validation for and non-string typed and optional params (using default value)
                // the default value of param is validated at validation webhook dryrun
                if p.Value.Type != v1.ParamTypeString || p.Value.StringVal == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                // skip validation for paramSpec without enum
                <span class="cov8" title="1">if _, ok := paramSpecNameToEnum[p.Name]; !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !slices.Contains(paramSpecNameToEnum[p.Name], p.Value.StringVal) </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("param `%s` value: %s is not in the enum list", p.Name, p.Value.StringVal))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateTaskSpecRequestResources(taskSpec *v1.TaskSpec) error <span class="cov8" title="1">{
        if taskSpec != nil </span><span class="cov8" title="1">{
                for _, step := range taskSpec.Steps </span><span class="cov8" title="1">{
                        for k, request := range step.ComputeResources.Requests </span><span class="cov8" title="1">{
                                // First validate the limit in step
                                if limit, ok := step.ComputeResources.Limits[k]; ok </span><span class="cov8" title="1">{
                                        if (&amp;limit).Cmp(request) == -1 </span><span class="cov8" title="1">{
                                                return pipelineErrors.WrapUserError(fmt.Errorf("invalid request resource value: %v must be less or equal to limit %v", request.String(), limit.String()))
                                        }</span>
                                } else<span class="cov8" title="1"> if taskSpec.StepTemplate != nil </span><span class="cov8" title="1">{
                                        // If step doesn't configure the limit, validate the limit in stepTemplate
                                        if limit, ok := taskSpec.StepTemplate.ComputeResources.Limits[k]; ok </span><span class="cov8" title="1">{
                                                if (&amp;limit).Cmp(request) == -1 </span><span class="cov8" title="1">{
                                                        return pipelineErrors.WrapUserError(fmt.Errorf("invalid request resource value: %v must be less or equal to limit %v", request.String(), limit.String()))
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateOverrides validates that all stepOverrides map to valid steps, and likewise for sidecarOverrides
func validateOverrides(ts *v1.TaskSpec, trs *v1.TaskRunSpec) error <span class="cov8" title="1">{
        stepErr := validateStepOverrides(ts, trs)
        sidecarErr := validateSidecarOverrides(ts, trs)
        return errors.Join(stepErr, sidecarErr)
}</span>

func validateStepOverrides(ts *v1.TaskSpec, trs *v1.TaskRunSpec) error <span class="cov8" title="1">{
        var errs []error
        stepNames := sets.NewString()
        for _, step := range ts.Steps </span><span class="cov8" title="1">{
                stepNames.Insert(step.Name)
        }</span>
        <span class="cov8" title="1">for _, stepOverride := range trs.StepSpecs </span><span class="cov8" title="1">{
                if !stepNames.Has(stepOverride.Name) </span><span class="cov8" title="1">{
                        errs = append(errs, pipelineErrors.WrapUserError(fmt.Errorf("invalid StepOverride: No Step named %s", stepOverride.Name)))
                }</span>
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func validateSidecarOverrides(ts *v1.TaskSpec, trs *v1.TaskRunSpec) error <span class="cov8" title="1">{
        var errs []error
        sidecarNames := sets.NewString()
        for _, sidecar := range ts.Sidecars </span><span class="cov8" title="1">{
                sidecarNames.Insert(sidecar.Name)
        }</span>
        <span class="cov8" title="1">for _, sidecarOverride := range trs.SidecarSpecs </span><span class="cov8" title="1">{
                if !sidecarNames.Has(sidecarOverride.Name) </span><span class="cov8" title="1">{
                        errs = append(errs, pipelineErrors.WrapUserError(fmt.Errorf("invalid SidecarOverride: No Sidecar named %s", sidecarOverride.Name)))
                }</span>
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

// validateResults checks the emitted results type and object properties against the ones defined in spec.
func validateTaskRunResults(tr *v1.TaskRun, resolvedTaskSpec *v1.TaskSpec) error <span class="cov8" title="1">{
        specResults := []v1.TaskResult{}
        if tr.Spec.TaskSpec != nil </span><span class="cov8" title="1">{
                specResults = append(specResults, tr.Spec.TaskSpec.Results...)
        }</span>

        <span class="cov8" title="1">if resolvedTaskSpec != nil </span><span class="cov8" title="1">{
                specResults = append(specResults, resolvedTaskSpec.Results...)
        }</span>

        // When get the results, check if the type of result is the expected one
        <span class="cov8" title="1">if missmatchedTypes := mismatchedTypesResults(tr, specResults); len(missmatchedTypes) != 0 </span><span class="cov8" title="1">{
                var s []string
                for k, v := range missmatchedTypes </span><span class="cov8" title="1">{
                        s = append(s, fmt.Sprintf(" \"%v\": %v", k, v))
                }</span>
                <span class="cov8" title="1">sort.Strings(s)
                return pipelineErrors.WrapUserError(fmt.Errorf("Provided results don't match declared results; may be invalid JSON or missing result declaration: %v", strings.Join(s, ",")))</span>
        }

        // When get the results, for object value need to check if they have missing keys.
        <span class="cov8" title="1">if missingKeysObjectNames := missingKeysofObjectResults(tr, specResults); len(missingKeysObjectNames) != 0 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(fmt.Errorf("missing keys for these results which are required in TaskResult's properties %v", missingKeysObjectNames))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// mismatchedTypesResults checks and returns all the mismatched types of emitted results against specified results.
func mismatchedTypesResults(tr *v1.TaskRun, specResults []v1.TaskResult) map[string]string <span class="cov8" title="1">{
        neededTypes := make(map[string]string)
        mismatchedTypes := make(map[string]string)
        var filteredResults []v1.TaskRunResult
        // collect needed types for results
        for _, r := range specResults </span><span class="cov8" title="1">{
                neededTypes[r.Name] = string(r.Type)
        }</span>

        // collect mismatched types for results, and correct results in filteredResults
        // TODO(#6097): Validate if the emitted results are defined in taskspec
        <span class="cov8" title="1">for _, trr := range tr.Status.Results </span><span class="cov8" title="1">{
                needed, ok := neededTypes[trr.Name]
                if ok &amp;&amp; needed != string(trr.Type) </span><span class="cov8" title="1">{
                        mismatchedTypes[trr.Name] = fmt.Sprintf("task result is expected to be \"%v\" type but was initialized to a different type \"%v\"", needed, trr.Type)
                }</span> else<span class="cov8" title="1"> {
                        filteredResults = append(filteredResults, trr)
                }</span>
        }
        // remove the mismatched results
        <span class="cov8" title="1">tr.Status.Results = filteredResults
        return mismatchedTypes</span>
}

// missingKeysofObjectResults checks and returns the missing keys of object results.
func missingKeysofObjectResults(tr *v1.TaskRun, specResults []v1.TaskResult) map[string][]string <span class="cov8" title="1">{
        neededKeys := make(map[string][]string)
        providedKeys := make(map[string][]string)
        // collect needed keys for object results
        for _, r := range specResults </span><span class="cov8" title="1">{
                if string(r.Type) == string(v1.ParamTypeObject) </span><span class="cov8" title="1">{
                        for key := range r.Properties </span><span class="cov8" title="1">{
                                neededKeys[r.Name] = append(neededKeys[r.Name], key)
                        }</span>
                }
        }

        // collect provided keys for object results
        <span class="cov8" title="1">for _, trr := range tr.Status.Results </span><span class="cov8" title="1">{
                if trr.Value.Type == v1.ParamTypeObject </span><span class="cov8" title="1">{
                        for key := range trr.Value.ObjectVal </span><span class="cov8" title="1">{
                                providedKeys[trr.Name] = append(providedKeys[trr.Name], key)
                        }</span>
                }
        }
        <span class="cov8" title="1">return findMissingKeys(neededKeys, providedKeys)</span>
}
</pre>
		
		<pre class="file" id="file462" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testing

import (
        "fmt"
        "os"
        "strconv"
        "testing"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/system"
        "sigs.k8s.io/yaml"
)

const (
        apiFieldsFeatureFlag           = "enable-api-fields"
        maxMatrixCombinationsCountFlag = "default-max-matrix-combinations-count"
)

// ConfigMapFromTestFile creates a v1.ConfigMap from a YAML file
// It loads the YAML file from the testdata folder.
func ConfigMapFromTestFile(t *testing.T, name string) *corev1.ConfigMap <span class="cov0" title="0">{
        t.Helper()

        b, err := os.ReadFile(fmt.Sprintf("testdata/%s.yaml", name))
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("ReadFile() = %v", err)
        }</span>

        <span class="cov0" title="0">var cm corev1.ConfigMap

        // Use "sigs.k8s.io/yaml" since it reads json struct
        // tags so things unmarshal properly
        if err := yaml.Unmarshal(b, &amp;cm); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("yaml.Unmarshal() = %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;cm</span>
}

func NewFeatureFlagsConfigMapInSlice() []*corev1.ConfigMap <span class="cov0" title="0">{
        return []*corev1.ConfigMap{newFeatureFlagsConfigMap()}
}</span>

func newFeatureFlagsConfigMap() *corev1.ConfigMap <span class="cov0" title="0">{
        return &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      config.GetFeatureFlagsConfigName(),
                        Namespace: system.Namespace(),
                },
                Data: make(map[string]string),
        }
}</span>

func NewAlphaFeatureFlagsConfigMapInSlice() []*corev1.ConfigMap <span class="cov0" title="0">{
        return []*corev1.ConfigMap{withEnabledAlphaAPIFields(newFeatureFlagsConfigMap())}
}</span>

func withEnabledAlphaAPIFields(cm *corev1.ConfigMap) *corev1.ConfigMap <span class="cov0" title="0">{
        newCM := cm.DeepCopy()
        newCM.Data[apiFieldsFeatureFlag] = config.AlphaAPIFields
        return newCM
}</span>

func NewFeatureFlagsConfigMapWithMatrixInSlice(count int) []*corev1.ConfigMap <span class="cov0" title="0">{
        return append(
                NewFeatureFlagsConfigMapInSlice(),
                withMaxMatrixCombinationsCount(newDefaultsConfigMap(), count),
        )
}</span>

func withMaxMatrixCombinationsCount(cm *corev1.ConfigMap, count int) *corev1.ConfigMap <span class="cov0" title="0">{
        newCM := cm.DeepCopy()
        newCM.Data[maxMatrixCombinationsCountFlag] = strconv.Itoa(count)
        return newCM
}</span>

func newDefaultsConfigMap() *corev1.ConfigMap <span class="cov0" title="0">{
        return &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      config.GetDefaultsConfigName(),
                        Namespace: system.Namespace(),
                },
                Data: make(map[string]string),
        }
}</span>

func NewAlphaFeatureFlagsConfigMapWithMatrixInSlice(count int) []*corev1.ConfigMap <span class="cov0" title="0">{
        return append(
                NewAlphaFeatureFlagsConfigMapInSlice(),
                withMaxMatrixCombinationsCount(newDefaultsConfigMap(), count),
        )
}</span>

func NewDefaultsCofigMapInSlice() []*corev1.ConfigMap <span class="cov0" title="0">{
        return []*corev1.ConfigMap{newDefaultsConfigMap()}
}</span>
</pre>
		
		<pre class="file" id="file463" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testing

import (
        "context"
        "testing"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "go.uber.org/zap"
        "go.uber.org/zap/zaptest"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/record"
        filteredinformerfactory "knative.dev/pkg/client/injection/kube/informers/factory/filtered"

        // Import for creating fake filtered factory in the test
        _ "knative.dev/pkg/client/injection/kube/informers/factory/filtered/fake"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
        logtesting "knative.dev/pkg/logging/testing"
)

// SetupFakeContext sets up the Context and the fake filtered informers for the tests.
func SetupFakeContext(t *testing.T) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        t.Helper()
        ctx, _, informer := setupFakeContextWithLabelKey(t)
        return WithLogger(ctx, t), informer
}</span>

// SetupFakeCloudClientContext sets up the fakeclient to context
func SetupFakeCloudClientContext(ctx context.Context, expectedEventCount int) context.Context <span class="cov0" title="0">{
        cloudEventClientBehaviour := cloudevent.FakeClientBehaviour{
                SendSuccessfully: true,
        }
        return cloudevent.WithFakeClient(ctx, &amp;cloudEventClientBehaviour, expectedEventCount)
}</span>

// SetupDefaultContext sets up the Context and the default filtered informers for the tests.
func SetupDefaultContext(t *testing.T) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        t.Helper()
        ctx, _, informer := setupDefaultContextWithLabelKey(t)
        return WithLogger(ctx, t), informer
}</span>

// WithLogger returns the Logger
func WithLogger(ctx context.Context, t *testing.T) context.Context <span class="cov0" title="0">{
        t.Helper()
        return logging.WithLogger(ctx, TestLogger(t))
}</span>

// TestLogger sets up the Logger
func TestLogger(t *testing.T) *zap.SugaredLogger <span class="cov0" title="0">{
        logger := zaptest.NewLogger(t, zaptest.WrapOptions(zap.AddCaller()))
        return logger.Sugar().Named(t.Name())
}</span>

// setupFakeContextWithLabelKey sets up the Context and the fake informers for the tests
// The provided context includes the FilteredInformerFactory LabelKey.
func setupFakeContextWithLabelKey(t zaptest.TestingT) (context.Context, context.CancelFunc, []controller.Informer) <span class="cov0" title="0">{
        ctx, c := context.WithCancel(logtesting.TestContextWithLogger(t))
        ctx = controller.WithEventRecorder(ctx, record.NewFakeRecorder(1000))
        ctx = filteredinformerfactory.WithSelectors(ctx, v1.ManagedByLabelKey)
        ctx, is := injection.Fake.SetupInformers(ctx, &amp;rest.Config{})
        return ctx, c, is
}</span>

// setupDefaultContextWithLabelKey sets up the Context and the default informers for the tests
// The provided context includes the FilteredInformerFactory LabelKey.
func setupDefaultContextWithLabelKey(t zaptest.TestingT) (context.Context, context.CancelFunc, []controller.Informer) <span class="cov0" title="0">{
        ctx, c := context.WithCancel(logtesting.TestContextWithLogger(t))
        ctx = filteredinformerfactory.WithSelectors(ctx, v1.ManagedByLabelKey)
        ctx, is := injection.Default.SetupInformers(ctx, &amp;rest.Config{})
        return ctx, c, is
}</span>
</pre>
		
		<pre class="file" id="file464" style="display: none">package testing

import (
        "testing"

        "github.com/google/go-cmp/cmp"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/test/diff"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
)

const (
        taskRun     = pipeline.TaskRunControllerName
        customRun   = pipeline.CustomRunControllerName
        pipelineRun = pipeline.PipelineRunControllerName
)

func CheckPipelineRunConditionStatusAndReason(
        t *testing.T,
        prStatus v1.PipelineRunStatus,
        expectedStatus corev1.ConditionStatus,
        expectedReason string,
) <span class="cov0" title="0">{
        t.Helper()

        actualCondition := prStatus.GetCondition(apis.ConditionSucceeded)
        if actualCondition == nil </span><span class="cov0" title="0">{
                t.Fatalf("want condition, got nil")
        }</span>
        <span class="cov0" title="0">if actualCondition.Status != expectedStatus </span><span class="cov0" title="0">{
                t.Errorf("want status %v, got %v", expectedStatus, actualCondition.Status)
        }</span>
        <span class="cov0" title="0">if actualCondition.Reason != expectedReason </span><span class="cov0" title="0">{
                t.Errorf("want reason %s, got %s", expectedReason, actualCondition.Reason)
        }</span>
}

func VerifyTaskRunStatusesCount(t *testing.T, prStatus v1.PipelineRunStatus, expectedCount int) <span class="cov0" title="0">{
        t.Helper()
        verifyCount(t, prStatus, expectedCount, taskRun)
}</span>

func verifyCount(t *testing.T, prStatus v1.PipelineRunStatus, expectedCount int, kind string) <span class="cov0" title="0">{
        t.Helper()

        actualCount := len(filterChildRefsForKind(prStatus.ChildReferences, kind))
        if actualCount != expectedCount </span><span class="cov0" title="0">{
                oneOrMany := kind
                if expectedCount &gt; 1 </span><span class="cov0" title="0">{
                        oneOrMany += "s"
                }</span>
                <span class="cov0" title="0">t.Errorf("Expected PipelineRun status ChildReferences to have %d %s, but was %d", expectedCount, oneOrMany, actualCount)</span>
        }
}

func filterChildRefsForKind(childRefs []v1.ChildStatusReference, kind string) []v1.ChildStatusReference <span class="cov0" title="0">{
        var filtered []v1.ChildStatusReference
        for _, cr := range childRefs </span><span class="cov0" title="0">{
                if cr.Kind == kind </span><span class="cov0" title="0">{
                        filtered = append(filtered, cr)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func VerifyTaskRunStatusesNames(t *testing.T, prStatus v1.PipelineRunStatus, expectedNames ...string) <span class="cov0" title="0">{
        t.Helper()
        verifyNames(t, prStatus, expectedNames, taskRun)
}</span>

func verifyNames(t *testing.T, prStatus v1.PipelineRunStatus, expectedNames []string, kind string) <span class="cov0" title="0">{
        t.Helper()

        actualNames := make(map[string]bool)
        for _, cr := range filterChildRefsForKind(prStatus.ChildReferences, kind) </span><span class="cov0" title="0">{
                actualNames[cr.Name] = true
        }</span>

        <span class="cov0" title="0">for _, expectedName := range expectedNames </span><span class="cov0" title="0">{
                if actualNames[expectedName] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">t.Errorf("Expected PipelineRun status to include %s status for %s but was %v", kind, expectedName, prStatus.ChildReferences)</span>
        }
}

func VerifyTaskRunStatusesWhenExpressions(t *testing.T, prStatus v1.PipelineRunStatus, trName string, expectedWhen []v1.WhenExpression) <span class="cov0" title="0">{
        t.Helper()

        var actualWhen []v1.WhenExpression
        for _, cr := range prStatus.ChildReferences </span><span class="cov0" title="0">{
                if cr.Name == trName </span><span class="cov0" title="0">{
                        actualWhen = append(actualWhen, cr.WhenExpressions...)
                }</span>
        }

        <span class="cov0" title="0">if d := cmp.Diff(expectedWhen, actualWhen); d != "" </span><span class="cov0" title="0">{
                t.Errorf("Expected to see When Expressions %v created. Diff %s", trName, diff.PrintWantGot(d))
        }</span>
}

func VerifyCustomRunOrRunStatusesCount(t *testing.T, prStatus v1.PipelineRunStatus, expectedCount int) <span class="cov0" title="0">{
        t.Helper()
        verifyCount(t, prStatus, expectedCount, customRun)
}</span>

func VerifyCustomRunOrRunStatusesNames(t *testing.T, prStatus v1.PipelineRunStatus, expectedNames ...string) <span class="cov0" title="0">{
        t.Helper()
        verifyNames(t, prStatus, expectedNames, customRun)
}</span>
</pre>
		
		<pre class="file" id="file465" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package volumeclaim

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        "gomodules.xyz/jsonpatch/v2"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        clientset "k8s.io/client-go/kubernetes"
)

const (
        // ReasonCouldntCreateWorkspacePVC indicates that a Pipeline expects a workspace from a
        // volumeClaimTemplate but couldn't create a claim.
        ReasonCouldntCreateWorkspacePVC = "CouldntCreateWorkspacePVC"
)

var (
        ErrPvcCreationFailed          = errors.New("PVC creation error")
        ErrPvcCreationFailedRetryable = errors.New("PVC creation error, retryable")
)

// PvcHandler is used to create PVCs for workspaces
type PvcHandler interface {
        CreatePVCFromVolumeClaimTemplate(ctx context.Context, wb v1.WorkspaceBinding, ownerReference metav1.OwnerReference, namespace string) error
        PurgeFinalizerAndDeletePVCForWorkspace(ctx context.Context, pvcName, namespace string) error
}

type defaultPVCHandler struct {
        clientset clientset.Interface
        logger    *zap.SugaredLogger
}

// NewPVCHandler returns a new defaultPVCHandler
func NewPVCHandler(clientset clientset.Interface, logger *zap.SugaredLogger) PvcHandler <span class="cov0" title="0">{
        return &amp;defaultPVCHandler{clientset, logger}
}</span>

// CreatePVCFromVolumeClaimTemplate checks if a PVC named &lt;claim-name&gt;-&lt;workspace-name&gt;-&lt;owner-name&gt; exists;
// where claim-name is provided by the user in the volumeClaimTemplate, and owner-name is the name of the
// resource with the volumeClaimTemplate declared, a PipelineRun or TaskRun. If the PVC did not exist, a new PVC
// with that name is created with the provided OwnerReference.
func (c *defaultPVCHandler) CreatePVCFromVolumeClaimTemplate(ctx context.Context, wb v1.WorkspaceBinding, ownerReference metav1.OwnerReference, namespace string) error <span class="cov8" title="1">{
        claim := c.getPVCFromVolumeClaimTemplate(wb, ownerReference, namespace)
        if claim == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">_, err := c.clientset.CoreV1().PersistentVolumeClaims(claim.Namespace).Get(ctx, claim.Name, metav1.GetOptions{})
        switch </span>{
        case apierrors.IsNotFound(err):<span class="cov8" title="1">
                _, err := c.clientset.CoreV1().PersistentVolumeClaims(claim.Namespace).Create(ctx, claim, metav1.CreateOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        if apierrors.IsAlreadyExists(err) </span><span class="cov8" title="1">{
                                c.logger.Infof("Tried to create PersistentVolumeClaim %s in namespace %s, but it already exists",
                                        claim.Name, claim.Namespace)
                        }</span> else<span class="cov8" title="1"> if isRetryableError(err) </span><span class="cov8" title="1">{
                                // This is a retry-able error
                                return fmt.Errorf("%w for %s: %v", ErrPvcCreationFailedRetryable, claim.Name, err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Errorf("%w for %s: %v", ErrPvcCreationFailed, claim.Name, err.Error())
                        }</span>
                } else<span class="cov8" title="1"> {
                        c.logger.Infof("Created PersistentVolumeClaim %s in namespace %s", claim.Name, claim.Namespace)
                }</span>
        case err != nil:<span class="cov8" title="1">
                return fmt.Errorf("failed to retrieve PVC %s: %w", claim.Name, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PurgeFinalizerAndDeletePVCForWorkspace deletes pvcs and then purges the `kubernetes.io/pvc-protection` finalizer protection.
// Purging the `kubernetes.io/pvc-protection` finalizer allows the pvc to be deleted even when it is referenced by a taskrun pod.
// See mode details in https://kubernetes.io/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection.
func (c *defaultPVCHandler) PurgeFinalizerAndDeletePVCForWorkspace(ctx context.Context, pvcName, namespace string) error <span class="cov8" title="1">{
        p, err := c.clientset.CoreV1().PersistentVolumeClaims(namespace).Get(ctx, pvcName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                // check if the PVC exists, otherwise skip the deletion
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        c.logger.Debugf("PVC %s no longer exists, skipping deletion as it has already been removed", pvcName)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get the PVC %s: %w", pvcName, err)</span>
        }

        // get the list of existing finalizers and drop `pvc-protection` if exists
        <span class="cov8" title="1">var finalizers []string
        for _, f := range p.ObjectMeta.Finalizers </span><span class="cov8" title="1">{
                if f == "kubernetes.io/pvc-protection" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">finalizers = append(finalizers, f)</span>
        }

        // prepare data to remove pvc-protection from the list of finalizers
        <span class="cov8" title="1">removeFinalizerBytes, err := json.Marshal([]jsonpatch.JsonPatchOperation{{
                Path:      "/metadata/finalizers",
                Operation: "replace",
                Value:     finalizers,
        }})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal jsonpatch: %w", err)
        }</span>

        // delete PVC
        <span class="cov8" title="1">err = c.clientset.CoreV1().PersistentVolumeClaims(namespace).Delete(ctx, pvcName, metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete the PVC %s: %w", pvcName, err)
        }</span>

        // remove finalizer
        <span class="cov8" title="1">_, err = c.clientset.CoreV1().PersistentVolumeClaims(namespace).Patch(ctx, pvcName, types.JSONPatchType, removeFinalizerBytes, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch the PVC %s: %w", pvcName, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getPVCFromVolumeClaimTemplate returns a PersistentVolumeClaim based on given workspaceBinding (using VolumeClaimTemplate), ownerReference and namespace
func (c *defaultPVCHandler) getPVCFromVolumeClaimTemplate(workspaceBinding v1.WorkspaceBinding, ownerReference metav1.OwnerReference, namespace string) *corev1.PersistentVolumeClaim <span class="cov8" title="1">{
        if workspaceBinding.VolumeClaimTemplate == nil </span><span class="cov8" title="1">{
                c.logger.Infof("workspace binding %v does not contain VolumeClaimTemplate, skipping creating PVC", workspaceBinding.Name)
                return nil
        }</span>

        <span class="cov8" title="1">claim := workspaceBinding.VolumeClaimTemplate.DeepCopy()
        claim.Name = GeneratePVCNameFromWorkspaceBinding(workspaceBinding.VolumeClaimTemplate.Name, workspaceBinding, ownerReference)
        claim.Namespace = namespace
        claim.OwnerReferences = []metav1.OwnerReference{ownerReference}

        return claim</span>
}

// GeneratePVCNameFromWorkspaceBinding gets the name of PersistentVolumeClaim for a Workspace and PipelineRun or TaskRun. claim
// must be a PersistentVolumeClaim from a volumeClaimTemplate. The returned name must be consistent given the same
// workspaceBinding name and ownerReference UID - because it is first used for creating a PVC and later,
// possibly several TaskRuns to lookup the PVC to mount.
// We use ownerReference UID over ownerReference name to distinguish runs with the same name.
// If the given volumeClaimTemplate name is empty, the prefix "pvc" will be applied to the PersistentVolumeClaim name.
// See function `getPersistentVolumeClaimNameWithAffinityAssistant` when the PersistentVolumeClaim is created by Affinity Assistant StatefulSet.
func GeneratePVCNameFromWorkspaceBinding(claimName string, wb v1.WorkspaceBinding, owner metav1.OwnerReference) string <span class="cov8" title="1">{
        if claimName == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s-%s", "pvc", getPersistentVolumeClaimIdentity(wb.Name, string(owner.UID)))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", claimName, getPersistentVolumeClaimIdentity(wb.Name, string(owner.UID)))</span>
}

func getPersistentVolumeClaimIdentity(workspaceName, ownerName string) string <span class="cov8" title="1">{
        hashBytes := sha256.Sum256([]byte(workspaceName + ownerName))
        hashString := hex.EncodeToString(hashBytes[:])
        return hashString[:10]
}</span>

func isRetryableError(err error) bool <span class="cov8" title="1">{
        if (apierrors.IsForbidden(err) &amp;&amp; strings.Contains(err.Error(), "exceeded quota")) || apierrors.IsConflict(err) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file466" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package oci

import (
        "archive/tar"
        "context"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/google/go-containerregistry/pkg/authn"
        imgname "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        ociremote "github.com/google/go-containerregistry/pkg/v1/remote"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        "github.com/tektoncd/pipeline/pkg/remote"
        "k8s.io/apimachinery/pkg/runtime"
)

const (
        // KindAnnotation is an OCI annotation for the bundle kind
        KindAnnotation = "dev.tekton.image.kind"
        // APIVersionAnnotation is an OCI annotation for the bundle version
        APIVersionAnnotation = "dev.tekton.image.apiVersion"
        // TitleAnnotation is an OCI annotation for the bundle title
        TitleAnnotation = "dev.tekton.image.name"
        // MaximumBundleObjects defines the maximum number of objects in a bundle
        MaximumBundleObjects = 20
)

// Resolver implements the Resolver interface using OCI images.
type Resolver struct {
        imageReference string
        keychain       authn.Keychain
        timeout        time.Duration
}

// NewResolver is a convenience function to return a new OCI resolver instance as a remote.Resolver with a short, 1m
// timeout for resolving an individual image.
func NewResolver(ref string, keychain authn.Keychain) remote.Resolver <span class="cov8" title="1">{
        return &amp;Resolver{imageReference: ref, keychain: keychain, timeout: time.Second * 60}
}</span>

// List retrieves a flat set of Tekton objects
func (o *Resolver) List(ctx context.Context) ([]remote.ResolvedObject, error) <span class="cov8" title="1">{
        timeoutCtx, cancel := context.WithTimeout(ctx, o.timeout)
        defer cancel()
        img, err := o.retrieveImage(timeoutCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">manifest, err := img.Manifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not parse image manifest: %w", err)
        }</span>

        <span class="cov8" title="1">if err := o.checkImageCompliance(manifest); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contents := make([]remote.ResolvedObject, 0, len(manifest.Layers))
        for _, l := range manifest.Layers </span><span class="cov8" title="1">{
                contents = append(contents, remote.ResolvedObject{
                        Kind:       l.Annotations[KindAnnotation],
                        APIVersion: l.Annotations[APIVersionAnnotation],
                        Name:       l.Annotations[TitleAnnotation],
                })
        }</span>

        <span class="cov8" title="1">return contents, nil</span>
}

// Get retrieves a specific object with the given Kind and name
func (o *Resolver) Get(ctx context.Context, kind, name string) (runtime.Object, *pipelinev1.RefSource, error) <span class="cov8" title="1">{
        timeoutCtx, cancel := context.WithTimeout(ctx, o.timeout)
        defer cancel()
        img, err := o.retrieveImage(timeoutCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">manifest, err := img.Manifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("could not parse image manifest: %w", err)
        }</span>

        <span class="cov8" title="1">if err := o.checkImageCompliance(manifest); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">layers, err := img.Layers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("could not read image layers: %w", err)
        }</span>

        <span class="cov8" title="1">layerMap := map[string]v1.Layer{}
        for _, l := range layers </span><span class="cov8" title="1">{
                digest, err := l.Digest()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to find digest for layer: %w", err)
                }</span>
                <span class="cov8" title="1">layerMap[digest.String()] = l</span>
        }

        <span class="cov8" title="1">for idx, l := range manifest.Layers </span><span class="cov8" title="1">{
                lKind := l.Annotations[KindAnnotation]
                lName := l.Annotations[TitleAnnotation]

                if kind == lKind &amp;&amp; name == lName </span><span class="cov8" title="1">{
                        obj, err := readTarLayer(layerMap[l.Digest.String()])
                        if err != nil </span><span class="cov0" title="0">{
                                // This could still be a raw layer so try to read it as that instead.
                                obj, err := readRawLayer(layers[idx])
                                return obj, nil, err
                        }</span>
                        <span class="cov8" title="1">return obj, nil, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("could not find object in image with kind: %s and name: %s", kind, name)</span>
}

// retrieveImage will fetch the image's contents and manifest.
func (o *Resolver) retrieveImage(ctx context.Context) (v1.Image, error) <span class="cov8" title="1">{
        imgRef, err := imgname.ParseReference(o.imageReference)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s is an unparseable image reference: %w", o.imageReference, err)
        }</span>
        <span class="cov8" title="1">return ociremote.Image(imgRef, ociremote.WithAuthFromKeychain(o.keychain), ociremote.WithContext(ctx))</span>
}

// checkImageCompliance will perform common checks to ensure the Tekton Bundle is compliant to our spec.
func (o *Resolver) checkImageCompliance(manifest *v1.Manifest) error <span class="cov8" title="1">{
        // Check the manifest's layers to ensure there are a maximum of 10.
        if len(manifest.Layers) &gt; MaximumBundleObjects </span><span class="cov8" title="1">{
                return fmt.Errorf("bundle %s contained more than the maximum %d allow objects", o.imageReference, MaximumBundleObjects)
        }</span>

        // Ensure each layer complies to the spec.
        <span class="cov8" title="1">for _, l := range manifest.Layers </span><span class="cov8" title="1">{
                refDigest := fmt.Sprintf("%s:%s", o.imageReference, l.Digest.String())
                if _, ok := l.Annotations[APIVersionAnnotation]; !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid tekton bundle: %s does not contain a %s annotation", refDigest, APIVersionAnnotation)
                }</span>

                <span class="cov8" title="1">if _, ok := l.Annotations[TitleAnnotation]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid tekton bundle: %s does not contain a %s annotation", refDigest, TitleAnnotation)
                }</span>

                <span class="cov8" title="1">kind, ok := l.Annotations[KindAnnotation]
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid tekton bundle: %s does not contain a %s annotation", refDigest, KindAnnotation)
                }</span>
                <span class="cov8" title="1">if strings.TrimSuffix(strings.ToLower(kind), "s") != kind </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid tekton bundle: %s annotation for %s must be lowercased and singular, found %s", KindAnnotation, refDigest, kind)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Utility function to read out the contents of an image layer, assumed to be a tarball, as a parsed Tekton resource.
func readTarLayer(layer v1.Layer) (runtime.Object, error) <span class="cov8" title="1">{
        rc, err := layer.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to read image layer: %w", err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        // If the user bundled this up as a tar file then we need to untar it.
        treader := tar.NewReader(rc)
        header, err := treader.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("layer is not a tarball")
        }</span>

        <span class="cov8" title="1">contents := make([]byte, header.Size)
        if _, err := treader.Read(contents); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                // We only allow 1 resource per layer so this tar bundle should have one and only one file.
                return nil, fmt.Errorf("failed to read tar bundle: %w", err)
        }</span>

        <span class="cov8" title="1">obj, _, err := scheme.Codecs.UniversalDeserializer().Decode(contents, nil, nil)
        return obj, err</span>
}

// Utility function to read out the contents of an image layer, assumed to be raw bytes, as a parsed Tekton resource.
func readRawLayer(layer v1.Layer) (runtime.Object, error) <span class="cov0" title="0">{
        rc, err := layer.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read image layer: %w", err)
        }</span>
        <span class="cov0" title="0">defer rc.Close()

        contents, err := io.ReadAll(rc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read contents of image layer: %w", err)
        }</span>

        <span class="cov0" title="0">obj, _, err := scheme.Codecs.UniversalDeserializer().Decode(contents, nil, nil)
        return obj, err</span>
}
</pre>
		
		<pre class="file" id="file467" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolution

import (
        "errors"
        "fmt"
)

// ErrNilResource is returned when remote resolution
// appears to have succeeded but the resolved resource is nil.
var ErrNilResource = errors.New("unknown error occurred: requested resource is nil")

// InvalidRuntimeObjectError is returned when remote resolution
// succeeded but the returned data is not a valid runtime.Object.
type InvalidRuntimeObjectError struct {
        Original error
}

var _ error = &amp;InvalidRuntimeObjectError{}

// Error returns the string representation of this error.
func (e *InvalidRuntimeObjectError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid runtime object: %v", e.Original)
}</span>

// Unwrap returns the underlying original error.
func (e *InvalidRuntimeObjectError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// Is returns true if the given error coerces into an error of this type.
func (e *InvalidRuntimeObjectError) Is(that error) bool <span class="cov8" title="1">{
        return errors.As(that, &amp;e)
}</span>

// DataAccessError is returned when remote resolution succeeded but
// attempting to access the resolved data failed. An example of this
// type of error would be if a ResolutionRequest contained malformed base64.
type DataAccessError struct {
        Original error
}

var _ error = &amp;DataAccessError{}

// Error returns the string representation of this error.
func (e *DataAccessError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error accessing data from remote resource: %v", e.Original)
}</span>

// Unwrap returns the underlying original error.
func (e *DataAccessError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// Is returns true if the given error coerces into an error of this type.
func (e *DataAccessError) Is(that error) bool <span class="cov8" title="1">{
        return errors.As(that, &amp;e)
}</span>
</pre>
		
		<pre class="file" id="file468" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolution

import (
        resolution "github.com/tektoncd/pipeline/pkg/resolution/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/kmeta"
)

var _ resolution.Request = &amp;resolutionRequest{}
var _ resolution.OwnedRequest = &amp;resolutionRequest{}

type resolutionRequest struct {
        resolution.Request
        owner kmeta.OwnerRefable
}

func (req *resolutionRequest) OwnerRef() metav1.OwnerReference <span class="cov8" title="1">{
        return *kmeta.NewControllerRef(req.owner)
}</span>
</pre>
		
		<pre class="file" id="file469" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolution

import (
        "context"
        "errors"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        "github.com/tektoncd/pipeline/pkg/remote"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        remoteresource "github.com/tektoncd/pipeline/pkg/resolution/resource"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer"
        "knative.dev/pkg/kmeta"
)

// Resolver implements remote.Resolver and encapsulates the majority of
// code required to interface with the tektoncd/resolution project. It
// is used to make async requests for resources like pipelines from
// remote places like git repos.
type Resolver struct {
        requester       remoteresource.Requester
        owner           kmeta.OwnerRefable
        resolverName    string
        params          v1.Params
        targetName      string
        targetNamespace string
}

var _ remote.Resolver = &amp;Resolver{}

// NewResolver returns an implementation of remote.Resolver capable
// of performing asynchronous remote resolution.
func NewResolver(requester remoteresource.Requester, owner kmeta.OwnerRefable, resolverName string, targetName string, targetNamespace string, params v1.Params) remote.Resolver <span class="cov8" title="1">{
        return &amp;Resolver{
                requester:       requester,
                owner:           owner,
                resolverName:    resolverName,
                params:          params,
                targetName:      targetName,
                targetNamespace: targetNamespace,
        }
}</span>

// Get implements remote.Resolver.
func (resolver *Resolver) Get(ctx context.Context, _, _ string) (runtime.Object, *v1.RefSource, error) <span class="cov8" title="1">{
        resolverName := remoteresource.ResolverName(resolver.resolverName)
        req, err := buildRequest(resolver.resolverName, resolver.owner, resolver.targetName, resolver.targetNamespace, resolver.params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error building request for remote resource: %w", err)
        }</span>
        <span class="cov8" title="1">resolved, err := resolver.requester.Submit(ctx, resolverName, req)
        return ResolvedRequest(resolved, err)</span>
}

// List implements remote.Resolver but is unused for remote resolution.
func (resolver *Resolver) List(_ context.Context) ([]remote.ResolvedObject, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func buildRequest(resolverName string, owner kmeta.OwnerRefable, name string, namespace string, params v1.Params) (*resolutionRequest, error) <span class="cov8" title="1">{
        rr := &amp;v1beta1.ResolutionRequestSpec{
                Params: params,
        }
        name, namespace, err := remoteresource.GetNameAndNamespace(resolverName, owner, name, namespace, rr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req := &amp;resolutionRequest{
                Request: remoteresource.NewRequest(name, namespace, params),
                owner:   owner,
        }
        return req, nil</span>
}

func ResolvedRequest(resolved resolutioncommon.ResolvedResource, err error) (runtime.Object, *v1.RefSource, error) <span class="cov8" title="1">{
        switch </span>{
        case errors.Is(err, resolutioncommon.ErrRequestInProgress):<span class="cov8" title="1">
                return nil, nil, remote.ErrRequestInProgress</span>
        case err != nil:<span class="cov8" title="1">
                return nil, nil, fmt.Errorf("error requesting remote resource: %w", err)</span>
        case resolved == nil:<span class="cov8" title="1">
                return nil, nil, ErrNilResource</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">data, err := resolved.Data()
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, &amp;DataAccessError{Original: err}
        }</span>
        <span class="cov8" title="1">codecs := serializer.NewCodecFactory(scheme.Scheme, serializer.EnableStrict)
        obj, _, err := codecs.UniversalDeserializer().Decode(data, nil, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, &amp;InvalidRuntimeObjectError{Original: err}
        }</span>
        <span class="cov8" title="1">return obj, resolved.RefSource(), nil</span>
}
</pre>
		
		<pre class="file" id="file470" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolution

import (
        resolution "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/kmeta"
)

var _ resolution.Request = &amp;resolutionRequest{}
var _ resolution.OwnedRequest = &amp;resolutionRequest{}

type resolutionRequest struct {
        resolution.Request
        owner kmeta.OwnerRefable
}

func (req *resolutionRequest) OwnerRef() metav1.OwnerReference <span class="cov8" title="1">{
        return *kmeta.NewControllerRef(req.owner)
}</span>
</pre>
		
		<pre class="file" id="file471" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolution

import (
        "context"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remote"
        resolution "github.com/tektoncd/pipeline/pkg/remote/resolution"
        remoteresource "github.com/tektoncd/pipeline/pkg/remoteresolution/resource"
        resource "github.com/tektoncd/pipeline/pkg/resolution/resource"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/kmeta"
)

// Resolver implements remote.Resolver and encapsulates the majority of
// code required to interface with the tektoncd/resolution project. It
// is used to make async requests for resources like pipelines from
// remote places like git repos.
type Resolver struct {
        requester       remoteresource.Requester
        owner           kmeta.OwnerRefable
        resolverName    string
        resolverPayload remoteresource.ResolverPayload
}

var _ remote.Resolver = &amp;Resolver{}

// NewResolver returns an implementation of remote.Resolver capable
// of performing asynchronous remote resolution.
func NewResolver(requester remoteresource.Requester, owner kmeta.OwnerRefable, resolverName string, resolverPayload remoteresource.ResolverPayload) remote.Resolver <span class="cov8" title="1">{
        return &amp;Resolver{
                requester:       requester,
                owner:           owner,
                resolverName:    resolverName,
                resolverPayload: resolverPayload,
        }
}</span>

// Get implements remote.Resolver.
func (resolver *Resolver) Get(ctx context.Context, _, _ string) (runtime.Object, *v1.RefSource, error) <span class="cov8" title="1">{
        resolverName := remoteresource.ResolverName(resolver.resolverName)
        req, err := buildRequest(resolver.resolverName, resolver.owner, &amp;resolver.resolverPayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error building request for remote resource: %w", err)
        }</span>
        <span class="cov8" title="1">resolved, err := resolver.requester.Submit(ctx, resolverName, req)
        return resolution.ResolvedRequest(resolved, err)</span>
}

// List implements remote.Resolver but is unused for remote resolution.
func (resolver *Resolver) List(_ context.Context) ([]remote.ResolvedObject, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func buildRequest(resolverName string, owner kmeta.OwnerRefable, resolverPayload *remoteresource.ResolverPayload) (*resolutionRequest, error) <span class="cov8" title="1">{
        var name string
        var namespace string
        var url string
        var params v1.Params
        if resolverPayload != nil </span><span class="cov8" title="1">{
                name = resolverPayload.Name
                namespace = resolverPayload.Namespace
                if resolverPayload.ResolutionSpec != nil </span><span class="cov8" title="1">{
                        params = resolverPayload.ResolutionSpec.Params
                        url = resolverPayload.ResolutionSpec.URL
                }</span>
        }
        <span class="cov8" title="1">rr := &amp;v1beta1.ResolutionRequestSpec{
                Params: params,
                URL:    url,
        }
        name, namespace, err := resource.GetNameAndNamespace(resolverName, owner, name, namespace, rr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resolverPayload.Name = name
        resolverPayload.Namespace = namespace
        req := &amp;resolutionRequest{
                Request: remoteresource.NewRequest(*resolverPayload),
                owner:   owner,
        }
        return req, nil</span>
}
</pre>
		
		<pre class="file" id="file472" style="display: none">/*
 Copyright 2024 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package bundle

import (
        "context"
        "errors"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/bundle"
        resolutionframework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/client/injection/kube/client"
)

const (
        // LabelValueBundleResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueBundleResolverType string = "bundles"

        // BundleResolverName is the name that the bundle resolver should be associated with.
        BundleResolverName = "bundleresolver"
)

var _ framework.Resolver = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from OCI bundles.
type Resolver struct {
        kubeClientSet kubernetes.Interface
}

// Initialize sets up any dependencies needed by the Resolver. None atm.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClientSet = client.Get(ctx)
        return nil
}</span>

// GetName returns a string name to refer to this Resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return BundleResolverName
}</span>

// GetConfigName returns the name of the bundle resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return bundle.ConfigMapName
}</span>

// GetSelector returns a map of labels to match requests to this Resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueBundleResolverType,
        }
}</span>

// Validate ensures reqolution request spec from a request are as expected.
func (r *Resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return bundle.ValidateParams(ctx, req.Params)
        }</span>
        // Remove this error once validate url has been implemented.
        <span class="cov0" title="0">return errors.New("cannot validate request. the Validate method has not been implemented.")</span>
}

// Resolve uses the given request spec resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (resolutionframework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return bundle.ResolveRequest(ctx, r.kubeClientSet, req)
        }</span>
        // Remove this error once resolution of url has been implemented.
        <span class="cov0" title="0">return nil, errors.New("the Resolve method has not been implemented.")</span>
}
</pre>
		
		<pre class="file" id="file473" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cluster

import (
        "context"
        "errors"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/cluster"
        resolutionframework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const (
        // LabelValueClusterResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueClusterResolverType string = "cluster"

        // ClusterResolverName is the name that the cluster resolver should be
        // associated with
        ClusterResolverName string = "Cluster"

        configMapName = "cluster-resolver-config"
)

var _ framework.Resolver = &amp;Resolver{}

// ResolverV2 implements a framework.Resolver that can fetch resources from other namespaces.
type Resolver struct {
        pipelineClientSet clientset.Interface
}

// Initialize performs any setup required by the cluster resolver.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.pipelineClientSet = pipelineclient.Get(ctx)
        return nil
}</span>

// GetName returns the string name that the cluster resolver should be
// associated with.
func (r *Resolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return ClusterResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the cluster resolver to process them.
func (r *Resolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                resolutioncommon.LabelKeyResolverType: LabelValueClusterResolverType,
        }
}</span>

// Validate returns an error if the given parameter map is not
// valid for a resource request targeting the cluster resolver.
func (r *Resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return cluster.ValidateParams(ctx, req.Params)
        }</span>
        // Remove this error once validate url has been implemented.
        <span class="cov0" title="0">return errors.New("cannot validate request. the Validate method has not been implemented.")</span>
}

// Resolve performs the work of fetching a resource from a namespace with the given
// resolution spec.
func (r *Resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (resolutionframework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return cluster.ResolveFromParams(ctx, req.Params, r.pipelineClientSet)
        }</span>
        // Remove this error once resolution of url has been implemented.
        <span class="cov0" title="0">return nil, errors.New("the Resolve method has not been implemented.")</span>
}

var _ resolutionframework.ConfigWatcher = &amp;Resolver{}

// GetConfigName returns the name of the cluster resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return configMapName
}</span>
</pre>
		
		<pre class="file" id="file474" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package framework

import (
        "context"
        "strings"

        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        rrinformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        framework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// ReconcilerModifier is a func that can access and modify a reconciler
// in the moments before a resolver is started. It allows for
// things like injecting a test clock.
type ReconcilerModifier = func(reconciler *Reconciler)

// NewController returns a knative controller for a Tekton Resolver.
// This sets up a lot of the boilerplate that individual resolvers
// shouldn't need to be concerned with since it's common to all of them.
func NewController(ctx context.Context, resolver Resolver, modifiers ...ReconcilerModifier) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        if err := framework.ValidateResolver(ctx, resolver.GetSelector(ctx)); err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                kubeclientset := kubeclient.Get(ctx)
                rrclientset := rrclient.Get(ctx)
                rrInformer := rrinformer.Get(ctx)

                if err := resolver.Initialize(ctx); err != nil </span><span class="cov0" title="0">{
                        panic(err.Error())</span>
                }

                <span class="cov8" title="1">r := &amp;Reconciler{
                        LeaderAwareFuncs:           framework.LeaderAwareFuncs(rrInformer.Lister()),
                        kubeClientSet:              kubeclientset,
                        resolutionRequestLister:    rrInformer.Lister(),
                        resolutionRequestClientSet: rrclientset,
                        resolver:                   resolver,
                }

                watchConfigChanges(ctx, r, cmw)

                // TODO(sbwsg): Do better sanitize.
                resolverName := resolver.GetName(ctx)
                resolverName = strings.ReplaceAll(resolverName, "/", "")
                resolverName = strings.ReplaceAll(resolverName, " ", "")

                applyModifiersAndDefaults(ctx, r, modifiers)

                impl := controller.NewContext(ctx, r, controller.ControllerOptions{
                        WorkQueueName: "TektonResolverFramework." + resolverName,
                        Logger:        logger,
                })

                _, err := rrInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: framework.FilterResolutionRequestsBySelector(resolver.GetSelector(ctx)),
                        Handler: cache.ResourceEventHandlerFuncs{
                                AddFunc: impl.Enqueue,
                                UpdateFunc: func(oldObj, newObj interface{}) </span><span class="cov0" title="0">{
                                        impl.Enqueue(newObj)
                                }</span>,
                                // TODO(sbwsg): should we deliver delete events
                                // to the resolver?
                                // DeleteFunc: impl.Enqueue,
                        },
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ResolutionRequest informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}

// watchConfigChanges binds a framework.Resolver to updates on its
// configmap, using knative's configmap helpers. This is only done if
// the resolver implements the framework.ConfigWatcher interface.
func watchConfigChanges(ctx context.Context, reconciler *Reconciler, cmw configmap.Watcher) <span class="cov8" title="1">{
        if configWatcher, ok := reconciler.resolver.(framework.ConfigWatcher); ok </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                resolverConfigName := configWatcher.GetConfigName(ctx)
                if resolverConfigName == "" </span><span class="cov0" title="0">{
                        panic("resolver returned empty config name")</span>
                }
                <span class="cov0" title="0">reconciler.configStore = framework.NewConfigStore(resolverConfigName, logger)
                reconciler.configStore.WatchConfigs(cmw)</span>
        }
}

// applyModifiersAndDefaults applies the given modifiers to
// a reconciler and, after doing so, sets any default values for things
// that weren't set by a modifier.
func applyModifiersAndDefaults(ctx context.Context, r *Reconciler, modifiers []ReconcilerModifier) <span class="cov8" title="1">{
        for _, mod := range modifiers </span><span class="cov8" title="1">{
                mod(r)
        }</span>

        <span class="cov8" title="1">if r.Clock == nil </span><span class="cov0" title="0">{
                r.Clock = clock.RealClock{}
        }</span>
}
</pre>
		
		<pre class="file" id="file475" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package framework

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const FakeUrl string = "fake://url"

var _ Resolver = &amp;FakeResolver{}

// FakeResolver implements a framework.Resolver that can fetch pre-configured strings based on a parameter value, or return
// resolution attempts with a configured error.
type FakeResolver framework.FakeResolver

// Initialize performs any setup required by the fake resolver.
func (r *FakeResolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        if r.ForParam == nil </span><span class="cov8" title="1">{
                r.ForParam = make(map[string]*framework.FakeResolvedResource)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetName returns the string name that the fake resolver should be
// associated with.
func (r *FakeResolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return framework.FakeResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the fake resolver to process them.
func (r *FakeResolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                resolutioncommon.LabelKeyResolverType: framework.LabelValueFakeResolverType,
        }
}</span>

// Validate returns an error if the given parameter map is not
// valid for a resource request targeting the fake resolver.
func (r *FakeResolver) Validate(_ context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return framework.ValidateParams(req.Params)
        }</span>
        <span class="cov8" title="1">if req.URL != FakeUrl </span><span class="cov8" title="1">{
                return fmt.Errorf("Wrong url. Expected: %s,  Got: %s", FakeUrl, req.URL)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Resolve performs the work of fetching a file from the fake resolver given a map of
// parameters.
func (r *FakeResolver) Resolve(_ context.Context, req *v1beta1.ResolutionRequestSpec) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return framework.Resolve(req.Params, r.ForParam)
        }</span>
        <span class="cov8" title="1">frr, ok := r.ForParam[req.URL]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("couldn't find resource for url %s", req.URL)
        }</span>
        <span class="cov8" title="1">return frr, nil</span>
}

var _ framework.TimedResolution = &amp;FakeResolver{}

// GetResolutionTimeout returns the configured timeout for the reconciler, or the default time.Duration if not configured.
func (r *FakeResolver) GetResolutionTimeout(ctx context.Context, defaultTimeout time.Duration, params map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        return framework.GetResolutionTimeout(r.Timeout, defaultTimeout), nil
}</span>
</pre>
		
		<pre class="file" id="file476" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package framework

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        rrv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/reconciler"
)

// defaultMaximumResolutionDuration is the maximum amount of time
// resolution may take.

// defaultMaximumResolutionDuration is the max time that a call to
// Resolve() may take. It can be overridden by a resolver implementing
// the framework.TimedResolution interface.
const defaultMaximumResolutionDuration = time.Minute

// statusDataPatch is the json structure that will be PATCHed into
// a ResolutionRequest with its data and annotations once successfully
// resolved.
type statusDataPatch struct {
        Annotations map[string]string             `json:"annotations"`
        Data        string                        `json:"data"`
        Source      *pipelinev1beta1.ConfigSource `json:"source"`
        RefSource   *pipelinev1.RefSource         `json:"refSource"`
}

// Reconciler handles ResolutionRequest objects, performs functionality
// common to all resolvers and delegates resolver-specific actions
// to its embedded type-specific Resolver object.
type Reconciler struct {
        // Implements reconciler.LeaderAware
        reconciler.LeaderAwareFuncs

        // Clock is used by the reconciler to track the passage of time
        // and can be overridden for tests.
        Clock clock.PassiveClock

        resolver                   Resolver
        kubeClientSet              kubernetes.Interface
        resolutionRequestLister    rrv1beta1.ResolutionRequestLister
        resolutionRequestClientSet rrclient.Interface

        configStore *framework.ConfigStore
}

var _ reconciler.LeaderAware = &amp;Reconciler{}

// Reconcile receives the string key of a ResolutionRequest object, looks
// it up, checks it for common errors, and then delegates
// resolver-specific functionality to the reconciler's embedded
// type-specific resolver. Any errors that occur during validation or
// resolution are handled by updating or failing the ResolutionRequest.
func (r *Reconciler) Reconcile(ctx context.Context, key string) error <span class="cov8" title="1">{
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;resolutioncommon.InvalidResourceKeyError{Key: key, Original: err}
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">rr, err := r.resolutionRequestLister.ResolutionRequests(namespace).Get(name)
        if err != nil </span><span class="cov0" title="0">{
                err := &amp;resolutioncommon.GetResourceError{ResolverName: "resolutionrequest", Key: key, Original: err}
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if rr.IsDone() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Inject request-scoped information into the context, such as
        // the namespace that the request originates from and the
        // configuration from the configmap this resolver is watching.
        <span class="cov8" title="1">ctx = resolutioncommon.InjectRequestNamespace(ctx, namespace)
        ctx = resolutioncommon.InjectRequestName(ctx, name)
        if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        <span class="cov8" title="1">return r.resolve(ctx, key, rr)</span>
}

func (r *Reconciler) resolve(ctx context.Context, key string, rr *v1beta1.ResolutionRequest) error <span class="cov8" title="1">{
        errChan := make(chan error)
        resourceChan := make(chan framework.ResolvedResource)

        paramsMap := make(map[string]string)
        for _, p := range rr.Spec.Params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.StringVal
        }</span>

        <span class="cov8" title="1">timeoutDuration := defaultMaximumResolutionDuration
        if timed, ok := r.resolver.(framework.TimedResolution); ok </span><span class="cov8" title="1">{
                var err error
                timeoutDuration, err = timed.GetResolutionTimeout(ctx, defaultMaximumResolutionDuration, paramsMap)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // A new context is created for resolution so that timeouts can
        // be enforced without affecting other uses of ctx (e.g. sending
        // Updates to ResolutionRequest objects).
        <span class="cov8" title="1">resolutionCtx, cancelFn := context.WithTimeout(ctx, timeoutDuration)
        defer cancelFn()

        go func() </span><span class="cov8" title="1">{
                validationError := r.resolver.Validate(resolutionCtx, &amp;rr.Spec)
                if validationError != nil </span><span class="cov8" title="1">{
                        errChan &lt;- &amp;resolutioncommon.InvalidRequestError{
                                ResolutionRequestKey: key,
                                Message:              validationError.Error(),
                        }
                        return
                }</span>
                <span class="cov8" title="1">resource, resolveErr := r.resolver.Resolve(resolutionCtx, &amp;rr.Spec)
                if resolveErr != nil </span><span class="cov8" title="1">{
                        errChan &lt;- &amp;resolutioncommon.GetResourceError{
                                ResolverName: r.resolver.GetName(resolutionCtx),
                                Key:          key,
                                Original:     resolveErr,
                        }
                        return
                }</span>
                <span class="cov8" title="1">resourceChan &lt;- resource</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-errChan:<span class="cov8" title="1">
                if err != nil </span><span class="cov8" title="1">{
                        return r.OnError(ctx, rr, err)
                }</span>
        case &lt;-resolutionCtx.Done():<span class="cov8" title="1">
                if err := resolutionCtx.Err(); err != nil </span><span class="cov8" title="1">{
                        return r.OnError(ctx, rr, err)
                }</span>
        case resource := &lt;-resourceChan:<span class="cov8" title="1">
                return r.writeResolvedData(ctx, rr, resource)</span>
        }

        <span class="cov0" title="0">return errors.New("unknown error")</span>
}

// OnError is used to handle any situation where a ResolutionRequest has
// reached a terminal situation that cannot be recovered from.
func (r *Reconciler) OnError(ctx context.Context, rr *v1beta1.ResolutionRequest, err error) error <span class="cov8" title="1">{
        if resolutioncommon.IsErrTransient(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rr == nil </span><span class="cov0" title="0">{
                return controller.NewPermanentError(err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                _ = r.MarkFailed(ctx, rr, err)
                return controller.NewPermanentError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MarkFailed updates a ResolutionRequest as having failed. It returns
// errors that occur during the update process or nil if the update
// appeared to succeed.
func (r *Reconciler) MarkFailed(ctx context.Context, rr *v1beta1.ResolutionRequest, resolutionErr error) error <span class="cov8" title="1">{
        key := fmt.Sprintf("%s/%s", rr.Namespace, rr.Name)
        reason, resolutionErr := resolutioncommon.ReasonError(resolutionErr)
        latestGeneration, err := r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Get(ctx, rr.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("error getting latest generation of resolutionrequest %q: %v", key, err)
                return err
        }</span>
        <span class="cov8" title="1">if latestGeneration.IsDone() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">latestGeneration.Status.MarkFailed(reason, resolutionErr.Error())
        _, err = r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).UpdateStatus(ctx, latestGeneration, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("error marking resolutionrequest %q as failed: %v", key, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) writeResolvedData(ctx context.Context, rr *v1beta1.ResolutionRequest, resource framework.ResolvedResource) error <span class="cov8" title="1">{
        encodedData := base64.StdEncoding.Strict().EncodeToString(resource.Data())
        patchBytes, err := json.Marshal(map[string]statusDataPatch{
                "status": {
                        Data:        encodedData,
                        Annotations: resource.Annotations(),
                        RefSource:   resource.RefSource(),
                        Source:      (*pipelinev1beta1.ConfigSource)(resource.RefSource()),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("writeResolvedData error serializing resource request patch for resolution request %s:%s: %s", rr.Namespace, rr.Name, err.Error())
                return r.OnError(ctx, rr, &amp;resolutioncommon.UpdatingRequestError{
                        ResolutionRequestKey: fmt.Sprintf("%s/%s", rr.Namespace, rr.Name),
                        Original:             fmt.Errorf("error serializing resource request patch: %w", err),
                })
        }</span>
        <span class="cov8" title="1">_, err = r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Patch(ctx, rr.Name, types.MergePatchType, patchBytes, metav1.PatchOptions{}, "status")
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("writeResolvedData error patching resolution request %s:%s: %s", rr.Namespace, rr.Name, err.Error())
                return r.OnError(ctx, rr, &amp;resolutioncommon.UpdatingRequestError{
                        ResolutionRequestKey: fmt.Sprintf("%s/%s", rr.Namespace, rr.Name),
                        Original:             err,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file477" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package testing

import (
        "context"
        "encoding/base64"
        "strings"
        "testing"
        "time"

        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/test"
        "github.com/tektoncd/pipeline/test/diff"
        "github.com/tektoncd/pipeline/test/names"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        testclock "k8s.io/utils/clock/testing"
        "knative.dev/pkg/apis"
        cminformer "knative.dev/pkg/configmap/informer"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
)

var (
        now                      = time.Date(2022, time.January, 1, 0, 0, 0, 0, time.UTC)
        testClock                = testclock.NewFakePassiveClock(now)
        ignoreLastTransitionTime = cmpopts.IgnoreFields(apis.Condition{}, "LastTransitionTime.Inner.Time")
)

// ResolverReconcileTestModifier is a function thaat will be invoked after the test assets and controller have been created
type ResolverReconcileTestModifier = func(resolver framework.Resolver, testAssets test.Assets)

// RunResolverReconcileTest takes data to seed clients and informers, a Resolver, a ResolutionRequest, and the expected
// ResolutionRequestStatus and error, both of which can be nil. It instantiates a controller for that resolver and
// reconciles the given request. It then checks for the expected error, if any, and compares the resulting status with
// the expected status.
func RunResolverReconcileTest(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, request *v1beta1.ResolutionRequest,
        expectedStatus *v1beta1.ResolutionRequestStatus, expectedErr error, resolverModifiers ...ResolverReconcileTestModifier) <span class="cov0" title="0">{
        t.Helper()

        testAssets, cancel := GetResolverFrameworkController(ctx, t, d, resolver, setClockOnReconciler)
        defer cancel()

        for _, rm := range resolverModifiers </span><span class="cov0" title="0">{
                rm(resolver, testAssets)
        }</span>

        <span class="cov0" title="0">err := testAssets.Controller.Reconciler.Reconcile(testAssets.Ctx, getRequestName(request)) //nolint
        if expectedErr != nil </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        t.Fatalf("expected to get error: `%v`, but got nothing", expectedErr)
                }</span>
                <span class="cov0" title="0">if expectedErr.Error() != err.Error() </span><span class="cov0" title="0">{
                        t.Fatalf("expected to get error `%v`, but got `%v`", expectedErr, err)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                if ok, _ := controller.IsRequeueKey(err); !ok </span><span class="cov0" title="0">{
                        t.Fatalf("did not expect an error, but got `%v`", err)
                }</span>
        }

        <span class="cov0" title="0">c := testAssets.Clients.ResolutionRequests.ResolutionV1beta1()
        reconciledRR, err := c.ResolutionRequests(request.Namespace).Get(testAssets.Ctx, request.Name, metav1.GetOptions{}) //nolint
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("getting updated ResolutionRequest: %v", err)
        }</span>
        <span class="cov0" title="0">if expectedStatus != nil </span><span class="cov0" title="0">{
                if d := cmp.Diff(*expectedStatus, reconciledRR.Status, ignoreLastTransitionTime); d != "" </span><span class="cov0" title="0">{
                        t.Errorf("ResolutionRequest status doesn't match %s", diff.PrintWantGot(d))
                        if expectedStatus.Data != "" &amp;&amp; expectedStatus.Data != reconciledRR.Status.Data </span><span class="cov0" title="0">{
                                decodedExpectedData, err := base64.StdEncoding.Strict().DecodeString(expectedStatus.Data)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Errorf("couldn't decode expected data: %v", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">decodedGotData, err := base64.StdEncoding.Strict().DecodeString(reconciledRR.Status.Data)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Errorf("couldn't decode reconciled data: %v", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">if d := cmp.Diff(decodedExpectedData, decodedGotData); d != "" </span><span class="cov0" title="0">{
                                        t.Errorf("decoded data did not match expected: %s", diff.PrintWantGot(d))
                                }</span>
                        }
                }
        }
}

// GetResolverFrameworkController returns an instance of the resolver framework controller/reconciler using the given resolver,
// seeded with d, where d represents the state of the system (existing resources) needed for the test.
func GetResolverFrameworkController(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, modifiers ...framework.ReconcilerModifier) (test.Assets, func()) <span class="cov0" title="0">{
        t.Helper()
        names.TestingSeed()
        return initializeResolverFrameworkControllerAssets(ctx, t, d, resolver, modifiers...)
}</span>

func initializeResolverFrameworkControllerAssets(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, modifiers ...framework.ReconcilerModifier) (test.Assets, func()) <span class="cov0" title="0">{
        t.Helper()
        ctx, cancel := context.WithCancel(ctx)
        ensureConfigurationConfigMapsExist(&amp;d)
        c, informers := test.SeedTestData(t, ctx, d)
        configMapWatcher := cminformer.NewInformedWatcher(c.Kube, resolverconfig.ResolversNamespace(system.Namespace()))
        ctl := framework.NewController(ctx, resolver, modifiers...)(ctx, configMapWatcher)
        if err := configMapWatcher.Start(ctx.Done()); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error starting configmap watcher: %v", err)
        }</span>

        <span class="cov0" title="0">if la, ok := ctl.Reconciler.(pkgreconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                _ = la.Promote(pkgreconciler.UniversalBucket(), func(pkgreconciler.Bucket, types.NamespacedName) </span>{<span class="cov0" title="0">}</span>)
        }

        <span class="cov0" title="0">return test.Assets{
                Logger:     logging.FromContext(ctx),
                Controller: ctl,
                Clients:    c,
                Informers:  informers,
                Recorder:   controller.GetEventRecorder(ctx).(*record.FakeRecorder),
                Ctx:        ctx,
        }, cancel</span>
}

func getRequestName(rr *v1beta1.ResolutionRequest) string <span class="cov0" title="0">{
        return strings.Join([]string{rr.Namespace, rr.Name}, "/")
}</span>

func setClockOnReconciler(r *framework.Reconciler) <span class="cov0" title="0">{
        if r.Clock == nil </span><span class="cov0" title="0">{
                r.Clock = testClock
        }</span>
}

func ensureConfigurationConfigMapsExist(d *test.Data) <span class="cov0" title="0">{
        var featureFlagsExists bool
        for _, cm := range d.ConfigMaps </span><span class="cov0" title="0">{
                if cm.Name == resolverconfig.GetFeatureFlagsConfigName() </span><span class="cov0" title="0">{
                        featureFlagsExists = true
                }</span>
        }
        <span class="cov0" title="0">if !featureFlagsExists </span><span class="cov0" title="0">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      resolverconfig.GetFeatureFlagsConfigName(),
                                Namespace: resolverconfig.ResolversNamespace(system.Namespace()),
                        },
                        Data: map[string]string{},
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file478" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
        "context"
        "errors"
        "time"

        "github.com/jenkins-x/go-scm/scm"
        "github.com/jenkins-x/go-scm/scm/factory"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        resolutionframework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/git"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/util/cache"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

const (
        disabledError = "cannot handle resolution request, enable-git-resolver feature flag not true"

        // labelValueGitResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        labelValueGitResolverType string = "git"

        // gitResolverName is the name that the git resolver should be
        // associated with
        gitResolverName string = "Git"

        // ConfigMapName is the git resolver's config map
        ConfigMapName = "git-resolver-config"

        // cacheSize is the size of the LRU secrets cache
        cacheSize = 1024
        // ttl is the time to live for a cache entry
        ttl = 5 * time.Minute
)

var _ framework.Resolver = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from git.
type Resolver struct {
        kubeClient kubernetes.Interface
        logger     *zap.SugaredLogger
        cache      *cache.LRUExpireCache
        ttl        time.Duration

        // Used in testing
        clientFunc func(string, string, string, ...factory.ClientOptionFunc) (*scm.Client, error)
}

// Initialize performs any setup required by the gitresolver.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClient = kubeclient.Get(ctx)
        r.logger = logging.FromContext(ctx)
        r.cache = cache.NewLRUExpireCache(cacheSize)
        r.ttl = ttl
        if r.clientFunc == nil </span><span class="cov0" title="0">{
                r.clientFunc = factory.NewClient
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetName returns the string name that the gitresolver should be
// associated with.
func (r *Resolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return gitResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the gitresolver to process them.
func (r *Resolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                resolutioncommon.LabelKeyResolverType: labelValueGitResolverType,
        }
}</span>

// ValidateParams returns an error if the given parameter map is not
// valid for a resource request targeting the gitresolver.
func (r *Resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return git.ValidateParams(ctx, req.Params)
        }</span>
        // Remove this error once validate url has been implemented.
        <span class="cov0" title="0">return errors.New("cannot validate request. the Validate method has not been implemented.")</span>
}

// Resolve performs the work of fetching a file from git given a map of
// parameters.
func (r *Resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (resolutionframework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                origParams := req.Params

                if git.IsDisabled(ctx) </span><span class="cov8" title="1">{
                        return nil, errors.New(disabledError)
                }</span>

                <span class="cov8" title="1">params, err := git.PopulateDefaultParams(ctx, origParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">g := &amp;git.GitResolver{
                        KubeClient: r.kubeClient,
                        Logger:     r.logger,
                        Cache:      r.cache,
                        TTL:        r.ttl,
                        Params:     params,
                }

                if params[git.UrlParam] != "" </span><span class="cov8" title="1">{
                        return g.ResolveGitClone(ctx)
                }</span>

                <span class="cov8" title="1">return g.ResolveAPIGit(ctx, r.clientFunc)</span>
        }
        // Remove this error once resolution of url has been implemented.
        <span class="cov0" title="0">return nil, errors.New("the Resolve method has not been implemented.")</span>
}

var _ resolutionframework.ConfigWatcher = &amp;Resolver{}

// GetConfigName returns the name of the git resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return ConfigMapName
}</span>

var _ resolutionframework.TimedResolution = &amp;Resolver{}

// GetResolutionTimeout returns a time.Duration for the amount of time a
// single git fetch may take. This can be configured with the
// fetch-timeout field in the git-resolver-config configmap.
func (r *Resolver) GetResolutionTimeout(ctx context.Context, defaultTimeout time.Duration, params map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        conf, err := git.GetScmConfigForParamConfigKey(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return time.Duration(0), err
        }</span>
        <span class="cov8" title="1">if timeoutString := conf.Timeout; timeoutString != "" </span><span class="cov8" title="1">{
                timeout, err := time.ParseDuration(timeoutString)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Duration(0), err
                }</span>
                <span class="cov8" title="1">return timeout, nil</span>
        }
        <span class="cov8" title="1">return defaultTimeout, nil</span>
}
</pre>
		
		<pre class="file" id="file479" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package http

import (
        "context"
        "errors"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        resolutionframework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/http"
        "go.uber.org/zap"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

const (
        // LabelValueHttpResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueHttpResolverType string = "http"

        disabledError = "cannot handle resolution request, enable-http-resolver feature flag not true"

        // httpResolverName The name of the resolver
        httpResolverName = "Http"

        // configMapName is the http resolver's config map
        configMapName = "http-resolver-config"

        // default Timeout value when fetching http resources in seconds
        defaultHttpTimeoutValue = "1m"

        // default key in the HTTP password secret
        defaultBasicAuthSecretKey = "password"
)

var _ framework.Resolver = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from an HTTP URL
type Resolver struct {
        kubeClient kubernetes.Interface
        logger     *zap.SugaredLogger
}

func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClient = kubeclient.Get(ctx)
        r.logger = logging.FromContext(ctx)
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return httpResolverName
}</span>

// GetConfigName returns the name of the http resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return configMapName
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueHttpResolverType,
        }
}</span>

// Validate ensures parameters from a request are as expected.
func (r *Resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return http.ValidateParams(ctx, req.Params)
        }</span>
        // Remove this error once validate url has been implemented.
        <span class="cov0" title="0">return errors.New("cannot validate request. the Validate method has not been implemented.")</span>
}

// Resolve uses the given params to resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (resolutionframework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                oParams := req.Params
                if http.IsDisabled(ctx) </span><span class="cov8" title="1">{
                        return nil, errors.New(disabledError)
                }</span>

                <span class="cov8" title="1">params, err := http.PopulateDefaultParams(ctx, oParams)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return http.FetchHttpResource(ctx, params, r.kubeClient, r.logger)</span>
        }
        // Remove this error once resolution of url has been implemented.
        <span class="cov0" title="0">return nil, errors.New("the Resolve method has not been implemented.")</span>
}
</pre>
		
		<pre class="file" id="file480" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package hub

import (
        "context"
        "errors"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        resolutionframework "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/hub"
)

const (
        // LabelValueHubResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueHubResolverType string = "hub"

        // ArtifactHubType is the value to use setting the type field to artifact
        ArtifactHubType string = "artifact"

        // TektonHubType is the value to use setting the type field to tekton
        TektonHubType string = "tekton"
)

var _ framework.Resolver = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from OCI bundles.
type Resolver struct {
        // TektonHubURL is the URL for hub resolver with type tekton
        TektonHubURL string
        // ArtifactHubURL is the URL for hub resolver with type artifact
        ArtifactHubURL string
}

// Initialize sets up any dependencies needed by the resolver. None atm.
func (r *Resolver) Initialize(context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov0" title="0">{
        return "Hub"
}</span>

// GetConfigName returns the name of the bundle resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov0" title="0">{
        return "hubresolver-config"
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueHubResolverType,
        }
}</span>

// Validate ensures parameters from a request are as expected.
func (r *Resolver) Validate(ctx context.Context, req *v1beta1.ResolutionRequestSpec) error <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return hub.ValidateParams(ctx, req.Params, r.TektonHubURL)
        }</span>
        // Remove this error once validate url has been implemented.
        <span class="cov0" title="0">return errors.New("cannot validate request. the Validate method has not been implemented.")</span>
}

// Resolve uses the given params to resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, req *v1beta1.ResolutionRequestSpec) (resolutionframework.ResolvedResource, error) <span class="cov8" title="1">{
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                return hub.Resolve(ctx, req.Params, r.TektonHubURL, r.ArtifactHubURL)
        }</span>
        // Remove this error once resolution of url has been implemented.
        <span class="cov0" title="0">return nil, errors.New("the Resolve method has not been implemented.")</span>
}
</pre>
		
		<pre class="file" id="file481" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "context"
        "errors"

        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        rrlisters "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        resolutionresource "github.com/tektoncd/pipeline/pkg/resolution/resource"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// CRDRequester implements the Requester interface using
// ResolutionRequest CRDs.
type CRDRequester struct {
        clientset rrclient.Interface
        lister    rrlisters.ResolutionRequestLister
}

// NewCRDRequester returns an implementation of Requester that uses
// ResolutionRequest CRD objects to mediate between the caller who wants a
// resource (e.g. Tekton Pipelines) and the responder who can fetch
// it (e.g. the gitresolver)
func NewCRDRequester(clientset rrclient.Interface, lister rrlisters.ResolutionRequestLister) *CRDRequester <span class="cov8" title="1">{
        return &amp;CRDRequester{clientset, lister}
}</span>

var _ Requester = &amp;CRDRequester{}

// Submit constructs a ResolutionRequest object and submits it to the
// kubernetes cluster, returning any errors experienced while doing so.
// If ResolutionRequest is succeeded then it returns the resolved data.
func (r *CRDRequester) Submit(ctx context.Context, resolver ResolverName, req Request) (ResolvedResource, error) <span class="cov8" title="1">{
        rr, _ := r.lister.ResolutionRequests(req.ResolverPayload().Namespace).Get(req.ResolverPayload().Name)
        if rr == nil </span><span class="cov8" title="1">{
                if err := r.createResolutionRequest(ctx, resolver, req); err != nil &amp;&amp;
                        // When the request reconciles frequently, the creation may fail
                        // because the list informer cache is not updated.
                        // If the request already exists then we can assume that is in progress.
                        // The next reconcile will handle it based on the actual situation.
                        !apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, resolutioncommon.ErrRequestInProgress</span>
        }

        <span class="cov8" title="1">if rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown() </span><span class="cov8" title="1">{
                // TODO(sbwsg): This should be where an existing
                // resource is given an additional owner reference so
                // that it doesn't get deleted until the caller is done
                // with it. Use appendOwnerReference and then submit
                // update to ResolutionRequest.
                return nil, resolutioncommon.ErrRequestInProgress
        }</span>

        <span class="cov8" title="1">if rr.Status.GetCondition(apis.ConditionSucceeded).IsTrue() </span><span class="cov8" title="1">{
                return resolutionresource.CrdIntoResource(rr), nil
        }</span>

        <span class="cov8" title="1">message := rr.Status.GetCondition(apis.ConditionSucceeded).GetMessage()
        err := resolutioncommon.NewError(resolutioncommon.ReasonResolutionFailed, errors.New(message))
        return nil, err</span>
}

func (r *CRDRequester) createResolutionRequest(ctx context.Context, resolver ResolverName, req Request) error <span class="cov8" title="1">{
        var owner metav1.OwnerReference
        if ownedReq, ok := req.(OwnedRequest); ok </span><span class="cov8" title="1">{
                owner = ownedReq.OwnerRef()
        }</span>
        <span class="cov8" title="1">rr := resolutionresource.CreateResolutionRequest(ctx, resolver, req.ResolverPayload().Name, req.ResolverPayload().Namespace, req.ResolverPayload().ResolutionSpec.Params, owner)
        rr.Spec.URL = req.ResolverPayload().ResolutionSpec.URL
        _, err := r.clientset.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Create(ctx, rr, metav1.CreateOptions{})
        return err</span>
}
</pre>
		
		<pre class="file" id="file482" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
)

type BasicRequest struct {
        resolverPayload ResolverPayload
}

var _ Request = &amp;BasicRequest{}

// NewRequest returns an instance of a BasicRequestV2 with the given resolverPayload.
func NewRequest(resolverPayload ResolverPayload) Request <span class="cov8" title="1">{
        return &amp;BasicRequest{resolverPayload}
}</span>

var _ Request = &amp;BasicRequest{}

// Params are the map of parameters associated with this request
func (req *BasicRequest) ResolverPayload() ResolverPayload <span class="cov8" title="1">{
        return req.resolverPayload
}</span>

// Requester is the interface implemented by a type that knows how to
// submit requests for remote resources.
type Requester interface {
        // Submit accepts the name of a resolver to submit a request to
        // along with the request itself.
        Submit(ctx context.Context, name ResolverName, req Request) (ResolvedResource, error)
}

// Request is implemented by any type that represents a single request
// for a remote resource. Implementing this interface gives the underlying
// type an opportunity to control properties such as whether the name of
// a request has particular properties, whether the request should be made
// to a specific namespace, and precisely which parameters should be included.
type Request interface {
        ResolverPayload() ResolverPayload
}

// ResolverPayload is the struct which holds the payload to create
// the Resolution Request CRD.
type ResolverPayload struct {
        Name           string
        Namespace      string
        ResolutionSpec *v1beta1.ResolutionRequestSpec
}

// ResolutionRequester is the interface implemented by a type that knows how to
// submit requests for remote resources.
type ResolutionRequester interface {
        // SubmitResolutionRequest accepts the name of a resolver to submit a request to
        // along with the request itself.
        SubmitResolutionRequest(ctx context.Context, name ResolverName, req RequestRemoteResource) (ResolvedResource, error)
}

// RequestRemoteResource is implemented by any type that represents a single request
// for a remote resource. Implementing this interface gives the underlying
// type an opportunity to control properties such as whether the name of
// a request has particular properties, whether the request should be made
// to a specific namespace, and precisely which parameters should be included.
type RequestRemoteResource interface {
        ResolverPayload() ResolverPayload
}
</pre>
		
		<pre class="file" id="file483" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import "context"

// contextKey is a unique type to map common request-scoped
// context information.
type contextKey struct{}

// requestNamespaceContextKey is the key stored in a context alongside
// the string namespace of a resolution request.
var requestNamespaceContextKey = contextKey{}

// InjectRequestNamespace returns a new context with a request-scoped
// namespace. This value may only be set once per request; subsequent
// calls with the same context or a derived context will be ignored.
func InjectRequestNamespace(ctx context.Context, namespace string) context.Context <span class="cov8" title="1">{
        // Once set don't allow the value to be overwritten.
        if val := ctx.Value(requestNamespaceContextKey); val != nil </span><span class="cov8" title="1">{
                return ctx
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, requestNamespaceContextKey, namespace)</span>
}

// RequestNamespace returns the namespace of the resolution request
// currently being processed or an empty string if the request somehow
// does not originate from a namespaced location.
func RequestNamespace(ctx context.Context) string <span class="cov8" title="1">{
        if val := ctx.Value(requestNamespaceContextKey); val != nil </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// requestNameContextKey is the key stored in a context alongside
// the string name of a resolution request.
var requestNameContextKey = contextKey{}

// InjectRequestName returns a new context with a request-scoped
// name. This value may only be set once per request; subsequent
// calls with the same context or a derived context will be ignored.
func InjectRequestName(ctx context.Context, name string) context.Context <span class="cov8" title="1">{
        // Once set don't allow the value to be overwritten.
        if val := ctx.Value(requestNameContextKey); val != nil </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, requestNameContextKey, name)</span>
}

// RequestName returns the name of the resolution request
// currently being processed or an empty string if none were registered.
func RequestName(ctx context.Context) string <span class="cov8" title="1">{
        if val := ctx.Value(requestNameContextKey); val != nil </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file484" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "strings"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
)

// This error is defined in etcd at
// https://github.com/etcd-io/etcd/blob/5b226e0abf4100253c94bb71f47d6815877ed5a2/server/etcdserver/errors.go#L30
// TODO: If/when https://github.com/kubernetes/kubernetes/issues/106491 is addressed,
// we should stop relying on a hardcoded string.
var errEtcdLeaderChange = "etcdserver: leader changed"

// Error embeds both a short machine-readable string reason for resolution
// problems alongside the original error generated during the resolution flow.
type Error struct {
        Reason   string
        Original error
}

var _ error = &amp;Error{}

// Error returns the original error's message. This is intended to meet the error.Error interface.
func (e *Error) Error() string <span class="cov8" title="1">{
        return e.Original.Error()
}</span>

// Unwrap returns the original error without the Reason annotation. This is
// intended to support usage of errors.Is and errors.As with Errors.
func (e *Error) Unwrap() error <span class="cov8" title="1">{
        return e.Original
}</span>

// NewError returns a Error with the given reason and underlying
// original error.
func NewError(reason string, err error) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Reason:   reason,
                Original: err,
        }
}</span>

// ErrRequestInProgress is a sentinel value to indicate that
// a resource request is still in progress.
var ErrRequestInProgress = NewError("RequestInProgress", errors.New("Resource request is still in-progress"))

// InvalidResourceKeyError indicates that a string key given to the
// Reconcile function does not match the expected "name" or "namespace/name"
// format.
type InvalidResourceKeyError struct {
        Key      string
        Original error
}

var _ error = &amp;InvalidResourceKeyError{}

func (e *InvalidResourceKeyError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid resource key %q: %v", e.Key, e.Original)
}</span>

func (e *InvalidResourceKeyError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// InvalidRequestError is an error received when a
// resource request is badly formed for some reason: either the
// parameters don't match the resolver's expectations or there is some
// other structural issue.
type InvalidRequestError struct {
        ResolutionRequestKey string
        Message              string
}

var _ error = &amp;InvalidRequestError{}

func (e *InvalidRequestError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid resource request %q: %s", e.ResolutionRequestKey, e.Message)
}</span>

// GetResourceError is an error received during what should
// otherwise have been a successful resource request.
type GetResourceError struct {
        ResolverName string
        Key          string
        Original     error
}

var _ error = &amp;GetResourceError{}

func (e *GetResourceError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error getting %q %q: %v", e.ResolverName, e.Key, e.Original)
}</span>

func (e *GetResourceError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// UpdatingRequestError is an error during any part of the update
// process for a ResolutionRequest, e.g. when attempting to patch the
// ResolutionRequest with resolved data.
type UpdatingRequestError struct {
        ResolutionRequestKey string
        Original             error
}

var _ error = &amp;UpdatingRequestError{}

func (e *UpdatingRequestError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error updating resource request %q with data: %v", e.ResolutionRequestKey, e.Original)
}</span>

func (e *UpdatingRequestError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// ReasonError extracts the reason and underlying error
// embedded in a given error or returns some sane defaults
// if the error isn't a common.Error.
func ReasonError(err error) (string, error) <span class="cov0" title="0">{
        reason := ReasonResolutionFailed
        resolutionError := err

        var e *Error
        if errors.As(err, &amp;e) </span><span class="cov0" title="0">{
                reason = e.Reason
                resolutionError = e.Unwrap()
        }</span>

        <span class="cov0" title="0">return reason, resolutionError</span>
}

// IsErrTransient returns true if an error returned by GetTask/GetStepAction is retryable.
func IsErrTransient(err error) bool <span class="cov0" title="0">{
        switch </span>{
        case apierrors.IsConflict(err), apierrors.IsServerTimeout(err), apierrors.IsTimeout(err), apierrors.IsTooManyRequests(err):<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return slices.ContainsFunc([]string{errEtcdLeaderChange, context.DeadlineExceeded.Error()}, func(s string) bool </span><span class="cov0" title="0">{
                        return strings.Contains(err.Error(), s)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file485" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bundle

import (
        "archive/tar"
        "context"
        "errors"
        "fmt"
        "io"
        "strings"

        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const (
        // MaximumBundleObjects defines the maximum number of objects in a bundle
        MaximumBundleObjects = 20
)

// RequestOptions are the options used to request a resource from
// a remote bundle.
type RequestOptions struct {
        ServiceAccount  string
        ImagePullSecret string
        Bundle          string
        EntryName       string
        Kind            string
}

// ResolvedResource wraps the content of a matched entry in a bundle.
type ResolvedResource struct {
        data        []byte
        annotations map[string]string
        source      *pipelinev1.RefSource
}

var _ framework.ResolvedResource = &amp;ResolvedResource{}

// Data returns the bytes of the resource fetched from the bundle.
func (br *ResolvedResource) Data() []byte <span class="cov8" title="1">{
        return br.data
}</span>

// Annotations returns the annotations from the bundle that are relevant
// to resolution.
func (br *ResolvedResource) Annotations() map[string]string <span class="cov8" title="1">{
        return br.annotations
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (br *ResolvedResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return br.source
}</span>

// GetEntry accepts a keychain and options for the request and returns
// either a successfully resolved bundle entry or an error.
func GetEntry(ctx context.Context, keychain authn.Keychain, opts RequestOptions) (*ResolvedResource, error) <span class="cov8" title="1">{
        uri, img, err := retrieveImage(ctx, keychain, opts.Bundle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot retrieve the oci image: %w", err)
        }</span>

        <span class="cov8" title="1">h, err := img.Digest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get the oci digest: %w", err)
        }</span>

        <span class="cov8" title="1">manifest, err := img.Manifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse image manifest: %w", err)
        }</span>

        <span class="cov8" title="1">if err := checkImageCompliance(manifest); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid tekton bundle %s, error: %w", opts.Bundle, err)
        }</span>

        <span class="cov8" title="1">layers, err := img.Layers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read image layers: %w", err)
        }</span>

        <span class="cov8" title="1">layerMap := map[string]v1.Layer{}
        for _, l := range layers </span><span class="cov8" title="1">{
                digest, err := l.Digest()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find digest for layer: %w", err)
                }</span>
                <span class="cov8" title="1">layerMap[digest.String()] = l</span>
        }

        <span class="cov8" title="1">for idx, l := range manifest.Layers </span><span class="cov8" title="1">{
                lKind := l.Annotations[BundleAnnotationKind]
                lName := l.Annotations[BundleAnnotationName]

                if strings.ToLower(opts.Kind) == strings.ToLower(lKind) &amp;&amp; opts.EntryName == lName </span><span class="cov8" title="1">{
                        obj, err := readTarLayer(layerMap[l.Digest.String()])
                        if err != nil </span><span class="cov0" title="0">{
                                // This could still be a raw layer so try to read it as that instead.
                                obj, _ = readRawLayer(layers[idx])
                        }</span>
                        <span class="cov8" title="1">return &amp;ResolvedResource{
                                data: obj,
                                annotations: map[string]string{
                                        ResolverAnnotationKind:       lKind,
                                        ResolverAnnotationName:       lName,
                                        ResolverAnnotationAPIVersion: l.Annotations[BundleAnnotationAPIVersion],
                                },
                                source: &amp;pipelinev1.RefSource{
                                        URI: uri,
                                        Digest: map[string]string{
                                                h.Algorithm: h.Hex,
                                        },
                                        EntryPoint: opts.EntryName,
                                },
                        }, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("could not find object in image with kind: %s and name: %s", opts.Kind, opts.EntryName)</span>
}

// retrieveImage will fetch the image's url, contents and manifest.
func retrieveImage(ctx context.Context, keychain authn.Keychain, ref string) (string, v1.Image, error) <span class="cov8" title="1">{
        imgRef, err := name.ParseReference(ref)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("%s is an unparseable image reference: %w", ref, err)
        }</span>
        <span class="cov8" title="1">customRetryBackoff, err := GetBundleResolverBackoff(ctx)
        if err == nil </span><span class="cov8" title="1">{
                img, err := remote.Image(imgRef, remote.WithAuthFromKeychain(keychain), remote.WithContext(ctx),
                        remote.WithRetryBackoff(customRetryBackoff))

                return imgRef.Context().Name(), img, err
        }</span> else<span class="cov0" title="0"> {
                img, err := remote.Image(imgRef, remote.WithAuthFromKeychain(keychain), remote.WithContext(ctx))

                return imgRef.Context().Name(), img, err
        }</span>
}

// checkImageCompliance will perform common checks to ensure the Tekton Bundle is compliant to our spec.
func checkImageCompliance(manifest *v1.Manifest) error <span class="cov8" title="1">{
        // Check the manifest's layers to ensure there are a maximum of 10.
        if len(manifest.Layers) &gt; MaximumBundleObjects </span><span class="cov8" title="1">{
                return fmt.Errorf("contained more than the maximum %d allow objects", MaximumBundleObjects)
        }</span>

        // Ensure each layer complies to the spec.
        <span class="cov8" title="1">for i, l := range manifest.Layers </span><span class="cov8" title="1">{
                if _, ok := l.Annotations[BundleAnnotationAPIVersion]; !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("the layer %v does not contain a %s annotation", i, BundleAnnotationAPIVersion)
                }</span>

                <span class="cov8" title="1">if _, ok := l.Annotations[BundleAnnotationName]; !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("the layer %v does not contain a %s annotation", i, BundleAnnotationName)
                }</span>

                <span class="cov8" title="1">kind, ok := l.Annotations[BundleAnnotationKind]
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("the layer %v does not contain a %s annotation", i, BundleAnnotationKind)
                }</span>
                <span class="cov8" title="1">if strings.TrimSuffix(strings.ToLower(kind), "s") != kind </span><span class="cov8" title="1">{
                        return fmt.Errorf("the layer %v the annotation %s must be lowercased and singular, found %s", i, BundleAnnotationKind, kind)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Utility function to read out the contents of an image layer, assumed to be a tarball, as bytes.
func readTarLayer(layer v1.Layer) ([]byte, error) <span class="cov8" title="1">{
        rc, err := layer.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read image layer: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = rc.Close()
        }</span>()

        // If the user bundled this up as a tar file then we need to untar it.
        <span class="cov8" title="1">treader := tar.NewReader(rc)
        header, err := treader.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("layer is not a tarball")
        }</span>

        <span class="cov8" title="1">contents := make([]byte, header.Size)
        if _, err := io.ReadFull(treader, contents); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                // We only allow 1 resource per layer so this tar bundle should have one and only one file.
                return nil, fmt.Errorf("failed to read tar bundle: %w", err)
        }</span>

        <span class="cov8" title="1">return contents, nil</span>
}

// Utility function to read out the contents of an image layer, assumed to be raw bytes, as bytes.
func readRawLayer(layer v1.Layer) ([]byte, error) <span class="cov0" title="0">{
        rc, err := layer.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read image layer: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = rc.Close()
        }</span>()

        <span class="cov0" title="0">contents, err := io.ReadAll(rc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read contents of image layer: %w", err)
        }</span>

        <span class="cov0" title="0">return contents, nil</span>
}
</pre>
		
		<pre class="file" id="file486" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bundle

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const (
        // ConfigServiceAccount is the configuration field name for controlling
        // the Service Account name to use for bundle requests.
        ConfigServiceAccount = "default-service-account"
        // ConfigKind is the configuration field name for controlling
        // what the layer name in the bundle image is.
        ConfigKind = "default-kind"
        // ConfigTimeoutKey is the configuration field name for controlling
        // the maximum duration of a resolution request for a file from registry.
        ConfigTimeoutKey = "fetch-timeout"
        // ConfigBackoffDuration is the configuration field name for controlling
        // the initial duration of a backoff when a bundle resolution fails
        ConfigBackoffDuration  = "backoff-duration"
        DefaultBackoffDuration = 2.0 * time.Second
        // ConfigBackoffFactor is the configuration field name for controlling
        // the factor by which successive backoffs will increase when a bundle
        // resolution fails
        ConfigBackoffFactor  = "backoff-factor"
        DefaultBackoffFactor = 2.0
        // ConfigBackoffJitter is the configuration field name for controlling
        // the randomness applied to backoff durations when a bundle resolution fails
        ConfigBackoffJitter  = "backoff-jitter"
        DefaultBackoffJitter = 0.1
        // ConfigBackoffSteps is the configuration field name for controlling
        // the number of attempted backoffs to retry when a bundle resolution fails
        ConfigBackoffSteps  = "backoff-steps"
        DefaultBackoffSteps = 2
        // ConfigBackoffCap is the configuration field name for controlling
        // the maximum duration to try when backing off
        ConfigBackoffCap  = "backoff-cap"
        DefaultBackoffCap = 10 * time.Second
)

// GetBundleResolverBackoff returns a remote.Backoff to
// be passed when resolving remote images. This can be configured with the
// backoff-duration, backoff-factor, backoff-jitter, backoff-steps, and backoff-cap
// fields in the bundle-resolver-config ConfigMap.
func GetBundleResolverBackoff(ctx context.Context) (remote.Backoff, error) <span class="cov8" title="1">{
        conf := framework.GetResolverConfigFromContext(ctx)

        customRetryBackoff := remote.Backoff{
                Duration: DefaultBackoffDuration,
                Factor:   DefaultBackoffFactor,
                Jitter:   DefaultBackoffJitter,
                Steps:    DefaultBackoffSteps,
                Cap:      DefaultBackoffCap,
        }
        if v, ok := conf[ConfigBackoffDuration]; ok </span><span class="cov8" title="1">{
                var err error
                duration, err := time.ParseDuration(v)
                if err != nil </span><span class="cov0" title="0">{
                        return customRetryBackoff, fmt.Errorf("error parsing backoff duration value %s: %w", v, err)
                }</span>
                <span class="cov8" title="1">customRetryBackoff.Duration = duration</span>
        }
        <span class="cov8" title="1">if v, ok := conf[ConfigBackoffFactor]; ok </span><span class="cov8" title="1">{
                var err error
                factor, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return customRetryBackoff, fmt.Errorf("error parsing backoff factor value %s: %w", v, err)
                }</span>
                <span class="cov8" title="1">customRetryBackoff.Factor = factor</span>
        }
        <span class="cov8" title="1">if v, ok := conf[ConfigBackoffJitter]; ok </span><span class="cov8" title="1">{
                var err error
                jitter, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return customRetryBackoff, fmt.Errorf("error parsing backoff jitter value %s: %w", v, err)
                }</span>
                <span class="cov8" title="1">customRetryBackoff.Jitter = jitter</span>
        }
        <span class="cov8" title="1">if v, ok := conf[ConfigBackoffSteps]; ok </span><span class="cov8" title="1">{
                var err error
                steps, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return customRetryBackoff, fmt.Errorf("error parsing backoff steps value %s: %w", v, err)
                }</span>
                <span class="cov8" title="1">customRetryBackoff.Steps = steps</span>
        }
        <span class="cov8" title="1">if v, ok := conf[ConfigBackoffCap]; ok </span><span class="cov8" title="1">{
                var err error
                cap, err := time.ParseDuration(v)
                if err != nil </span><span class="cov0" title="0">{
                        return customRetryBackoff, fmt.Errorf("error parsing backoff steps value %s: %w", v, err)
                }</span>
                <span class="cov8" title="1">customRetryBackoff.Cap = cap</span>
        }

        <span class="cov8" title="1">return customRetryBackoff, nil</span>
}
</pre>
		
		<pre class="file" id="file487" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bundle

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/go-containerregistry/pkg/name"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "github.com/tektoncd/pipeline/pkg/resolution/resource"
)

// ParamServiceAccount is the parameter defining what service
// account name to use for bundle requests.
const ParamServiceAccount = "serviceAccount"

// ParamImagePullSecret is the parameter defining what secret
// name to use for bundle requests.
const ParamImagePullSecret = "secret"

// ParamBundle is the parameter defining what the bundle image url is.
const ParamBundle = "bundle"

// ParamName is the parameter defining what the layer name in the bundle
// image is.
const ParamName = resource.ParamName

// ParamKind is the parameter defining what the layer kind in the bundle
// image is.
const ParamKind = "kind"

// OptionsFromParams parses the params from a resolution request and
// converts them into options to pass as part of a bundle request.
func OptionsFromParams(ctx context.Context, params []pipelinev1.Param) (RequestOptions, error) <span class="cov8" title="1">{
        opts := RequestOptions{}
        conf := framework.GetResolverConfigFromContext(ctx)

        paramsMap := make(map[string]pipelinev1.ParamValue)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value
        }</span>

        <span class="cov8" title="1">saVal, ok := paramsMap[ParamServiceAccount]
        sa := ""
        if !ok || saVal.StringVal == "" </span><span class="cov8" title="1">{
                if saString, ok := conf[ConfigServiceAccount]; ok </span><span class="cov8" title="1">{
                        sa = saString
                }</span> else<span class="cov8" title="1"> {
                        return opts, errors.New("default Service Account was not set during installation of the bundle resolver")
                }</span>
        } else<span class="cov8" title="1"> {
                sa = saVal.StringVal
        }</span>

        <span class="cov8" title="1">bundleVal, ok := paramsMap[ParamBundle]
        if !ok || bundleVal.StringVal == "" </span><span class="cov0" title="0">{
                return opts, fmt.Errorf("parameter %q required", ParamBundle)
        }</span>
        <span class="cov8" title="1">if _, err := name.ParseReference(bundleVal.StringVal); err != nil </span><span class="cov0" title="0">{
                return opts, fmt.Errorf("invalid bundle reference: %w", err)
        }</span>

        <span class="cov8" title="1">nameVal, ok := paramsMap[ParamName]
        if !ok || nameVal.StringVal == "" </span><span class="cov0" title="0">{
                return opts, fmt.Errorf("parameter %q required", ParamName)
        }</span>

        <span class="cov8" title="1">kindVal, ok := paramsMap[ParamKind]
        kind := ""
        if !ok || kindVal.StringVal == "" </span><span class="cov8" title="1">{
                if kindString, ok := conf[ConfigKind]; ok </span><span class="cov8" title="1">{
                        kind = kindString
                }</span> else<span class="cov0" title="0"> {
                        return opts, errors.New("default resource Kind was not set during installation of the bundle resolver")
                }</span>
        } else<span class="cov8" title="1"> {
                kind = kindVal.StringVal
        }</span>

        <span class="cov8" title="1">opts.ServiceAccount = sa
        opts.ImagePullSecret = paramsMap[ParamImagePullSecret].StringVal
        opts.Bundle = bundleVal.StringVal
        opts.EntryName = nameVal.StringVal
        opts.Kind = kind

        return opts, nil</span>
}
</pre>
		
		<pre class="file" id="file488" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package bundle

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/go-containerregistry/pkg/authn/k8schain"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/client/injection/kube/client"
)

const (
        disabledError = "cannot handle resolution request, enable-bundles-resolver feature flag not true"

        // LabelValueBundleResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueBundleResolverType string = "bundles"

        // BundleResolverName is the name that the bundle resolver should be associated with.
        BundleResolverName = "bundleresolver"

        // ConfigMapName is the bundle resolver's config map
        ConfigMapName = "bundleresolver-config"
)

var _ framework.ConfigWatcher = &amp;Resolver{}

// GetConfigName returns the name of the git resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return ConfigMapName
}</span>

var _ framework.TimedResolution = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from OCI bundles.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/bundle.Resolver] instead.
type Resolver struct {
        kubeClientSet kubernetes.Interface
}

// Initialize sets up any dependencies needed by the Resolver. None atm.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClientSet = client.Get(ctx)
        return nil
}</span>

// GetName returns a string name to refer to this Resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return BundleResolverName
}</span>

// GetSelector returns a map of labels to match requests to this Resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueBundleResolverType,
        }
}</span>

// ValidateParams ensures parameters from a request are as expected.
func (r *Resolver) ValidateParams(ctx context.Context, params []v1.Param) error <span class="cov8" title="1">{
        return ValidateParams(ctx, params)
}</span>

// Resolve uses the given params to resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, params []v1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        return ResolveRequest(ctx, r.kubeClientSet, &amp;v1beta1.ResolutionRequestSpec{Params: params})
}</span>

// Resolve uses the given params to resolve the requested file or resource.
func ResolveRequest(ctx context.Context, kubeClientSet kubernetes.Interface, req *v1beta1.ResolutionRequestSpec) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov8" title="1">{
                return nil, errors.New(disabledError)
        }</span>
        <span class="cov8" title="1">opts, err := OptionsFromParams(ctx, req.Params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var imagePullSecrets []string
        if opts.ImagePullSecret != "" </span><span class="cov8" title="1">{
                imagePullSecrets = append(imagePullSecrets, opts.ImagePullSecret)
        }</span>
        <span class="cov8" title="1">namespace := common.RequestNamespace(ctx)
        kc, err := k8schain.New(ctx, kubeClientSet, k8schain.Options{
                Namespace:          namespace,
                ServiceAccountName: opts.ServiceAccount,
                ImagePullSecrets:   imagePullSecrets,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return GetEntry(ctx, kc, opts)</span>
}

func ValidateParams(ctx context.Context, params []v1.Param) error <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov8" title="1">{
                return errors.New(disabledError)
        }</span>
        <span class="cov8" title="1">if _, err := OptionsFromParams(ctx, params); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func isDisabled(ctx context.Context) bool <span class="cov8" title="1">{
        cfg := resolverconfig.FromContextOrDefaults(ctx)
        return !cfg.FeatureFlags.EnableBundleResolver
}</span>

// GetResolutionTimeout returns a time.Duration for the amount of time a
// single bundle fetch may take. This can be configured with the
// fetch-timeout field in the bundle-resolver-config ConfigMap.
func (r *Resolver) GetResolutionTimeout(ctx context.Context, defaultTimeout time.Duration, params map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        conf := framework.GetResolverConfigFromContext(ctx)

        timeout := defaultTimeout
        if v, ok := conf[ConfigTimeoutKey]; ok </span><span class="cov8" title="1">{
                var err error
                timeout, err = time.ParseDuration(v)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Duration(0), fmt.Errorf("error parsing bundle timeout value %s: %w", v, err)
                }</span>
        }

        <span class="cov8" title="1">return timeout, nil</span>
}
</pre>
		
		<pre class="file" id="file489" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cluster

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "slices"
        "strings"

        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
        "sigs.k8s.io/yaml"
)

const (
        disabledError = "cannot handle resolution request, enable-cluster-resolver feature flag not true"

        // LabelValueClusterResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueClusterResolverType string = "cluster"

        // ClusterResolverName is the name that the cluster resolver should be
        // associated with
        ClusterResolverName string = "Cluster"

        configMapName = "cluster-resolver-config"
)

var _ framework.Resolver = &amp;Resolver{}

var supportedKinds = []string{"task", "pipeline", "stepaction"}

// Resolver implements a framework.Resolver that can fetch resources from other namespaces.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/cluster.Resolver] instead.
type Resolver struct {
        pipelineClientSet clientset.Interface
}

// Initialize performs any setup required by the cluster resolver.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.pipelineClientSet = pipelineclient.Get(ctx)
        return nil
}</span>

// GetName returns the string name that the cluster resolver should be
// associated with.
func (r *Resolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return ClusterResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the cluster resolver to process them.
func (r *Resolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueClusterResolverType,
        }
}</span>

// ValidateParams returns an error if the given parameter map is not
// valid for a resource request targeting the cluster resolver.
func (r *Resolver) ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        return ValidateParams(ctx, params)
}</span>

// Resolve performs the work of fetching a resource from a namespace with the given
// parameters.
func (r *Resolver) Resolve(ctx context.Context, origParams []pipelinev1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        return ResolveFromParams(ctx, origParams, r.pipelineClientSet)
}</span>

func ResolveFromParams(ctx context.Context, origParams []pipelinev1.Param, pipelineClientSet clientset.Interface) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov0" title="0">{
                return nil, errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">logger := logging.FromContext(ctx)

        params, err := populateParamsWithDefaults(ctx, origParams)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("cluster resolver parameter(s) invalid: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var data []byte
        var spec []byte
        var sha256Checksum []byte
        var uid string
        groupVersion := pipelinev1.SchemeGroupVersion.String()

        switch params[KindParam] </span>{
        case "stepaction":<span class="cov8" title="1">
                stepaction, err := pipelineClientSet.TektonV1beta1().StepActions(params[NamespaceParam]).Get(ctx, params[NameParam], metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Infof("failed to load stepaction %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">uid, data, sha256Checksum, spec, err = fetchStepaction(ctx, pipelinev1beta1.SchemeGroupVersion.String(), stepaction, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case "task":<span class="cov8" title="1">
                task, err := pipelineClientSet.TektonV1().Tasks(params[NamespaceParam]).Get(ctx, params[NameParam], metav1.GetOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        logger.Infof("failed to load task %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">uid, data, sha256Checksum, spec, err = fetchTask(ctx, groupVersion, task, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case "pipeline":<span class="cov8" title="1">
                pipeline, err := pipelineClientSet.TektonV1().Pipelines(params[NamespaceParam]).Get(ctx, params[NameParam], metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Infof("failed to load pipeline %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">uid, data, sha256Checksum, spec, err = fetchPipeline(ctx, groupVersion, pipeline, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        default:<span class="cov0" title="0">
                logger.Infof("unknown or invalid resource kind %s", params[KindParam])
                return nil, fmt.Errorf("unknown or invalid resource kind %s", params[KindParam])</span>
        }

        <span class="cov8" title="1">return &amp;ResolvedClusterResource{
                Content:    data,
                Spec:       spec,
                Name:       params[NameParam],
                Namespace:  params[NamespaceParam],
                Identifier: fmt.Sprintf("/apis/%s/namespaces/%s/%s/%s@%s", groupVersion, params[NamespaceParam], params[KindParam], params[NameParam], uid),
                Checksum:   sha256Checksum,
        }, nil</span>
}

var _ framework.ConfigWatcher = &amp;Resolver{}

// GetConfigName returns the name of the cluster resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return configMapName
}</span>

// ResolvedClusterResource implements framework.ResolvedResource and returns
// the resolved file []byte data and an annotation map for any metadata.
type ResolvedClusterResource struct {
        // Content is the actual resolved resource data.
        Content []byte
        // Spec is the data in the resolved task/pipeline CRD spec.
        Spec []byte
        // Name is the resolved resource name in the cluster
        Name string
        // Namespace is the namespace in the cluster under which the resolved resource was created.
        Namespace string
        // Identifier is the unique identifier for the resource in the cluster.
        // It is in the format of &lt;resource uri&gt;@&lt;uid&gt;.
        // Resource URI is the namespace-scoped uri i.e. /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME.
        // https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-uris
        Identifier string
        // Sha256 Checksum of the cluster resource
        Checksum []byte
}

var _ framework.ResolvedResource = &amp;ResolvedClusterResource{}

// Data returns the bytes of the file resolved from git.
func (r *ResolvedClusterResource) Data() []byte <span class="cov8" title="1">{
        return r.Content
}</span>

// Annotations returns the metadata that accompanies the resource fetched from the cluster.
func (r *ResolvedClusterResource) Annotations() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                ResourceNameAnnotation:      r.Name,
                ResourceNamespaceAnnotation: r.Namespace,
        }
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (r ResolvedClusterResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return &amp;pipelinev1.RefSource{
                URI: r.Identifier,
                Digest: map[string]string{
                        "sha256": hex.EncodeToString(r.Checksum),
                },
        }
}</span>

func populateParamsWithDefaults(ctx context.Context, origParams []pipelinev1.Param) (map[string]string, error) <span class="cov8" title="1">{
        conf := framework.GetResolverConfigFromContext(ctx)

        paramsMap := make(map[string]pipelinev1.ParamValue)
        for _, p := range origParams </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value
        }</span>

        <span class="cov8" title="1">params := make(map[string]string)

        var missingParams []string

        if pKind, ok := paramsMap[KindParam]; !ok || pKind.StringVal == "" </span><span class="cov8" title="1">{
                if kindVal, ok := conf[DefaultKindKey]; !ok </span><span class="cov8" title="1">{
                        missingParams = append(missingParams, KindParam)
                }</span> else<span class="cov8" title="1"> {
                        params[KindParam] = kindVal
                }</span>
        } else<span class="cov8" title="1"> {
                params[KindParam] = pKind.StringVal
        }</span>
        <span class="cov8" title="1">if kindVal, ok := params[KindParam]; ok &amp;&amp; !isSupportedKind(kindVal) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown or unsupported resource kind '%s'", kindVal)
        }</span>

        <span class="cov8" title="1">if pName, ok := paramsMap[NameParam]; !ok || pName.StringVal == "" </span><span class="cov8" title="1">{
                missingParams = append(missingParams, NameParam)
        }</span> else<span class="cov8" title="1"> {
                params[NameParam] = pName.StringVal
        }</span>

        <span class="cov8" title="1">if pNS, ok := paramsMap[NamespaceParam]; !ok || pNS.StringVal == "" </span><span class="cov8" title="1">{
                if nsVal, ok := conf[DefaultNamespaceKey]; !ok </span><span class="cov8" title="1">{
                        missingParams = append(missingParams, NamespaceParam)
                }</span> else<span class="cov8" title="1"> {
                        params[NamespaceParam] = nsVal
                }</span>
        } else<span class="cov8" title="1"> {
                params[NamespaceParam] = pNS.StringVal
        }</span>

        <span class="cov8" title="1">if len(missingParams) &gt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required cluster resolver params: %s", strings.Join(missingParams, ", "))
        }</span>

        <span class="cov8" title="1">if conf[BlockedNamespacesKey] != "" &amp;&amp; isInCommaSeparatedList(params[NamespaceParam], conf[BlockedNamespacesKey]) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access to specified namespace %s is blocked", params[NamespaceParam])
        }</span>

        <span class="cov8" title="1">if conf[AllowedNamespacesKey] != "" &amp;&amp; isInCommaSeparatedList(params[NamespaceParam], conf[AllowedNamespacesKey]) </span><span class="cov8" title="1">{
                return params, nil
        }</span>

        <span class="cov8" title="1">if conf[BlockedNamespacesKey] != "" &amp;&amp; conf[BlockedNamespacesKey] == "*" </span><span class="cov8" title="1">{
                return nil, errors.New("only explicit allowed access to namespaces is allowed")
        }</span>

        <span class="cov8" title="1">if conf[AllowedNamespacesKey] != "" &amp;&amp; !isInCommaSeparatedList(params[NamespaceParam], conf[AllowedNamespacesKey]) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access to specified namespace %s is not allowed", params[NamespaceParam])
        }</span>

        <span class="cov8" title="1">return params, nil</span>
}

func isInCommaSeparatedList(checkVal string, commaList string) bool <span class="cov8" title="1">{
        for _, s := range strings.Split(commaList, ",") </span><span class="cov8" title="1">{
                if s == checkVal </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isDisabled(ctx context.Context) bool <span class="cov8" title="1">{
        cfg := resolverconfig.FromContextOrDefaults(ctx)
        return !cfg.FeatureFlags.EnableClusterResolver
}</span>

func ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov8" title="1">{
                return errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">_, err := populateParamsWithDefaults(ctx, params)
        return err</span>
}

func fetchStepaction(ctx context.Context, groupVersion string, stepaction *pipelinev1beta1.StepAction, params map[string]string) (string, []byte, []byte, []byte, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        uid := string(stepaction.UID)
        stepaction.Kind = "StepAction"
        stepaction.APIVersion = groupVersion
        data, err := yaml.Marshal(stepaction)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal stepaction %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">sha256Checksum, err := stepaction.Checksum()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, nil, nil, err
        }</span>

        <span class="cov8" title="1">spec, err := yaml.Marshal(stepaction.Spec)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal the spec of the task %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">return uid, data, sha256Checksum, spec, nil</span>
}

func fetchTask(ctx context.Context, groupVersion string, task *pipelinev1.Task, params map[string]string) (string, []byte, []byte, []byte, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        uid := string(task.UID)
        task.Kind = "Task"
        task.APIVersion = groupVersion
        data, err := yaml.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal task %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">sha256Checksum, err := task.Checksum()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, nil, nil, err
        }</span>

        <span class="cov8" title="1">spec, err := yaml.Marshal(task.Spec)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal the spec of the task %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">return uid, data, sha256Checksum, spec, nil</span>
}

func fetchPipeline(ctx context.Context, groupVersion string, pipeline *pipelinev1.Pipeline, params map[string]string) (string, []byte, []byte, []byte, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        uid := string(pipeline.UID)
        pipeline.Kind = "Pipeline"
        pipeline.APIVersion = groupVersion
        data, err := yaml.Marshal(pipeline)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal pipeline %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>

        <span class="cov8" title="1">sha256Checksum, err := pipeline.Checksum()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, nil, nil, err
        }</span>

        <span class="cov8" title="1">spec, err := yaml.Marshal(pipeline.Spec)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("failed to marshal the spec of the pipeline %s from namespace %s: %v", params[NameParam], params[NamespaceParam], err)
                return "", nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">return uid, data, sha256Checksum, spec, nil</span>
}

func isSupportedKind(kindValue string) bool <span class="cov8" title="1">{
        return slices.Contains[[]string, string](supportedKinds, kindValue)
}</span>
</pre>
		
		<pre class="file" id="file490" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package framework

import (
        "context"

        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/configmap"
)

// resolverConfigKey is the contenxt key associated with configuration
// for one specific resolver, and is only used if that resolver
// implements the optional framework.ConfigWatcher interface.
var resolverConfigKey = struct{}{}

// DataFromConfigMap returns a copy of the contents of a configmap or an
// empty map if the configmap doesn't have any data.
func DataFromConfigMap(config *corev1.ConfigMap) (map[string]string, error) <span class="cov8" title="1">{
        resolverConfig := map[string]string{}
        if config == nil </span><span class="cov8" title="1">{
                return resolverConfig, nil
        }</span>
        <span class="cov8" title="1">for key, value := range config.Data </span><span class="cov8" title="1">{
                resolverConfig[key] = value
        }</span>
        <span class="cov8" title="1">return resolverConfig, nil</span>
}

// ConfigStore wraps a knative untyped store and provides helper methods
// for working with a resolver's configuration data.
type ConfigStore struct {
        *resolverconfig.Store
        resolverConfigName string
        untyped            *configmap.UntypedStore
}

// NewConfigStore creates a new untyped store for the resolver's configuration and a config.Store for general Pipeline configuration.
func NewConfigStore(resolverConfigName string, logger configmap.Logger) *ConfigStore <span class="cov8" title="1">{
        return &amp;ConfigStore{
                Store:              resolverconfig.NewStore(logger),
                resolverConfigName: resolverConfigName,
                untyped: configmap.NewUntypedStore(
                        "resolver-config",
                        logger,
                        configmap.Constructors{
                                resolverConfigName: DataFromConfigMap,
                        },
                ),
        }
}</span>

// WatchConfigs uses the provided configmap.Watcher
// to setup watches for the config names provided in the
// Constructors map
func (store *ConfigStore) WatchConfigs(w configmap.Watcher) <span class="cov0" title="0">{
        store.untyped.WatchConfigs(w)
        store.Store.WatchConfigs(w)
}</span>

// GetResolverConfig returns a copy of the resolver's current
// configuration or an empty map if the stored config is nil or invalid.
func (store *ConfigStore) GetResolverConfig() map[string]string <span class="cov8" title="1">{
        resolverConfig := map[string]string{}
        untypedConf := store.untyped.UntypedLoad(store.resolverConfigName)
        if conf, ok := untypedConf.(map[string]string); ok </span><span class="cov0" title="0">{
                for key, val := range conf </span><span class="cov0" title="0">{
                        resolverConfig[key] = val
                }</span>
        }
        <span class="cov8" title="1">return resolverConfig</span>
}

// ToContext returns a new context with the resolver's configuration
// data stored in it.
func (store *ConfigStore) ToContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        conf := store.GetResolverConfig()
        return InjectResolverConfigToContext(store.Store.ToContext(ctx), conf)
}</span>

// InjectResolverConfigToContext returns a new context with a
// map stored in it for a resolvers config.
func InjectResolverConfigToContext(ctx context.Context, conf map[string]string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, resolverConfigKey, conf)
}</span>

// GetResolverConfigFromContext returns any resolver-specific
// configuration that has been stored or an empty map if none exists.
func GetResolverConfigFromContext(ctx context.Context) map[string]string <span class="cov0" title="0">{
        conf := map[string]string{}
        storedConfig := ctx.Value(resolverConfigKey)
        if resolverConfig, ok := storedConfig.(map[string]string); ok </span><span class="cov0" title="0">{
                conf = resolverConfig
        }</span>
        <span class="cov0" title="0">return conf</span>
}
</pre>
		
		<pre class="file" id="file491" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package framework

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client"
        rrinformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest"
        rrlister "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/resolution/common"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/reconciler"
)

// ReconcilerModifier is a func that can access and modify a reconciler
// in the moments before a resolver is started. It allows for
// things like injecting a test clock.
type ReconcilerModifier = func(reconciler *Reconciler)

// NewController returns a knative controller for a Tekton Resolver.
// This sets up a lot of the boilerplate that individual resolvers
// shouldn't need to be concerned with since it's common to all of them.
func NewController(ctx context.Context, resolver Resolver, modifiers ...ReconcilerModifier) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        if err := ValidateResolver(ctx, resolver.GetSelector(ctx)); err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                kubeclientset := kubeclient.Get(ctx)
                rrclientset := rrclient.Get(ctx)
                rrInformer := rrinformer.Get(ctx)

                if err := resolver.Initialize(ctx); err != nil </span><span class="cov0" title="0">{
                        panic(err.Error())</span>
                }

                <span class="cov8" title="1">r := &amp;Reconciler{
                        LeaderAwareFuncs:           LeaderAwareFuncs(rrInformer.Lister()),
                        kubeClientSet:              kubeclientset,
                        resolutionRequestLister:    rrInformer.Lister(),
                        resolutionRequestClientSet: rrclientset,
                        resolver:                   resolver,
                }

                watchConfigChanges(ctx, r, cmw)

                // TODO(sbwsg): Do better sanitize.
                resolverName := resolver.GetName(ctx)
                resolverName = strings.ReplaceAll(resolverName, "/", "")
                resolverName = strings.ReplaceAll(resolverName, " ", "")

                applyModifiersAndDefaults(ctx, r, modifiers)

                impl := controller.NewContext(ctx, r, controller.ControllerOptions{
                        WorkQueueName: "TektonResolverFramework." + resolverName,
                        Logger:        logger,
                })

                _, err := rrInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: FilterResolutionRequestsBySelector(resolver.GetSelector(ctx)),
                        Handler: cache.ResourceEventHandlerFuncs{
                                AddFunc: impl.Enqueue,
                                UpdateFunc: func(oldObj, newObj interface{}) </span><span class="cov0" title="0">{
                                        impl.Enqueue(newObj)
                                }</span>,
                                // TODO(sbwsg): should we deliver delete events
                                // to the resolver?
                                // DeleteFunc: impl.Enqueue,
                        },
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ResolutionRequest informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}

// watchConfigChanges binds a framework.Resolver to updates on its
// configmap, using knative's configmap helpers. This is only done if
// the resolver implements the framework.ConfigWatcher interface.
func watchConfigChanges(ctx context.Context, reconciler *Reconciler, cmw configmap.Watcher) <span class="cov8" title="1">{
        if configWatcher, ok := reconciler.resolver.(ConfigWatcher); ok </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                resolverConfigName := configWatcher.GetConfigName(ctx)
                if resolverConfigName == "" </span><span class="cov0" title="0">{
                        panic("resolver returned empty config name")</span>
                }
                <span class="cov0" title="0">reconciler.configStore = NewConfigStore(resolverConfigName, logger)
                reconciler.configStore.WatchConfigs(cmw)</span>
        }
}

// applyModifiersAndDefaults applies the given modifiers to
// a reconciler and, after doing so, sets any default values for things
// that weren't set by a modifier.
func applyModifiersAndDefaults(ctx context.Context, r *Reconciler, modifiers []ReconcilerModifier) <span class="cov8" title="1">{
        for _, mod := range modifiers </span><span class="cov8" title="1">{
                mod(r)
        }</span>

        <span class="cov8" title="1">if r.Clock == nil </span><span class="cov0" title="0">{
                r.Clock = clock.RealClock{}
        }</span>
}

func FilterResolutionRequestsBySelector(selector map[string]string) func(obj interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov0" title="0">{
                rr, ok := obj.(*v1beta1.ResolutionRequest)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if len(rr.ObjectMeta.Labels) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for key, val := range selector </span><span class="cov0" title="0">{
                        lookup, has := rr.ObjectMeta.Labels[key]
                        if !has </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if lookup != val </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// TODO(sbwsg): I don't really understand the LeaderAwareness types beyond the
// fact that the controller crashes if they're missing. It looks
// like this is bucketing based on labels. Should we use the filter
// selector from above in the call to lister.List here?
func LeaderAwareFuncs(lister rrlister.ResolutionRequestLister) reconciler.LeaderAwareFuncs <span class="cov8" title="1">{
        return reconciler.LeaderAwareFuncs{
                PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov8" title="1">{
                        all, err := lister.List(labels.Everything())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">for _, elt := range all </span><span class="cov8" title="1">{
                                enq(bkt, types.NamespacedName{
                                        Namespace: elt.GetNamespace(),
                                        Name:      elt.GetName(),
                                })
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        }
}

// ErrMissingTypeSelector is returned when a resolver does not return
// a selector with a type label from its GetSelector method.
var ErrMissingTypeSelector = fmt.Errorf("invalid resolver: minimum selector must include %q", common.LabelKeyResolverType)

func ValidateResolver(ctx context.Context, sel map[string]string) error <span class="cov8" title="1">{
        if sel == nil </span><span class="cov0" title="0">{
                return ErrMissingTypeSelector
        }</span>
        <span class="cov8" title="1">if sel[common.LabelKeyResolverType] == "" </span><span class="cov0" title="0">{
                return ErrMissingTypeSelector
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file492" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package framework

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
)

const (
        // LabelValueFakeResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueFakeResolverType string = "fake"

        // FakeResolverName is the name that the fake resolver should be
        // associated with
        FakeResolverName string = "Fake"

        // FakeParamName is the name used for the fake resolver's single parameter.
        FakeParamName string = "fake-key"
)

var _ Resolver = &amp;FakeResolver{}

// FakeResolvedResource is a framework.ResolvedResource implementation for use with the fake resolver.
// If it's the value in the FakeResolver's ForParam map for the key given as the fake param value, the FakeResolver will
// first check if it's got a value for ErrorWith. If so, that string will be returned as an error. Then, if WaitFor is
// greater than zero, the FakeResolver will wait that long before returning. And finally, the FakeResolvedResource will
// be returned.
type FakeResolvedResource struct {
        Content       string
        AnnotationMap map[string]string
        ContentSource *pipelinev1.RefSource
        ErrorWith     string
        WaitFor       time.Duration
}

// Data returns the FakeResolvedResource's Content field as bytes.
func (f *FakeResolvedResource) Data() []byte <span class="cov8" title="1">{
        return []byte(f.Content)
}</span>

// Annotations returns the FakeResolvedResource's AnnotationMap field.
func (f *FakeResolvedResource) Annotations() map[string]string <span class="cov8" title="1">{
        return f.AnnotationMap
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (f *FakeResolvedResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return f.ContentSource
}</span>

// FakeResolver implements a framework.Resolver that can fetch pre-configured strings based on a parameter value, or return
// resolution attempts with a configured error.
type FakeResolver struct {
        ForParam map[string]*FakeResolvedResource
        Timeout  time.Duration
}

// Initialize performs any setup required by the fake resolver.
func (r *FakeResolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        if r.ForParam == nil </span><span class="cov8" title="1">{
                r.ForParam = make(map[string]*FakeResolvedResource)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetName returns the string name that the fake resolver should be
// associated with.
func (r *FakeResolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return FakeResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the fake resolver to process them.
func (r *FakeResolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                resolutioncommon.LabelKeyResolverType: LabelValueFakeResolverType,
        }
}</span>

// ValidateParams returns an error if the given parameter map is not
// valid for a resource request targeting the fake resolver.
func (r *FakeResolver) ValidateParams(_ context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        return ValidateParams(params)
}</span>

func ValidateParams(params []pipelinev1.Param) error <span class="cov8" title="1">{
        paramsMap := make(map[string]pipelinev1.ParamValue)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value
        }</span>

        <span class="cov8" title="1">required := []string{
                FakeParamName,
        }
        missing := []string{}
        if params == nil </span><span class="cov0" title="0">{
                missing = required
        }</span> else<span class="cov8" title="1"> {
                for _, p := range required </span><span class="cov8" title="1">{
                        v, has := paramsMap[p]
                        if !has || v.StringVal == "" </span><span class="cov0" title="0">{
                                missing = append(missing, p)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing %v", strings.Join(missing, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Resolve performs the work of fetching a file from the fake resolver given a map of
// parameters.
func (r *FakeResolver) Resolve(_ context.Context, params []pipelinev1.Param) (ResolvedResource, error) <span class="cov8" title="1">{
        return Resolve(params, r.ForParam)
}</span>

func Resolve(params []pipelinev1.Param, forParam map[string]*FakeResolvedResource) (ResolvedResource, error) <span class="cov8" title="1">{
        paramsMap := make(map[string]pipelinev1.ParamValue)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value
        }</span>

        <span class="cov8" title="1">paramValue := paramsMap[FakeParamName].StringVal

        frr, ok := forParam[paramValue]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("couldn't find resource for param value %s", paramValue)
        }</span>

        <span class="cov8" title="1">if frr.ErrorWith != "" </span><span class="cov8" title="1">{
                return nil, errors.New(frr.ErrorWith)
        }</span>

        <span class="cov8" title="1">if frr.WaitFor.Seconds() &gt; 0 </span><span class="cov8" title="1">{
                time.Sleep(frr.WaitFor)
        }</span>

        <span class="cov8" title="1">return frr, nil</span>
}

var _ TimedResolution = &amp;FakeResolver{}

// GetResolutionTimeout returns the configured timeout for the reconciler, or the default time.Duration if not configured.
func (r *FakeResolver) GetResolutionTimeout(ctx context.Context, defaultTimeout time.Duration, params map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        return GetResolutionTimeout(r.Timeout, defaultTimeout), nil
}</span>

// GetResolutionTimeout returns the input timeout if set to something greater than 0 or the default time.Duration if not configured.
func GetResolutionTimeout(timeout, defaultTimeout time.Duration) time.Duration <span class="cov8" title="1">{
        if timeout &gt; 0 </span><span class="cov8" title="1">{
                return timeout
        }</span>
        <span class="cov8" title="1">return defaultTimeout</span>
}
</pre>
		
		<pre class="file" id="file493" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package framework

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinev1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        rrv1beta1 "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        resolutioncommon "github.com/tektoncd/pipeline/pkg/resolution/common"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/reconciler"
)

// Reconciler handles ResolutionRequest objects, performs functionality
// common to all resolvers and delegates resolver-specific actions
// to its embedded type-specific Resolver object.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/framework.Reconciler] instead.
type Reconciler struct {
        // Implements reconciler.LeaderAware
        reconciler.LeaderAwareFuncs

        // Clock is used by the reconciler to track the passage of time
        // and can be overridden for tests.
        Clock clock.PassiveClock

        resolver                   Resolver
        kubeClientSet              kubernetes.Interface
        resolutionRequestLister    rrv1beta1.ResolutionRequestLister
        resolutionRequestClientSet rrclient.Interface

        configStore *ConfigStore
}

var _ reconciler.LeaderAware = &amp;Reconciler{}

// defaultMaximumResolutionDuration is the maximum amount of time
// resolution may take.

// defaultMaximumResolutionDuration is the max time that a call to
// Resolve() may take. It can be overridden by a resolver implementing
// the framework.TimedResolution interface.
const defaultMaximumResolutionDuration = time.Minute

// Reconcile receives the string key of a ResolutionRequest object, looks
// it up, checks it for common errors, and then delegates
// resolver-specific functionality to the reconciler's embedded
// type-specific resolver. Any errors that occur during validation or
// resolution are handled by updating or failing the ResolutionRequest.
func (r *Reconciler) Reconcile(ctx context.Context, key string) error <span class="cov8" title="1">{
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;resolutioncommon.InvalidResourceKeyError{Key: key, Original: err}
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">rr, err := r.resolutionRequestLister.ResolutionRequests(namespace).Get(name)
        if err != nil </span><span class="cov0" title="0">{
                err := &amp;resolutioncommon.GetResourceError{ResolverName: "resolutionrequest", Key: key, Original: err}
                return controller.NewPermanentError(err)
        }</span>

        <span class="cov8" title="1">if rr.IsDone() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Inject request-scoped information into the context, such as
        // the namespace that the request originates from and the
        // configuration from the configmap this resolver is watching.
        <span class="cov8" title="1">ctx = resolutioncommon.InjectRequestNamespace(ctx, namespace)
        ctx = resolutioncommon.InjectRequestName(ctx, name)
        if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        <span class="cov8" title="1">return r.resolve(ctx, key, rr)</span>
}

func (r *Reconciler) resolve(ctx context.Context, key string, rr *v1beta1.ResolutionRequest) error <span class="cov8" title="1">{
        errChan := make(chan error)
        resourceChan := make(chan ResolvedResource)

        paramsMap := make(map[string]string)
        for _, p := range rr.Spec.Params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.StringVal
        }</span>

        <span class="cov8" title="1">timeoutDuration := defaultMaximumResolutionDuration
        if timed, ok := r.resolver.(TimedResolution); ok </span><span class="cov8" title="1">{
                var err error
                timeoutDuration, err = timed.GetResolutionTimeout(ctx, defaultMaximumResolutionDuration, paramsMap)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // A new context is created for resolution so that timeouts can
        // be enforced without affecting other uses of ctx (e.g. sending
        // Updates to ResolutionRequest objects).
        <span class="cov8" title="1">resolutionCtx, cancelFn := context.WithTimeout(ctx, timeoutDuration)
        defer cancelFn()

        go func() </span><span class="cov8" title="1">{
                validationError := r.resolver.ValidateParams(resolutionCtx, rr.Spec.Params)
                if validationError != nil </span><span class="cov0" title="0">{
                        errChan &lt;- &amp;resolutioncommon.InvalidRequestError{
                                ResolutionRequestKey: key,
                                Message:              validationError.Error(),
                        }
                        return
                }</span>
                <span class="cov8" title="1">resource, resolveErr := r.resolver.Resolve(resolutionCtx, rr.Spec.Params)
                if resolveErr != nil </span><span class="cov8" title="1">{
                        errChan &lt;- &amp;resolutioncommon.GetResourceError{
                                ResolverName: r.resolver.GetName(resolutionCtx),
                                Key:          key,
                                Original:     resolveErr,
                        }
                        return
                }</span>
                <span class="cov8" title="1">resourceChan &lt;- resource</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-errChan:<span class="cov8" title="1">
                if err != nil </span><span class="cov8" title="1">{
                        return r.OnError(ctx, rr, err)
                }</span>
        case &lt;-resolutionCtx.Done():<span class="cov8" title="1">
                if err := resolutionCtx.Err(); err != nil </span><span class="cov8" title="1">{
                        return r.OnError(ctx, rr, err)
                }</span>
        case resource := &lt;-resourceChan:<span class="cov8" title="1">
                return r.writeResolvedData(ctx, rr, resource)</span>
        }

        <span class="cov0" title="0">return errors.New("unknown error")</span>
}

// OnError is used to handle any situation where a ResolutionRequest has
// reached a terminal situation that cannot be recovered from.
func (r *Reconciler) OnError(ctx context.Context, rr *v1beta1.ResolutionRequest, err error) error <span class="cov8" title="1">{
        if rr == nil </span><span class="cov0" title="0">{
                return controller.NewPermanentError(err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                _ = r.MarkFailed(ctx, rr, err)
                return controller.NewPermanentError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MarkFailed updates a ResolutionRequest as having failed. It returns
// errors that occur during the update process or nil if the update
// appeared to succeed.
func (r *Reconciler) MarkFailed(ctx context.Context, rr *v1beta1.ResolutionRequest, resolutionErr error) error <span class="cov8" title="1">{
        key := fmt.Sprintf("%s/%s", rr.Namespace, rr.Name)
        reason, resolutionErr := resolutioncommon.ReasonError(resolutionErr)
        latestGeneration, err := r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Get(ctx, rr.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("error getting latest generation of resolutionrequest %q: %v", key, err)
                return err
        }</span>
        <span class="cov8" title="1">if latestGeneration.IsDone() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">latestGeneration.Status.MarkFailed(reason, resolutionErr.Error())
        _, err = r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).UpdateStatus(ctx, latestGeneration, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Warnf("error marking resolutionrequest %q as failed: %v", key, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// statusDataPatch is the json structure that will be PATCHed into
// a ResolutionRequest with its data and annotations once successfully
// resolved.
type statusDataPatch struct {
        Annotations map[string]string             `json:"annotations"`
        Data        string                        `json:"data"`
        Source      *pipelinev1beta1.ConfigSource `json:"source"`
        RefSource   *pipelinev1.RefSource         `json:"refSource"`
}

func (r *Reconciler) writeResolvedData(ctx context.Context, rr *v1beta1.ResolutionRequest, resource ResolvedResource) error <span class="cov8" title="1">{
        encodedData := base64.StdEncoding.Strict().EncodeToString(resource.Data())
        patchBytes, err := json.Marshal(map[string]statusDataPatch{
                "status": {
                        Data:        encodedData,
                        Annotations: resource.Annotations(),
                        RefSource:   resource.RefSource(),
                        Source:      (*pipelinev1beta1.ConfigSource)(resource.RefSource()),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return r.OnError(ctx, rr, &amp;resolutioncommon.UpdatingRequestError{
                        ResolutionRequestKey: fmt.Sprintf("%s/%s", rr.Namespace, rr.Name),
                        Original:             fmt.Errorf("error serializing resource request patch: %w", err),
                })
        }</span>
        <span class="cov8" title="1">_, err = r.resolutionRequestClientSet.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Patch(ctx, rr.Name, types.MergePatchType, patchBytes, metav1.PatchOptions{}, "status")
        if err != nil </span><span class="cov0" title="0">{
                return r.OnError(ctx, rr, &amp;resolutioncommon.UpdatingRequestError{
                        ResolutionRequestKey: fmt.Sprintf("%s/%s", rr.Namespace, rr.Name),
                        Original:             err,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file494" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package testing

import (
        "context"
        "encoding/base64"
        "strings"
        "testing"
        "time"

        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "github.com/tektoncd/pipeline/test"
        "github.com/tektoncd/pipeline/test/diff"
        "github.com/tektoncd/pipeline/test/names"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        testclock "k8s.io/utils/clock/testing"
        "knative.dev/pkg/apis"
        cminformer "knative.dev/pkg/configmap/informer"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
)

var (
        now                      = time.Date(2022, time.January, 1, 0, 0, 0, 0, time.UTC)
        testClock                = testclock.NewFakePassiveClock(now)
        ignoreLastTransitionTime = cmpopts.IgnoreFields(apis.Condition{}, "LastTransitionTime.Inner.Time")
)

// ResolverReconcileTestModifier is a function thaat will be invoked after the test assets and controller have been created
type ResolverReconcileTestModifier = func(resolver framework.Resolver, testAssets test.Assets)

// RunResolverReconcileTest takes data to seed clients and informers, a Resolver, a ResolutionRequest, and the expected
// ResolutionRequestStatus and error, both of which can be nil. It instantiates a controller for that resolver and
// reconciles the given request. It then checks for the expected error, if any, and compares the resulting status with
// the expected status.
func RunResolverReconcileTest(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, request *v1beta1.ResolutionRequest,
        expectedStatus *v1beta1.ResolutionRequestStatus, expectedErr error, resolverModifiers ...ResolverReconcileTestModifier) <span class="cov0" title="0">{
        t.Helper()

        testAssets, cancel := GetResolverFrameworkController(ctx, t, d, resolver, setClockOnReconciler)
        defer cancel()

        for _, rm := range resolverModifiers </span><span class="cov0" title="0">{
                rm(resolver, testAssets)
        }</span>

        <span class="cov0" title="0">err := testAssets.Controller.Reconciler.Reconcile(testAssets.Ctx, getRequestName(request))
        if expectedErr != nil </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        t.Fatalf("expected to get error: `%v`, but got nothing", expectedErr)
                }</span>
                <span class="cov0" title="0">if expectedErr.Error() != err.Error() </span><span class="cov0" title="0">{
                        t.Fatalf("expected to get error `%v`, but got `%v`", expectedErr, err)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                if ok, _ := controller.IsRequeueKey(err); !ok </span><span class="cov0" title="0">{
                        t.Fatalf("did not expect an error, but got `%v`", err)
                }</span>
        }

        <span class="cov0" title="0">c := testAssets.Clients.ResolutionRequests.ResolutionV1beta1()
        reconciledRR, err := c.ResolutionRequests(request.Namespace).Get(testAssets.Ctx, request.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("getting updated ResolutionRequest: %v", err)
        }</span>
        <span class="cov0" title="0">if expectedStatus != nil </span><span class="cov0" title="0">{
                if d := cmp.Diff(*expectedStatus, reconciledRR.Status, ignoreLastTransitionTime); d != "" </span><span class="cov0" title="0">{
                        t.Errorf("ResolutionRequest status doesn't match %s", diff.PrintWantGot(d))
                        if expectedStatus.Data != "" &amp;&amp; expectedStatus.Data != reconciledRR.Status.Data </span><span class="cov0" title="0">{
                                decodedExpectedData, err := base64.StdEncoding.Strict().DecodeString(expectedStatus.Data)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Errorf("couldn't decode expected data: %v", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">decodedGotData, err := base64.StdEncoding.Strict().DecodeString(reconciledRR.Status.Data)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Errorf("couldn't decode reconciled data: %v", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">if d := cmp.Diff(decodedExpectedData, decodedGotData); d != "" </span><span class="cov0" title="0">{
                                        t.Errorf("decoded data did not match expected: %s", diff.PrintWantGot(d))
                                }</span>
                        }
                }
        }
}

// GetResolverFrameworkController returns an instance of the resolver framework controller/reconciler using the given resolver,
// seeded with d, where d represents the state of the system (existing resources) needed for the test.
func GetResolverFrameworkController(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, modifiers ...framework.ReconcilerModifier) (test.Assets, func()) <span class="cov0" title="0">{
        t.Helper()
        names.TestingSeed()
        return initializeResolverFrameworkControllerAssets(ctx, t, d, resolver, modifiers...)
}</span>

func initializeResolverFrameworkControllerAssets(ctx context.Context, t *testing.T, d test.Data, resolver framework.Resolver, modifiers ...framework.ReconcilerModifier) (test.Assets, func()) <span class="cov0" title="0">{
        t.Helper()
        ctx, cancel := context.WithCancel(ctx)
        ensureConfigurationConfigMapsExist(&amp;d)
        c, informers := test.SeedTestData(t, ctx, d)
        configMapWatcher := cminformer.NewInformedWatcher(c.Kube, resolverconfig.ResolversNamespace(system.Namespace()))
        ctl := framework.NewController(ctx, resolver, modifiers...)(ctx, configMapWatcher)
        if err := configMapWatcher.Start(ctx.Done()); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error starting configmap watcher: %v", err)
        }</span>

        <span class="cov0" title="0">if la, ok := ctl.Reconciler.(pkgreconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                _ = la.Promote(pkgreconciler.UniversalBucket(), func(pkgreconciler.Bucket, types.NamespacedName) </span>{<span class="cov0" title="0">}</span>)
        }

        <span class="cov0" title="0">return test.Assets{
                Logger:     logging.FromContext(ctx),
                Controller: ctl,
                Clients:    c,
                Informers:  informers,
                Recorder:   controller.GetEventRecorder(ctx).(*record.FakeRecorder),
                Ctx:        ctx,
        }, cancel</span>
}

func getRequestName(rr *v1beta1.ResolutionRequest) string <span class="cov0" title="0">{
        return strings.Join([]string{rr.Namespace, rr.Name}, "/")
}</span>

func setClockOnReconciler(r *framework.Reconciler) <span class="cov0" title="0">{
        if r.Clock == nil </span><span class="cov0" title="0">{
                r.Clock = testClock
        }</span>
}

func ensureConfigurationConfigMapsExist(d *test.Data) <span class="cov0" title="0">{
        var featureFlagsExists bool
        for _, cm := range d.ConfigMaps </span><span class="cov0" title="0">{
                if cm.Name == resolverconfig.GetFeatureFlagsConfigName() </span><span class="cov0" title="0">{
                        featureFlagsExists = true
                }</span>
        }
        <span class="cov0" title="0">if !featureFlagsExists </span><span class="cov0" title="0">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      resolverconfig.GetFeatureFlagsConfigName(),
                                Namespace: resolverconfig.ResolversNamespace(system.Namespace()),
                        },
                        Data: map[string]string{},
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file495" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

*/

package testing

import (
        "context"

        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
)

// ContextWithGitResolverDisabled returns a context containing a Config with the enable-git-resolver feature flag disabled.
func ContextWithGitResolverDisabled(ctx context.Context) context.Context <span class="cov0" title="0">{
        return contextWithResolverDisabled(ctx, "enable-git-resolver")
}</span>

// ContextWithHubResolverDisabled returns a context containing a Config with the enable-hub-resolver feature flag disabled.
func ContextWithHubResolverDisabled(ctx context.Context) context.Context <span class="cov0" title="0">{
        return contextWithResolverDisabled(ctx, "enable-hub-resolver")
}</span>

// ContextWithBundlesResolverDisabled returns a context containing a Config with the enable-bundles-resolver feature flag disabled.
func ContextWithBundlesResolverDisabled(ctx context.Context) context.Context <span class="cov0" title="0">{
        return contextWithResolverDisabled(ctx, "enable-bundles-resolver")
}</span>

// ContextWithClusterResolverDisabled returns a context containing a Config with the enable-cluster-resolver feature flag disabled.
func ContextWithClusterResolverDisabled(ctx context.Context) context.Context <span class="cov0" title="0">{
        return contextWithResolverDisabled(ctx, "enable-cluster-resolver")
}</span>

// ContextWithHttpResolverDisabled returns a context containing a Config with the enable-http-resolver feature flag disabled.
func ContextWithHttpResolverDisabled(ctx context.Context) context.Context <span class="cov0" title="0">{
        return contextWithResolverDisabled(ctx, "enable-http-resolver")
}</span>

func contextWithResolverDisabled(ctx context.Context, resolverFlag string) context.Context <span class="cov0" title="0">{
        featureFlags, _ := resolverconfig.NewFeatureFlagsFromMap(map[string]string{
                resolverFlag: "false",
        })
        cfg := &amp;resolverconfig.Config{
                FeatureFlags: featureFlags,
        }
        return resolverconfig.ToContext(ctx, cfg)
}</span>
</pre>
		
		<pre class="file" id="file496" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const (
        // DefaultTimeoutKey is the configuration field name for controlling
        // the maximum duration of a resolution request for a file from git.
        DefaultTimeoutKey = "fetch-timeout"

        // DefaultURLKey is the configuration field name for controlling
        // the git url to fetch the remote resource from.
        DefaultURLKey = "default-url"

        // DefaultRevisionKey is the configuration field name for controlling
        // the revision to fetch the remote resource from.
        DefaultRevisionKey = "default-revision"

        // DefaultOrgKey is the configuration field name for setting a default organization when using the SCM API.
        DefaultOrgKey = "default-org"

        // ServerURLKey is the config map key for the SCM provider URL
        ServerURLKey = "server-url"
        // SCMTypeKey is the config map key for the SCM provider type
        SCMTypeKey = "scm-type"
        // APISecretNameKey is the config map key for the token secret's name
        APISecretNameKey = "api-token-secret-name"
        // APISecretKeyKey is the config map key for the containing the token within the token secret
        APISecretKeyKey = "api-token-secret-key"
        // APISecretNamespaceKey is the config map key for the token secret's namespace
        APISecretNamespaceKey = "api-token-secret-namespace"
)

type GitResolverConfig map[string]ScmConfig

type ScmConfig struct {
        Timeout            string `json:"fetch-timeout"`
        URL                string `json:"default-url"`
        Revision           string `json:"default-revision"`
        Org                string `json:"default-org"`
        ServerURL          string `json:"server-url"`
        SCMType            string `json:"scm-type"`
        GitToken           string `json:"git-token"`
        APISecretName      string `json:"api-token-secret-name"`
        APISecretKey       string `json:"api-token-secret-key"`
        APISecretNamespace string `json:"api-token-secret-namespace"`
}

func GetGitResolverConfig(ctx context.Context) (GitResolverConfig, error) <span class="cov8" title="1">{
        var scmConfig interface{} = &amp;ScmConfig{}
        structType := reflect.TypeOf(scmConfig).Elem()
        gitResolverConfig := map[string]ScmConfig{}
        conf := framework.GetResolverConfigFromContext(ctx)
        for key, value := range conf </span><span class="cov8" title="1">{
                var configIdentifier, configKey string
                splittedKeyName := strings.Split(key, ".")
                switch len(splittedKeyName) </span>{
                case 2:<span class="cov8" title="1">
                        configKey = splittedKeyName[1]
                        configIdentifier = splittedKeyName[0]</span>
                case 1:<span class="cov8" title="1">
                        configKey = key
                        configIdentifier = "default"</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("key %s passed in git resolver configmap is invalid", key)</span>
                }
                <span class="cov8" title="1">_, ok := gitResolverConfig[configIdentifier]
                if !ok </span><span class="cov8" title="1">{
                        gitResolverConfig[configIdentifier] = ScmConfig{}
                }</span>
                <span class="cov8" title="1">for i := range structType.NumField() </span><span class="cov8" title="1">{
                        field := structType.Field(i)
                        fieldName := field.Name
                        jsonTag := field.Tag.Get("json")
                        if configKey == jsonTag </span><span class="cov8" title="1">{
                                tokenDetails := gitResolverConfig[configIdentifier]
                                var scm interface{} = &amp;tokenDetails
                                structValue := reflect.ValueOf(scm).Elem()
                                structValue.FieldByName(fieldName).SetString(value)
                                gitResolverConfig[configIdentifier] = structValue.Interface().(ScmConfig)
                        }</span>
                }
        }
        <span class="cov8" title="1">return gitResolverConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file497" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

type cmdExecutor = func(context.Context, string, ...string) *exec.Cmd

type remote struct {
        url         string
        username    string
        password    string
        cmdExecutor cmdExecutor
}

func (r remote) clone(ctx context.Context) (*repository, func(), error) <span class="cov8" title="1">{
        urlParts := strings.Split(r.url, "/")
        repoName := urlParts[len(urlParts)-1]
        tmpDir, err := os.MkdirTemp("", repoName+"-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, func() </span>{<span class="cov0" title="0">}</span>, err
        }
        <span class="cov8" title="1">cleanupFunc := func() </span><span class="cov8" title="1">{
                os.RemoveAll(tmpDir)
        }</span>

        <span class="cov8" title="1">repo := &amp;repository{
                url:       r.url,
                username:  r.username,
                password:  r.password,
                directory: tmpDir,
                executor:  r.cmdExecutor,
        }

        _, err = repo.execGit(ctx, "clone", repo.url, tmpDir, "--depth=1", "--no-checkout")
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "could not read Username") </span><span class="cov0" title="0">{
                        err = errors.New("clone error: authentication required")
                }</span>
                <span class="cov0" title="0">return nil, cleanupFunc, err</span>
        }
        <span class="cov8" title="1">return repo, cleanupFunc, nil</span>
}

type repository struct {
        url       string
        username  string
        password  string
        directory string
        executor  cmdExecutor
}

func (repo *repository) currentRevision(ctx context.Context) (string, error) <span class="cov8" title="1">{
        revisionSha, err := repo.execGit(ctx, "rev-list", "-n1", "HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(revisionSha)), nil</span>
}

func (repo *repository) checkout(ctx context.Context, revision string) error <span class="cov8" title="1">{
        _, err := repo.execGit(ctx, "fetch", "origin", revision, "--depth=1")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = repo.execGit(ctx, "checkout", "FETCH_HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (repo *repository) execGit(ctx context.Context, subCmd string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        if repo.executor == nil </span><span class="cov8" title="1">{
                repo.executor = exec.CommandContext
        }</span>

        <span class="cov8" title="1">args = append([]string{subCmd}, args...)

        // We need to configure  which directory contains the cloned repository since `cd`ing
        // into the repository directory is not concurrency-safe
        configArgs := []string{"-C", repo.directory}

        env := []string{"GIT_TERMINAL_PROMPT=false"}
        // NOTE: Since this is only HTTP basic auth, authentication is only supported for http
        // cloning, while unauthenticated cloning is supported for any other protocol supported
        // by git which doesn't require authentication.
        if repo.username != "" &amp;&amp; repo.password != "" </span><span class="cov8" title="1">{
                token := base64.URLEncoding.EncodeToString([]byte(repo.username + ":" + repo.password))
                env = append(
                        env,
                        "GIT_AUTH_HEADER=Authorization: Basic "+token,
                )
                configArgs = append(configArgs, "--config-env", "http.extraHeader=GIT_AUTH_HEADER")
        }</span>
        <span class="cov8" title="1">cmd := repo.executor(ctx, "git", append(configArgs, args...)...)
        cmd.Env = append(cmd.Environ(), env...)

        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                msg := string(out)
                var exitErr *exec.ExitError
                if errors.As(err, &amp;exitErr) </span><span class="cov8" title="1">{
                        msg = string(exitErr.Stderr)
                }</span>
                <span class="cov8" title="1">err = fmt.Errorf("git %s error: %s: %w", subCmd, strings.TrimSpace(msg), err)</span>
        }
        <span class="cov8" title="1">return out, err</span>
}

func (repo *repository) getFileContent(path string) ([]byte, error) <span class="cov8" title="1">{
        if _, err := os.Stat(repo.directory); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repository clone no longer exists, used after cleaned? %w", err)
        }</span>
        <span class="cov8" title="1">fileContents, err := os.ReadFile(filepath.Join(repo.directory, path))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        return nil, errors.New("file does not exist")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return fileContents, nil</span>
}
</pre>
		
		<pre class="file" id="file498" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
        "context"
        "errors"
        "fmt"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/jenkins-x/go-scm/scm"
        "github.com/jenkins-x/go-scm/scm/factory"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/cache"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

const (
        disabledError = "cannot handle resolution request, enable-git-resolver feature flag not true"

        // labelValueGitResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        labelValueGitResolverType string = "git"

        // gitResolverName is the name that the git resolver should be
        // associated with
        gitResolverName string = "Git"

        // yamlContentType is the content type to use when returning yaml
        yamlContentType string = "application/x-yaml"

        // ConfigMapName is the git resolver's config map
        ConfigMapName = "git-resolver-config"

        // cacheSize is the size of the LRU secrets cache
        cacheSize = 1024
        // ttl is the time to live for a cache entry
        ttl = 5 * time.Minute
)

var _ framework.Resolver = &amp;Resolver{}

// Resolver implements a framework.Resolver that can fetch files from git.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/git.Resolver] instead.
type Resolver struct {
        kubeClient kubernetes.Interface
        logger     *zap.SugaredLogger
        cache      *cache.LRUExpireCache
        ttl        time.Duration

        // Used in testing
        clientFunc func(string, string, string, ...factory.ClientOptionFunc) (*scm.Client, error)
}

// Initialize performs any setup required by the gitresolver.
func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClient = kubeclient.Get(ctx)
        r.logger = logging.FromContext(ctx)
        r.cache = cache.NewLRUExpireCache(cacheSize)
        r.ttl = ttl
        if r.clientFunc == nil </span><span class="cov0" title="0">{
                r.clientFunc = factory.NewClient
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetName returns the string name that the gitresolver should be
// associated with.
func (r *Resolver) GetName(_ context.Context) string <span class="cov8" title="1">{
        return gitResolverName
}</span>

// GetSelector returns the labels that resource requests are required to have for
// the gitresolver to process them.
func (r *Resolver) GetSelector(_ context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: labelValueGitResolverType,
        }
}</span>

// ValidateParams returns an error if the given parameter map is not
// valid for a resource request targeting the gitresolver.
func (r *Resolver) ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        return ValidateParams(ctx, params)
}</span>

// Resolve performs the work of fetching a file from git given a map of
// parameters.
func (r *Resolver) Resolve(ctx context.Context, origParams []pipelinev1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if IsDisabled(ctx) </span><span class="cov8" title="1">{
                return nil, errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">params, err := PopulateDefaultParams(ctx, origParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">g := &amp;GitResolver{
                Params:     params,
                Logger:     r.logger,
                Cache:      r.cache,
                TTL:        r.ttl,
                KubeClient: r.kubeClient,
        }

        if params[UrlParam] != "" </span><span class="cov8" title="1">{
                return g.ResolveGitClone(ctx)
        }</span>

        <span class="cov8" title="1">return g.ResolveAPIGit(ctx, r.clientFunc)</span>
}

func ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        if IsDisabled(ctx) </span><span class="cov8" title="1">{
                return errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">_, err := PopulateDefaultParams(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateRepoURL validates if the given URL is a valid git, http, https URL or
// starting with a / (a local repository).
func validateRepoURL(url string) bool <span class="cov8" title="1">{
        // Explanation:
        pattern := `^(/|[^@]+@[^:]+|(git|https?)://)`
        re := regexp.MustCompile(pattern)
        return re.MatchString(url)
}</span>

type GitResolver struct {
        Params     map[string]string
        Logger     *zap.SugaredLogger
        Cache      *cache.LRUExpireCache
        TTL        time.Duration
        KubeClient kubernetes.Interface
}

func (g *GitResolver) ResolveGitClone(ctx context.Context) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        conf, err := GetScmConfigForParamConfigKey(ctx, g.Params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repoURL := g.Params[UrlParam]
        if repoURL == "" </span><span class="cov0" title="0">{
                urlString := conf.URL
                if urlString == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("default Git Repo Url was not set during installation of the git resolver")
                }</span>
        }
        <span class="cov8" title="1">revision := g.Params[RevisionParam]
        if revision == "" </span><span class="cov0" title="0">{
                revisionString := conf.Revision
                if revisionString == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("default Git Revision was not set during installation of the git resolver")
                }</span>
        }

        <span class="cov8" title="1">var username string
        var password string

        secretRef := &amp;secretCacheKey{
                name: g.Params[GitTokenParam],
                key:  g.Params[GitTokenKeyParam],
        }
        if secretRef.name != "" </span><span class="cov8" title="1">{
                if secretRef.key == "" </span><span class="cov0" title="0">{
                        secretRef.key = DefaultTokenKeyParam
                }</span>
                <span class="cov8" title="1">secretRef.ns = common.RequestNamespace(ctx)</span>
        } else<span class="cov8" title="1"> {
                secretRef = nil
        }</span>

        <span class="cov8" title="1">if secretRef != nil </span><span class="cov8" title="1">{
                gitToken, err := g.getAPIToken(ctx, secretRef, GitTokenKeyParam)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">username = "git"
                password = string(gitToken)</span>
        }

        <span class="cov8" title="1">path := g.Params[PathParam]

        repo, cleanupFunc, err := remote{url: repoURL, username: username, password: password}.clone(ctx)
        defer cleanupFunc()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error resolving repository: %w", err)
        }</span>

        <span class="cov8" title="1">err = repo.checkout(ctx, revision)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fullRevision, err := repo.currentRevision(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fileContents, err := repo.getFileContent(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error opening file %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">return &amp;resolvedGitResource{
                Revision: fullRevision,
                Content:  fileContents,
                URL:      repo.url,
                Path:     path,
        }, nil</span>
}

var _ framework.ConfigWatcher = &amp;Resolver{}

// GetConfigName returns the name of the git resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return ConfigMapName
}</span>

var _ framework.TimedResolution = &amp;Resolver{}

// GetResolutionTimeout returns a time.Duration for the amount of time a
// single git fetch may take. This can be configured with the
// fetch-timeout field in the git-resolver-config configmap.
func (r *Resolver) GetResolutionTimeout(ctx context.Context, defaultTimeout time.Duration, params map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        conf, err := GetScmConfigForParamConfigKey(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return time.Duration(0), err
        }</span>
        <span class="cov8" title="1">if timeoutString := conf.Timeout; timeoutString != "" </span><span class="cov8" title="1">{
                timeout, err := time.ParseDuration(timeoutString)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Duration(0), err
                }</span>
                <span class="cov8" title="1">return timeout, nil</span>
        }
        <span class="cov8" title="1">return defaultTimeout, nil</span>
}

func PopulateDefaultParams(ctx context.Context, params []pipelinev1.Param) (map[string]string, error) <span class="cov8" title="1">{
        paramsMap := make(map[string]string)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.StringVal
        }</span>

        <span class="cov8" title="1">conf, err := GetScmConfigForParamConfigKey(ctx, paramsMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var missingParams []string

        if _, ok := paramsMap[RevisionParam]; !ok </span><span class="cov8" title="1">{
                defaultRevision := conf.Revision
                if defaultRevision != "" </span><span class="cov8" title="1">{
                        paramsMap[RevisionParam] = defaultRevision
                }</span> else<span class="cov8" title="1"> {
                        missingParams = append(missingParams, RevisionParam)
                }</span>
        }
        <span class="cov8" title="1">if _, ok := paramsMap[PathParam]; !ok </span><span class="cov8" title="1">{
                missingParams = append(missingParams, PathParam)
        }</span>

        <span class="cov8" title="1">if paramsMap[UrlParam] != "" &amp;&amp; paramsMap[RepoParam] != "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot specify both '%s' and '%s'", UrlParam, RepoParam)
        }</span>

        <span class="cov8" title="1">if paramsMap[UrlParam] == "" &amp;&amp; paramsMap[RepoParam] == "" </span><span class="cov8" title="1">{
                urlString := conf.URL
                if urlString != "" </span><span class="cov0" title="0">{
                        paramsMap[UrlParam] = urlString
                }</span> else<span class="cov8" title="1"> {
                        return nil, fmt.Errorf("must specify one of '%s' or '%s'", UrlParam, RepoParam)
                }</span>
        }

        <span class="cov8" title="1">if paramsMap[RepoParam] != "" </span><span class="cov8" title="1">{
                if _, ok := paramsMap[OrgParam]; !ok </span><span class="cov8" title="1">{
                        defaultOrg := conf.Org
                        if defaultOrg != "" </span><span class="cov0" title="0">{
                                paramsMap[OrgParam] = defaultOrg
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("'%s' is required when '%s' is specified", OrgParam, RepoParam)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(missingParams) &gt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required git resolver params: %s", strings.Join(missingParams, ", "))
        }</span>

        // validate the url params if we are not using the SCM API
        <span class="cov8" title="1">if paramsMap[RepoParam] == "" &amp;&amp; paramsMap[OrgParam] == "" &amp;&amp; !validateRepoURL(paramsMap[UrlParam]) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid git repository url: %s", paramsMap[UrlParam])
        }</span>

        // TODO(sbwsg): validate pathInRepo is valid relative pathInRepo
        <span class="cov8" title="1">return paramsMap, nil</span>
}

// supports the SPDX format which is recommended by in-toto
// ref: https://spdx.dev/spdx-specification-21-web-version/#h.49x2ik5
// ref: https://github.com/in-toto/attestation/blob/main/spec/field_types.md
func spdxGit(url string) string <span class="cov8" title="1">{
        return "git+" + url
}</span>

// resolvedGitResource implements framework.ResolvedResource and returns
// the resolved file []byte data and an annotation map for any metadata.
type resolvedGitResource struct {
        Revision string
        Content  []byte
        Org      string
        Repo     string
        Path     string
        URL      string
}

var _ framework.ResolvedResource = &amp;resolvedGitResource{}

// Data returns the bytes of the file resolved from git.
func (r *resolvedGitResource) Data() []byte <span class="cov8" title="1">{
        return r.Content
}</span>

// Annotations returns the metadata that accompanies the file fetched
// from git.
func (r *resolvedGitResource) Annotations() map[string]string <span class="cov8" title="1">{
        m := map[string]string{
                AnnotationKeyRevision:           r.Revision,
                AnnotationKeyPath:               r.Path,
                AnnotationKeyURL:                r.URL,
                common.AnnotationKeyContentType: yamlContentType,
        }

        if r.Org != "" </span><span class="cov8" title="1">{
                m[AnnotationKeyOrg] = r.Org
        }</span>
        <span class="cov8" title="1">if r.Repo != "" </span><span class="cov8" title="1">{
                m[AnnotationKeyRepo] = r.Repo
        }</span>

        <span class="cov8" title="1">return m</span>
}

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (r *resolvedGitResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        return &amp;pipelinev1.RefSource{
                URI: spdxGit(r.URL),
                Digest: map[string]string{
                        "sha1": r.Revision,
                },
                EntryPoint: r.Path,
        }
}</span>

type secretCacheKey struct {
        ns   string
        name string
        key  string
}

func (g *GitResolver) ResolveAPIGit(ctx context.Context, clientFunc func(string, string, string, ...factory.ClientOptionFunc) (*scm.Client, error)) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        // If we got here, the "repo" param was specified, so use the API approach
        scmType, serverURL, err := getSCMTypeAndServerURL(ctx, g.Params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">secretRef := &amp;secretCacheKey{
                name: g.Params[TokenParam],
                key:  g.Params[TokenKeyParam],
        }
        if secretRef.name != "" </span><span class="cov8" title="1">{
                if secretRef.key == "" </span><span class="cov0" title="0">{
                        secretRef.key = DefaultTokenKeyParam
                }</span>
                <span class="cov8" title="1">secretRef.ns = common.RequestNamespace(ctx)</span>
        } else<span class="cov8" title="1"> {
                secretRef = nil
        }</span>
        <span class="cov8" title="1">apiToken, err := g.getAPIToken(ctx, secretRef, APISecretNameKey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">scmClient, err := clientFunc(scmType, serverURL, string(apiToken))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SCM client: %w", err)
        }</span>

        <span class="cov8" title="1">orgRepo := fmt.Sprintf("%s/%s", g.Params[OrgParam], g.Params[RepoParam])
        path := g.Params[PathParam]
        ref := g.Params[RevisionParam]

        // fetch the actual content from a file in the repo
        content, _, err := scmClient.Contents.Find(ctx, orgRepo, path, ref)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("couldn't fetch resource content: %w", err)
        }</span>
        <span class="cov8" title="1">if content == nil || len(content.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no content for resource in %s %s", orgRepo, path)
        }</span>

        // find the actual git commit sha by the ref
        <span class="cov8" title="1">commit, _, err := scmClient.Git.FindCommit(ctx, orgRepo, ref)
        if err != nil || commit == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't fetch the commit sha for the ref %s in the repo: %w", ref, err)
        }</span>

        // fetch the repository URL
        <span class="cov8" title="1">repo, _, err := scmClient.Repositories.Find(ctx, orgRepo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't fetch repository: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;resolvedGitResource{
                Content:  content.Data,
                Revision: commit.Sha,
                Org:      g.Params[OrgParam],
                Repo:     g.Params[RepoParam],
                Path:     content.Path,
                URL:      repo.Clone,
        }, nil</span>
}

func (g *GitResolver) getAPIToken(ctx context.Context, apiSecret *secretCacheKey, key string) ([]byte, error) <span class="cov8" title="1">{
        conf, err := GetScmConfigForParamConfigKey(ctx, g.Params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok := false

        // NOTE(chmouel): only cache secrets when user hasn't passed params in their resolver configuration
        cacheSecret := false
        if apiSecret == nil </span><span class="cov8" title="1">{
                cacheSecret = true
                apiSecret = &amp;secretCacheKey{}
        }</span>

        <span class="cov8" title="1">if apiSecret.name == "" </span><span class="cov8" title="1">{
                apiSecret.name = conf.APISecretName
                if apiSecret.name == "" </span><span class="cov8" title="1">{
                        err := fmt.Errorf("cannot get API token, required when specifying '%s' param, '%s' not specified in config", RepoParam, key)
                        g.Logger.Info(err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if apiSecret.key == "" </span><span class="cov8" title="1">{
                apiSecret.key = conf.APISecretKey
                if apiSecret.key == "" </span><span class="cov8" title="1">{
                        err := fmt.Errorf("cannot get API token, required when specifying '%s' param, '%s' not specified in config", RepoParam, APISecretKeyKey)
                        g.Logger.Info(err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if apiSecret.ns == "" </span><span class="cov8" title="1">{
                apiSecret.ns = conf.APISecretNamespace
                if apiSecret.ns == "" </span><span class="cov0" title="0">{
                        apiSecret.ns = os.Getenv("SYSTEM_NAMESPACE")
                }</span>
        }

        <span class="cov8" title="1">if cacheSecret </span><span class="cov8" title="1">{
                val, ok := g.Cache.Get(apiSecret)
                if ok </span><span class="cov0" title="0">{
                        return val.([]byte), nil
                }</span>
        }

        <span class="cov8" title="1">secret, err := g.KubeClient.CoreV1().Secrets(apiSecret.ns).Get(ctx, apiSecret.name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        notFoundErr := fmt.Errorf("cannot get API token, secret %s not found in namespace %s", apiSecret.name, apiSecret.ns)
                        g.Logger.Info(notFoundErr)
                        return nil, notFoundErr
                }</span>
                <span class="cov0" title="0">wrappedErr := fmt.Errorf("error reading API token from secret %s in namespace %s: %w", apiSecret.name, apiSecret.ns, err)
                g.Logger.Info(wrappedErr)
                return nil, wrappedErr</span>
        }

        <span class="cov8" title="1">secretVal, ok := secret.Data[apiSecret.key]
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("cannot get API token, key %s not found in secret %s in namespace %s", apiSecret.key, apiSecret.name, apiSecret.ns)
                g.Logger.Info(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if cacheSecret </span><span class="cov8" title="1">{
                g.Cache.Add(apiSecret, secretVal, ttl)
        }</span>
        <span class="cov8" title="1">return secretVal, nil</span>
}

func getSCMTypeAndServerURL(ctx context.Context, params map[string]string) (string, string, error) <span class="cov8" title="1">{
        conf, err := GetScmConfigForParamConfigKey(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">var scmType, serverURL string
        if key, ok := params[ScmTypeParam]; ok </span><span class="cov8" title="1">{
                scmType = key
        }</span>
        <span class="cov8" title="1">if scmType == "" </span><span class="cov8" title="1">{
                scmType = conf.SCMType
        }</span>
        <span class="cov8" title="1">if key, ok := params[ServerURLParam]; ok </span><span class="cov8" title="1">{
                serverURL = key
        }</span>
        <span class="cov8" title="1">if serverURL == "" </span><span class="cov8" title="1">{
                serverURL = conf.ServerURL
        }</span>
        <span class="cov8" title="1">return scmType, serverURL, nil</span>
}

func IsDisabled(ctx context.Context) bool <span class="cov8" title="1">{
        cfg := resolverconfig.FromContextOrDefaults(ctx)
        return !cfg.FeatureFlags.EnableGitResolver
}</span>

func GetScmConfigForParamConfigKey(ctx context.Context, params map[string]string) (ScmConfig, error) <span class="cov8" title="1">{
        gitResolverConfig, err := GetGitResolverConfig(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return ScmConfig{}, err
        }</span>
        <span class="cov8" title="1">if configKeyToUse, ok := params[ConfigKeyParam]; ok </span><span class="cov8" title="1">{
                if config, exist := gitResolverConfig[configKeyToUse]; exist </span><span class="cov8" title="1">{
                        return config, nil
                }</span>
                <span class="cov8" title="1">return ScmConfig{}, fmt.Errorf("no git resolver configuration found for configKey %s", configKeyToUse)</span>
        }
        <span class="cov8" title="1">return gitResolverConfig["default"], nil</span>
}
</pre>
		
		<pre class="file" id="file499" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package http

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

const (
        // LabelValueHttpResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueHttpResolverType string = "http"

        disabledError = "cannot handle resolution request, enable-http-resolver feature flag not true"

        // httpResolverName The name of the resolver
        httpResolverName = "Http"

        // configMapName is the http resolver's config map
        configMapName = "http-resolver-config"

        // default Timeout value when fetching http resources in seconds
        defaultHttpTimeoutValue = "1m"

        // default key in the HTTP password secret
        defaultBasicAuthSecretKey = "password"
)

// Resolver implements a framework.Resolver that can fetch files from an HTTP URL
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/http.Resolver] instead.
type Resolver struct {
        kubeClient kubernetes.Interface
        logger     *zap.SugaredLogger
}

func (r *Resolver) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        r.kubeClient = kubeclient.Get(ctx)
        r.logger = logging.FromContext(ctx)
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov8" title="1">{
        return httpResolverName
}</span>

// GetConfigName returns the name of the http resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov8" title="1">{
        return configMapName
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueHttpResolverType,
        }
}</span>

// ValidateParams ensures parameters from a request are as expected.
func (r *Resolver) ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        return ValidateParams(ctx, params)
}</span>

// Resolve uses the given params to resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, oParams []pipelinev1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if IsDisabled(ctx) </span><span class="cov8" title="1">{
                return nil, errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">params, err := PopulateDefaultParams(ctx, oParams)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return FetchHttpResource(ctx, params, r.kubeClient, r.logger)</span>
}

func IsDisabled(ctx context.Context) bool <span class="cov8" title="1">{
        cfg := resolverconfig.FromContextOrDefaults(ctx)
        return !cfg.FeatureFlags.EnableHttpResolver
}</span>

// resolvedHttpResource wraps the data we want to return to Pipelines
type resolvedHttpResource struct {
        URL     string
        Content []byte
}

var _ framework.ResolvedResource = &amp;resolvedHttpResource{}

// Data returns the bytes of our hard-coded Pipeline
func (rr *resolvedHttpResource) Data() []byte <span class="cov8" title="1">{
        return rr.Content
}</span>

// Annotations returns any metadata needed alongside the data. None atm.
func (*resolvedHttpResource) Annotations() map[string]string <span class="cov8" title="1">{
        return nil
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (rr *resolvedHttpResource) RefSource() *pipelinev1.RefSource <span class="cov8" title="1">{
        h := sha256.New()
        h.Write(rr.Content)
        sha256CheckSum := hex.EncodeToString(h.Sum(nil))

        return &amp;pipelinev1.RefSource{
                URI: rr.URL,
                Digest: map[string]string{
                        "sha256": sha256CheckSum,
                },
        }
}</span>

func PopulateDefaultParams(ctx context.Context, params []pipelinev1.Param) (map[string]string, error) <span class="cov8" title="1">{
        paramsMap := make(map[string]string)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.StringVal
        }</span>

        <span class="cov8" title="1">var missingParams []string

        if _, ok := paramsMap[UrlParam]; !ok </span><span class="cov8" title="1">{
                missingParams = append(missingParams, UrlParam)
        }</span> else<span class="cov8" title="1"> {
                u, err := url.ParseRequestURI(paramsMap[UrlParam])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("cannot parse url %s: %w", paramsMap[UrlParam], err)
                }</span>
                <span class="cov8" title="1">if u.Scheme != "http" &amp;&amp; u.Scheme != "https" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("url %s is not a valid http(s) url", paramsMap[UrlParam])
                }</span>
        }

        <span class="cov8" title="1">if username, ok := paramsMap[HttpBasicAuthUsername]; ok </span><span class="cov8" title="1">{
                if _, ok := paramsMap[HttpBasicAuthSecret]; !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required param %s when using %s", HttpBasicAuthSecret, HttpBasicAuthUsername)
                }</span>
                <span class="cov8" title="1">if username == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("value %s cannot be empty", HttpBasicAuthUsername)
                }</span>
        }

        <span class="cov8" title="1">if secret, ok := paramsMap[HttpBasicAuthSecret]; ok </span><span class="cov8" title="1">{
                if _, ok := paramsMap[HttpBasicAuthUsername]; !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing required param %s when using %s", HttpBasicAuthUsername, HttpBasicAuthSecret)
                }</span>
                <span class="cov8" title="1">if secret == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("value %s cannot be empty", HttpBasicAuthSecret)
                }</span>
        }

        <span class="cov8" title="1">if len(missingParams) &gt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required http resolver params: %s", strings.Join(missingParams, ", "))
        }</span>

        <span class="cov8" title="1">return paramsMap, nil</span>
}

func makeHttpClient(ctx context.Context) (*http.Client, error) <span class="cov8" title="1">{
        conf := framework.GetResolverConfigFromContext(ctx)
        timeout, _ := time.ParseDuration(defaultHttpTimeoutValue)
        if v, ok := conf[TimeoutKey]; ok </span><span class="cov8" title="1">{
                var err error
                timeout, err = time.ParseDuration(v)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error parsing timeout value %s: %w", v, err)
                }</span>
        }
        <span class="cov8" title="1">return &amp;http.Client{
                Timeout: timeout,
        }, nil</span>
}

func FetchHttpResource(ctx context.Context, params map[string]string, kubeclient kubernetes.Interface, logger *zap.SugaredLogger) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        var targetURL string
        var ok bool

        httpClient, err := makeHttpClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if targetURL, ok = params[UrlParam]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required params: %s", UrlParam)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodGet, targetURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructing request: %w", err)
        }</span>

        // NOTE(chmouel): We already made sure that username and secret was specified by the user
        <span class="cov8" title="1">if secret, ok := params[HttpBasicAuthSecret]; ok &amp;&amp; secret != "" </span><span class="cov8" title="1">{
                if encodedSecret, err := getBasicAuthSecret(ctx, params, kubeclient, logger); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        req.Header.Set("Authorization", encodedSecret)
                }</span>
        }

        <span class="cov8" title="1">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error fetching URL: %w", err)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("requested URL '%s' is not found", targetURL)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = resp.Body.Close()
        }</span>()
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading response body: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;resolvedHttpResource{
                Content: body,
                URL:     targetURL,
        }, nil</span>
}

func getBasicAuthSecret(ctx context.Context, params map[string]string, kubeclient kubernetes.Interface, logger *zap.SugaredLogger) (string, error) <span class="cov8" title="1">{
        secretName := params[HttpBasicAuthSecret]
        userName := params[HttpBasicAuthUsername]
        tokenSecretKey := defaultBasicAuthSecretKey
        if v, ok := params[HttpBasicAuthSecretKey]; ok </span><span class="cov8" title="1">{
                if v != "" </span><span class="cov8" title="1">{
                        tokenSecretKey = v
                }</span>
        }
        <span class="cov8" title="1">secretNS := common.RequestNamespace(ctx)
        secret, err := kubeclient.CoreV1().Secrets(secretNS).Get(ctx, secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        notFoundErr := fmt.Errorf("cannot get API token, secret %s not found in namespace %s", secretName, secretNS)
                        logger.Info(notFoundErr)
                        return "", notFoundErr
                }</span>
                <span class="cov0" title="0">wrappedErr := fmt.Errorf("error reading API token from secret %s in namespace %s: %w", secretName, secretNS, err)
                logger.Info(wrappedErr)
                return "", wrappedErr</span>
        }
        <span class="cov8" title="1">secretVal, ok := secret.Data[tokenSecretKey]
        if !ok </span><span class="cov8" title="1">{
                err := fmt.Errorf("cannot get API token, key %s not found in secret %s in namespace %s", tokenSecretKey, secretName, secretNS)
                logger.Info(err)
                return "", err
        }</span>
        <span class="cov8" title="1">return "Basic " + base64.StdEncoding.EncodeToString(
                []byte(fmt.Sprintf("%s:%s", userName, secretVal))), nil</span>
}

func ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        if IsDisabled(ctx) </span><span class="cov8" title="1">{
                return errors.New(disabledError)
        }</span>
        <span class="cov8" title="1">_, err := PopulateDefaultParams(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file500" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package hub

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "slices"
        "strings"

        goversion "github.com/hashicorp/go-version"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        "github.com/tektoncd/pipeline/pkg/resolution/resolver/framework"
)

const (
        // LabelValueHubResolverType is the value to use for the
        // resolution.tekton.dev/type label on resource requests
        LabelValueHubResolverType string = "hub"

        // ArtifactHubType is the value to use setting the type field to artifact
        ArtifactHubType string = "artifact"

        // TektonHubType is the value to use setting the type field to tekton
        TektonHubType string = "tekton"

        disabledError = "cannot handle resolution request, enable-hub-resolver feature flag not true"
)

var supportedKinds = []string{"task", "pipeline", "stepaction"}

// Resolver implements a framework.Resolver that can fetch files from OCI bundles.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resolver/hub.Resolver] instead.
type Resolver struct {
        // TektonHubURL is the URL for hub resolver with type tekton
        TektonHubURL string
        // ArtifactHubURL is the URL for hub resolver with type artifact
        ArtifactHubURL string
}

// Initialize sets up any dependencies needed by the resolver. None atm.
func (r *Resolver) Initialize(context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// GetName returns a string name to refer to this resolver by.
func (r *Resolver) GetName(context.Context) string <span class="cov0" title="0">{
        return "Hub"
}</span>

// GetConfigName returns the name of the bundle resolver's configmap.
func (r *Resolver) GetConfigName(context.Context) string <span class="cov0" title="0">{
        return "hubresolver-config"
}</span>

// GetSelector returns a map of labels to match requests to this resolver.
func (r *Resolver) GetSelector(context.Context) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                common.LabelKeyResolverType: LabelValueHubResolverType,
        }
}</span>

// ValidateParams ensures parameters from a request are as expected.
func (r *Resolver) ValidateParams(ctx context.Context, params []pipelinev1.Param) error <span class="cov8" title="1">{
        return ValidateParams(ctx, params, r.TektonHubURL)
}</span>

func ValidateParams(ctx context.Context, params []pipelinev1.Param, tektonHubUrl string) error <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov8" title="1">{
                return errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">paramsMap, err := populateDefaultParams(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to populate default params: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateParams(ctx, paramsMap, tektonHubUrl); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to validate params: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type tektonHubDataResponse struct {
        YAML string `json:"yaml"`
}

type tektonHubResponse struct {
        Data tektonHubDataResponse `json:"data"`
}

type artifactHubDataResponse struct {
        YAML string `json:"manifestRaw"`
}

type artifactHubResponse struct {
        Data artifactHubDataResponse `json:"data"`
}

// Resolve uses the given params to resolve the requested file or resource.
func (r *Resolver) Resolve(ctx context.Context, params []pipelinev1.Param) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        return Resolve(ctx, params, r.TektonHubURL, r.ArtifactHubURL)
}</span>

func Resolve(ctx context.Context, params []pipelinev1.Param, tektonHubURL, artifactHubURL string) (framework.ResolvedResource, error) <span class="cov8" title="1">{
        if isDisabled(ctx) </span><span class="cov8" title="1">{
                return nil, errors.New(disabledError)
        }</span>

        <span class="cov8" title="1">paramsMap, err := populateDefaultParams(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to populate default params: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateParams(ctx, paramsMap, tektonHubURL); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate params: %w", err)
        }</span>

        <span class="cov8" title="1">if constraint, err := goversion.NewConstraint(paramsMap[ParamVersion]); err == nil </span><span class="cov8" title="1">{
                chosen, err := resolveVersionConstraint(ctx, paramsMap, constraint, artifactHubURL, tektonHubURL)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">paramsMap[ParamVersion] = chosen.String()</span>
        }

        <span class="cov8" title="1">resVer, err := resolveVersion(paramsMap[ParamVersion], paramsMap[ParamType])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">paramsMap[ParamVersion] = resVer

        // call hub API
        switch paramsMap[ParamType] </span>{
        case ArtifactHubType:<span class="cov8" title="1">
                url := fmt.Sprintf(fmt.Sprintf("%s/%s", artifactHubURL, ArtifactHubYamlEndpoint),
                        paramsMap[ParamKind], paramsMap[ParamCatalog], paramsMap[ParamName], paramsMap[ParamVersion])
                resp := artifactHubResponse{}
                if err := fetchHubResource(ctx, url, &amp;resp); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("fail to fetch Artifact Hub resource: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;ResolvedHubResource{
                        URL:     url,
                        Content: []byte(resp.Data.YAML),
                }, nil</span>
        case TektonHubType:<span class="cov8" title="1">
                url := fmt.Sprintf(fmt.Sprintf("%s/%s", tektonHubURL, TektonHubYamlEndpoint),
                        paramsMap[ParamCatalog], paramsMap[ParamKind], paramsMap[ParamName], paramsMap[ParamVersion])
                resp := tektonHubResponse{}
                if err := fetchHubResource(ctx, url, &amp;resp); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("fail to fetch Tekton Hub resource: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;ResolvedHubResource{
                        URL:     url,
                        Content: []byte(resp.Data.YAML),
                }, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("hub resolver type: %s is not supported", paramsMap[ParamType])</span>
}

// ResolvedHubResource wraps the data we want to return to Pipelines
type ResolvedHubResource struct {
        URL     string
        Content []byte
}

var _ framework.ResolvedResource = &amp;ResolvedHubResource{}

// Data returns the bytes of our hard-coded Pipeline
func (rr *ResolvedHubResource) Data() []byte <span class="cov8" title="1">{
        return rr.Content
}</span>

// Annotations returns any metadata needed alongside the data. None atm.
func (*ResolvedHubResource) Annotations() map[string]string <span class="cov0" title="0">{
        return nil
}</span>

// RefSource is the source reference of the remote data that records where the remote
// file came from including the url, digest and the entrypoint.
func (rr *ResolvedHubResource) RefSource() *pipelinev1.RefSource <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(rr.Content)
        sha256CheckSum := hex.EncodeToString(h.Sum(nil))

        return &amp;pipelinev1.RefSource{
                URI: rr.URL,
                Digest: map[string]string{
                        "sha256": sha256CheckSum,
                },
        }
}</span>

func isDisabled(ctx context.Context) bool <span class="cov8" title="1">{
        cfg := resolverconfig.FromContextOrDefaults(ctx)
        return !cfg.FeatureFlags.EnableHubResolver
}</span>

func fetchHubResource(ctx context.Context, apiEndpoint string, v interface{}) error <span class="cov8" title="1">{
        // #nosec G107 -- URL cannot be constant in this case.
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, apiEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructing request: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requesting resource from Hub: %w", err)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("requested resource '%s' not found on hub", apiEndpoint)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = resp.Body.Close()
        }</span>()
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading response body: %w", err)
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(body, v)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error unmarshalling json response: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func resolveCatalogName(paramsMap, conf map[string]string) (string, error) <span class="cov8" title="1">{
        var configTHCatalog, configAHTaskCatalog, configAHPipelineCatalog string
        var ok bool

        if configTHCatalog, ok = conf[ConfigTektonHubCatalog]; !ok </span><span class="cov0" title="0">{
                return "", errors.New("default Tekton Hub catalog was not set during installation of the hub resolver")
        }</span>
        <span class="cov8" title="1">if configAHTaskCatalog, ok = conf[ConfigArtifactHubTaskCatalog]; !ok </span><span class="cov0" title="0">{
                return "", errors.New("default Artifact Hub task catalog was not set during installation of the hub resolver")
        }</span>
        <span class="cov8" title="1">if configAHPipelineCatalog, ok = conf[ConfigArtifactHubPipelineCatalog]; !ok </span><span class="cov0" title="0">{
                return "", errors.New("default Artifact Hub pipeline catalog was not set during installation of the hub resolver")
        }</span>
        <span class="cov8" title="1">if _, ok := paramsMap[ParamCatalog]; !ok </span><span class="cov8" title="1">{
                switch paramsMap[ParamType] </span>{
                case ArtifactHubType:<span class="cov8" title="1">
                        switch paramsMap[ParamKind] </span>{
                        case "task":<span class="cov8" title="1">
                                return configAHTaskCatalog, nil</span>
                        case "pipeline":<span class="cov8" title="1">
                                return configAHPipelineCatalog, nil</span>
                        default:<span class="cov8" title="1">
                                return "", fmt.Errorf("failed to resolve catalog name with kind: %s", paramsMap[ParamKind])</span>
                        }
                case TektonHubType:<span class="cov8" title="1">
                        return configTHCatalog, nil</span>
                default:<span class="cov0" title="0">
                        return "", fmt.Errorf("failed to resolve catalog name with type: %s", paramsMap[ParamType])</span>
                }
        }

        <span class="cov8" title="1">return paramsMap[ParamCatalog], nil</span>
}

type artifactHubavailableVersionsResults struct {
        Version    string `json:"version"`
        Prerelease bool   `json:"prerelease"`
}

type artifactHubListResult struct {
        AvailableVersions []artifactHubavailableVersionsResults `json:"available_versions"`
        Version           string                                `json:"version"`
}

type tektonHubListResultVersion struct {
        Version string `json:"version"`
}

type tektonHubListDataResult struct {
        Versions []tektonHubListResultVersion `json:"versions"`
}

type tektonHubListResult struct {
        Data tektonHubListDataResult `json:"data"`
}

// the Artifact Hub follows the semVer (i.e. &lt;major-version&gt;.&lt;minor-version&gt;.0)
// the Tekton Hub follows the simplified semVer (i.e. &lt;major-version&gt;.&lt;minor-version&gt;)
// for resolution request with "artifact" type, we append ".0" suffix if the input version is simplified semVer
// for resolution request with "tekton" type, we only use &lt;major-version&gt;.&lt;minor-version&gt; part of the input if it is semVer
func resolveVersion(version, hubType string) (string, error) <span class="cov8" title="1">{
        semVer := strings.Split(version, ".")
        resVer := version

        if hubType == ArtifactHubType &amp;&amp; len(semVer) == 2 </span><span class="cov8" title="1">{
                resVer = version + ".0"
        }</span> else<span class="cov8" title="1"> if hubType == TektonHubType &amp;&amp; len(semVer) &gt; 2 </span><span class="cov8" title="1">{
                resVer = strings.Join(semVer[0:2], ".")
        }</span>

        <span class="cov8" title="1">return resVer, nil</span>
}

func populateDefaultParams(ctx context.Context, params []pipelinev1.Param) (map[string]string, error) <span class="cov8" title="1">{
        conf := framework.GetResolverConfigFromContext(ctx)
        paramsMap := make(map[string]string)
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value.StringVal
        }</span>

        // type
        <span class="cov8" title="1">if _, ok := paramsMap[ParamType]; !ok </span><span class="cov8" title="1">{
                if typeString, ok := conf[ConfigType]; ok </span><span class="cov8" title="1">{
                        paramsMap[ParamType] = typeString
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("default type was not set during installation of the hub resolver")
                }</span>
        }

        // kind
        <span class="cov8" title="1">if _, ok := paramsMap[ParamKind]; !ok </span><span class="cov0" title="0">{
                if kindString, ok := conf[ConfigKind]; ok </span><span class="cov0" title="0">{
                        paramsMap[ParamKind] = kindString
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("default resource kind was not set during installation of the hub resolver")
                }</span>
        }

        // catalog
        <span class="cov8" title="1">resCatName, err := resolveCatalogName(paramsMap, conf)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">paramsMap[ParamCatalog] = resCatName

        return paramsMap, nil</span>
}

func validateParams(ctx context.Context, paramsMap map[string]string, tektonHubURL string) error <span class="cov8" title="1">{
        var missingParams []string
        if _, ok := paramsMap[ParamName]; !ok </span><span class="cov0" title="0">{
                missingParams = append(missingParams, ParamName)
        }</span>
        <span class="cov8" title="1">if _, ok := paramsMap[ParamVersion]; !ok </span><span class="cov0" title="0">{
                missingParams = append(missingParams, ParamVersion)
        }</span>
        <span class="cov8" title="1">if kind, ok := paramsMap[ParamKind]; ok </span><span class="cov8" title="1">{
                if !isSupportedKind(kind) </span><span class="cov8" title="1">{
                        return fmt.Errorf("kind param must be one of: %s", strings.Join(supportedKinds, ", "))
                }</span>
        }
        <span class="cov8" title="1">if hubType, ok := paramsMap[ParamType]; ok </span><span class="cov8" title="1">{
                if hubType != ArtifactHubType &amp;&amp; hubType != TektonHubType </span><span class="cov8" title="1">{
                        return fmt.Errorf("type param must be %s or %s", ArtifactHubType, TektonHubType)
                }</span>

                <span class="cov8" title="1">if hubType == TektonHubType &amp;&amp; tektonHubURL == "" </span><span class="cov8" title="1">{
                        return errors.New("please configure TEKTON_HUB_API env variable to use tekton type")
                }</span>
        }

        <span class="cov8" title="1">if len(missingParams) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required hub resolver params: %s", strings.Join(missingParams, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func resolveVersionConstraint(ctx context.Context, paramsMap map[string]string, constraint goversion.Constraints, artifactHubURL, tektonHubURL string) (*goversion.Version, error) <span class="cov8" title="1">{
        var ret *goversion.Version
        if paramsMap[ParamType] == ArtifactHubType </span><span class="cov8" title="1">{
                allVersionsURL := fmt.Sprintf("%s/%s", artifactHubURL, fmt.Sprintf(
                        ArtifactHubListTasksEndpoint,
                        paramsMap[ParamKind], paramsMap[ParamCatalog], paramsMap[ParamName]))
                resp := artifactHubListResult{}
                if err := fetchHubResource(ctx, allVersionsURL, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fail to fetch Artifact Hub resource: %w", err)
                }</span>
                <span class="cov8" title="1">for _, vers := range resp.AvailableVersions </span><span class="cov8" title="1">{
                        if vers.Prerelease </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">checkV, err := goversion.NewVersion(vers.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("fail to parse version %s from %s: %w", ArtifactHubType, vers.Version, err)
                        }</span>
                        <span class="cov8" title="1">if checkV == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if constraint.Check(checkV) </span><span class="cov8" title="1">{
                                if ret != nil &amp;&amp; ret.GreaterThan(checkV) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                // TODO(chmouel): log constraint result in controller
                                <span class="cov8" title="1">ret = checkV</span>
                        }
                }
        } else<span class="cov8" title="1"> if paramsMap[ParamType] == TektonHubType </span><span class="cov8" title="1">{
                allVersionsURL := fmt.Sprintf("%s/%s", tektonHubURL,
                        fmt.Sprintf(TektonHubListTasksEndpoint,
                                paramsMap[ParamCatalog], paramsMap[ParamKind], paramsMap[ParamName]))
                resp := tektonHubListResult{}
                if err := fetchHubResource(ctx, allVersionsURL, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fail to fetch Tekton Hub resource: %w", err)
                }</span>
                <span class="cov8" title="1">for _, vers := range resp.Data.Versions </span><span class="cov8" title="1">{
                        checkV, err := goversion.NewVersion(vers.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("fail to parse version %s from %s: %w", TektonHubType, vers, err)
                        }</span>
                        <span class="cov8" title="1">if checkV == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if constraint.Check(checkV) </span><span class="cov8" title="1">{
                                if ret != nil &amp;&amp; ret.GreaterThan(checkV) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                // TODO(chmouel): log constraint result in controller
                                <span class="cov8" title="1">ret = checkV</span>
                        }
                }
        }
        <span class="cov8" title="1">if ret == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no version found for constraint %s", paramsMap[ParamVersion])
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func isSupportedKind(kindValue string) bool <span class="cov8" title="1">{
        return slices.Contains[[]string, string](supportedKinds, kindValue)
}</span>
</pre>
		
		<pre class="file" id="file501" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        rrclient "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        rrlisters "github.com/tektoncd/pipeline/pkg/client/resolution/listers/resolution/v1beta1"
        common "github.com/tektoncd/pipeline/pkg/resolution/common"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// CRDRequester implements the Requester interface using
// ResolutionRequest CRDs.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resource.CRDRequester] instead.
type CRDRequester struct {
        clientset rrclient.Interface
        lister    rrlisters.ResolutionRequestLister
}

// NewCRDRequester returns an implementation of Requester that uses
// ResolutionRequest CRD objects to mediate between the caller who wants a
// resource (e.g. Tekton Pipelines) and the responder who can fetch
// it (e.g. the gitresolver)
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resource.NewCRDRequester] instead.
func NewCRDRequester(clientset rrclient.Interface, lister rrlisters.ResolutionRequestLister) *CRDRequester <span class="cov8" title="1">{
        return &amp;CRDRequester{clientset, lister}
}</span>

var _ Requester = &amp;CRDRequester{}

// Submit constructs a ResolutionRequest object and submits it to the
// kubernetes cluster, returning any errors experienced while doing so.
// If ResolutionRequest is succeeded then it returns the resolved data.
func (r *CRDRequester) Submit(ctx context.Context, resolver ResolverName, req Request) (ResolvedResource, error) <span class="cov8" title="1">{
        rr, _ := r.lister.ResolutionRequests(req.Namespace()).Get(req.Name())
        if rr == nil </span><span class="cov8" title="1">{
                if err := r.createResolutionRequest(ctx, resolver, req); err != nil &amp;&amp;
                        // When the request reconciles frequently, the creation may fail
                        // because the list informer cache is not updated.
                        // If the request already exists then we can assume that is in progress.
                        // The next reconcile will handle it based on the actual situation.
                        !apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, common.ErrRequestInProgress</span>
        }

        <span class="cov8" title="1">if rr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown() </span><span class="cov8" title="1">{
                // TODO(sbwsg): This should be where an existing
                // resource is given an additional owner reference so
                // that it doesn't get deleted until the caller is done
                // with it. Use appendOwnerReference and then submit
                // update to ResolutionRequest.
                return nil, common.ErrRequestInProgress
        }</span>

        <span class="cov8" title="1">if rr.Status.GetCondition(apis.ConditionSucceeded).IsTrue() </span><span class="cov8" title="1">{
                return CrdIntoResource(rr), nil
        }</span>

        <span class="cov8" title="1">message := rr.Status.GetCondition(apis.ConditionSucceeded).GetMessage()
        err := common.NewError(common.ReasonResolutionFailed, errors.New(message))
        return nil, err</span>
}

func (r *CRDRequester) createResolutionRequest(ctx context.Context, resolver ResolverName, req Request) error <span class="cov8" title="1">{
        var owner metav1.OwnerReference
        if ownedReq, ok := req.(OwnedRequest); ok </span><span class="cov8" title="1">{
                owner = ownedReq.OwnerRef()
        }</span>
        <span class="cov8" title="1">rr := CreateResolutionRequest(ctx, resolver, req.Name(), req.Namespace(), req.Params(), owner)
        _, err := r.clientset.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Create(ctx, rr, metav1.CreateOptions{})
        return err</span>
}

func CreateResolutionRequest(ctx context.Context, resolver common.ResolverName, name, namespace string, params []v1.Param, ownerRef metav1.OwnerReference) *v1beta1.ResolutionRequest <span class="cov8" title="1">{
        rr := &amp;v1beta1.ResolutionRequest{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "resolution.tekton.dev/v1beta1",
                        Kind:       "ResolutionRequest",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                common.LabelKeyResolverType: string(resolver),
                        },
                },
                Spec: v1beta1.ResolutionRequestSpec{
                        Params: params,
                },
        }
        appendOwnerReference(rr, ownerRef)
        return rr
}</span>

func appendOwnerReference(rr *v1beta1.ResolutionRequest, ownerRef metav1.OwnerReference) <span class="cov8" title="1">{
        isOwner := false
        for _, ref := range rr.ObjectMeta.OwnerReferences </span><span class="cov0" title="0">{
                if ownerRefsAreEqual(ref, ownerRef) </span><span class="cov0" title="0">{
                        isOwner = true
                }</span>
        }
        <span class="cov8" title="1">if !isOwner </span><span class="cov8" title="1">{
                rr.ObjectMeta.OwnerReferences = append(rr.ObjectMeta.OwnerReferences, ownerRef)
        }</span>
}

func ownerRefsAreEqual(a, b metav1.OwnerReference) bool <span class="cov0" title="0">{
        // pointers values cannot be directly compared.
        if (a.Controller == nil &amp;&amp; b.Controller != nil) ||
                (a.Controller != nil &amp;&amp; b.Controller == nil) ||
                (*a.Controller != *b.Controller) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return a.APIVersion == b.APIVersion &amp;&amp; a.Kind == b.Kind &amp;&amp; a.Name == b.Name &amp;&amp; a.UID == b.UID</span>
}

// ReadOnlyResolutionRequest is an opaque wrapper around ResolutionRequest
// that provides the methods needed to read data from it using the
// Resource interface without exposing the underlying API
// object.
type ReadOnlyResolutionRequest struct {
        req *v1beta1.ResolutionRequest
}

var _ common.ResolvedResource = ReadOnlyResolutionRequest{}

func CrdIntoResource(rr *v1beta1.ResolutionRequest) ReadOnlyResolutionRequest <span class="cov8" title="1">{
        return ReadOnlyResolutionRequest{req: rr}
}</span>

func (r ReadOnlyResolutionRequest) Annotations() map[string]string <span class="cov8" title="1">{
        status := r.req.GetStatus()
        if status != nil &amp;&amp; status.Annotations != nil </span><span class="cov8" title="1">{
                annotationsCopy := map[string]string{}
                for key, val := range status.Annotations </span><span class="cov8" title="1">{
                        annotationsCopy[key] = val
                }</span>
                <span class="cov8" title="1">return annotationsCopy</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r ReadOnlyResolutionRequest) Data() ([]byte, error) <span class="cov8" title="1">{
        encodedData := r.req.Status.ResolutionRequestStatusFields.Data
        decodedBytes, err := base64.StdEncoding.Strict().DecodeString(encodedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding data from base64: %w", err)
        }</span>
        <span class="cov8" title="1">return decodedBytes, nil</span>
}

func (r ReadOnlyResolutionRequest) RefSource() *v1.RefSource <span class="cov8" title="1">{
        return r.req.Status.RefSource
}</span>
</pre>
		
		<pre class="file" id="file502" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "fmt"
        "hash"
        "hash/fnv"
        "sort"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/kmeta"
)

const (
        // ParamName is a param that explicitly assigns a name to the remote object
        ParamName = "name"

        // ParamURL is a param that hold the URL used for accesing the remote object
        ParamURL = "url"
)

//

const maxLength = validation.DNS1123LabelMaxLength

// GenerateDeterministicName makes a best-effort attempt to create a
// unique but reproducible name for use in a Request. The returned value
// will have the format {prefix}-{hash} where {prefix} is
// given and {hash} is nameHasher(base) + nameHasher(param1) +
// nameHasher(param2) + ...
func GenerateDeterministicName(prefix, base string, params v1.Params) (string, error) <span class="cov8" title="1">{
        return GenerateDeterministicNameFromSpec(prefix, base, &amp;v1beta1.ResolutionRequestSpec{Params: params})
}</span>

// GetNameAndNamespace determines the name and namespace for a resource request.
// It prioritizes explicit values, falling back to the owning object and "default" namespace.
// If needed, it generates a deterministic name to prevent duplicate requests within a context.
func GetNameAndNamespace(resolverName string, owner kmeta.OwnerRefable, name string, namespace string, req *v1beta1.ResolutionRequestSpec) (string, string, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                name = owner.GetObjectMeta().GetName()
                namespace = owner.GetObjectMeta().GetNamespace()
        }</span>
        <span class="cov0" title="0">if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>
        // Generating a deterministic name for the resource request
        // prevents multiple requests being issued for the same
        // pipelinerun's pipelineRef or taskrun's taskRef.
        <span class="cov0" title="0">remoteResourceBaseName := namespace + "/" + name
        name, err := GenerateDeterministicNameFromSpec(resolverName, remoteResourceBaseName, req)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error generating name for taskrun %s/%s: %w", namespace, name, err)
        }</span>
        <span class="cov0" title="0">return name, namespace, nil</span>
}

// nameHasher returns the hash.Hash to use when generating names.
func nameHasher() hash.Hash <span class="cov8" title="1">{
        return fnv.New128a()
}</span>

// GenerateDeterministicNameFromSpec makes a best-effort attempt to create a
// unique but reproducible name for use in a Request. The returned value
// will have the format {prefix}-{hash} where {prefix} is
// given and {hash} is nameHasher(base) + nameHasher(param1) +
// nameHasher(param2) + ...
func GenerateDeterministicNameFromSpec(prefix, base string, resolutionSpec *v1beta1.ResolutionRequestSpec) (string, error) <span class="cov8" title="1">{
        hasher := nameHasher()
        if _, err := hasher.Write([]byte(base)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if resolutionSpec == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s-%x", prefix, hasher.Sum(nil)), nil
        }</span>
        <span class="cov8" title="1">params := resolutionSpec.Params
        sortedParams := make(v1.Params, len(params))
        for i := range params </span><span class="cov8" title="1">{
                sortedParams[i] = *params[i].DeepCopy()
        }</span>
        <span class="cov8" title="1">sort.SliceStable(sortedParams, func(i, j int) bool </span><span class="cov8" title="1">{
                return sortedParams[i].Name &lt; sortedParams[j].Name
        }</span>)
        <span class="cov8" title="1">for _, p := range sortedParams </span><span class="cov8" title="1">{
                if _, err := hasher.Write([]byte(p.Name)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">switch p.Value.Type </span>{
                case v1.ParamTypeString:<span class="cov8" title="1">
                        if _, err := hasher.Write([]byte(p.Value.StringVal)); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                case v1.ParamTypeArray, v1.ParamTypeObject:<span class="cov8" title="1">
                        asJSON, err := p.Value.MarshalJSON()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if _, err := hasher.Write(asJSON); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(resolutionSpec.URL) &gt; 0 </span><span class="cov8" title="1">{
                if _, err := hasher.Write([]byte(resolutionSpec.URL)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov8" title="1">name := fmt.Sprintf("%s-%x", prefix, hasher.Sum(nil))
        if maxLength &gt; len(name) </span><span class="cov8" title="1">{
                return name, nil
        }</span>
        <span class="cov0" title="0">return name[:strings.LastIndex(name[:maxLength], " ")], nil</span>
}

// GenerateErrorLogString makes a best effort attempt to get the name of the task
// when a resolver error occurred.  The TaskRef name does not have to be set, where
// the specific resolver gets the name from the parameters.
func GenerateErrorLogString(resolverType string, params v1.Params) string <span class="cov8" title="1">{
        paramString := fmt.Sprintf("resolver type %s\n", resolverType)
        for _, p := range params </span><span class="cov8" title="1">{
                if p.Name == ParamName </span><span class="cov8" title="1">{
                        name := p.Value.StringVal
                        if p.Value.Type != v1.ParamTypeString </span><span class="cov8" title="1">{
                                asJSON, err := p.Value.MarshalJSON()
                                if err != nil </span><span class="cov8" title="1">{
                                        paramString += fmt.Sprintf("name could not be marshalled: %s\n", err.Error())
                                        continue</span>
                                }
                                <span class="cov8" title="1">name = string(asJSON)</span>
                        }
                        <span class="cov8" title="1">paramString += fmt.Sprintf("name = %s\n", name)</span>
                }
                <span class="cov8" title="1">if p.Name == ParamURL </span><span class="cov8" title="1">{
                        paramString += fmt.Sprintf("url = %s\n", p.Value.StringVal)
                }</span>
        }
        <span class="cov8" title="1">return paramString</span>
}
</pre>
		
		<pre class="file" id="file503" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"

var _ Request = &amp;BasicRequest{}

// BasicRequest holds the fields needed to submit a new resource request.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resource.BasicRequest] instead.
type BasicRequest struct {
        name      string
        namespace string
        params    v1.Params
}

// NewRequest returns an instance of a BasicRequest with the given name,
// namespace and params.
//
// Deprecated: Use [github.com/tektoncd/pipeline/pkg/remoteresolution/resource.NewRequest] instead.
func NewRequest(name, namespace string, params v1.Params) Request <span class="cov8" title="1">{
        return &amp;BasicRequest{name, namespace, params}
}</span>

// Name returns the name attached to the request
func (req *BasicRequest) Name() string <span class="cov8" title="1">{
        return req.name
}</span>

// Namespace returns the namespace that the request is associated with
func (req *BasicRequest) Namespace() string <span class="cov8" title="1">{
        return req.namespace
}</span>

// Params are the map of parameters associated with this request
func (req *BasicRequest) Params() v1.Params <span class="cov8" title="1">{
        return req.params
}</span>
</pre>
		
		<pre class="file" id="file504" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package result

import (
        "encoding/json"
        "errors"
        "fmt"
)

const (
        // TaskRunResultType default task run result value
        TaskRunResultType ResultType = 1
        // reserved: 2
        // was RunResultType

        // InternalTektonResultType default internal tekton result value
        InternalTektonResultType = 3
        // UnknownResultType default unknown result type value
        UnknownResultType = 10
        // StepResultType default step result value
        StepResultType ResultType = 4

        // StepArtifactsResultType default step artifacts result value
        StepArtifactsResultType ResultType = 5

        // TaskRunArtifactsResultType default taskRun artifacts result value
        TaskRunArtifactsResultType ResultType = 6
)

// RunResult is used to write key/value pairs to TaskRun pod termination messages.
// The key/value pairs may come from the entrypoint binary, or represent a TaskRunResult.
// If they represent a TaskRunResult, the key is the name of the result and the value is the
// JSON-serialized value of the result.
type RunResult struct {
        Key   string `json:"key"`
        Value string `json:"value"`
        // ResourceName may be used in tests, but it is not populated in termination messages.
        // It is preserved here for backwards compatibility and will not be ported to v1.
        ResourceName string     `json:"resourceName,omitempty"`
        ResultType   ResultType `json:"type,omitempty"`
}

// ResultType used to find out whether a RunResult is from a task result or not
// Note that ResultsType is another type which is used to define the data type
// (e.g. string, array, etc) we used for Results
//
//nolint:revive // revive complains about stutter of `result.ResultType`.
type ResultType int

// UnmarshalJSON unmarshals either an int or a string into a ResultType. String
// ResultTypes were removed because they made JSON messages bigger, which in
// turn limited the amount of space in termination messages for task results. String
// support is maintained for backwards compatibility - the Pipelines controller could
// be stopped midway through TaskRun execution, updated with support for int in place
// of string, and then fail the running TaskRun because it doesn't know how to interpret
// the string value that the TaskRun's entrypoint will emit when it completes.
func (r *ResultType) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var asInt int
        var intErr error

        if err := json.Unmarshal(data, &amp;asInt); err != nil </span><span class="cov8" title="1">{
                intErr = err
        }</span> else<span class="cov8" title="1"> {
                *r = ResultType(asInt)
                return nil
        }</span>

        <span class="cov8" title="1">var asString string

        if err := json.Unmarshal(data, &amp;asString); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported value type, neither int nor string: %w", errors.Join(intErr, err))
        }</span>

        <span class="cov8" title="1">switch asString </span>{
        case "StepResult":<span class="cov8" title="1">
                *r = StepResultType</span>
        case "TaskRunResult":<span class="cov8" title="1">
                *r = TaskRunResultType</span>
        case "InternalTektonResult":<span class="cov8" title="1">
                *r = InternalTektonResultType</span>
        case "StepArtifactsResult":<span class="cov8" title="1">
                *r = StepArtifactsResultType</span>
        case "TaskRunArtifactsResult":<span class="cov8" title="1">
                *r = TaskRunArtifactsResultType</span>
        default:<span class="cov0" title="0">
                *r = UnknownResultType</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file505" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "errors"
        "fmt"
        "sort"
        "strings"
)

// SpireConfig holds the images reference for a number of container images used
// across tektoncd pipelines.
// +k8s:deepcopy-gen=true
type SpireConfig struct {
        // The trust domain corresponds to the trust root of a SPIFFE identity provider.
        TrustDomain string
        // Path to the spire agent socket defined by the CSI driver
        SocketPath string
        // Spire server address
        ServerAddr string
        // Prefix to attach to the node name when registering it with the spire server
        NodeAliasPrefix string

        // MockSpire only to be used for testing the controller, will not exhibit
        // all characteristics of spire since it is only being used in the context
        // of process memory.
        MockSpire bool
}

// Validate returns an error if any image is not set.
func (c SpireConfig) Validate() error <span class="cov0" title="0">{
        var unset []string
        for _, f := range []struct {
                v, name string
        }{
                {c.TrustDomain, "spire-trust-domain"},
                {c.SocketPath, "spire-socket-path"},
                {c.ServerAddr, "spire-server-addr"},
                {c.NodeAliasPrefix, "spire-node-alias-prefix"},
        } </span><span class="cov0" title="0">{
                if f.v == "" </span><span class="cov0" title="0">{
                        unset = append(unset, f.name)
                }</span>
        }
        <span class="cov0" title="0">if len(unset) &gt; 0 </span><span class="cov0" title="0">{
                sort.Strings(unset)
                return fmt.Errorf("found unset spire configuration flags: %s", unset)
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(c.NodeAliasPrefix, "/") </span><span class="cov0" title="0">{
                return errors.New("Spire node alias should start with a /")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file506" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spire

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
        "github.com/spiffe/go-spiffe/v2/svid/x509svid"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        entryv1 "github.com/spiffe/spire-api-sdk/proto/spire/api/server/entry/v1"
        spiffetypes "github.com/spiffe/spire-api-sdk/proto/spire/api/types"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        spireconfig "github.com/tektoncd/pipeline/pkg/spire/config"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(withControllerClient)
}</span>

// controllerKey is a way to associate the ControllerAPIClient from inside the context.Context
type controllerKey struct{}

// OnStore stores the changed spire config into the SpireClientApi
func OnStore(ctx context.Context, logger *zap.SugaredLogger) func(name string, value interface{}) <span class="cov8" title="1">{
        return func(name string, value interface{}) </span><span class="cov8" title="1">{
                if name == config.GetSpireConfigName() </span><span class="cov8" title="1">{
                        cfg, ok := value.(*spireconfig.SpireConfig)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Failed to do type assertion for extracting SPIRE config")
                                return
                        }</span>
                        <span class="cov8" title="1">controllerAPIClient := GetControllerAPIClient(ctx)
                        controllerAPIClient.Close()
                        controllerAPIClient.SetConfig(*cfg)</span>
                }
        }
}

// GetControllerAPIClient extracts the ControllerAPIClient from the context.
func GetControllerAPIClient(ctx context.Context) ControllerAPIClient <span class="cov8" title="1">{
        untyped := ctx.Value(controllerKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Unable to fetch client from context.")
                return nil
        }</span>
        <span class="cov8" title="1">return untyped.(ControllerAPIClient)</span>
}

func withControllerClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, controllerKey{}, &amp;spireControllerAPIClient{})
}</span>

type spireControllerAPIClient struct {
        config       *spireconfig.SpireConfig
        serverConn   *grpc.ClientConn
        workloadConn *workloadapi.X509Source
        entryClient  entryv1.EntryClient
        workloadAPI  *workloadapi.Client
}

var _ ControllerAPIClient = (*spireControllerAPIClient)(nil)

func (sc *spireControllerAPIClient) setupClient(ctx context.Context) error <span class="cov8" title="1">{
        if sc.config == nil </span><span class="cov0" title="0">{
                return errors.New("config has not been set yet")
        }</span>
        <span class="cov8" title="1">if sc.entryClient == nil || sc.workloadConn == nil || sc.workloadAPI == nil || sc.serverConn == nil </span><span class="cov8" title="1">{
                return sc.dial(ctx)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (sc *spireControllerAPIClient) dial(ctx context.Context) error <span class="cov8" title="1">{
        if sc.workloadConn == nil </span><span class="cov8" title="1">{
                // Create X509Source - https://github.com/spiffe/go-spiffe/blob/main/v2/workloadapi/client.go
                source, err := workloadapi.NewX509Source(ctx, workloadapi.WithClientOptions(workloadapi.WithAddr(sc.config.SocketPath)))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to create X509Source for SPIFFE client: %w", err)
                }</span>
                <span class="cov8" title="1">sc.workloadConn = source</span>
        }

        <span class="cov8" title="1">if sc.workloadAPI == nil </span><span class="cov8" title="1">{
                // spire workloadapi client for controller - https://github.com/spiffe/go-spiffe/blob/main/v2/workloadapi/client.go
                client, err := workloadapi.New(ctx, workloadapi.WithAddr(sc.config.SocketPath))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("spire workload API not initialized due to error: %w", err)
                }</span>
                <span class="cov8" title="1">sc.workloadAPI = client</span>
        }

        <span class="cov8" title="1">if sc.serverConn == nil </span><span class="cov8" title="1">{
                // Create connection to spire server
                tlsConfig := tlsconfig.MTLSClientConfig(sc.workloadConn, sc.workloadConn, tlsconfig.AuthorizeAny())
                conn, err := grpc.DialContext(ctx, sc.config.ServerAddr, grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)))
                if err != nil </span><span class="cov0" title="0">{
                        sc.workloadConn.Close()
                        sc.workloadConn = nil
                        return fmt.Errorf("unable to dial SPIRE server: %w", err)
                }</span>
                <span class="cov8" title="1">sc.serverConn = conn</span>
        }

        <span class="cov8" title="1">if sc.entryClient == nil </span><span class="cov8" title="1">{
                sc.entryClient = entryv1.NewEntryClient(sc.serverConn)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetConfig sets the spire configuration for ControllerAPIClient
func (sc *spireControllerAPIClient) SetConfig(c spireconfig.SpireConfig) <span class="cov8" title="1">{
        sc.config = &amp;c
}</span>

func (sc *spireControllerAPIClient) fetchControllerSVID(ctx context.Context) (*x509svid.SVID, error) <span class="cov8" title="1">{
        xsvid, err := sc.workloadAPI.FetchX509SVID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch controller SVID: %w", err)
        }</span>
        <span class="cov8" title="1">return xsvid, nil</span>
}

func (sc *spireControllerAPIClient) nodeEntry(nodeName string) *spiffetypes.Entry <span class="cov0" title="0">{
        selectors := []*spiffetypes.Selector{
                {
                        Type:  "k8s_psat",
                        Value: "agent_ns:spire",
                },
                {
                        Type:  "k8s_psat",
                        Value: "agent_node_name:" + nodeName,
                },
        }

        return &amp;spiffetypes.Entry{
                SpiffeId: &amp;spiffetypes.SPIFFEID{
                        TrustDomain: sc.config.TrustDomain,
                        Path:        fmt.Sprintf("%v%v", sc.config.NodeAliasPrefix, nodeName),
                },
                ParentId: &amp;spiffetypes.SPIFFEID{
                        TrustDomain: sc.config.TrustDomain,
                        Path:        "/spire/server",
                },
                Selectors: selectors,
        }
}</span>

func (sc *spireControllerAPIClient) workloadEntry(tr *v1beta1.TaskRun, pod *corev1.Pod, expiry int64) *spiffetypes.Entry <span class="cov0" title="0">{
        // Note: We can potentially add attestation on the container images as well since
        // the information is available here.
        selectors := []*spiffetypes.Selector{
                {
                        Type:  "k8s",
                        Value: "pod-uid:" + string(pod.UID),
                },
                {
                        Type:  "k8s",
                        Value: "pod-name:" + pod.Name,
                },
        }

        return &amp;spiffetypes.Entry{
                SpiffeId: &amp;spiffetypes.SPIFFEID{
                        TrustDomain: sc.config.TrustDomain,
                        Path:        fmt.Sprintf("/ns/%v/taskrun/%v", tr.Namespace, tr.Name),
                },
                ParentId: &amp;spiffetypes.SPIFFEID{
                        TrustDomain: sc.config.TrustDomain,
                        Path:        fmt.Sprintf("%v%v", sc.config.NodeAliasPrefix, pod.Spec.NodeName),
                },
                Selectors: selectors,
                ExpiresAt: expiry,
        }
}</span>

// ttl is the TTL for the SPIRE entry in seconds, not the SVID TTL
func (sc *spireControllerAPIClient) CreateEntries(ctx context.Context, tr *v1beta1.TaskRun, pod *corev1.Pod, ttl time.Duration) error <span class="cov0" title="0">{
        err := sc.setupClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">expiryTime := time.Now().Unix() + int64(ttl)
        entries := []*spiffetypes.Entry{
                sc.nodeEntry(pod.Spec.NodeName),
                sc.workloadEntry(tr, pod, expiryTime),
        }

        req := entryv1.BatchCreateEntryRequest{
                Entries: entries,
        }

        resp, err := sc.entryClient.BatchCreateEntry(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(resp.GetResults()) != len(entries) </span><span class="cov0" title="0">{
                return fmt.Errorf("batch create entry failed, malformed response expected %v result", len(entries))
        }</span>

        <span class="cov0" title="0">var errPaths []string
        var errCodes []int32

        for _, r := range resp.GetResults() </span><span class="cov0" title="0">{
                statusCode := r.GetStatus().GetCode()
                if statusCode &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("statusCode overflows uint32: %d", statusCode)
                }</span>
                <span class="cov0" title="0">code := codes.Code(statusCode)

                if code != codes.AlreadyExists &amp;&amp; code != codes.OK </span><span class="cov0" title="0">{
                        errPaths = append(errPaths, r.GetEntry().GetSpiffeId().GetPath())
                        errCodes = append(errCodes, statusCode)
                }</span>
        }

        <span class="cov0" title="0">if len(errPaths) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch create entry failed for entries %+v with codes %+v", errPaths, errCodes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sc *spireControllerAPIClient) getEntries(ctx context.Context, tr *v1beta1.TaskRun, pod *corev1.Pod) ([]*spiffetypes.Entry, error) <span class="cov0" title="0">{
        req := &amp;entryv1.ListEntriesRequest{
                Filter: &amp;entryv1.ListEntriesRequest_Filter{
                        BySpiffeId: &amp;spiffetypes.SPIFFEID{
                                TrustDomain: sc.config.TrustDomain,
                                Path:        fmt.Sprintf("/ns/%v/taskrun/%v", tr.Namespace, tr.Name),
                        },
                },
        }

        entries := []*spiffetypes.Entry{}
        for </span><span class="cov0" title="0">{
                resp, err := sc.entryClient.ListEntries(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">entries = append(entries, resp.GetEntries()...)

                if resp.GetNextPageToken() == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">req.PageToken = resp.GetNextPageToken()</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

func (sc *spireControllerAPIClient) DeleteEntry(ctx context.Context, tr *v1beta1.TaskRun, pod *corev1.Pod) error <span class="cov0" title="0">{
        entries, err := sc.getEntries(ctx, tr, pod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var ids []string
        for _, e := range entries </span><span class="cov0" title="0">{
                ids = append(ids, e.GetId())
        }</span>

        <span class="cov0" title="0">req := &amp;entryv1.BatchDeleteEntryRequest{
                Ids: ids,
        }
        resp, err := sc.entryClient.BatchDeleteEntry(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var errIds []string
        var errCodes []int32

        for _, r := range resp.GetResults() </span><span class="cov0" title="0">{
                statusCode := r.GetStatus().GetCode()
                if statusCode &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("statusCode overflows uint32: %d", statusCode)
                }</span>
                <span class="cov0" title="0">code := codes.Code(statusCode)

                if code != codes.NotFound &amp;&amp; code != codes.OK </span><span class="cov0" title="0">{
                        errIds = append(errIds, r.GetId())
                        errCodes = append(errCodes, statusCode)
                }</span>
        }

        <span class="cov0" title="0">if len(errIds) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch delete entry failed for ids %+v with codes %+v", errIds, errCodes)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sc *spireControllerAPIClient) Close() error <span class="cov8" title="1">{
        var err error
        if sc.serverConn != nil </span><span class="cov8" title="1">{
                err = sc.serverConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sc.serverConn = nil</span>
        }
        <span class="cov8" title="1">if sc.workloadAPI != nil </span><span class="cov8" title="1">{
                err = sc.workloadAPI.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sc.workloadAPI = nil</span>
        }
        <span class="cov8" title="1">if sc.workloadConn != nil </span><span class="cov8" title="1">{
                err = sc.workloadConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">sc.workloadConn = nil</span>
        }
        <span class="cov8" title="1">sc.entryClient = nil
        return nil</span>
}
</pre>
		
		<pre class="file" id="file507" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spire

import (
        "context"
        "time"

        "github.com/pkg/errors"
        "github.com/spiffe/go-spiffe/v2/svid/x509svid"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spireconfig "github.com/tektoncd/pipeline/pkg/spire/config"
)

// NewEntrypointerAPIClient creates the EntrypointerAPIClient
func NewEntrypointerAPIClient(c *spireconfig.SpireConfig) EntrypointerAPIClient <span class="cov8" title="1">{
        return &amp;spireEntrypointerAPIClient{
                config: c,
        }
}</span>

type spireEntrypointerAPIClient struct {
        config *spireconfig.SpireConfig
        client *workloadapi.Client
}

func (w *spireEntrypointerAPIClient) setupClient(ctx context.Context) error <span class="cov8" title="1">{
        if w.config == nil </span><span class="cov0" title="0">{
                return errors.New("config has not been set yet")
        }</span>
        <span class="cov8" title="1">if w.client == nil </span><span class="cov8" title="1">{
                return w.dial(ctx)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (w *spireEntrypointerAPIClient) dial(ctx context.Context) error <span class="cov8" title="1">{
        // spire workloadapi client for entrypoint - https://github.com/spiffe/go-spiffe/blob/main/v2/workloadapi/client.go
        client, err := workloadapi.New(ctx, workloadapi.WithAddr(w.config.SocketPath))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "spire workload API not initialized due to error")
        }</span>
        <span class="cov8" title="1">w.client = client
        return nil</span>
}

// package-level timeout and backoff enable shortened timeout for unit tests
var (
        timeout = 20 * time.Second
        backoff = 2 * time.Second
)

func (w *spireEntrypointerAPIClient) getWorkloadSVID(ctx context.Context) (*x509svid.SVID, error) <span class="cov8" title="1">{
        // Should this be using exponential backoff? IDK enough about the underlying
        // implementation to know if exponential backoff is in fact justified, so
        // when I modified this code to use a ticker I didn't change the backoff
        // logic.
        ticker := time.NewTicker(backoff)
        defer ticker.Stop()

        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        for </span><span class="cov8" title="1">{
                var xsvid *x509svid.SVID
                var err error
                if xsvid, err = w.client.FetchX509SVID(ctx); err == nil </span><span class="cov8" title="1">{ // No err -- return immediately on success
                        return xsvid, nil
                }</span>
                <span class="cov8" title="1">select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1"></span>
                        // do nothing; loop will try again
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        // ctx timed out or was cancelled
                        return nil, errors.Wrap(ctx.Err(), errors.Wrap(err, "failed to fetch SVID").Error())</span>
                }
        }
}

func (w *spireEntrypointerAPIClient) Close() error <span class="cov8" title="1">{
        if w.client != nil </span><span class="cov8" title="1">{
                return w.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file508" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spire

import (
        "context"
        "crypto"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/pem"
        "errors"
        "strings"

        "github.com/spiffe/go-spiffe/v2/svid/x509svid"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/result"
)

// Signs the TaskRun results with the TaskRun spire SVID and appends the results to RunResult
func (w *spireEntrypointerAPIClient) Sign(ctx context.Context, results []result.RunResult) ([]result.RunResult, error) <span class="cov8" title="1">{
        err := w.setupClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">xsvid, err := w.getWorkloadSVID(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(xsvid.Certificates) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("returned workload svid does not have certificates")
        }</span>

        <span class="cov8" title="1">output := []result.RunResult{}
        p := pem.EncodeToMemory(&amp;pem.Block{
                Bytes: xsvid.Certificates[0].Raw,
                Type:  "CERTIFICATE",
        })
        output = append(output, result.RunResult{
                Key:        KeySVID,
                Value:      string(p),
                ResultType: result.TaskRunResultType,
        })

        for _, r := range results </span><span class="cov8" title="1">{
                if r.ResultType == result.TaskRunResultType </span><span class="cov8" title="1">{
                        resultValue, err := getResultValue(r)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">s, err := signWithKey(xsvid, resultValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">output = append(output, result.RunResult{
                                Key:        r.Key + KeySignatureSuffix,
                                Value:      base64.StdEncoding.EncodeToString(s),
                                ResultType: result.TaskRunResultType,
                        })</span>
                }
        }
        // get complete manifest of keys such that it can be verified
        <span class="cov8" title="1">manifest := getManifest(results)
        output = append(output, result.RunResult{
                Key:        KeyResultManifest,
                Value:      manifest,
                ResultType: result.TaskRunResultType,
        })
        manifestSig, err := signWithKey(xsvid, manifest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output = append(output, result.RunResult{
                Key:        KeyResultManifest + KeySignatureSuffix,
                Value:      base64.StdEncoding.EncodeToString(manifestSig),
                ResultType: result.TaskRunResultType,
        })

        return output, nil</span>
}

func signWithKey(xsvid *x509svid.SVID, value string) ([]byte, error) <span class="cov8" title="1">{
        dgst := sha256.Sum256([]byte(value))
        s, err := xsvid.PrivateKey.Sign(rand.Reader, dgst[:], crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func getManifest(results []result.RunResult) string <span class="cov8" title="1">{
        keys := []string{}
        for _, r := range results </span><span class="cov8" title="1">{
                if strings.HasSuffix(r.Key, KeySignatureSuffix) || r.Key == KeySVID || r.ResultType != result.TaskRunResultType </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">keys = append(keys, r.Key)</span>
        }
        <span class="cov8" title="1">return strings.Join(keys, ",")</span>
}

// AppendStatusInternalAnnotation creates the status annotations which are used by the controller to verify the status hash
func (sc *spireControllerAPIClient) AppendStatusInternalAnnotation(ctx context.Context, tr *v1beta1.TaskRun) error <span class="cov8" title="1">{
        err := sc.setupClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add status hash
        <span class="cov8" title="1">currentHash, err := hashTaskrunStatusInternal(tr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Sign with controller private key
        <span class="cov8" title="1">xsvid, err := sc.fetchControllerSVID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sig, err := signWithKey(xsvid, currentHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(xsvid.Certificates) == 0 </span><span class="cov0" title="0">{
                return errors.New("returned controller svid does not have certificates")
        }</span>
        // Store Controller SVID
        <span class="cov8" title="1">p := pem.EncodeToMemory(&amp;pem.Block{
                Bytes: xsvid.Certificates[0].Raw,
                Type:  "CERTIFICATE",
        })
        if tr.Status.Annotations == nil </span><span class="cov8" title="1">{
                tr.Status.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">tr.Status.Annotations[controllerSvidAnnotation] = string(p)
        tr.Status.Annotations[TaskRunStatusHashAnnotation] = currentHash
        tr.Status.Annotations[taskRunStatusHashSigAnnotation] = base64.StdEncoding.EncodeToString(sig)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file509" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spire

import (
        "context"
        "crypto/sha256"
        "fmt"
        "strings"
        "time"

        "github.com/pkg/errors"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/result"
        spireconfig "github.com/tektoncd/pipeline/pkg/spire/config"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

func init() <span class="cov8" title="1">{
        injection.Fake.RegisterClient(withFakeControllerClient)
}</span>

func withFakeControllerClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, controllerKey{}, &amp;spireControllerAPIClient{})
}</span>

// MockClient is a client used for mocking the this package for unit testing
// other tekton components that use the spire entrypointer or controller client.
//
// The MockClient implements both SpireControllerApiClient and SpireEntrypointerApiClient
// and in addition to that provides the helper functions to define and query internal state.
type MockClient struct {
        // Entries is a dictionary of entries that mock the SPIRE server datastore (for function Sign only)
        Entries map[string]bool

        // SignIdentities represents the list of identities to use to sign (providing context of a caller to Sign)
        // when Sign is called, the identity is dequeued from the slice. A signature will only be provided if the
        // corresponding entry is in Entries. This only takes effect if SignOverride is nil.
        SignIdentities []string

        // VerifyAlwaysReturns defines whether to always verify successfully or to always fail verification if non-nil.
        // This only take effect on Verify functions:
        // - VerifyStatusInternalAnnotationOverride
        // - VerifyTaskRunResultsOverride
        VerifyAlwaysReturns *bool

        // VerifyStatusInternalAnnotationOverride contains the function to overwrite a call to VerifyStatusInternalAnnotation
        VerifyStatusInternalAnnotationOverride func(ctx context.Context, tr *v1beta1.TaskRun, logger *zap.SugaredLogger) error

        // VerifyTaskRunResultsOverride contains the function to overwrite a call to VerifyTaskRunResults
        VerifyTaskRunResultsOverride func(ctx context.Context, prs []result.RunResult, tr *v1beta1.TaskRun) error

        // AppendStatusInternalAnnotationOverride  contains the function to overwrite a call to AppendStatusInternalAnnotation
        AppendStatusInternalAnnotationOverride func(ctx context.Context, tr *v1beta1.TaskRun) error

        // CheckSpireVerifiedFlagOverride contains the function to overwrite a call to CheckSpireVerifiedFlag
        CheckSpireVerifiedFlagOverride func(tr *v1beta1.TaskRun) bool

        // SignOverride contains the function to overwrite a call to Sign
        SignOverride func(ctx context.Context, results []result.RunResult) ([]result.RunResult, error)
}

var _ ControllerAPIClient = (*MockClient)(nil)
var _ EntrypointerAPIClient = (*MockClient)(nil)

const controllerSvid = "CONTROLLER_SVID_DATA"

func (*MockClient) mockSign(content, signedBy string) string <span class="cov8" title="1">{
        return fmt.Sprintf("signed-by-%s:%x", signedBy, sha256.Sum256([]byte(content)))
}</span>

func (sc *MockClient) mockVerify(content, sig, signedBy string) bool <span class="cov8" title="1">{
        return sig == sc.mockSign(content, signedBy)
}</span>

// GetIdentity get the taskrun namespace and taskrun name that is used for signing and verifying in mocked spire
func (*MockClient) GetIdentity(tr *v1beta1.TaskRun) string <span class="cov8" title="1">{
        return fmt.Sprintf("/ns/%v/taskrun/%v", tr.Namespace, tr.Name)
}</span>

// AppendStatusInternalAnnotation creates the status annotations which are used by the controller to verify the status hash
func (sc *MockClient) AppendStatusInternalAnnotation(ctx context.Context, tr *v1beta1.TaskRun) error <span class="cov8" title="1">{
        if sc.AppendStatusInternalAnnotationOverride != nil </span><span class="cov0" title="0">{
                return sc.AppendStatusInternalAnnotationOverride(ctx, tr)
        }</span>
        // Add status hash
        <span class="cov8" title="1">currentHash, err := hashTaskrunStatusInternal(tr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if tr.Status.Annotations == nil </span><span class="cov8" title="1">{
                tr.Status.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">tr.Status.Annotations[controllerSvidAnnotation] = controllerSvid
        tr.Status.Annotations[TaskRunStatusHashAnnotation] = currentHash
        tr.Status.Annotations[taskRunStatusHashSigAnnotation] = sc.mockSign(currentHash, "controller")
        return nil</span>
}

// CheckSpireVerifiedFlag checks if the verified status annotation is set which would result in spire verification failed
func (sc *MockClient) CheckSpireVerifiedFlag(tr *v1beta1.TaskRun) bool <span class="cov8" title="1">{
        if sc.CheckSpireVerifiedFlagOverride != nil </span><span class="cov0" title="0">{
                return sc.CheckSpireVerifiedFlagOverride(tr)
        }</span>

        <span class="cov8" title="1">_, ok := tr.Status.Annotations[VerifiedAnnotation]
        return !ok</span>
}

// CreateEntries adds entries to the dictionary of entries that mock the SPIRE server datastore
func (sc *MockClient) CreateEntries(ctx context.Context, tr *v1beta1.TaskRun, pod *corev1.Pod, ttl time.Duration) error <span class="cov8" title="1">{
        id := fmt.Sprintf("/ns/%v/taskrun/%v", tr.Namespace, tr.Name)
        if sc.Entries == nil </span><span class="cov8" title="1">{
                sc.Entries = map[string]bool{}
        }</span>
        <span class="cov8" title="1">sc.Entries[id] = true
        return nil</span>
}

// DeleteEntry removes the entry from the dictionary of entries that mock the SPIRE server datastore
func (sc *MockClient) DeleteEntry(ctx context.Context, tr *v1beta1.TaskRun, pod *corev1.Pod) error <span class="cov8" title="1">{
        id := fmt.Sprintf("/ns/%v/taskrun/%v", tr.Namespace, tr.Name)
        if sc.Entries != nil </span><span class="cov8" title="1">{
                delete(sc.Entries, id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// VerifyStatusInternalAnnotation checks that the internal status annotations are valid by the mocked spire client
func (sc *MockClient) VerifyStatusInternalAnnotation(ctx context.Context, tr *v1beta1.TaskRun, logger *zap.SugaredLogger) error <span class="cov8" title="1">{
        if sc.VerifyStatusInternalAnnotationOverride != nil </span><span class="cov0" title="0">{
                return sc.VerifyStatusInternalAnnotationOverride(ctx, tr, logger)
        }</span>

        <span class="cov8" title="1">if sc.VerifyAlwaysReturns != nil </span><span class="cov0" title="0">{
                if *sc.VerifyAlwaysReturns </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return errors.New("failed to verify from mock VerifyAlwaysReturns")</span>
        }

        <span class="cov8" title="1">if !sc.CheckSpireVerifiedFlag(tr) </span><span class="cov0" title="0">{
                return errors.New("annotation tekton.dev/not-verified = yes failed spire verification")
        }</span>

        <span class="cov8" title="1">annotations := tr.Status.Annotations

        // Verify annotations are there
        if annotations[controllerSvidAnnotation] != controllerSvid </span><span class="cov8" title="1">{
                return errors.New("svid annotation missing")
        }</span>

        // Check signature
        <span class="cov8" title="1">currentHash, err := hashTaskrunStatusInternal(tr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !sc.mockVerify(currentHash, annotations[taskRunStatusHashSigAnnotation], "controller") </span><span class="cov8" title="1">{
                return errors.New("signature was not able to be verified")
        }</span>

        // check current status hash vs annotation status hash by controller
        <span class="cov8" title="1">return CheckStatusInternalAnnotation(tr)</span>
}

// VerifyTaskRunResults checks that all the TaskRun results are valid by the mocked spire client
func (sc *MockClient) VerifyTaskRunResults(ctx context.Context, prs []result.RunResult, tr *v1beta1.TaskRun) error <span class="cov8" title="1">{
        if sc.VerifyTaskRunResultsOverride != nil </span><span class="cov0" title="0">{
                return sc.VerifyTaskRunResultsOverride(ctx, prs, tr)
        }</span>

        <span class="cov8" title="1">if sc.VerifyAlwaysReturns != nil </span><span class="cov0" title="0">{
                if *sc.VerifyAlwaysReturns </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return errors.New("failed to verify from mock VerifyAlwaysReturns")</span>
        }

        <span class="cov8" title="1">resultMap := map[string]result.RunResult{}
        for _, r := range prs </span><span class="cov8" title="1">{
                if r.ResultType == result.TaskRunResultType </span><span class="cov8" title="1">{
                        resultMap[r.Key] = r
                }</span>
        }

        <span class="cov8" title="1">var identity string
        // Get SVID identity
        for k, p := range resultMap </span><span class="cov8" title="1">{
                if k == KeySVID </span><span class="cov8" title="1">{
                        identity = p.Value
                        break</span>
                }
        }

        // Verify manifest
        <span class="cov8" title="1">if err := verifyManifest(resultMap); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if identity != sc.GetIdentity(tr) </span><span class="cov8" title="1">{
                return errors.New("mock identity did not match")
        }</span>

        <span class="cov8" title="1">for key, r := range resultMap </span><span class="cov8" title="1">{
                if strings.HasSuffix(key, KeySignatureSuffix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if key == KeySVID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">sigEntry, ok := resultMap[key+KeySignatureSuffix]
                sigValue, err := getResultValue(sigEntry)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">resultValue, err := getResultValue(r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !ok || !sc.mockVerify(resultValue, sigValue, identity) </span><span class="cov8" title="1">{
                        return errors.Errorf("failed to verify field: %v", key)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Sign signs and appends signatures to the RunResult based on the mocked spire client
func (sc *MockClient) Sign(ctx context.Context, results []result.RunResult) ([]result.RunResult, error) <span class="cov8" title="1">{
        if sc.SignOverride != nil </span><span class="cov0" title="0">{
                return sc.SignOverride(ctx, results)
        }</span>

        <span class="cov8" title="1">if len(sc.SignIdentities) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("signIdentities empty, please provide identities to sign with the MockClient.GetIdentity function")
        }</span>

        <span class="cov8" title="1">identity := sc.SignIdentities[0]
        sc.SignIdentities = sc.SignIdentities[1:]

        if !sc.Entries[identity] </span><span class="cov8" title="1">{
                return nil, errors.Errorf("entry doesn't exist for identity: %v", identity)
        }</span>

        <span class="cov8" title="1">output := []result.RunResult{}
        output = append(output, result.RunResult{
                Key:        KeySVID,
                Value:      identity,
                ResultType: result.TaskRunResultType,
        })

        for _, r := range results </span><span class="cov8" title="1">{
                if r.ResultType == result.TaskRunResultType </span><span class="cov8" title="1">{
                        resultValue, err := getResultValue(r)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">s := sc.mockSign(resultValue, identity)
                        output = append(output, result.RunResult{
                                Key:        r.Key + KeySignatureSuffix,
                                Value:      s,
                                ResultType: result.TaskRunResultType,
                        })</span>
                }
        }
        // get complete manifest of keys such that it can be verified
        <span class="cov8" title="1">manifest := getManifest(results)
        output = append(output, result.RunResult{
                Key:        KeyResultManifest,
                Value:      manifest,
                ResultType: result.TaskRunResultType,
        })
        manifestSig := sc.mockSign(manifest, identity)
        output = append(output, result.RunResult{
                Key:        KeyResultManifest + KeySignatureSuffix,
                Value:      manifestSig,
                ResultType: result.TaskRunResultType,
        })

        return output, nil</span>
}

// Close mock closing the spire client connection
func (*MockClient) Close() error <span class="cov0" title="0">{ return nil }</span>

// SetConfig sets the spire configuration for MockClient
func (*MockClient) SetConfig(spireconfig.SpireConfig) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file510" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "crypto"
        "crypto/rand"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "fmt"
        "math/big"
        "net"
        "net/url"
        "testing"
        "time"

        "github.com/go-jose/go-jose/v3"
        "github.com/go-jose/go-jose/v3/cryptosigner"
        "github.com/go-jose/go-jose/v3/jwt"
        "github.com/spiffe/go-spiffe/v2/bundle/jwtbundle"
        "github.com/spiffe/go-spiffe/v2/bundle/spiffebundle"
        "github.com/spiffe/go-spiffe/v2/bundle/x509bundle"
        "github.com/spiffe/go-spiffe/v2/spiffeid"
        "github.com/spiffe/go-spiffe/v2/svid/jwtsvid"
        "github.com/spiffe/go-spiffe/v2/svid/x509svid"
        "github.com/tektoncd/pipeline/pkg/spire/test/x509util"
)

var (
        localhostIPs = []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback}
)

type CA struct {
        tb     testing.TB
        td     spiffeid.TrustDomain
        parent *CA
        cert   *x509.Certificate
        key    crypto.Signer
        jwtKey crypto.Signer
        jwtKid string
}

type CertificateOption interface {
        apply(*x509.Certificate)
}

type certificateOption func(*x509.Certificate)

func (co certificateOption) apply(c *x509.Certificate) <span class="cov0" title="0">{
        co(c)
}</span>

func NewCA(tb testing.TB, td spiffeid.TrustDomain) *CA <span class="cov0" title="0">{
        cert, key := CreateCACertificate(tb, nil, nil)
        return &amp;CA{
                tb:     tb,
                td:     td,
                cert:   cert,
                key:    key,
                jwtKey: NewEC256Key(tb),
                jwtKid: NewKeyID(tb),
        }
}</span>

func (ca *CA) ChildCA(options ...CertificateOption) *CA <span class="cov0" title="0">{
        cert, key := CreateCACertificate(ca.tb, ca.cert, ca.key, options...)
        return &amp;CA{
                tb:     ca.tb,
                parent: ca,
                cert:   cert,
                key:    key,
                jwtKey: NewEC256Key(ca.tb),
                jwtKid: NewKeyID(ca.tb),
        }
}</span>

func (ca *CA) CreateX509SVID(id spiffeid.ID, options ...CertificateOption) *x509svid.SVID <span class="cov0" title="0">{
        cert, key := CreateX509SVID(ca.tb, ca.cert, ca.key, id, options...)
        return &amp;x509svid.SVID{
                ID:           id,
                Certificates: append([]*x509.Certificate{cert}, ca.chain(false)...),
                PrivateKey:   key,
        }
}</span>

func (ca *CA) CreateX509Certificate(options ...CertificateOption) ([]*x509.Certificate, crypto.Signer) <span class="cov0" title="0">{
        cert, key := CreateX509Certificate(ca.tb, ca.cert, ca.key, options...)
        return append([]*x509.Certificate{cert}, ca.chain(false)...), key
}</span>

func (ca *CA) CreateJWTSVID(id spiffeid.ID, audience []string) *jwtsvid.SVID <span class="cov0" title="0">{
        claims := jwt.Claims{
                Subject:  id.String(),
                Issuer:   "FAKECA",
                Audience: audience,
                IssuedAt: jwt.NewNumericDate(time.Now()),
                Expiry:   jwt.NewNumericDate(time.Now().Add(time.Hour)),
        }

        jwtSigner, err := jose.NewSigner(
                jose.SigningKey{
                        Algorithm: jose.ES256,
                        Key: jose.JSONWebKey{
                                Key:   cryptosigner.Opaque(ca.jwtKey),
                                KeyID: ca.jwtKid,
                        },
                },
                new(jose.SignerOptions).WithType("JWT"),
        )
        if err != nil </span><span class="cov0" title="0">{
                ca.tb.Fatalf("failed to convert claims to Struct: %v", err)
        }</span>

        <span class="cov0" title="0">signedToken, err := jwt.Signed(jwtSigner).Claims(claims).CompactSerialize()
        if err != nil </span><span class="cov0" title="0">{
                ca.tb.Fatalf("failed to convert claims to Struct: %v", err)
        }</span>

        <span class="cov0" title="0">svid, err := jwtsvid.ParseInsecure(signedToken, audience)
        if err != nil </span><span class="cov0" title="0">{
                ca.tb.Fatalf("failed to convert claims to Struct: %v", err)
        }</span>
        <span class="cov0" title="0">return svid</span>
}

func (ca *CA) X509Authorities() []*x509.Certificate <span class="cov0" title="0">{
        root := ca
        for root.parent != nil </span><span class="cov0" title="0">{
                root = root.parent
        }</span>
        <span class="cov0" title="0">return []*x509.Certificate{root.cert}</span>
}

func (ca *CA) JWTAuthorities() map[string]crypto.PublicKey <span class="cov0" title="0">{
        return map[string]crypto.PublicKey{
                ca.jwtKid: ca.jwtKey.Public(),
        }
}</span>

func (ca *CA) Bundle() *spiffebundle.Bundle <span class="cov0" title="0">{
        bundle := spiffebundle.New(ca.td)
        bundle.SetX509Authorities(ca.X509Authorities())
        bundle.SetJWTAuthorities(ca.JWTAuthorities())
        return bundle
}</span>

func (ca *CA) X509Bundle() *x509bundle.Bundle <span class="cov0" title="0">{
        return x509bundle.FromX509Authorities(ca.td, ca.X509Authorities())
}</span>

func (ca *CA) JWTBundle() *jwtbundle.Bundle <span class="cov0" title="0">{
        return jwtbundle.FromJWTAuthorities(ca.td, ca.JWTAuthorities())
}</span>

func CreateCACertificate(tb testing.TB, parent *x509.Certificate, parentKey crypto.Signer, options ...CertificateOption) (*x509.Certificate, crypto.Signer) <span class="cov0" title="0">{
        now := time.Now()
        serial := NewSerial(tb)
        key := NewEC256Key(tb)
        tmpl := &amp;x509.Certificate{
                SerialNumber: serial,
                Subject: pkix.Name{
                        CommonName: fmt.Sprintf("CA %x", serial),
                },
                BasicConstraintsValid: true,
                IsCA:                  true,
                NotBefore:             now,
                NotAfter:              now.Add(time.Hour),
        }

        applyOptions(tmpl, options...)

        if parent == nil </span><span class="cov0" title="0">{
                parent = tmpl
                parentKey = key
        }</span>
        <span class="cov0" title="0">return CreateCertificate(tb, tmpl, parent, key.Public(), parentKey), key</span>
}

func CreateX509Certificate(tb testing.TB, parent *x509.Certificate, parentKey crypto.Signer, options ...CertificateOption) (*x509.Certificate, crypto.Signer) <span class="cov0" title="0">{
        now := time.Now()
        serial := NewSerial(tb)
        key := NewEC256Key(tb)
        tmpl := &amp;x509.Certificate{
                SerialNumber: serial,
                Subject: pkix.Name{
                        CommonName: fmt.Sprintf("X509-Certificate %x", serial),
                },
                NotBefore: now,
                NotAfter:  now.Add(time.Hour),
                KeyUsage:  x509.KeyUsageDigitalSignature,
        }

        applyOptions(tmpl, options...)

        return CreateCertificate(tb, tmpl, parent, key.Public(), parentKey), key
}</span>

func CreateX509SVID(tb testing.TB, parent *x509.Certificate, parentKey crypto.Signer, id spiffeid.ID, options ...CertificateOption) (*x509.Certificate, crypto.Signer) <span class="cov0" title="0">{
        serial := NewSerial(tb)
        options = append(options,
                WithSerial(serial),
                WithKeyUsage(x509.KeyUsageDigitalSignature),
                WithSubject(pkix.Name{
                        CommonName: fmt.Sprintf("X509-SVID %x", serial),
                }),
                WithURIs(id.URL()))

        return CreateX509Certificate(tb, parent, parentKey, options...)
}</span>

func CreateCertificate(tb testing.TB, tmpl, parent *x509.Certificate, pub, priv interface{}) *x509.Certificate <span class="cov0" title="0">{
        certDER, err := x509.CreateCertificate(rand.Reader, tmpl, parent, pub, priv)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("failed to create listener: %v", err)
        }</span>
        <span class="cov0" title="0">cert, err := x509.ParseCertificate(certDER)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("failed to create listener: %v", err)
        }</span>
        <span class="cov0" title="0">return cert</span>
}

func CreateWebCredentials(t testing.TB) (*x509.CertPool, *tls.Certificate) <span class="cov0" title="0">{
        rootCert, rootKey := CreateCACertificate(t, nil, nil)

        childCert, childKey := CreateX509Certificate(t, rootCert, rootKey,
                WithIPAddresses(localhostIPs...))

        return x509util.NewCertPool([]*x509.Certificate{rootCert}),
                &amp;tls.Certificate{
                        Certificate: [][]byte{childCert.Raw},
                        PrivateKey:  childKey,
                }
}</span>

func NewSerial(tb testing.TB) *big.Int <span class="cov0" title="0">{
        b := make([]byte, 8)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("failed to create listener: %v", err)
        }</span>
        <span class="cov0" title="0">return new(big.Int).SetBytes(b)</span>
}

func WithSerial(serial *big.Int) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.SerialNumber = serial
        }</span>)
}

func WithKeyUsage(keyUsage x509.KeyUsage) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.KeyUsage = keyUsage
        }</span>)
}

func WithLifetime(notBefore, notAfter time.Time) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.NotBefore = notBefore
                c.NotAfter = notAfter
        }</span>)
}

func WithIPAddresses(ips ...net.IP) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.IPAddresses = ips
        }</span>)
}

func WithURIs(uris ...*url.URL) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.URIs = uris
        }</span>)
}

func WithSubject(subject pkix.Name) CertificateOption <span class="cov0" title="0">{
        return certificateOption(func(c *x509.Certificate) </span><span class="cov0" title="0">{
                c.Subject = subject
        }</span>)
}

func applyOptions(c *x509.Certificate, options ...CertificateOption) <span class="cov0" title="0">{
        for _, opt := range options </span><span class="cov0" title="0">{
                opt.apply(c)
        }</span>
}

func (ca *CA) chain(includeRoot bool) []*x509.Certificate <span class="cov0" title="0">{
        chain := []*x509.Certificate{}
        next := ca
        for next != nil </span><span class="cov0" title="0">{
                if includeRoot || next.parent != nil </span><span class="cov0" title="0">{
                        chain = append(chain, next.cert)
                }</span>
                <span class="cov0" title="0">next = next.parent</span>
        }
        <span class="cov0" title="0">return chain</span>
}</pre>
		
		<pre class="file" id="file511" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "strings"
        "testing"
)

// Methods to generate private keys. If generation starts slowing down test
// execution then switch over to pre-generated keys.

// NewEC256Key returns an ECDSA key over the P256 curve
func NewEC256Key(tb testing.TB) *ecdsa.PrivateKey <span class="cov0" title="0">{
        key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                                tb.Fatalf("failed to marshal private key: %v", err)
                        }</span>
        <span class="cov0" title="0">return key</span>
}

// NewKeyID returns a random id useful for identifying keys
func NewKeyID(tb testing.TB) string <span class="cov0" title="0">{
        choices := make([]byte, 32)
        _, err := rand.Read(choices)
        if err != nil </span><span class="cov0" title="0">{
                                tb.Fatalf("failed to marshal private key: %v", err)
                        }</span>
        <span class="cov0" title="0">return keyIDFromBytes(choices)</span>
}

func keyIDFromBytes(choices []byte) string <span class="cov0" title="0">{
        const alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        var builder strings.Builder
        for _, choice := range choices </span><span class="cov0" title="0">{
                builder.WriteByte(alphabet[int(choice)%len(alphabet)])
        }</span>
        <span class="cov0" title="0">return builder.String()</span>
}</pre>
		
		<pre class="file" id="file512" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spire

import (
        "context"
        "crypto"
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "sort"
        "strings"

        "github.com/pkg/errors"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/result"
        "go.uber.org/zap"
)

// VerifyTaskRunResults ensures that the TaskRun results are valid and have not been tampered with
func (sc *spireControllerAPIClient) VerifyTaskRunResults(ctx context.Context, prs []result.RunResult, tr *v1beta1.TaskRun) error <span class="cov8" title="1">{
        err := sc.setupClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">resultMap := map[string]result.RunResult{}
        for _, r := range prs </span><span class="cov8" title="1">{
                if r.ResultType == result.TaskRunResultType </span><span class="cov8" title="1">{
                        resultMap[r.Key] = r
                }</span>
        }

        <span class="cov8" title="1">cert, err := getSVID(resultMap)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">trust, err := getTrustBundle(ctx, sc.workloadAPI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := verifyManifest(resultMap); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := verifyCertURI(cert, tr, sc.config.TrustDomain); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := verifyCertificateTrust(cert, trust); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for key := range resultMap </span><span class="cov8" title="1">{
                if strings.HasSuffix(key, KeySignatureSuffix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if key == KeySVID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if err := verifyResult(cert.PublicKey, key, resultMap); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyStatusInternalAnnotation run multuple verification steps to ensure that the spire status annotations are valid
func (sc *spireControllerAPIClient) VerifyStatusInternalAnnotation(ctx context.Context, tr *v1beta1.TaskRun, logger *zap.SugaredLogger) error <span class="cov8" title="1">{
        err := sc.setupClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !sc.CheckSpireVerifiedFlag(tr) </span><span class="cov8" title="1">{
                return errors.New("annotation tekton.dev/not-verified = yes failed spire verification")
        }</span>

        <span class="cov8" title="1">annotations := tr.Status.Annotations

        // get trust bundle from spire server
        trust, err := getTrustBundle(ctx, sc.workloadAPI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // verify controller SVID
        <span class="cov8" title="1">svid, ok := annotations[controllerSvidAnnotation]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("No SVID found")
        }</span>
        <span class="cov8" title="1">block, _ := pem.Decode([]byte(svid))
        if block == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid SVID: %w", err)
        }</span>
        <span class="cov8" title="1">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid SVID: %w", err)
        }</span>

        // verify certificate root of trust
        <span class="cov8" title="1">if err := verifyCertificateTrust(cert, trust); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("Successfully verified certificate %s against SPIRE", svid)

        if err := verifyAnnotation(cert.PublicKey, annotations); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Info("Successfully verified signature")

        // CheckStatusInternalAnnotation check current status hash vs annotation status hash by controller
        if err := CheckStatusInternalAnnotation(tr); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Info("Successfully verified status annotation hash matches the current taskrun status")

        return nil</span>
}

// CheckSpireVerifiedFlag checks if the verified status annotation is set which would result in spire verification failed
func (sc *spireControllerAPIClient) CheckSpireVerifiedFlag(tr *v1beta1.TaskRun) bool <span class="cov8" title="1">{
        if _, ok := tr.Status.Annotations[VerifiedAnnotation]; !ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func hashTaskrunStatusInternal(tr *v1beta1.TaskRun) (string, error) <span class="cov8" title="1">{
        s, err := json.Marshal(tr.Status.TaskRunStatusFields)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%x", sha256.Sum256(s)), nil</span>
}

// CheckStatusInternalAnnotation ensures that the internal status annotation hash and current status hash match
func CheckStatusInternalAnnotation(tr *v1beta1.TaskRun) error <span class="cov8" title="1">{
        // get stored hash of status
        annotations := tr.Status.Annotations
        hash, ok := annotations[TaskRunStatusHashAnnotation]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no annotation status hash found for %s", TaskRunStatusHashAnnotation)
        }</span>
        // get current hash of status
        <span class="cov8" title="1">current, err := hashTaskrunStatusInternal(tr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if hash != current </span><span class="cov8" title="1">{
                return fmt.Errorf("current status hash and stored annotation hash does not match! Annotation Hash: %s, Current Status Hash: %s", hash, current)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getSVID(resultMap map[string]result.RunResult) (*x509.Certificate, error) <span class="cov8" title="1">{
        svid, ok := resultMap[KeySVID]
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("no SVID found")
        }</span>
        <span class="cov8" title="1">svidValue, err := getResultValue(svid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">block, _ := pem.Decode([]byte(svidValue))
        if block == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid SVID: %w", err)
        }</span>
        <span class="cov8" title="1">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid SVID: %w", err)
        }</span>
        <span class="cov8" title="1">return cert, nil</span>
}

func getTrustBundle(ctx context.Context, client *workloadapi.Client) (*x509.CertPool, error) <span class="cov8" title="1">{
        x509set, err := client.FetchX509Bundles(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">x509Bundle := x509set.Bundles()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(x509Bundle) &gt; 0 </span><span class="cov8" title="1">{
                trustPool := x509.NewCertPool()
                for _, bundle := range x509Bundle </span><span class="cov8" title="1">{
                        for _, c := range bundle.X509Authorities() </span><span class="cov8" title="1">{
                                trustPool.AddCert(c)
                        }</span>
                        <span class="cov8" title="1">return trustPool, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.Wrap(err, "trust domain bundle empty")</span>
}

func getFullPath(tr *v1beta1.TaskRun) string <span class="cov8" title="1">{
        // URI:spiffe://example.org/ns/default/taskrun/cache-image-pipelinerun-r4r22-fetch-from-git
        return fmt.Sprintf("/ns/%s/taskrun/%s", tr.Namespace, tr.Name)
}</span>

func verifyCertURI(cert *x509.Certificate, tr *v1beta1.TaskRun, trustDomain string) error <span class="cov8" title="1">{
        path := getFullPath(tr)
        switch </span>{
        case len(cert.URIs) == 0:<span class="cov0" title="0">
                return fmt.Errorf("cert uri missing for taskrun: %s", tr.Name)</span>
        case len(cert.URIs) &gt; 1:<span class="cov0" title="0">
                return fmt.Errorf("cert contains more than one URI for taskrun: %s", tr.Name)</span>
        case len(cert.URIs) == 1:<span class="cov8" title="1">
                if cert.URIs[0].Host != trustDomain </span><span class="cov0" title="0">{
                        return fmt.Errorf("cert uri: %s does not match trust domain: %s", cert.URIs[0].Host, trustDomain)
                }</span>
                <span class="cov8" title="1">if cert.URIs[0].Path != path </span><span class="cov8" title="1">{
                        return fmt.Errorf("cert uri: %s does not match taskrun: %s", cert.URIs[0].Path, path)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func verifyCertificateTrust(cert *x509.Certificate, rootCertPool *x509.CertPool) error <span class="cov8" title="1">{
        verifyOptions := x509.VerifyOptions{
                Roots: rootCertPool,
        }
        chains, err := cert.Verify(verifyOptions)
        if len(chains) == 0 || err != nil </span><span class="cov0" title="0">{
                return errors.New("cert cannot be verified by provided roots")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func verifyManifest(results map[string]result.RunResult) error <span class="cov8" title="1">{
        manifest, ok := results[KeyResultManifest]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("no manifest found in results")
        }</span>
        <span class="cov8" title="1">manifestValue, err := getResultValue(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s := strings.Split(manifestValue, ",")
        for _, key := range s </span><span class="cov8" title="1">{
                _, found := results[key]
                if key != "" &amp;&amp; !found </span><span class="cov8" title="1">{
                        return fmt.Errorf("no result found for %s but is part of the manifest %s", key, manifestValue)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func verifyAnnotation(pub interface{}, annotations map[string]string) error <span class="cov8" title="1">{
        signature, ok := annotations[taskRunStatusHashSigAnnotation]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no signature found for %s", taskRunStatusHashSigAnnotation)
        }</span>
        <span class="cov8" title="1">hash, ok := annotations[TaskRunStatusHashAnnotation]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no annotation status hash found for %s", TaskRunStatusHashAnnotation)
        }</span>
        <span class="cov8" title="1">return verifySignature(pub, signature, hash)</span>
}

func verifyResult(pub crypto.PublicKey, key string, results map[string]result.RunResult) error <span class="cov8" title="1">{
        signature, ok := results[key+KeySignatureSuffix]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("no signature found for %s", key)
        }</span>
        <span class="cov8" title="1">sigValue, err := getResultValue(signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resultValue, err := getResultValue(results[key])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return verifySignature(pub, sigValue, resultValue)</span>
}

func verifySignature(pub crypto.PublicKey, signature string, value string) error <span class="cov8" title="1">{
        b, err := base64.StdEncoding.DecodeString(signature)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid signature: %w", err)
        }</span>
        <span class="cov8" title="1">h := sha256.Sum256([]byte(value))
        // Check val against sig
        switch t := pub.(type) </span>{
        case *ecdsa.PublicKey:<span class="cov8" title="1">
                if !ecdsa.VerifyASN1(t, h[:], b) </span><span class="cov8" title="1">{
                        return errors.New("invalid signature")
                }</span>
                <span class="cov8" title="1">return nil</span>
        case *rsa.PublicKey:<span class="cov0" title="0">
                return rsa.VerifyPKCS1v15(t, crypto.SHA256, h[:], b)</span>
        case ed25519.PublicKey:<span class="cov0" title="0">
                if !ed25519.Verify(t, []byte(value), b) </span><span class="cov0" title="0">{
                        return errors.New("invalid signature")
                }</span>
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported key type: %s", t)</span>
        }
}

func getResultValue(result result.RunResult) (string, error) <span class="cov8" title="1">{
        aos := v1beta1.ArrayOrString{}
        err := aos.UnmarshalJSON([]byte(result.Value))
        valList := []string{}
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unmarshal error for key: %s", result.Key)
        }</span>
        <span class="cov8" title="1">switch aos.Type </span>{
        case v1beta1.ParamTypeString:<span class="cov8" title="1">
                return aos.StringVal, nil</span>
        case v1beta1.ParamTypeArray:<span class="cov8" title="1">
                valList = append(valList, aos.ArrayVal...)
                return strings.Join(valList, ","), nil</span>
        case v1beta1.ParamTypeObject:<span class="cov8" title="1">
                keys := make([]string, 0, len(aos.ObjectVal))
                for k := range aos.ObjectVal </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)
                for _, k := range keys </span><span class="cov8" title="1">{
                        valList = append(valList, k)
                        valList = append(valList, aos.ObjectVal[k])
                }</span>
                <span class="cov8" title="1">return strings.Join(valList, ","), nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("invalid result type for key: %s", result.Key)</span>
}
</pre>
		
		<pre class="file" id="file513" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// GetTaskRunStatusForPipelineTask takes a child reference and returns the actual TaskRunStatus
// for the PipelineTask. It returns an error if the child reference's kind isn't TaskRun.
func GetTaskRunStatusForPipelineTask(ctx context.Context, client versioned.Interface, ns string, childRef v1.ChildStatusReference) (*v1.TaskRunStatus, error) <span class="cov8" title="1">{
        if childRef.Kind != "TaskRun" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not fetch status for PipelineTask %s: should have kind TaskRun, but is %s", childRef.PipelineTaskName, childRef.Kind)
        }</span>

        <span class="cov8" title="1">tr, err := client.TektonV1().TaskRuns(ns).Get(ctx, childRef.Name, metav1.GetOptions{})
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if tr == nil </span><span class="cov0" title="0">{
                return nil, nil //nolint:nilnil // would be more ergonomic to return a sentinel error
        }</span>

        <span class="cov8" title="1">return &amp;tr.Status, nil</span>
}

// GetCustomRunStatusForPipelineTask takes a child reference and returns the actual CustomRunStatus for the
// PipelineTask. It returns an error if the child reference's kind isn't CustomRun.
func GetCustomRunStatusForPipelineTask(ctx context.Context, client versioned.Interface, ns string, childRef v1.ChildStatusReference) (*v1beta1.CustomRunStatus, error) <span class="cov8" title="1">{
        var runStatus *v1beta1.CustomRunStatus

        switch childRef.Kind </span>{
        case "CustomRun":<span class="cov8" title="1">
                r, err := client.TektonV1beta1().CustomRuns(ns).Get(ctx, childRef.Name, metav1.GetOptions{})
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if r == nil </span><span class="cov0" title="0">{
                        return nil, nil //nolint:nilnil // would be more ergonomic to return a sentinel error
                }</span>
                <span class="cov8" title="1">runStatus = &amp;r.Status</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("could not fetch status for PipelineTask %s: should have kind CustomRun, but is %s", childRef.PipelineTaskName, childRef.Kind)</span>
        }

        <span class="cov8" title="1">return runStatus, nil</span>
}

// GetPipelineTaskStatuses returns populated TaskRun and Run status maps for a PipelineRun from its ChildReferences.
// If the PipelineRun has no ChildReferences, nothing will be populated.
func GetPipelineTaskStatuses(ctx context.Context, client versioned.Interface, ns string, pr *v1.PipelineRun) (map[string]*v1.PipelineRunTaskRunStatus,
        map[string]*v1.PipelineRunRunStatus, error) <span class="cov8" title="1">{
        // If the PipelineRun is nil, just return
        if pr == nil </span><span class="cov8" title="1">{
                return nil, nil, nil
        }</span>

        // If there are no child references or either TaskRuns or Runs is non-zero, return the existing TaskRuns and Runs maps
        <span class="cov8" title="1">if len(pr.Status.ChildReferences) == 0 </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>

        <span class="cov8" title="1">trStatuses := make(map[string]*v1.PipelineRunTaskRunStatus)
        runStatuses := make(map[string]*v1.PipelineRunRunStatus)

        for _, cr := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                switch cr.Kind </span>{
                case "TaskRun":<span class="cov8" title="1">
                        tr, err := client.TektonV1().TaskRuns(ns).Get(ctx, cr.Name, metav1.GetOptions{})
                        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        <span class="cov8" title="1">trStatuses[cr.Name] = &amp;v1.PipelineRunTaskRunStatus{
                                PipelineTaskName: cr.PipelineTaskName,
                                WhenExpressions:  cr.WhenExpressions,
                        }

                        if tr != nil </span><span class="cov8" title="1">{
                                trStatuses[cr.Name].Status = &amp;tr.Status
                        }</span>
                case "CustomRun":<span class="cov8" title="1">
                        r, err := client.TektonV1beta1().CustomRuns(ns).Get(ctx, cr.Name, metav1.GetOptions{})
                        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        <span class="cov8" title="1">runStatuses[cr.Name] = &amp;v1.PipelineRunRunStatus{
                                PipelineTaskName: cr.PipelineTaskName,
                                WhenExpressions:  cr.WhenExpressions,
                        }

                        if r != nil </span><span class="cov8" title="1">{
                                runStatuses[cr.Name].Status = &amp;r.Status
                        }</span>
                default:<span class="cov0" title="0"></span>
                        // Don't do anything for unknown types.
                }
        }

        <span class="cov8" title="1">return trStatuses, runStatuses, nil</span>
}
</pre>
		
		<pre class="file" id="file514" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package substitution

import (
        "fmt"
        "strings"
)

// ApplyReplacements returns a string with references to parameters replaced,
// based on the mapping provided in replacements.
// For example, if the input string is "foo: $(params.foo)", and replacements maps "params.foo" to "bar",
// the output would be "foo: bar".
func ApplyReplacements(in string, replacements map[string]string) string <span class="cov8" title="1">{
        replacementsList := []string{}
        for k, v := range replacements </span><span class="cov8" title="1">{
                replacementsList = append(replacementsList, fmt.Sprintf("$(%s)", k), v)
        }</span>
        // strings.Replacer does all replacements in one pass, preventing multiple replacements
        // See #2093 for an explanation on why we need to do this.
        <span class="cov8" title="1">replacer := strings.NewReplacer(replacementsList...)
        return replacer.Replace(in)</span>
}

// ApplyArrayReplacements takes an input string, and output an array of strings related to possible arrayReplacements. If there aren't any
// areas where the input can be split up via arrayReplacements, then just return an array with a single element,
// which is ApplyReplacements(in, replacements).
func ApplyArrayReplacements(in string, stringReplacements map[string]string, arrayReplacements map[string][]string) []string <span class="cov8" title="1">{
        for k, v := range arrayReplacements </span><span class="cov8" title="1">{
                stringToReplace := fmt.Sprintf("$(%s)", k)

                // If the input string matches a replacement's key (without padding characters), return the corresponding array.
                // Note that the webhook should prevent all instances where this could evaluate to false.
                if (strings.Count(in, stringToReplace) == 1) &amp;&amp; len(in) == len(stringToReplace) </span><span class="cov8" title="1">{
                        return v
                }</span>

                // same replace logic for star array expressions
                <span class="cov8" title="1">starStringtoReplace := fmt.Sprintf("$(%s[*])", k)
                if (strings.Count(in, starStringtoReplace) == 1) &amp;&amp; len(in) == len(starStringtoReplace) </span><span class="cov8" title="1">{
                        return v
                }</span>
        }

        // Otherwise return a size-1 array containing the input string with standard stringReplacements applied.
        <span class="cov8" title="1">return []string{ApplyReplacements(in, stringReplacements)}</span>
}
</pre>
		
		<pre class="file" id="file515" style="display: none">//go:build !disable_tls

/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package substitution

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

const (
        parameterSubstitution = `.*?(\[\*\])?`

        // braceMatchingRegex is a regex for parameter references including dot notation, bracket notation with single and double quotes.
        braceMatchingRegex = "(\\$(\\(%s(\\.(?P&lt;var1&gt;%s)|\\[\"(?P&lt;var2&gt;%s)\"\\]|\\['(?P&lt;var3&gt;%s)'\\])\\)))"
        // arrayIndexing will match all `[int]` and `[*]` for parseExpression
        arrayIndexing = `\[([0-9])*\*?\]`
        // paramIndex will match all `$(params.paramName[int])` expressions
        paramIndexing = `\$\(params(\.[_a-zA-Z0-9.-]+|\[\'[_a-zA-Z0-9.-\/]+\'\]|\[\"[_a-zA-Z0-9.-\/]+\"\])\[[0-9]+\]\)`
        // intIndex will match all `[int]` expressions
        intIndex = `\[[0-9]+\]`
)

// arrayIndexingRegex is used to match `[int]` and `[*]`
var arrayIndexingRegex = regexp.MustCompile(arrayIndexing)

// paramIndexingRegex will match all `$(params.paramName[int])` expressions
var paramIndexingRegex = regexp.MustCompile(paramIndexing)

// intIndexRegex will match all `[int]` for param expression
var intIndexRegex = regexp.MustCompile(intIndex)

// ValidateNoReferencesToUnknownVariables returns an error if the input string contains references to unknown variables
// Inputs:
// - value: a string containing a reference to a variable that can be substituted, e.g. "echo $(params.foo)"
// - prefix: the prefix of the substitutable variable, e.g. "params" or "context.pipeline"
// - vars: names of known variables
func ValidateNoReferencesToUnknownVariables(value, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        return validateNoReferencesToUnknownVariables(value, prefix, vars, false)
}</span>

// ValidateNoReferencesToUnknownVariablesWithDetail same as ValidateNoReferencesToUnknownVariables
// but with more prefix detailed error message
func ValidateNoReferencesToUnknownVariablesWithDetail(value, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        return validateNoReferencesToUnknownVariables(value, prefix, vars, true)
}</span>

func validateNoReferencesToUnknownVariables(value, prefix string, vars sets.String, withDetail bool) *apis.FieldError <span class="cov8" title="1">{
        if vs, present, errString := ExtractVariablesFromString(value, prefix); present </span><span class="cov8" title="1">{
                if errString != "" </span><span class="cov8" title="1">{
                        return &amp;apis.FieldError{
                                Message: errString,
                                Paths:   []string{""},
                        }
                }</span>
                <span class="cov8" title="1">for _, v := range vs </span><span class="cov8" title="1">{
                        v = TrimArrayIndex(v)
                        if !vars.Has(v) </span><span class="cov8" title="1">{
                                var msg string
                                if withDetail </span><span class="cov8" title="1">{
                                        msg = fmt.Sprintf("non-existent variable `%s` in %q", v, value)
                                }</span> else<span class="cov8" title="1"> {
                                        msg = fmt.Sprintf("non-existent variable in %q", value)
                                }</span>
                                <span class="cov8" title="1">return &amp;apis.FieldError{
                                        Message: msg,
                                        // Empty path is required to make the `ViaField`,  work
                                        Paths: []string{""},
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateNoReferencesToProhibitedVariables returns an error if the input string contains any references to any variables in vars,
// except for array indexing references.
//
// Inputs:
// - value: a string containing a reference to a variable that can be substituted, e.g. "echo $(params.foo)"
// - prefix: the prefix of the substitutable variable, e.g. "params" or "context.pipeline"
// - vars: names of known variables
func ValidateNoReferencesToProhibitedVariables(value, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        if vs, present, errString := ExtractVariablesFromString(value, prefix); present </span><span class="cov8" title="1">{
                if errString != "" </span><span class="cov0" title="0">{
                        return &amp;apis.FieldError{
                                Message: errString,
                                Paths:   []string{""},
                        }
                }</span>
                <span class="cov8" title="1">for _, v := range vs </span><span class="cov8" title="1">{
                        v = strings.TrimSuffix(v, "[*]")
                        if vars.Has(v) </span><span class="cov8" title="1">{
                                return &amp;apis.FieldError{
                                        Message: fmt.Sprintf("variable type invalid in %q", value),
                                        // Empty path is required to make the `ViaField`,  work
                                        Paths: []string{""},
                                }
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateNoReferencesToEntireProhibitedVariables returns an error if the input string contains any whole array/object references
// to any variables in vars. References to array indexes or object keys are permitted.
//
// Inputs:
// - value: a string containing a reference to a variable that can be substituted, e.g. "echo $(params.foo)"
// - prefix: the prefix of the substitutable variable, e.g. "params" or "context.pipeline"
// - vars: names of known variables
func ValidateNoReferencesToEntireProhibitedVariables(value, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        paths := []string{""} // Empty path is required to make the `ViaField`,  work
        vs, err := extractEntireVariablesFromString(value, prefix)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("extractEntireVariablesFromString failed : %v", err),
                        Paths:   paths,
                }
        }</span>

        <span class="cov8" title="1">for _, v := range vs </span><span class="cov8" title="1">{
                v = strings.TrimSuffix(v, "[*]")
                if vars.Has(v) </span><span class="cov8" title="1">{
                        return &amp;apis.FieldError{
                                Message: fmt.Sprintf("variable type invalid in %q", value),
                                Paths:   paths,
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateVariableReferenceIsIsolated returns an error if the input string contains characters in addition to references to known parameters.
// For example, if "foo" is a known parameter, a value of "foo: $(params.foo)" returns an error, but a value of "$(params.foo)" does not.
// Inputs:
// - value: a string containing a reference to a variable that can be substituted, e.g. "echo $(params.foo)"
// - prefix: the prefix of the substitutable variable, e.g. "params" or "context.pipeline"
// - vars: names of known variables
func ValidateVariableReferenceIsIsolated(value, prefix string, vars sets.String) *apis.FieldError <span class="cov8" title="1">{
        paths := []string{""} // Empty path is required to make the `ViaField`,  work
        if vs, present, errString := ExtractVariablesFromString(value, prefix); present </span><span class="cov8" title="1">{
                if errString != "" </span><span class="cov0" title="0">{
                        return &amp;apis.FieldError{
                                Message: errString,
                                Paths:   paths,
                        }
                }</span>
                <span class="cov8" title="1">firstMatch, err := extractExpressionFromString(value, prefix)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;apis.FieldError{
                                Message: err.Error(),
                                Paths:   paths,
                        }
                }</span>
                <span class="cov8" title="1">for _, v := range vs </span><span class="cov8" title="1">{
                        v = strings.TrimSuffix(v, "[*]")
                        if vars.Has(v) </span><span class="cov8" title="1">{
                                if len(value) != len(firstMatch) </span><span class="cov8" title="1">{
                                        return &amp;apis.FieldError{
                                                Message: fmt.Sprintf("variable is not properly isolated in %q", value),
                                                Paths:   paths,
                                        }
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateWholeArrayOrObjectRefInStringVariable validates if a single string field uses references to the whole array/object appropriately
// valid example: "$(params.myObject[*])"
// invalid example: "$(params.name-not-exist[*])"
func ValidateWholeArrayOrObjectRefInStringVariable(name, value, prefix string, vars sets.String) (isIsolated bool, errs *apis.FieldError) <span class="cov0" title="0">{
        nameSubstitution := `[_a-zA-Z0-9.-]+\[\*\]`

        // a regex to check if the stringValue is an isolated reference to the whole array/object param without extra string literal.
        isolatedVariablePattern := fmt.Sprintf(fmt.Sprintf("^%s$", braceMatchingRegex), prefix, nameSubstitution, nameSubstitution, nameSubstitution)
        isolatedVariableRegex, err := regexp.Compile(isolatedVariablePattern)
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;apis.FieldError{
                        Message: fmt.Sprint("Fail to parse the regex: ", err),
                        Paths:   []string{fmt.Sprintf("%s.%s", prefix, name)},
                }
        }</span>

        <span class="cov0" title="0">if isolatedVariableRegex.MatchString(value) </span><span class="cov0" title="0">{
                return true, ValidateNoReferencesToUnknownVariables(value, prefix, vars).ViaFieldKey(prefix, name)
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// extract a the first full string expressions found (e.g "$(input.params.foo)").
// Returns "" if nothing is found.
func extractExpressionFromString(s, prefix string) (string, error) <span class="cov8" title="1">{
        pattern := fmt.Sprintf(braceMatchingRegex, prefix, parameterSubstitution, parameterSubstitution, parameterSubstitution)
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">match := re.FindStringSubmatch(s)
        if match == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return match[0], nil</span>
}

// ExtractVariablesFromString extracts variables from an input string s with the given prefix via regex matching.
// It returns a slice of strings which contains the extracted variables, a bool flag to indicate if matches were found
// and the error string if the referencing of parameters is invalid.
// If the string does not contain the input prefix then the output will contain a slice of strings with length 0.
func ExtractVariablesFromString(s, prefix string) ([]string, bool, string) <span class="cov8" title="1">{
        pattern := fmt.Sprintf(braceMatchingRegex, prefix, parameterSubstitution, parameterSubstitution, parameterSubstitution)
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, ""
        }</span>
        <span class="cov8" title="1">matches := re.FindAllStringSubmatch(s, -1)
        errString := ""
        // Input string does not contain the prefix and therefore not matches are found.
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return []string{}, false, ""
        }</span>
        <span class="cov8" title="1">vars := make([]string, len(matches))
        for i, match := range matches </span><span class="cov8" title="1">{
                groups := matchGroups(match, re)
                for j, v := range []string{"var1", "var2", "var3"} </span><span class="cov8" title="1">{
                        val := groups[v]
                        // If using the dot notation, the number of dot-separated components is restricted up to 2.
                        // Valid Examples:
                        //  - extract "aString" from &lt;prefix&gt;.aString
                        //  - extract "anObject" from &lt;prefix&gt;.anObject.key
                        // Invalid Examples:
                        //  - &lt;prefix&gt;.foo.bar.baz....
                        if j == 0 &amp;&amp; strings.Contains(val, ".") </span><span class="cov8" title="1">{
                                if len(strings.Split(val, ".")) &gt; 2 </span><span class="cov8" title="1">{
                                        errString = fmt.Sprintf(`Invalid referencing of parameters in "%s"! Only two dot-separated components after the prefix "%s" are allowed.`, s, prefix)
                                        return vars, true, errString
                                }</span>
                                <span class="cov8" title="1">vars[i] = strings.SplitN(val, ".", 2)[0]
                                break</span>
                        }
                        <span class="cov8" title="1">if val != "" </span><span class="cov8" title="1">{
                                vars[i] = val
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return vars, true, errString</span>
}

// extractEntireVariablesFromString returns any references to entire array or object params in s with the given prefix
func extractEntireVariablesFromString(s, prefix string) ([]string, error) <span class="cov8" title="1">{
        pattern := fmt.Sprintf(braceMatchingRegex, prefix, parameterSubstitution, parameterSubstitution, parameterSubstitution)
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse regex pattern: %w", err)
        }</span>

        <span class="cov8" title="1">matches := re.FindAllStringSubmatch(s, -1)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov8" title="1">vars := make([]string, len(matches))
        for i, match := range matches </span><span class="cov8" title="1">{
                groups := matchGroups(match, re)
                // foo -&gt; foo
                // foo.bar -&gt; foo.bar
                // foo.bar.baz -&gt; foo.bar.baz
                for _, v := range []string{"var1", "var2", "var3"} </span><span class="cov8" title="1">{
                        val := groups[v]
                        if val != "" </span><span class="cov8" title="1">{
                                vars[i] = val
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return vars, nil</span>
}

func matchGroups(matches []string, pattern *regexp.Regexp) map[string]string <span class="cov8" title="1">{
        groups := make(map[string]string)
        for i, name := range pattern.SubexpNames()[1:] </span><span class="cov8" title="1">{
                groups[name] = matches[i+1]
        }</span>
        <span class="cov8" title="1">return groups</span>
}

// TrimArrayIndex replaces all `[i]` and `[*]` to "".
func TrimArrayIndex(s string) string <span class="cov8" title="1">{
        return arrayIndexingRegex.ReplaceAllString(s, "")
}</span>

// ExtractArrayIndexingParamsExpressions will find all  `$(params.paramName[int])` expressions
func ExtractArrayIndexingParamsExpressions(s string) []string <span class="cov8" title="1">{
        return paramIndexingRegex.FindAllString(s, -1)
}</span>

func ExtractVariableExpressions(s, prefix string) ([]string, error) <span class="cov8" title="1">{
        pattern := fmt.Sprintf(braceMatchingRegex, prefix, parameterSubstitution, parameterSubstitution, parameterSubstitution)
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse regex pattern: %w", err)
        }</span>

        <span class="cov8" title="1">matches := re.FindAllString(s, -1)
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return []string{}, nil
        }</span>
        <span class="cov8" title="1">return matches, nil</span>
}

// ExtractIndexString will find the leftmost match of `[int]`
func ExtractIndexString(s string) string <span class="cov8" title="1">{
        return intIndexRegex.FindString(s)
}</span>

// ExtractIndex will extract int from `[int]`
func ExtractIndex(s string) (int, error) <span class="cov8" title="1">{
        return strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(s, "["), "]"))
}</span>

// StripStarVarSubExpression strips "$(target[*])"" to get "target"
func StripStarVarSubExpression(s string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimSuffix(strings.TrimPrefix(s, "$("), ")"), "[*]")
}</span>
</pre>
		
		<pre class="file" id="file516" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fake

import (
        "context"

        _ "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/fake" // Make sure the fake taskrun informer is setup
        "github.com/tektoncd/pipeline/pkg/taskrunmetrics"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return taskrunmetrics.WithClient(ctx) }</span>)
        <span class="cov0" title="0">injection.Fake.RegisterInformer(taskrunmetrics.WithInformer)</span>
}
</pre>
		
		<pre class="file" id="file517" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrunmetrics

import (
        "context"

        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
        <span class="cov8" title="1">injection.Default.RegisterInformer(WithInformer)</span>
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

// WithClient adds a metrics recorder to the given context
func WithClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create taskrun metrics recorder %v", err)
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the taskrunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov0" title="0">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *taskrunmetrics.Recorder from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*Recorder)</span>
}

// InformerKey is used for associating the Informer inside the context.Context.
type InformerKey struct{}

// WithInformer returns the given context, and a configured informer
func WithInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        return ctx, &amp;recorderInformer{
                ctx:     ctx,
                metrics: Get(ctx),
                lister:  taskruninformer.Get(ctx).Lister(),
        }
}</span>

type recorderInformer struct {
        ctx     context.Context
        metrics *Recorder
        lister  listers.TaskRunLister
}

var _ controller.Informer = (*recorderInformer)(nil)

// Run starts the recorder informer in a goroutine
func (ri *recorderInformer) Run(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Turn the stopCh into a context for reporting metrics.
        ctx, cancel := context.WithCancel(ri.ctx)
        go func() </span><span class="cov0" title="0">{
                &lt;-stopCh
                cancel()
        }</span>()

        <span class="cov0" title="0">go ri.metrics.ReportRunningTaskRuns(ctx, ri.lister)</span>
}

// HasSynced returns whether the informer has synced, which in this case will always be true.
func (ri *recorderInformer) HasSynced() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file518" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrunmetrics

import (
        "context"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/pkg/errors"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/pod"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "golang.org/x/crypto/blake2b"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"
)

const anonymous = "anonymous"

var (
        pipelinerunTag = tag.MustNewKey("pipelinerun")
        pipelineTag    = tag.MustNewKey("pipeline")
        taskrunTag     = tag.MustNewKey("taskrun")
        taskTag        = tag.MustNewKey("task")
        namespaceTag   = tag.MustNewKey("namespace")
        statusTag      = tag.MustNewKey("status")
        reasonTag      = tag.MustNewKey("reason")
        podTag         = tag.MustNewKey("pod")

        trDurationView                             *view.View
        prTRDurationView                           *view.View
        trTotalView                                *view.View
        runningTRsView                             *view.View
        runningTRsThrottledByQuotaView             *view.View
        runningTRsThrottledByNodeView              *view.View
        runningTRsWaitingOnTaskResolutionCountView *view.View
        podLatencyView                             *view.View

        trDuration = stats.Float64(
                "taskrun_duration_seconds",
                "The taskrun's execution time in seconds",
                stats.UnitDimensionless)

        prTRDuration = stats.Float64(
                "pipelinerun_taskrun_duration_seconds",
                "The pipelinerun's taskrun execution time in seconds",
                stats.UnitDimensionless)

        trTotal = stats.Float64("taskrun_total",
                "Number of taskruns",
                stats.UnitDimensionless)

        runningTRs = stats.Float64("running_taskruns",
                "Number of taskruns executing currently",
                stats.UnitDimensionless)

        runningTRsWaitingOnTaskResolutionCount = stats.Float64("running_taskruns_waiting_on_task_resolution_count",
                "Number of taskruns executing currently that are waiting on resolution requests for their task references.",
                stats.UnitDimensionless)

        runningTRsThrottledByQuota = stats.Float64("running_taskruns_throttled_by_quota",
                "Number of taskruns executing currently, but whose underlying Pods or Containers are suspended by k8s because of defined ResourceQuotas.  Such suspensions can occur as part of initial scheduling of the Pod, or scheduling of any of the subsequent Container(s) in the Pod after the first Container is started",
                stats.UnitDimensionless)

        runningTRsThrottledByNode = stats.Float64("running_taskruns_throttled_by_node",
                "Number of taskruns executing currently, but whose underlying Pods or Containers are suspended by k8s because of Node level constraints. Such suspensions can occur as part of initial scheduling of the Pod, or scheduling of any of the subsequent Container(s) in the Pod after the first Container is started",
                stats.UnitDimensionless)

        podLatency = stats.Float64("taskruns_pod_latency_milliseconds",
                "scheduling latency for the taskruns pods",
                stats.UnitMilliseconds)
)

// Recorder is used to actually record TaskRun metrics
type Recorder struct {
        mutex       sync.Mutex
        initialized bool
        cfg         *config.Metrics

        ReportingPeriod time.Duration

        insertTaskTag func(task,
                taskrun string) []tag.Mutator

        insertPipelineTag func(pipeline,
                pipelinerun string) []tag.Mutator

        hash string
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once           sync.Once
        r              *Recorder
        errRegistering error
)

// NewRecorder creates a new metrics recorder instance
// to log the TaskRun related metrics
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                cfg := config.FromContextOrDefaults(ctx)
                r = &amp;Recorder{
                        initialized: true,
                        cfg:         cfg.Metrics,

                        // Default to reporting metrics every 30s.
                        ReportingPeriod: 30 * time.Second,
                }

                errRegistering = viewRegister(cfg.Metrics)
                if errRegistering != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, errRegistering</span>
}

func viewRegister(cfg *config.Metrics) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        var prunTag []tag.Key
        switch cfg.PipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipelinerun:<span class="cov8" title="1">
                prunTag = []tag.Key{pipelineTag, pipelinerunTag}
                r.insertPipelineTag = pipelinerunInsertTag</span>
        case config.PipelinerunLevelAtPipeline:<span class="cov0" title="0">
                prunTag = []tag.Key{pipelineTag}
                r.insertPipelineTag = pipelineInsertTag</span>
        case config.PipelinerunLevelAtNS:<span class="cov8" title="1">
                prunTag = []tag.Key{}
                r.insertPipelineTag = nilInsertTag</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid config for PipelinerunLevel: " + cfg.PipelinerunLevel)</span>
        }

        <span class="cov8" title="1">var trunTag []tag.Key
        switch cfg.TaskrunLevel </span>{
        case config.TaskrunLevelAtTaskrun:<span class="cov8" title="1">
                trunTag = []tag.Key{taskTag, taskrunTag}
                r.insertTaskTag = taskrunInsertTag</span>
        case config.TaskrunLevelAtTask:<span class="cov0" title="0">
                trunTag = []tag.Key{taskTag}
                r.insertTaskTag = taskInsertTag</span>
        case config.PipelinerunLevelAtNS:<span class="cov8" title="1">
                trunTag = []tag.Key{}
                r.insertTaskTag = nilInsertTag</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid config for TaskrunLevel: " + cfg.TaskrunLevel)</span>
        }

        <span class="cov8" title="1">distribution := view.Distribution(10, 30, 60, 300, 900, 1800, 3600, 5400, 10800, 21600, 43200, 86400)

        if cfg.TaskrunLevel == config.TaskrunLevelAtTaskrun ||
                cfg.PipelinerunLevel == config.PipelinerunLevelAtPipelinerun </span><span class="cov8" title="1">{
                distribution = view.LastValue()
        }</span> else<span class="cov8" title="1"> {
                switch cfg.DurationTaskrunType </span>{
                case config.DurationTaskrunTypeHistogram:<span class="cov0" title="0"></span>
                case config.DurationTaskrunTypeLastValue:<span class="cov8" title="1">
                        distribution = view.LastValue()</span>
                default:<span class="cov0" title="0">
                        return errors.New("invalid config for DurationTaskrunType: " + cfg.DurationTaskrunType)</span>
                }
        }

        <span class="cov8" title="1">if cfg.CountWithReason </span><span class="cov8" title="1">{
                trunTag = append(trunTag, reasonTag)
        }</span>

        <span class="cov8" title="1">trDurationView = &amp;view.View{
                Description: trDuration.Description(),
                Measure:     trDuration,
                Aggregation: distribution,
                TagKeys:     append([]tag.Key{statusTag, namespaceTag}, trunTag...),
        }
        prTRDurationView = &amp;view.View{
                Description: prTRDuration.Description(),
                Measure:     prTRDuration,
                Aggregation: distribution,
                TagKeys:     append([]tag.Key{statusTag, namespaceTag}, append(trunTag, prunTag...)...),
        }

        trTotalView = &amp;view.View{
                Description: trTotal.Description(),
                Measure:     trTotal,
                Aggregation: view.Count(),
                TagKeys:     []tag.Key{statusTag},
        }

        runningTRsView = &amp;view.View{
                Description: runningTRs.Description(),
                Measure:     runningTRs,
                Aggregation: view.LastValue(),
        }
        runningTRsWaitingOnTaskResolutionCountView = &amp;view.View{
                Description: runningTRsWaitingOnTaskResolutionCount.Description(),
                Measure:     runningTRsWaitingOnTaskResolutionCount,
                Aggregation: view.LastValue(),
        }

        throttleViewTags := []tag.Key{}
        if cfg.ThrottleWithNamespace </span><span class="cov8" title="1">{
                throttleViewTags = append(throttleViewTags, namespaceTag)
        }</span>
        <span class="cov8" title="1">runningTRsThrottledByQuotaView = &amp;view.View{
                Description: runningTRsThrottledByQuota.Description(),
                Measure:     runningTRsThrottledByQuota,
                Aggregation: view.LastValue(),
                TagKeys:     throttleViewTags,
        }
        runningTRsThrottledByNodeView = &amp;view.View{
                Description: runningTRsThrottledByNode.Description(),
                Measure:     runningTRsThrottledByNode,
                Aggregation: view.LastValue(),
                TagKeys:     throttleViewTags,
        }
        podLatencyView = &amp;view.View{
                Description: podLatency.Description(),
                Measure:     podLatency,
                Aggregation: view.LastValue(),
                TagKeys:     append([]tag.Key{namespaceTag, podTag}, trunTag...),
        }
        return view.Register(
                trDurationView,
                prTRDurationView,
                trTotalView,
                runningTRsView,
                runningTRsWaitingOnTaskResolutionCountView,
                runningTRsThrottledByQuotaView,
                runningTRsThrottledByNodeView,
                podLatencyView,
        )</span>
}

func viewUnregister() <span class="cov8" title="1">{
        view.Unregister(
                trDurationView,
                prTRDurationView,
                trTotalView,
                runningTRsView,
                runningTRsWaitingOnTaskResolutionCountView,
                runningTRsThrottledByQuotaView,
                runningTRsThrottledByNodeView,
                podLatencyView,
        )
}</span>

// OnStore returns a function that checks if metrics are configured for a config.Store, and registers it if so
func OnStore(logger *zap.SugaredLogger, r *Recorder) func(name string, value interface{}) <span class="cov8" title="1">{
        return func(name string, value interface{}) </span><span class="cov8" title="1">{
                if name == config.GetMetricsConfigName() </span><span class="cov8" title="1">{
                        cfg, ok := value.(*config.Metrics)
                        if !ok </span><span class="cov8" title="1">{
                                logger.Error("Failed to do type insertion for extracting metrics config")
                                return
                        }</span>
                        <span class="cov8" title="1">updated := r.updateConfig(cfg)
                        if !updated </span><span class="cov8" title="1">{
                                return
                        }</span>
                        // Update metrics according to the configuration
                        <span class="cov8" title="1">viewUnregister()
                        err := viewRegister(cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to register View %v ", err)
                                return
                        }</span>
                }
        }
}

func pipelinerunInsertTag(pipeline, pipelinerun string) []tag.Mutator <span class="cov8" title="1">{
        return []tag.Mutator{
                tag.Insert(pipelineTag, pipeline),
                tag.Insert(pipelinerunTag, pipelinerun),
        }
}</span>

func pipelineInsertTag(pipeline, pipelinerun string) []tag.Mutator <span class="cov0" title="0">{
        return []tag.Mutator{tag.Insert(pipelineTag, pipeline)}
}</span>

func taskrunInsertTag(task, taskrun string) []tag.Mutator <span class="cov8" title="1">{
        return []tag.Mutator{
                tag.Insert(taskTag, task),
                tag.Insert(taskrunTag, taskrun),
        }
}</span>

func taskInsertTag(task, taskrun string) []tag.Mutator <span class="cov0" title="0">{
        return []tag.Mutator{tag.Insert(taskTag, task)}
}</span>

func nilInsertTag(task, taskrun string) []tag.Mutator <span class="cov0" title="0">{
        return []tag.Mutator{}
}</span>

func getTaskTagName(tr *v1.TaskRun) string <span class="cov8" title="1">{
        taskName := anonymous
        switch </span>{
        case tr.Spec.TaskRef != nil &amp;&amp; len(tr.Spec.TaskRef.Name) &gt; 0:<span class="cov8" title="1">
                taskName = tr.Spec.TaskRef.Name</span>
        case tr.Spec.TaskSpec != nil:<span class="cov8" title="1">
                pipelineTaskTable, hasPipelineTaskTable := tr.Labels[pipeline.PipelineTaskLabelKey]
                if hasPipelineTaskTable &amp;&amp; len(pipelineTaskTable) &gt; 0 </span><span class="cov8" title="1">{
                        taskName = pipelineTaskTable
                }</span>
        default:<span class="cov8" title="1">
                if len(tr.Labels) &gt; 0 </span><span class="cov8" title="1">{
                        taskLabel, hasTaskLabel := tr.Labels[pipeline.TaskLabelKey]
                        if hasTaskLabel &amp;&amp; len(taskLabel) &gt; 0 </span><span class="cov8" title="1">{
                                taskName = taskLabel
                        }</span>
                }
        }

        <span class="cov8" title="1">return taskName</span>
}

func (r *Recorder) updateConfig(cfg *config.Metrics) bool <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        var hash string
        if cfg != nil </span><span class="cov8" title="1">{
                s := fmt.Sprintf("%v", *cfg)
                sum := blake2b.Sum256([]byte(s))
                hash = hex.EncodeToString(sum[:])
        }</span>

        <span class="cov8" title="1">if r.hash == hash </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">r.cfg = cfg
        r.hash = hash

        return true</span>
}

// DurationAndCount logs the duration of TaskRun execution and
// count for number of TaskRuns succeed or failed
// returns an error if its failed to log the metrics
func (r *Recorder) DurationAndCount(ctx context.Context, tr *v1.TaskRun, beforeCondition *apis.Condition) error <span class="cov8" title="1">{
        if !r.initialized </span><span class="cov8" title="1">{
                return fmt.Errorf("ignoring the metrics recording for %s , failed to initialize the metrics recorder", tr.Name)
        }</span>

        <span class="cov8" title="1">afterCondition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if equality.Semantic.DeepEqual(beforeCondition, afterCondition) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">r.mutex.Lock()
        defer r.mutex.Unlock()

        duration := time.Since(tr.Status.StartTime.Time)
        if tr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                duration = tr.Status.CompletionTime.Sub(tr.Status.StartTime.Time)
        }</span>

        <span class="cov8" title="1">taskName := getTaskTagName(tr)

        cond := tr.Status.GetCondition(apis.ConditionSucceeded)
        status := "success"
        if cond.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                status = "failed"
        }</span>
        <span class="cov8" title="1">reason := cond.Reason

        durationStat := trDuration
        tags := []tag.Mutator{tag.Insert(namespaceTag, tr.Namespace), tag.Insert(statusTag, status), tag.Insert(reasonTag, reason)}
        if ok, pipeline, pipelinerun := IsPartOfPipeline(tr); ok </span><span class="cov8" title="1">{
                durationStat = prTRDuration
                tags = append(tags, r.insertPipelineTag(pipeline, pipelinerun)...)
        }</span>
        <span class="cov8" title="1">tags = append(tags, r.insertTaskTag(taskName, tr.Name)...)

        ctx, err := tag.New(ctx, tags...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, durationStat.M(duration.Seconds()))
        metrics.Record(ctx, trTotal.M(1))

        return nil</span>
}

// RunningTaskRuns logs the number of TaskRuns running right now
// returns an error if its failed to log the metrics
func (r *Recorder) RunningTaskRuns(ctx context.Context, lister listers.TaskRunLister) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if !r.initialized </span><span class="cov8" title="1">{
                return errors.New("ignoring the metrics recording, failed to initialize the metrics recorder")
        }</span>

        <span class="cov8" title="1">trs, err := lister.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">addNamespaceLabelToQuotaThrottleMetric := r.cfg != nil &amp;&amp; r.cfg.ThrottleWithNamespace

        var runningTrs int
        trsThrottledByQuota := map[string]int{}
        trsThrottledByNode := map[string]int{}
        var trsWaitResolvingTaskRef int
        for _, pr := range trs </span><span class="cov8" title="1">{
                // initialize metrics with namespace tag to zero if unset; will then update as needed below
                _, ok := trsThrottledByQuota[pr.Namespace]
                if !ok </span><span class="cov8" title="1">{
                        trsThrottledByQuota[pr.Namespace] = 0
                }</span>
                <span class="cov8" title="1">_, ok = trsThrottledByNode[pr.Namespace]
                if !ok </span><span class="cov8" title="1">{
                        trsThrottledByNode[pr.Namespace] = 0
                }</span>

                <span class="cov8" title="1">if pr.IsDone() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">runningTrs++

                succeedCondition := pr.Status.GetCondition(apis.ConditionSucceeded)
                if succeedCondition != nil &amp;&amp; succeedCondition.Status == corev1.ConditionUnknown </span><span class="cov8" title="1">{
                        switch succeedCondition.Reason </span>{
                        case pod.ReasonExceededResourceQuota:<span class="cov8" title="1">
                                cnt := trsThrottledByQuota[pr.Namespace]
                                cnt++
                                trsThrottledByQuota[pr.Namespace] = cnt</span>
                        case pod.ReasonExceededNodeResources:<span class="cov8" title="1">
                                cnt := trsThrottledByNode[pr.Namespace]
                                cnt++
                                trsThrottledByNode[pr.Namespace] = cnt</span>
                        case v1.TaskRunReasonResolvingTaskRef:<span class="cov8" title="1">
                                trsWaitResolvingTaskRef++</span>
                        }
                }
        }

        <span class="cov8" title="1">ctx, err = tag.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metrics.Record(ctx, runningTRs.M(float64(runningTrs)))
        metrics.Record(ctx, runningTRsWaitingOnTaskResolutionCount.M(float64(trsWaitResolvingTaskRef)))

        for ns, cnt := range trsThrottledByQuota </span><span class="cov8" title="1">{
                var mutators []tag.Mutator
                if addNamespaceLabelToQuotaThrottleMetric </span><span class="cov8" title="1">{
                        mutators = []tag.Mutator{tag.Insert(namespaceTag, ns)}
                }</span>
                <span class="cov8" title="1">ctx, err := tag.New(ctx, mutators...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">metrics.Record(ctx, runningTRsThrottledByQuota.M(float64(cnt)))</span>
        }
        <span class="cov8" title="1">for ns, cnt := range trsThrottledByNode </span><span class="cov8" title="1">{
                var mutators []tag.Mutator
                if addNamespaceLabelToQuotaThrottleMetric </span><span class="cov8" title="1">{
                        mutators = []tag.Mutator{tag.Insert(namespaceTag, ns)}
                }</span>
                <span class="cov8" title="1">ctx, err := tag.New(ctx, mutators...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">metrics.Record(ctx, runningTRsThrottledByNode.M(float64(cnt)))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ReportRunningTaskRuns invokes RunningTaskRuns on our configured PeriodSeconds
// until the context is cancelled.
func (r *Recorder) ReportRunningTaskRuns(ctx context.Context, lister listers.TaskRunLister) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        for </span><span class="cov0" title="0">{
                delay := time.NewTimer(r.ReportingPeriod)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // When the context is cancelled, stop reporting.
                        if !delay.Stop() </span><span class="cov0" title="0">{
                                &lt;-delay.C
                        }</span>
                        <span class="cov0" title="0">return</span>

                case &lt;-delay.C:<span class="cov0" title="0">
                        // Every 30s surface a metric for the number of running tasks, as well as those running tasks that are currently throttled by k8s,
                        // and those running tasks waiting on task reference resolution
                        if err := r.RunningTaskRuns(ctx, lister); err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to log the metrics : %v", err)
                        }</span>
                }
        }
}

// RecordPodLatency logs the duration required to schedule the pod for TaskRun
// returns an error if its failed to log the metrics
func (r *Recorder) RecordPodLatency(ctx context.Context, pod *corev1.Pod, tr *v1.TaskRun) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if !r.initialized </span><span class="cov8" title="1">{
                return errors.New("ignoring the metrics recording for pod , failed to initialize the metrics recorder")
        }</span>

        <span class="cov8" title="1">scheduledTime := getScheduledTime(pod)
        if scheduledTime.IsZero() </span><span class="cov8" title="1">{
                return errors.New("pod has never got scheduled")
        }</span>

        <span class="cov8" title="1">latency := scheduledTime.Sub(pod.CreationTimestamp.Time)
        taskName := getTaskTagName(tr)

        ctx, err := tag.New(
                ctx,
                append([]tag.Mutator{
                        tag.Insert(namespaceTag, tr.Namespace),
                        tag.Insert(podTag, pod.Name),
                },
                        r.insertTaskTag(taskName, tr.Name)...)...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, podLatency.M(float64(latency.Milliseconds())))

        return nil</span>
}

// IsPartOfPipeline return true if TaskRun is a part of a Pipeline.
// It also return the name of Pipeline and PipelineRun
func IsPartOfPipeline(tr *v1.TaskRun) (bool, string, string) <span class="cov8" title="1">{
        pipelineLabel, hasPipelineLabel := tr.Labels[pipeline.PipelineLabelKey]
        pipelineRunLabel, hasPipelineRunLabel := tr.Labels[pipeline.PipelineRunLabelKey]

        if hasPipelineLabel &amp;&amp; hasPipelineRunLabel </span><span class="cov8" title="1">{
                return true, pipelineLabel, pipelineRunLabel
        }</span>

        <span class="cov8" title="1">return false, "", ""</span>
}

func getScheduledTime(pod *corev1.Pod) metav1.Time <span class="cov8" title="1">{
        for _, c := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if c.Type == corev1.PodScheduled </span><span class="cov8" title="1">{
                        return c.LastTransitionTime
                }</span>
        }

        <span class="cov8" title="1">return metav1.Time{}</span>
}
</pre>
		
		<pre class="file" id="file519" style="display: none">//go:build !disable_tls

/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package termination

import (
        "encoding/json"
        "fmt"
        "sort"

        "github.com/tektoncd/pipeline/pkg/result"
        "go.uber.org/zap"
)

// ParseMessage parses a termination message as results.
//
// If more than one item has the same key, only the latest is returned. Items
// are sorted by their key.
func ParseMessage(logger *zap.SugaredLogger, msg string) ([]result.RunResult, error) <span class="cov8" title="1">{
        if msg == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var r []result.RunResult
        if err := json.Unmarshal([]byte(msg), &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parsing message json: %w, msg: %s", err, msg)
        }</span>

        <span class="cov8" title="1">writeIndex := 0
        for _, rr := range r </span><span class="cov8" title="1">{
                if rr != (result.RunResult{}) </span><span class="cov8" title="1">{
                        // Erase incorrect result
                        r[writeIndex] = rr
                        writeIndex++
                }</span> else<span class="cov8" title="1"> {
                        logger.Errorf("termination message contains non taskrun or pipelineresource result keys")
                }</span>
        }
        <span class="cov8" title="1">r = r[:writeIndex]

        // Remove duplicates (last one wins) and sort by key.
        m := map[string]result.RunResult{}
        for _, rr := range r </span><span class="cov8" title="1">{
                m[rr.Key] = rr
        }</span>
        <span class="cov8" title="1">r2 := make([]result.RunResult, 0, len(m))
        for _, v := range m </span><span class="cov8" title="1">{
                r2 = append(r2, v)
        }</span>
        <span class="cov8" title="1">sort.Slice(r2, func(i, j int) bool </span><span class="cov8" title="1">{ return r2[i].Key &lt; r2[j].Key }</span>)

        <span class="cov8" title="1">return r2, nil</span>
}
</pre>
		
		<pre class="file" id="file520" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package termination

import (
        "encoding/json"
        "os"

        "github.com/tektoncd/pipeline/pkg/result"
)

const (
        // MaxContainerTerminationMessageLength is the upper bound any one container may write to
        // its termination message path. Contents above this length will cause a failure.
        MaxContainerTerminationMessageLength = 1024 * 4
)

// WriteMessage writes the results to the termination message path.
func WriteMessage(path string, pro []result.RunResult) error <span class="cov8" title="1">{
        // if the file at path exists, concatenate the new values otherwise create it
        // file at path already exists
        fileContents, err := os.ReadFile(path)
        if err == nil </span><span class="cov8" title="1">{
                var existingEntries []result.RunResult
                if err := json.Unmarshal(fileContents, &amp;existingEntries); err == nil </span><span class="cov8" title="1">{
                        // append new entries to existing entries
                        pro = append(existingEntries, pro...)
                }</span>
        } else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">jsonOutput, err := json.Marshal(pro)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(jsonOutput) &gt; MaxContainerTerminationMessageLength </span><span class="cov8" title="1">{
                return errTooLong
        }</span>

        <span class="cov8" title="1">f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        if _, err = f.Write(jsonOutput); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return f.Sync()</span>
}

// MessageLengthError indicate the length of termination message of container is beyond 4096 which is the max length read by kubenates
type MessageLengthError string

const (
        errTooLong MessageLengthError = "Termination message is above max allowed size 4096, caused by large task result."
)

func (e MessageLengthError) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>
</pre>
		
		<pre class="file" id="file521" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tracing

import (
        "context"
        "encoding/base64"
        "fmt"
        "net/url"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        tracesdk "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.12.0"
        "go.opentelemetry.io/otel/trace"
        "go.opentelemetry.io/otel/trace/embedded"
        "go.opentelemetry.io/otel/trace/noop"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        listerv1 "k8s.io/client-go/listers/core/v1"
        "knative.dev/pkg/system"
)

type tracerProvider struct {
        embedded.TracerProvider

        service  string
        provider trace.TracerProvider
        cfg      *config.Tracing
        username string
        password string
        logger   *zap.SugaredLogger
}

func init() <span class="cov8" title="1">{
        otel.SetTextMapPropagator(propagation.TraceContext{})
}</span>

// New returns a new instance of tracerProvider for the given service
func New(service string, logger *zap.SugaredLogger) *tracerProvider <span class="cov8" title="1">{
        return &amp;tracerProvider{
                service:  service,
                provider: noop.NewTracerProvider(),
                logger:   logger,
        }
}</span>

// OnStore configures tracerProvider dynamically
func (t *tracerProvider) OnStore(lister listerv1.SecretLister) func(name string, value interface{}) <span class="cov8" title="1">{
        return func(name string, value interface{}) </span><span class="cov8" title="1">{
                if name != config.GetTracingConfigName() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">cfg, ok := value.(*config.Tracing)
                if !ok </span><span class="cov0" title="0">{
                        t.logger.Error("tracing configmap is in invalid format. value: %v", value)
                        return
                }</span>

                <span class="cov8" title="1">if cfg.Equals(t.cfg) </span><span class="cov0" title="0">{
                        t.logger.Info("tracing config unchanged", cfg, t.cfg)
                        return
                }</span>
                <span class="cov8" title="1">t.cfg = cfg

                if lister != nil &amp;&amp; cfg.CredentialsSecret != "" </span><span class="cov8" title="1">{
                        sec, err := lister.Secrets(system.Namespace()).Get(cfg.CredentialsSecret)
                        if err != nil </span><span class="cov0" title="0">{
                                t.logger.Errorf("unable to initialize tracing with error : %v", err.Error())
                                return
                        }</span>
                        <span class="cov8" title="1">creds := sec.Data
                        t.username = string(creds["username"])
                        t.password = string(creds["password"])</span>
                } else<span class="cov8" title="1"> {
                        t.username = ""
                        t.password = ""
                }</span>

                <span class="cov8" title="1">t.reinitialize()</span>
        }
}

func (t *tracerProvider) Tracer(name string, options ...trace.TracerOption) trace.Tracer <span class="cov8" title="1">{
        return t.provider.Tracer(name, options...)
}</span>

// Handler is called by the informer when the secret is updated
func (t *tracerProvider) Handler(obj interface{}) <span class="cov8" title="1">{
        secret, ok := obj.(*corev1.Secret)
        if !ok </span><span class="cov0" title="0">{
                t.logger.Error("Failed to do type assertion for Secret")
                return
        }</span>
        <span class="cov8" title="1">t.OnSecret(secret)</span>
}

func (t *tracerProvider) OnSecret(secret *corev1.Secret) <span class="cov8" title="1">{
        if secret.Name != t.cfg.CredentialsSecret </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">creds := secret.Data
        username := string(creds["username"])
        password := string(creds["password"])

        if t.username == username &amp;&amp; t.password == password </span><span class="cov8" title="1">{
                // No change in credentials, no need to reinitialize
                return
        }</span>
        <span class="cov8" title="1">t.username = username
        t.password = password

        t.logger.Debugf("tracing credentials updated, reinitializing tracingprovider with secret: %v", secret.Name)

        t.reinitialize()</span>
}

func (t *tracerProvider) reinitialize() <span class="cov8" title="1">{
        tp, err := createTracerProvider(t.service, t.cfg, t.username, t.password)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Errorf("unable to initialize tracing with error : %v", err.Error())
                return
        }</span>
        <span class="cov8" title="1">t.logger.Info("initialized Tracer Provider")
        if p, ok := t.provider.(*tracesdk.TracerProvider); ok </span><span class="cov8" title="1">{
                if err := p.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        t.logger.Errorf("unable to shutdown tracingprovider with error : %v", err.Error())
                }</span>
        }
        <span class="cov8" title="1">t.provider = tp</span>
}

func createTracerProvider(service string, cfg *config.Tracing, user, pass string) (trace.TracerProvider, error) <span class="cov8" title="1">{
        if !cfg.Enabled </span><span class="cov8" title="1">{
                return noop.NewTracerProvider(), nil
        }</span>
        <span class="cov8" title="1">u, err := url.Parse(cfg.Endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">opts := []otlptracehttp.Option{
                otlptracehttp.WithEndpoint(u.Host),
                otlptracehttp.WithURLPath(u.Path),
        }

        if u.Scheme == "http" </span><span class="cov0" title="0">{
                opts = append(opts, otlptracehttp.WithInsecure())
        }</span>

        <span class="cov8" title="1">if user != "" &amp;&amp; pass != "" </span><span class="cov8" title="1">{
                creds := fmt.Sprintf("%s:%s", user, pass)
                enc := base64.StdEncoding.EncodeToString([]byte(creds))
                o := otlptracehttp.WithHeaders(map[string]string{
                        "Authorization": "Basic " + enc,
                })
                opts = append(opts, o)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        exp, err := otlptracehttp.New(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Initialize tracerProvider with the jaeger exporter
        <span class="cov8" title="1">tp := tracesdk.NewTracerProvider(
                tracesdk.WithBatcher(exp),
                // Record information about the service in a Resource.
                tracesdk.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(service),
                )),
        )
        return tp, nil</span>
}
</pre>
		
		<pre class="file" id="file522" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package verifier

import (
        "context"
        "crypto"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/sigstore/sigstore/pkg/cryptoutils"
        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/sigstore/sigstore/pkg/signature/kms"

        // TODO(#5976): consider move these registration to cmd/controller/main.go
        _ "github.com/sigstore/sigstore/pkg/signature/kms/aws"        // imported to execute init function to register aws kms
        _ "github.com/sigstore/sigstore/pkg/signature/kms/azure"      // imported to execute init function to register azure kms
        _ "github.com/sigstore/sigstore/pkg/signature/kms/gcp"        // imported to execute init function to register gcp kms
        _ "github.com/sigstore/sigstore/pkg/signature/kms/hashivault" // imported to execute init function to register hashivault kms
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

const (
        // keyReference is the prefix of secret reference
        keyReference = "k8s://"
)

// FromPolicy get all verifiers from VerificationPolicy.
// For each policy, loop the Authorities of the VerificationPolicy to fetch public key
// from either inline Data or from a SecretRef.
func FromPolicy(ctx context.Context, k8s kubernetes.Interface, policy *v1alpha1.VerificationPolicy) ([]signature.Verifier, error) <span class="cov8" title="1">{
        verifiers := []signature.Verifier{}
        for _, a := range policy.Spec.Authorities </span><span class="cov8" title="1">{
                algorithm, err := matchHashAlgorithm(a.Key.HashAlgorithm)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("authority %q contains an invalid hash algorithm: %w", a.Name, err)
                }</span>

                <span class="cov8" title="1">switch </span>{
                case a.Key.Data != "":<span class="cov8" title="1">
                        v, err := fromData([]byte(a.Key.Data), algorithm)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to get verifier from data: %w", err)
                        }</span>
                        <span class="cov8" title="1">verifiers = append(verifiers, v)</span>
                case a.Key.SecretRef != nil:<span class="cov8" title="1">
                        v, err := fromSecret(ctx, fmt.Sprintf("%s%s/%s", keyReference, a.Key.SecretRef.Namespace, a.Key.SecretRef.Name), algorithm, k8s)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to get verifier from secret: %w", err)
                        }</span>
                        <span class="cov8" title="1">verifiers = append(verifiers, v)</span>
                case a.Key.KMS != "":<span class="cov8" title="1">
                        v, err := kms.Get(ctx, a.Key.KMS, algorithm)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to get verifier from kms: %w", err)
                        }</span>
                        <span class="cov8" title="1">verifiers = append(verifiers, v)</span>
                default:<span class="cov8" title="1">
                        return nil, ErrEmptyKey</span>
                }
        }
        <span class="cov8" title="1">if len(verifiers) == 0 </span><span class="cov8" title="1">{
                return verifiers, ErrEmptyPublicKeys
        }</span>
        <span class="cov8" title="1">return verifiers, nil</span>
}

// fromKeyRef parses the given keyRef, loads the key and returns an appropriate
// verifier using the provided hash algorithm
func fromKeyRef(ctx context.Context, keyRef string, hashAlgorithm crypto.Hash, k8s kubernetes.Interface) (signature.Verifier, error) <span class="cov8" title="1">{
        var raw []byte
        if strings.HasPrefix(keyRef, keyReference) </span><span class="cov8" title="1">{
                v, err := fromSecret(ctx, keyRef, hashAlgorithm, k8s)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to get verifier from secret: %w", err)
                }</span>
                <span class="cov8" title="1">return v, nil</span>
        }
        <span class="cov8" title="1">raw, err := os.ReadFile(filepath.Clean(keyRef))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrFailedLoadKeyFile, err) //nolint:errorlint
        }</span>
        <span class="cov8" title="1">v, err := fromData(raw, hashAlgorithm)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get verifier from data: %w", err)
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// fromSecret fetches the public key from SecretRef and returns the verifier
// hashAlgorithm is provided to determine the hash algorithm of the key
func fromSecret(ctx context.Context, secretRef string, hashAlgorithm crypto.Hash, k8s kubernetes.Interface) (signature.Verifier, error) <span class="cov8" title="1">{
        if strings.HasPrefix(secretRef, keyReference) </span><span class="cov8" title="1">{
                s, err := getKeyPairSecret(ctx, secretRef, k8s)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to get secret: %w", err)
                }</span>
                // only 1 public key should be in the secret
                <span class="cov8" title="1">if len(s.Data) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("secret %q contains no data %w", secretRef, ErrEmptySecretData)
                }</span>
                <span class="cov8" title="1">if len(s.Data) &gt; 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("secret %q contains multiple data entries, only one is supported. %w", secretRef, ErrMultipleSecretData)
                }</span>
                <span class="cov8" title="1">for _, raw := range s.Data </span><span class="cov8" title="1">{
                        v, err := fromData(raw, hashAlgorithm)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to get verifier from secret data: %w", err)
                        }</span>
                        <span class="cov8" title="1">return v, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("%w: secretRef %v is invalid", ErrK8sSpecificationInvalid, secretRef)</span>
}

// fromData fetches the public key from raw data and returns the verifier
func fromData(raw []byte, hashAlgorithm crypto.Hash) (signature.Verifier, error) <span class="cov8" title="1">{
        pubKey, err := cryptoutils.UnmarshalPEMToPublicKey(raw)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrDecodeKey, err) //nolint:errorlint
        }</span>
        <span class="cov8" title="1">v, err := signature.LoadVerifier(pubKey, hashAlgorithm)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrLoadVerifier, err) //nolint:errorlint
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// getKeyPairSecret fetches the secret from a k8sRef
// TODO(#5884): use a secret lister to fetch secrets
func getKeyPairSecret(ctx context.Context, k8sRef string, k8s kubernetes.Interface) (*v1.Secret, error) <span class="cov8" title="1">{
        split := strings.Split(strings.TrimPrefix(k8sRef, keyReference), "/")
        if len(split) != 2 </span><span class="cov8" title="1">{
                return nil, ErrK8sSpecificationInvalid
        }</span>
        <span class="cov8" title="1">namespace, name := split[0], split[1]

        s, err := k8s.CoreV1().Secrets(namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrSecretNotFound, err) //nolint:errorlint
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}

// matchHashAlgorithm returns a crypto.Hash code using an algorithm name as input parameter
func matchHashAlgorithm(algorithmName v1alpha1.HashAlgorithm) (crypto.Hash, error) <span class="cov8" title="1">{
        normalizedAlgo := strings.ToLower(string(algorithmName))
        algo, exists := v1alpha1.SupportedSignatureAlgorithms[v1alpha1.HashAlgorithm(normalizedAlgo)]
        if !exists </span><span class="cov8" title="1">{
                return crypto.SHA256, fmt.Errorf("%w: %s", ErrAlgorithmInvalid, algorithmName)
        }</span>
        <span class="cov8" title="1">return algo, nil</span>
}
</pre>
		
		<pre class="file" id="file523" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trustedresources

import (
        "bytes"
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "regexp"

        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/trustedresources/verifier"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

const (
        // SignatureAnnotation is the key of signature in annotation map
        SignatureAnnotation = "tekton.dev/signature"
        // ConditionTrustedResourcesVerified specifies that the resources pass trusted resources verification or not.
        ConditionTrustedResourcesVerified apis.ConditionType = "TrustedResourcesVerified"
)

const (
        VerificationSkip = iota
        VerificationPass
        VerificationWarn
        VerificationError
)

type Hashable interface {
        Checksum() ([]byte, error)
}

// VerificationResultType indicates different cases of a verification result
type VerificationResultType int

// VerificationResult contains the type and message about the result of verification
type VerificationResult struct {
        // VerificationResultType has 4 types which is corresponding to 4 cases:
        // 0 (VerificationSkip): The verification was skipped. Err is nil in this case.
        // 1 (VerificationPass): The verification passed. Err is nil in this case.
        // 2 (VerificationWarn): A warning is logged. It could be no matching policies and feature flag "no-match-policy" is "warn", or only Warn mode verification policies fail.
        // 3 (VerificationError): The verification failed, it could be the signature doesn't match the public key, no matching policies and "no-match-policy" is set to "fail" or there are errors during verification.
        VerificationResultType VerificationResultType
        // Err contains the error message when there is a warning logged or error returned.
        Err error
}

// VerifyResource verifies the signature and public key against resource (v1beta1 and v1 task and pipeline).
// VerificationResult is returned with different types for different cases:
// 1) Return VerificationResult with VerificationSkip type, when no policies are found and no-match-policy is set to ignore
// 2) Return VerificationResult with VerificationPass type when verification passed;
// 3) Return VerificationResult with VerificationWarn type, when no matching policies and feature flag "no-match-policy" is "warn", or only Warn mode verification policies fail. Err field is filled with the warning;
// 4) Return VerificationResult with VerificationError type when no policies are found and no-match-policy is set to fail, the resource fails to pass matched enforce verification policy, or there are errors during verification. Err is filled with the err.
// refSource contains the source information of the resource.
func VerifyResource(ctx context.Context, resource metav1.Object, k8s kubernetes.Interface, refSource *v1.RefSource, verificationpolicies []*v1alpha1.VerificationPolicy) VerificationResult <span class="cov8" title="1">{
        var refSourceURI string
        if refSource != nil </span><span class="cov8" title="1">{
                refSourceURI = refSource.URI
        }</span>

        <span class="cov8" title="1">matchedPolicies, err := getMatchedPolicies(resource.GetName(), refSourceURI, verificationpolicies)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, ErrNoMatchedPolicies) </span><span class="cov8" title="1">{
                        switch config.GetVerificationNoMatchPolicy(ctx) </span>{
                        case config.IgnoreNoMatchPolicy:<span class="cov8" title="1">
                                return VerificationResult{VerificationResultType: VerificationSkip}</span>
                        case config.WarnNoMatchPolicy:<span class="cov8" title="1">
                                logger := logging.FromContext(ctx)
                                warning := fmt.Errorf("failed to get matched policies: %w", err)
                                logger.Warnf(warning.Error())
                                return VerificationResult{VerificationResultType: VerificationWarn, Err: warning}</span>
                        }
                }
                <span class="cov8" title="1">return VerificationResult{VerificationResultType: VerificationError, Err: fmt.Errorf("failed to get matched policies: %w", err)}</span>
        }
        <span class="cov8" title="1">signature, err := extractSignature(resource)
        if err != nil </span><span class="cov0" title="0">{
                return VerificationResult{VerificationResultType: VerificationError, Err: err}
        }</span>
        <span class="cov8" title="1">return verifyResource(ctx, resource, k8s, signature, matchedPolicies)</span>
}

// VerifyTask is the deprecated, this is to keep backward compatibility
func VerifyTask(ctx context.Context, taskObj *v1beta1.Task, k8s kubernetes.Interface, refSource *v1.RefSource, verificationpolicies []*v1alpha1.VerificationPolicy) VerificationResult <span class="cov0" title="0">{
        return VerifyResource(ctx, taskObj, k8s, refSource, verificationpolicies)
}</span>

// VerifyPipeline is the deprecated, this is to keep backward compatibility
func VerifyPipeline(ctx context.Context, pipelineObj *v1beta1.Pipeline, k8s kubernetes.Interface, refSource *v1.RefSource, verificationpolicies []*v1alpha1.VerificationPolicy) VerificationResult <span class="cov0" title="0">{
        return VerifyResource(ctx, pipelineObj, k8s, refSource, verificationpolicies)
}</span>

// getMatchedPolicies filters out the policies by checking if the resource url (source) is matching any of the `patterns` in the `resources` list.
func getMatchedPolicies(resourceName string, source string, policies []*v1alpha1.VerificationPolicy) ([]*v1alpha1.VerificationPolicy, error) <span class="cov8" title="1">{
        matchedPolicies := []*v1alpha1.VerificationPolicy{}
        for _, p := range policies </span><span class="cov8" title="1">{
                for _, r := range p.Spec.Resources </span><span class="cov8" title="1">{
                        matching, err := regexp.MatchString(r.Pattern, source)
                        if err != nil </span><span class="cov8" title="1">{
                                // FixMe: changing %v to %w breaks integration tests.
                                return matchedPolicies, fmt.Errorf("%v: %w", err, ErrRegexMatch) //nolint:errorlint
                        }</span>
                        <span class="cov8" title="1">if matching </span><span class="cov8" title="1">{
                                matchedPolicies = append(matchedPolicies, p)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if len(matchedPolicies) == 0 </span><span class="cov8" title="1">{
                return matchedPolicies, fmt.Errorf("%w: no matching policies are found for resource: %s against source: %s", ErrNoMatchedPolicies, resourceName, source)
        }</span>
        <span class="cov8" title="1">return matchedPolicies, nil</span>
}

// verifyResource verifies resource which implements metav1.Object by provided signature and public keys from verification policies.
// For matched policies, `verifyResource will adopt the following rules to do verification:
//  1. If multiple policies match, the resource must satisfy all the "enforce" policies to pass verification. The matching "enforce" policies are evaluated using AND logic.
//     Alternatively, if the resource only matches policies in "warn" mode, it will still pass verification and only log a warning if these policies are not satisfied.
//  2. To pass one policy, the resource can pass any public keys in the policy. We use OR logic on public keys of one policy.
//
// TODO(#6683): return all failed policies in error.
func verifyResource(ctx context.Context, resource metav1.Object, k8s kubernetes.Interface, signature []byte, matchedPolicies []*v1alpha1.VerificationPolicy) VerificationResult <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        var warnPolicies []*v1alpha1.VerificationPolicy
        var enforcePolicies []*v1alpha1.VerificationPolicy
        for _, p := range matchedPolicies </span><span class="cov8" title="1">{
                if p.Spec.Mode == v1alpha1.ModeWarn </span><span class="cov8" title="1">{
                        warnPolicies = append(warnPolicies, p)
                }</span> else<span class="cov8" title="1"> {
                        enforcePolicies = append(enforcePolicies, p)
                }</span>
        }

        // get the checksum of the resource
        <span class="cov8" title="1">checksumBytes, err := getChecksum(resource)
        if err != nil </span><span class="cov0" title="0">{
                return VerificationResult{VerificationResultType: VerificationError, Err: err}
        }</span>

        // first evaluate all enforce policies. Return VerificationError type of VerificationResult if any policy fails.
        <span class="cov8" title="1">for _, p := range enforcePolicies </span><span class="cov8" title="1">{
                verifiers, err := verifier.FromPolicy(ctx, k8s, p)
                if err != nil </span><span class="cov8" title="1">{
                        return VerificationResult{VerificationResultType: VerificationError, Err: fmt.Errorf("failed to get verifiers from policy: %w", err)}
                }</span>
                <span class="cov8" title="1">passVerification := doesAnyVerifierPass(ctx, checksumBytes, signature, verifiers)
                if !passVerification </span><span class="cov8" title="1">{
                        return VerificationResult{VerificationResultType: VerificationError, Err: fmt.Errorf("%w: resource %s in namespace %s fails verification", ErrResourceVerificationFailed, resource.GetName(), resource.GetNamespace())}
                }</span>
        }

        // then evaluate all warn policies. Return VerificationWarn type of VerificationResult if any warn policies fails.
        <span class="cov8" title="1">for _, p := range warnPolicies </span><span class="cov8" title="1">{
                verifiers, err := verifier.FromPolicy(ctx, k8s, p)
                if err != nil </span><span class="cov8" title="1">{
                        warn := fmt.Errorf("failed to get verifiers for resource %s from namespace %s: %w", resource.GetName(), resource.GetNamespace(), err)
                        logger.Warnf(warn.Error())
                        return VerificationResult{VerificationResultType: VerificationWarn, Err: warn}
                }</span>
                <span class="cov8" title="1">passVerification := doesAnyVerifierPass(ctx, checksumBytes, signature, verifiers)
                if !passVerification </span><span class="cov8" title="1">{
                        warn := fmt.Errorf("%w: resource %s in namespace %s fails verification", ErrResourceVerificationFailed, resource.GetName(), resource.GetNamespace())
                        logger.Warnf(warn.Error())
                        return VerificationResult{VerificationResultType: VerificationWarn, Err: warn}
                }</span>
        }

        <span class="cov8" title="1">return VerificationResult{VerificationResultType: VerificationPass}</span>
}

// doesAnyVerifierPass loop over verifiers to verify the checksum and the signature, return true if any verifier pass verification.
func doesAnyVerifierPass(ctx context.Context, checksumBytes []byte, signature []byte, verifiers []signature.Verifier) bool <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        passVerification := false
        for _, verifier := range verifiers </span><span class="cov8" title="1">{
                if err := verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(checksumBytes)); err == nil </span><span class="cov8" title="1">{
                        // if one of the verifier passes verification, then this policy passes verification
                        passVerification = true
                        break</span>
                } else<span class="cov8" title="1"> {
                        // FixMe: changing %v to %w breaks integration tests.
                        warn := fmt.Errorf("%w:%v", ErrResourceVerificationFailed, err.Error())
                        logger.Warnf(warn.Error())
                }</span>
        }
        <span class="cov8" title="1">return passVerification</span>
}

// extractSignature extracts the signature if it is present in the metadata.
// Returns a non-nil error if the signature cannot be decoded.
func extractSignature(in metav1.Object) ([]byte, error) <span class="cov8" title="1">{
        // signature should be contained in annotation
        sig, ok := in.GetAnnotations()[SignatureAnnotation]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // extract signature
        <span class="cov8" title="1">signature, err := base64.StdEncoding.DecodeString(sig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return signature, nil</span>
}

// getChecksum gets the sha256 checksum of the resource.
// Returns a non-nil error if the checksum cannot be computed or the resource is of unknown type.
func getChecksum(resource metav1.Object) ([]byte, error) <span class="cov8" title="1">{
        h, ok := resource.(Hashable)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: resource %T is not a Hashable type", ErrResourceNotSupported, resource)
        }</span>
        <span class="cov8" title="1">checksumBytes, err := h.Checksum()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return checksumBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file524" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package workspace

import (
        "context"
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pkgnames "github.com/tektoncd/pipeline/pkg/names"
        "github.com/tektoncd/pipeline/pkg/substitution"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
)

const (
        volumeNameBase      = "ws"
        defaultRandomLength = 5
)

// nameVolumeMap is a map from a workspace's name to its Volume.
type nameVolumeMap map[string]corev1.Volume

// setVolumeSource assigns a volume to a workspace's name.
func (nvm nameVolumeMap) setVolumeSource(workspaceName string, volumeName string, source corev1.VolumeSource) <span class="cov8" title="1">{
        nvm[workspaceName] = corev1.Volume{
                Name:         volumeName,
                VolumeSource: source,
        }
}</span>

// generateVolumeName generates a unique name for a volume based on the workspace name.
func generateVolumeName(name string) string <span class="cov8" title="1">{
        return pkgnames.GenerateHashedName(volumeNameBase, name, defaultRandomLength)
}</span>

// CreateVolumes will return a dictionary where the keys are the names of the workspaces bound in
// wb and the value is a newly-created Volume to use. If the same Volume is bound twice, the
// resulting volumes will both have the same name to prevent the same Volume from being attached
// to a pod twice. The names of the returned volumes will be a short hash string starting "ws-".
func CreateVolumes(wb []v1.WorkspaceBinding) map[string]corev1.Volume <span class="cov8" title="1">{
        pvcs := map[string]corev1.Volume{}
        v := make(nameVolumeMap, len(wb))
        // Track the names we've used so far to avoid collisions
        usedNames := make(map[string]struct{}, len(wb))

        for _, w := range wb </span><span class="cov8" title="1">{
                name := generateVolumeName(w.Name)

                // If we've already generated this name, try appending extra characters until we find a unique name
                for _, exists := usedNames[name]; exists; _, exists = usedNames[name] </span><span class="cov8" title="1">{
                        name = generateVolumeName(name + "$")
                }</span>
                // Track the name we've used
                <span class="cov8" title="1">usedNames[name] = struct{}{}

                switch </span>{
                case w.PersistentVolumeClaim != nil:<span class="cov8" title="1">
                        // If it's a PVC, we need to check if we've encountered it before so we avoid mounting it twice
                        if vv, ok := pvcs[w.PersistentVolumeClaim.ClaimName]; ok </span><span class="cov8" title="1">{
                                v[w.Name] = vv
                        }</span> else<span class="cov8" title="1"> {
                                pvc := *w.PersistentVolumeClaim
                                v.setVolumeSource(w.Name, name, corev1.VolumeSource{PersistentVolumeClaim: &amp;pvc})
                                pvcs[pvc.ClaimName] = v[w.Name]
                        }</span>
                case w.EmptyDir != nil:<span class="cov8" title="1">
                        ed := *w.EmptyDir
                        v.setVolumeSource(w.Name, name, corev1.VolumeSource{EmptyDir: &amp;ed})</span>
                case w.ConfigMap != nil:<span class="cov8" title="1">
                        cm := *w.ConfigMap
                        v.setVolumeSource(w.Name, name, corev1.VolumeSource{ConfigMap: &amp;cm})</span>
                case w.Secret != nil:<span class="cov8" title="1">
                        s := *w.Secret
                        v.setVolumeSource(w.Name, name, corev1.VolumeSource{Secret: &amp;s})</span>
                case w.Projected != nil:<span class="cov8" title="1">
                        s := *w.Projected
                        v.setVolumeSource(w.Name, name, corev1.VolumeSource{Projected: &amp;s})</span>
                case w.CSI != nil:<span class="cov8" title="1">
                        csi := *w.CSI
                        v.setVolumeSource(w.Name, name, corev1.VolumeSource{CSI: &amp;csi})</span>
                }
        }
        <span class="cov8" title="1">return v</span>
}

func getDeclaredWorkspace(name string, w []v1.WorkspaceDeclaration) (*v1.WorkspaceDeclaration, error) <span class="cov8" title="1">{
        for _, workspace := range w </span><span class="cov8" title="1">{
                if workspace.Name == name </span><span class="cov8" title="1">{
                        return &amp;workspace, nil
                }</span>
        }
        // Trusting validation to ensure
        <span class="cov0" title="0">return nil, fmt.Errorf("even though validation should have caught it, bound workspace %s did not exist in declared workspaces", name)</span>
}

// Apply will update the StepTemplate, Sidecars and Volumes declaration in ts so that the workspaces
// specified through wb combined with the declared workspaces in ts will be available for
// all Step and Sidecar containers in the resulting pod.
func Apply(ctx context.Context, ts v1.TaskSpec, wb []v1.WorkspaceBinding, v map[string]corev1.Volume) (*v1.TaskSpec, error) <span class="cov8" title="1">{
        // If there are no bound workspaces, we don't need to do anything
        if len(wb) == 0 </span><span class="cov8" title="1">{
                return &amp;ts, nil
        }</span>

        <span class="cov8" title="1">addedVolumes := sets.NewString()

        // Initialize StepTemplate if it hasn't been already
        if ts.StepTemplate == nil </span><span class="cov8" title="1">{
                ts.StepTemplate = &amp;v1.StepTemplate{}
        }</span>

        <span class="cov8" title="1">isolatedWorkspaces := sets.NewString()

        for _, step := range ts.Steps </span><span class="cov8" title="1">{
                for _, workspaceUsage := range step.Workspaces </span><span class="cov8" title="1">{
                        isolatedWorkspaces.Insert(workspaceUsage.Name)
                }</span>
        }
        <span class="cov8" title="1">for _, sidecar := range ts.Sidecars </span><span class="cov8" title="1">{
                for _, workspaceUsage := range sidecar.Workspaces </span><span class="cov8" title="1">{
                        isolatedWorkspaces.Insert(workspaceUsage.Name)
                }</span>
        }

        <span class="cov8" title="1">for i := range wb </span><span class="cov8" title="1">{
                // Propagate missing Workspaces
                addWorkspace := true
                for _, ws := range ts.Workspaces </span><span class="cov8" title="1">{
                        if ws.Name == wb[i].Name </span><span class="cov8" title="1">{
                                addWorkspace = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if addWorkspace </span><span class="cov8" title="1">{
                        ts.Workspaces = append(ts.Workspaces, v1.WorkspaceDeclaration{Name: wb[i].Name})
                }</span>
                <span class="cov8" title="1">w, err := getDeclaredWorkspace(wb[i].Name, ts.Workspaces)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Get the volume we should be using for this binding
                <span class="cov8" title="1">vv := v[wb[i].Name]

                volumeMount := corev1.VolumeMount{
                        Name:      vv.Name,
                        MountPath: w.GetMountPath(),
                        SubPath:   wb[i].SubPath,
                        ReadOnly:  w.ReadOnly,
                }

                if isolatedWorkspaces.Has(w.Name) </span><span class="cov8" title="1">{
                        mountAsIsolatedWorkspace(ts, w.Name, volumeMount)
                }</span> else<span class="cov8" title="1"> {
                        mountAsSharedWorkspace(ts, volumeMount)
                }</span>

                // Only add this volume if it hasn't already been added
                <span class="cov8" title="1">if !addedVolumes.Has(vv.Name) </span><span class="cov8" title="1">{
                        ts.Volumes = append(ts.Volumes, vv)
                        addedVolumes.Insert(vv.Name)
                }</span>
        }
        <span class="cov8" title="1">return &amp;ts, nil</span>
}

// mountAsSharedWorkspace takes a volumeMount and adds it to all the steps and sidecars in
// a TaskSpec.
func mountAsSharedWorkspace(ts v1.TaskSpec, volumeMount corev1.VolumeMount) <span class="cov8" title="1">{
        ts.StepTemplate.VolumeMounts = append(ts.StepTemplate.VolumeMounts, volumeMount)

        for i := range ts.Sidecars </span><span class="cov8" title="1">{
                AddSidecarVolumeMount(&amp;ts.Sidecars[i], volumeMount)
        }</span>
}

// mountAsIsolatedWorkspace takes a volumeMount and adds it only to the steps and sidecars
// that have requested access to it.
func mountAsIsolatedWorkspace(ts v1.TaskSpec, workspaceName string, volumeMount corev1.VolumeMount) <span class="cov8" title="1">{
        for i := range ts.Steps </span><span class="cov8" title="1">{
                step := &amp;ts.Steps[i]
                for _, workspaceUsage := range step.Workspaces </span><span class="cov8" title="1">{
                        if workspaceUsage.Name == workspaceName </span><span class="cov8" title="1">{
                                vm := volumeMount
                                if workspaceUsage.MountPath != "" </span><span class="cov8" title="1">{
                                        vm.MountPath = workspaceUsage.MountPath
                                }</span>
                                <span class="cov8" title="1">step.VolumeMounts = append(step.VolumeMounts, vm)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for i := range ts.Sidecars </span><span class="cov8" title="1">{
                sidecar := &amp;ts.Sidecars[i]
                for _, workspaceUsage := range sidecar.Workspaces </span><span class="cov8" title="1">{
                        if workspaceUsage.Name == workspaceName </span><span class="cov8" title="1">{
                                vm := volumeMount
                                if workspaceUsage.MountPath != "" </span><span class="cov8" title="1">{
                                        vm.MountPath = workspaceUsage.MountPath
                                }</span>
                                <span class="cov8" title="1">sidecar.VolumeMounts = append(sidecar.VolumeMounts, vm)
                                break</span>
                        }
                }
        }
}

// AddSidecarVolumeMount is a helper to add a volumeMount to the sidecar unless its
// MountPath would conflict with another of the sidecar's existing volume mounts.
func AddSidecarVolumeMount(sidecar *v1.Sidecar, volumeMount corev1.VolumeMount) <span class="cov8" title="1">{
        for j := range sidecar.VolumeMounts </span><span class="cov8" title="1">{
                if sidecar.VolumeMounts[j].MountPath == volumeMount.MountPath </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">sidecar.VolumeMounts = append(sidecar.VolumeMounts, volumeMount)</span>
}

func findWorkspaceSubstitutionLocationsInSidecars(sidecars []v1.Sidecar) sets.String <span class="cov8" title="1">{
        locationsToCheck := sets.NewString()
        for _, sidecar := range sidecars </span><span class="cov8" title="1">{
                locationsToCheck.Insert(sidecar.Script)

                for i := range sidecar.Args </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(sidecar.Args[i])
                }</span>

                <span class="cov8" title="1">for i := range sidecar.Command </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(sidecar.Command[i])
                }</span>
                <span class="cov8" title="1">locationsToCheck.Insert(sidecar.WorkingDir)
                for _, e := range sidecar.Env </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(e.Value)
                }</span>
        }
        <span class="cov8" title="1">return locationsToCheck</span>
}

func findWorkspaceSubstitutionLocationsInSteps(steps []v1.Step) sets.String <span class="cov8" title="1">{
        locationsToCheck := sets.NewString()
        for _, step := range steps </span><span class="cov8" title="1">{
                locationsToCheck.Insert(step.Script)

                for i := range step.Args </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(step.Args[i])
                }</span>

                <span class="cov8" title="1">for i := range step.Command </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(step.Command[i])
                }</span>

                <span class="cov8" title="1">locationsToCheck.Insert(step.WorkingDir)
                for _, e := range step.Env </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(e.Value)
                }</span>
                <span class="cov8" title="1">for _, p := range step.Params </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(p.Value.ArrayVal...)
                        for k := range p.Value.ObjectVal </span><span class="cov0" title="0">{
                                locationsToCheck.Insert(p.Value.ObjectVal[k])
                        }</span>
                        <span class="cov8" title="1">locationsToCheck.Insert(p.Value.StringVal)</span>
                }
        }
        <span class="cov8" title="1">return locationsToCheck</span>
}

func findWorkspaceSubstitutionLocationsInStepTemplate(stepTemplate *v1.StepTemplate) sets.String <span class="cov8" title="1">{
        locationsToCheck := sets.NewString()

        if stepTemplate != nil </span><span class="cov8" title="1">{
                for i := range stepTemplate.Args </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(stepTemplate.Args[i])
                }</span>
                <span class="cov8" title="1">for i := range stepTemplate.Command </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(stepTemplate.Command[i])
                }</span>

                <span class="cov8" title="1">locationsToCheck.Insert(stepTemplate.WorkingDir)
                for _, e := range stepTemplate.Env </span><span class="cov8" title="1">{
                        locationsToCheck.Insert(e.Value)
                }</span>
        }
        <span class="cov8" title="1">return locationsToCheck</span>
}

// FindWorkspacesUsedByTask returns a set of all the workspaces that the TaskSpec uses.
func FindWorkspacesUsedByTask(ts v1.TaskSpec) (sets.String, error) <span class="cov8" title="1">{
        locationsToCheck := sets.NewString()
        locationsToCheck.Insert(findWorkspaceSubstitutionLocationsInSteps(ts.Steps).List()...)
        locationsToCheck.Insert(findWorkspaceSubstitutionLocationsInSidecars(ts.Sidecars).List()...)
        locationsToCheck.Insert(findWorkspaceSubstitutionLocationsInStepTemplate(ts.StepTemplate).List()...)
        workspacesUsedInSteps := sets.NewString()
        for item := range locationsToCheck </span><span class="cov8" title="1">{
                workspacesUsed, _, errString := substitution.ExtractVariablesFromString(item, "workspaces")
                if errString != "" </span><span class="cov0" title="0">{
                        return workspacesUsedInSteps, fmt.Errorf("Error while extracting workspace: %s", errString)
                }</span>
                <span class="cov8" title="1">workspacesUsedInSteps.Insert(workspacesUsed...)</span>
        }
        <span class="cov8" title="1">return workspacesUsedInSteps, nil</span>
}

// ReplaceWorkspaceBindingsVars returns a new slice of WorkspaceBinding with references to parameters replaced,
// based on the mapping provided in replacements.
func ReplaceWorkspaceBindingsVars(wbs []v1.WorkspaceBinding, replacements map[string]string) []v1.WorkspaceBinding <span class="cov8" title="1">{
        for i := range wbs </span><span class="cov8" title="1">{
                replaceWorkspaceBindingVars(&amp;wbs[i], replacements)
        }</span>
        <span class="cov8" title="1">return wbs</span>
}

// replaceWorkspaceBindingVars returns a new WorkspaceBinding with references to parameters replaced,
// based on the mapping provided in replacements.
func replaceWorkspaceBindingVars(wb *v1.WorkspaceBinding, replacements map[string]string) *v1.WorkspaceBinding <span class="cov8" title="1">{
        wb.SubPath = substitution.ApplyReplacements(wb.SubPath, replacements)
        if wb.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                wb.PersistentVolumeClaim = applyPersistentVolumeClaimVolumeSource(wb.PersistentVolumeClaim, replacements)
        }</span>
        <span class="cov8" title="1">if wb.ConfigMap != nil </span><span class="cov8" title="1">{
                wb.ConfigMap = applyConfigMapVolumeSource(wb.ConfigMap, replacements)
        }</span>
        <span class="cov8" title="1">if wb.Secret != nil </span><span class="cov8" title="1">{
                wb.Secret = applySecretVolumeSource(wb.Secret, replacements)
        }</span>
        <span class="cov8" title="1">if wb.Projected != nil </span><span class="cov8" title="1">{
                for j, source := range wb.Projected.Sources </span><span class="cov8" title="1">{
                        if source.ConfigMap != nil </span><span class="cov8" title="1">{
                                wb.Projected.Sources[j].ConfigMap = applyConfigMapProjection(wb.Projected.Sources[j].ConfigMap, replacements)
                        }</span>
                        <span class="cov8" title="1">if source.Secret != nil </span><span class="cov8" title="1">{
                                wb.Projected.Sources[j].Secret = applySecretProjection(wb.Projected.Sources[j].Secret, replacements)
                        }</span>
                }
        }
        <span class="cov8" title="1">if wb.CSI != nil </span><span class="cov8" title="1">{
                wb.CSI = applyCSIVolumeSource(wb.CSI, replacements)
        }</span>
        <span class="cov8" title="1">return wb</span>
}

func applyPersistentVolumeClaimVolumeSource(pvc *corev1.PersistentVolumeClaimVolumeSource,
        replacements map[string]string) *corev1.PersistentVolumeClaimVolumeSource <span class="cov8" title="1">{
        pvc.ClaimName = substitution.ApplyReplacements(pvc.ClaimName, replacements)
        return pvc
}</span>

func applyConfigMapVolumeSource(cm *corev1.ConfigMapVolumeSource, replacements map[string]string) *corev1.ConfigMapVolumeSource <span class="cov8" title="1">{
        cm.Name = substitution.ApplyReplacements(cm.Name, replacements)
        cm.Items = applyKeyToPathItems(cm.Items, replacements)
        return cm
}</span>

func applySecretVolumeSource(s *corev1.SecretVolumeSource, replacements map[string]string) *corev1.SecretVolumeSource <span class="cov8" title="1">{
        s.SecretName = substitution.ApplyReplacements(s.SecretName, replacements)
        s.Items = applyKeyToPathItems(s.Items, replacements)
        return s
}</span>

func applyConfigMapProjection(cm *corev1.ConfigMapProjection, replacements map[string]string) *corev1.ConfigMapProjection <span class="cov8" title="1">{
        cm.Name = substitution.ApplyReplacements(cm.Name, replacements)
        cm.Items = applyKeyToPathItems(cm.Items, replacements)
        return cm
}</span>

func applySecretProjection(s *corev1.SecretProjection, replacements map[string]string) *corev1.SecretProjection <span class="cov8" title="1">{
        s.Name = substitution.ApplyReplacements(s.Name, replacements)
        s.Items = applyKeyToPathItems(s.Items, replacements)
        return s
}</span>

func applyCSIVolumeSource(csi *corev1.CSIVolumeSource, replacements map[string]string) *corev1.CSIVolumeSource <span class="cov8" title="1">{
        csi.Driver = substitution.ApplyReplacements(csi.Driver, replacements)
        if csi.NodePublishSecretRef != nil </span><span class="cov8" title="1">{
                csi.NodePublishSecretRef.Name = substitution.ApplyReplacements(csi.NodePublishSecretRef.Name, replacements)
        }</span>
        <span class="cov8" title="1">return csi</span>
}

func applyKeyToPathItems(items []corev1.KeyToPath, replacements map[string]string) []corev1.KeyToPath <span class="cov8" title="1">{
        for i := range items </span><span class="cov8" title="1">{
                item := &amp;items[i]
                item.Key = substitution.ApplyReplacements(item.Key, replacements)
                item.Path = substitution.ApplyReplacements(item.Path, replacements)
        }</span>
        <span class="cov8" title="1">return items</span>
}
</pre>
		
		<pre class="file" id="file525" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package workspace

import (
        "context"
        "errors"
        "fmt"

        pipelineErrors "github.com/tektoncd/pipeline/pkg/apis/pipeline/errors"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/util/sets"
)

// ValidateBindings will return an error if the bound workspaces in binds don't satisfy the declared
// workspaces in decls.
func ValidateBindings(ctx context.Context, decls []v1.WorkspaceDeclaration, binds []v1.WorkspaceBinding) error <span class="cov8" title="1">{
        // This will also be validated at webhook time but in case the webhook isn't invoked for some
        // reason we'll invoke the same validation here.
        for _, b := range binds </span><span class="cov8" title="1">{
                if err := b.Validate(ctx); err != nil </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("binding %q is invalid: %w", b.Name, err))
                }</span>
        }

        <span class="cov8" title="1">declNames := sets.NewString()
        bindNames := sets.NewString()
        for _, decl := range decls </span><span class="cov8" title="1">{
                declNames.Insert(decl.Name)
        }</span>
        <span class="cov8" title="1">for _, bind := range binds </span><span class="cov8" title="1">{
                bindNames.Insert(bind.Name)
        }</span>

        <span class="cov8" title="1">for _, decl := range decls </span><span class="cov8" title="1">{
                if decl.Optional </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !bindNames.Has(decl.Name) </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("declared workspace %q is required but has not been bound", decl.Name))
                }</span>
        }
        <span class="cov8" title="1">for _, bind := range binds </span><span class="cov8" title="1">{
                if !declNames.Has(bind.Name) </span><span class="cov8" title="1">{
                        return pipelineErrors.WrapUserError(fmt.Errorf("workspace binding %q does not match any declared workspace", bind.Name))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateOnlyOnePVCIsUsed checks that a list of WorkspaceBinding uses only one
// persistent volume claim.
//
// This is only useful to validate that WorkspaceBindings in TaskRuns are compatible
// with affinity rules enforced by the AffinityAssistant.
func ValidateOnlyOnePVCIsUsed(wb []v1.WorkspaceBinding) error <span class="cov8" title="1">{
        workspaceVolumes := make(map[string]bool)
        for _, w := range wb </span><span class="cov8" title="1">{
                if w.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        workspaceVolumes[w.PersistentVolumeClaim.ClaimName] = true
                }</span>
                <span class="cov8" title="1">if w.VolumeClaimTemplate != nil </span><span class="cov8" title="1">{
                        workspaceVolumes[w.Name] = true
                }</span>
        }

        <span class="cov8" title="1">if len(workspaceVolumes) &gt; 1 </span><span class="cov8" title="1">{
                return pipelineErrors.WrapUserError(errors.New("more than one PersistentVolumeClaim is bound"))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file526" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
This utility can be used to generate a new release name in the format:
        &lt;cat breed&gt; &lt;robot name&gt;

to be used for a Tekton Pipelines release.
It looks for cat breeds from CatAPIURL and it parses robot names out
of Wikipedia WikiURL. It filters names that have been used already,
based on the GitHub API GitHubReleasesURL

To use, run:
        go run release_names.go


Example output:
        {
                "release_name": "California Spangled Clank",
                "cat_breed_url": "https://en.wikipedia.org/wiki/California_Spangled",
                "robot_url": "https://en.wikipedia.org/wiki/Clank"
        }
*/

package main

import (
        "context"
        "crypto/rand"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/big"
        "net/http"
        "regexp"
        "strings"
)

// API Endpoints
const (
        CatAPIURL         = "https://api.thecatapi.com/v1/breeds"
        RobotWikiURL      = "https://en.wikipedia.org/wiki/List_of_fictional_robots_and_androids"
        WikiURL           = "https://en.wikipedia.org/wiki/"
        GitHubReleasesURL = "https://api.github.com/repos/tektoncd/pipeline/releases"
)

// Structs to hold API responses
type CatBreed struct {
        Name string `json:"name"`
}

type Release struct {
        Name string `json:"name"`
}

func httpGet(url string) (*http.Response, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("User-Agent", "golang-tekton-bot/0.1")

        return http.DefaultClient.Do(req)</span>
}

// Fetch cat breeds and organize them by first letter
func getCatBreeds() (map[string][]string, error) <span class="cov0" title="0">{
        resp, err := httpGet(CatAPIURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var breeds []CatBreed
        if err := json.NewDecoder(resp.Body).Decode(&amp;breeds); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">catDict := make(map[string][]string)
        for _, breed := range breeds </span><span class="cov0" title="0">{
                firstLetter := strings.ToUpper(string(breed.Name[0]))
                catDict[firstLetter] = append(catDict[firstLetter], breed.Name)
        }</span>

        <span class="cov0" title="0">return catDict, nil</span>
}

// Scrape Wikipedia for robot names
func getRobotNames() (map[string][]string, error) <span class="cov0" title="0">{
        resp, err := httpGet(RobotWikiURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        bodyBytes, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">robotDict := make(map[string][]string)

        // Regex to extract robot names from &lt;li&gt;&lt;b&gt;Robot Name&lt;/b&gt;
        re := regexp.MustCompile(`&lt;li&gt;\s*&lt;b&gt;\s*&lt;a[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;\s*&lt;/b&gt;`)
        matches := re.FindAllStringSubmatch(string(bodyBytes), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        name := strings.TrimSpace(match[1])
                        firstLetter := strings.ToUpper(string(name[0]))
                        robotDict[firstLetter] = append(robotDict[firstLetter], name)
                }</span>
        }

        <span class="cov0" title="0">return robotDict, nil</span>
}

// Fetch past releases from GitHub
func getPastReleases() (map[string]bool, error) <span class="cov0" title="0">{
        pastReleases := make(map[string]bool)
        page := 1
        perPage := 100

        // Loop until we get an page smaller than perPage (or empty)
        for </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s?per_page=%d&amp;page=%d", GitHubReleasesURL, perPage, page)
                resp, err := httpGet(url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch releases page %d: %w", page, err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                var pageReleases []Release
                if err := json.NewDecoder(resp.Body).Decode(&amp;pageReleases); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch releases page %d: %w", page, err)
                }</span>

                // If we got an empty page, we've reached the end
                <span class="cov0" title="0">if len(pageReleases) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">pastReleases := make(map[string]bool)
                for _, release := range pageReleases </span><span class="cov0" title="0">{
                        pastReleases[release.Name] = true
                }</span>

                // If we got fewer than the requested number, we've reached the end
                <span class="cov0" title="0">if len(pageReleases) &lt; perPage </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">page++</span>
        }

        <span class="cov0" title="0">return pastReleases, nil</span>
}

func randomElement(array []string) (string, error) <span class="cov0" title="0">{
        n, err := rand.Int(rand.Reader, big.NewInt(int64(len(array))))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return array[n.Int64()], nil</span>
}

// Generate a unique release name
func generateUniqueTuple() (string, string, error) <span class="cov0" title="0">{
        catBreeds, err := getCatBreeds()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">robotNames, err := getRobotNames()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">pastReleases, err := getPastReleases()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Find common letters
        <span class="cov0" title="0">commonLetters := []string{}
        for letter := range catBreeds </span><span class="cov0" title="0">{
                if _, exists := robotNames[letter]; exists </span><span class="cov0" title="0">{
                        commonLetters = append(commonLetters, letter)
                }</span>
        }

        <span class="cov0" title="0">if len(commonLetters) == 0 </span><span class="cov0" title="0">{
                return "", "", errors.New("no matching names found")
        }</span>

        <span class="cov0" title="0">maxAttempts := 10
        for range maxAttempts </span><span class="cov0" title="0">{
                chosenLetter, err := randomElement(commonLetters)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>

                <span class="cov0" title="0">cat, err := randomElement(catBreeds[chosenLetter])
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>

                <span class="cov0" title="0">robot, err := randomElement(robotNames[chosenLetter])
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>

                <span class="cov0" title="0">newName := cat + " " + robot
                if !pastReleases[newName] </span><span class="cov0" title="0">{
                        return cat, robot, nil
                }</span>
        }

        <span class="cov0" title="0">return "", "", errors.New("could not generate a unique name after multiple attempts")</span>
}

func printJsonError(err error) <span class="cov0" title="0">{
        fmt.Println(`{"error": "` + err.Error() + `"}`) //nolint:forbidigo
}</span>

func main() <span class="cov0" title="0">{
        cat, robot, err := generateUniqueTuple()
        if err != nil </span><span class="cov0" title="0">{
                printJsonError(err)
                return
        }</span>

        <span class="cov0" title="0">output := map[string]string{
                "release_name":  cat + " " + robot,
                "cat_breed_url": WikiURL + strings.ReplaceAll(cat, " ", "_"),
                "robot_url":     WikiURL + strings.ReplaceAll(robot, " ", "_"),
        }

        jsonOutput, err := json.MarshalIndent(output, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                printJsonError(err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonOutput))</span> //nolint:forbidigo
}
</pre>
		
		<pre class="file" id="file527" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "context"
        "fmt"
        "io"
        "strings"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/test/logging"
)

// CollectPodLogs will get the logs for all containers in a Pod
func CollectPodLogs(ctx context.Context, c *clients, podName, namespace string, logf logging.FormatLogger) <span class="cov0" title="0">{
        logs, err := getContainersLogsFromPod(ctx, c.KubeClient, podName, namespace)
        if err != nil </span><span class="cov0" title="0">{
                logf("Could not get logs for pod %s: %s", podName, err)
        }</span>
        <span class="cov0" title="0">logf("build logs %s", logs)</span>
}

func getContainersLogsFromPod(ctx context.Context, c kubernetes.Interface, pod, namespace string) (string, error) <span class="cov0" title="0">{
        p, err := c.CoreV1().Pods(namespace).Get(ctx, pod, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sb := strings.Builder{}
        for _, container := range p.Spec.Containers </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("\n&gt;&gt;&gt; Pod %s Container %s:\n", p.Name, container.Name))
                logs, err := getContainerLogsFromPod(ctx, c, pod, container.Name, namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">sb.WriteString(logs)</span>
        }
        <span class="cov0" title="0">return sb.String(), nil</span>
}

func getContainerLogsFromPod(ctx context.Context, c kubernetes.Interface, pod, container, namespace string) (string, error) <span class="cov0" title="0">{
        sb := strings.Builder{}
        // Do not follow, which will block until the Pod terminates, and potentially deadlock the test.
        // If done in the wrong order, this could actually block things and prevent the Pod from being
        // deleted at all.
        req := c.CoreV1().Pods(namespace).GetLogs(pod, &amp;corev1.PodLogOptions{Follow: false, Container: container})
        rc, err := req.Stream(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">bs, err := io.ReadAll(rc)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">sb.Write(bs)
        return sb.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file528" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
Get access to client objects

To initialize client objects you can use the setup function. It returns a clients struct
that contains initialized clients for accessing:

        - Kubernetes objects
        - Pipelines (https://github.com/tektoncd/pipeline#pipeline)

For example, to create a Pipeline

        _, err = clients.V1beta1PipelineClient.Pipelines.Create(test.Pipeline(namespaceName, pipelineName))

And you can use the client to clean up resources created by your test

        func tearDown(clients *test.Clients) {
            if clients != nil {
                clients.Delete([]string{routeName}, []string{configName})
            }
        }

*/

package test

import (
        "testing"

        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        v1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1beta1"
        resolutionversioned "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/typed/resolution/v1alpha1"
        apixclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        "k8s.io/client-go/kubernetes"
        knativetest "knative.dev/pkg/test"
)

// clients holds instances of interfaces for making requests to the Pipeline controllers.
type clients struct {
        KubeClient kubernetes.Interface
        ApixClient apixclient.Interface

        V1beta1PipelineClient            v1beta1.PipelineInterface
        V1beta1TaskClient                v1beta1.TaskInterface
        V1beta1TaskRunClient             v1beta1.TaskRunInterface
        V1beta1PipelineRunClient         v1beta1.PipelineRunInterface
        V1beta1CustomRunClient           v1beta1.CustomRunInterface
        V1alpha1ResolutionRequestclient  resolutionv1alpha1.ResolutionRequestInterface
        V1alpha1VerificationPolicyClient v1alpha1.VerificationPolicyInterface
        V1PipelineClient                 v1.PipelineInterface
        V1TaskClient                     v1.TaskInterface
        V1TaskRunClient                  v1.TaskRunInterface
        V1PipelineRunClient              v1.PipelineRunInterface
        V1beta1StepActionClient          v1beta1.StepActionInterface
}

// newClients instantiates and returns several clientsets required for making requests to the
// Pipeline cluster specified by the combination of clusterName and configPath. Clients can
// make requests within namespace.
func newClients(t *testing.T, configPath, clusterName, namespace string) *clients <span class="cov0" title="0">{
        t.Helper()
        var err error
        c := &amp;clients{}

        cfg, err := knativetest.BuildClientConfig(configPath, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create configuration obj from %s for cluster %s: %s", configPath, clusterName, err)
        }</span>

        <span class="cov0" title="0">kubeClient, err := kubernetes.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create kubeclient from config file at %s: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">c.KubeClient = kubeClient

        apixClient, err := apixclient.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create apixclient from config file at %s: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">c.ApixClient = apixClient

        cs, err := versioned.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create pipeline clientset from config file at %s: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">rrcs, err := resolutionversioned.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create resolution clientset from config file at %s: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">c.V1beta1PipelineClient = cs.TektonV1beta1().Pipelines(namespace)
        c.V1beta1TaskClient = cs.TektonV1beta1().Tasks(namespace)
        c.V1beta1TaskRunClient = cs.TektonV1beta1().TaskRuns(namespace)
        c.V1beta1PipelineRunClient = cs.TektonV1beta1().PipelineRuns(namespace)
        c.V1beta1CustomRunClient = cs.TektonV1beta1().CustomRuns(namespace)
        c.V1alpha1ResolutionRequestclient = rrcs.ResolutionV1alpha1().ResolutionRequests(namespace)
        c.V1alpha1VerificationPolicyClient = cs.TektonV1alpha1().VerificationPolicies(namespace)
        c.V1PipelineClient = cs.TektonV1().Pipelines(namespace)
        c.V1TaskClient = cs.TektonV1().Tasks(namespace)
        c.V1TaskRunClient = cs.TektonV1().TaskRuns(namespace)
        c.V1PipelineRunClient = cs.TektonV1().PipelineRuns(namespace)
        c.V1beta1StepActionClient = cs.TektonV1beta1().StepActions(namespace)
        return c</span>
}
</pre>
		
		<pre class="file" id="file529" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "context"
        "fmt"
        "sync/atomic"
        "testing"

        // Link in the fakes so they get injected into injection.Fake
        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        resolutionv1alpha1 "github.com/tektoncd/pipeline/pkg/apis/resolution/v1beta1"
        fakepipelineclientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/fake"
        informersv1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1"
        informersv1alpha1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1alpha1"
        informersv1beta1 "github.com/tektoncd/pipeline/pkg/client/informers/externalversions/pipeline/v1beta1"
        fakepipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client/fake"
        fakepipelineinformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipeline/fake"
        fakepipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/fake"
        faketaskinformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/task/fake"
        faketaskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/fake"
        fakeverificationpolicyinformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1alpha1/verificationpolicy/fake"
        fakecustomruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun/fake"
        fakestepactioninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/stepaction/fake"
        fakeresolutionclientset "github.com/tektoncd/pipeline/pkg/client/resolution/clientset/versioned/fake"
        resolutioninformersv1alpha1 "github.com/tektoncd/pipeline/pkg/client/resolution/informers/externalversions/resolution/v1beta1"
        fakeresolutionrequestclient "github.com/tektoncd/pipeline/pkg/client/resolution/injection/client/fake"
        fakeresolutionrequestinformer "github.com/tektoncd/pipeline/pkg/client/resolution/injection/informers/resolution/v1beta1/resolutionrequest/fake"
        cloudeventclient "github.com/tektoncd/pipeline/pkg/reconciler/events/cloudevent"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        coreinformers "k8s.io/client-go/informers/core/v1"
        fakekubeclientset "k8s.io/client-go/kubernetes/fake"
        ktesting "k8s.io/client-go/testing"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/record"
        fakekubeclient "knative.dev/pkg/client/injection/kube/client/fake"
        fakeconfigmapinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/configmap/fake"
        fakelimitrangeinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/limitrange/fake"
        fakefilteredpodinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/pod/filtered/fake"
        fakesecretinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/secret/fake"
        fakeserviceaccountinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/serviceaccount/fake"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/system"
)

// Data represents the desired state of the system (i.e. existing resources) to seed controllers
// with.
type Data struct {
        PipelineRuns            []*v1.PipelineRun
        Pipelines               []*v1.Pipeline
        TaskRuns                []*v1.TaskRun
        Tasks                   []*v1.Task
        StepActions             []*v1beta1.StepAction
        CustomRuns              []*v1beta1.CustomRun
        Pods                    []*corev1.Pod
        Namespaces              []*corev1.Namespace
        ConfigMaps              []*corev1.ConfigMap
        ServiceAccounts         []*corev1.ServiceAccount
        LimitRange              []*corev1.LimitRange
        ResolutionRequests      []*resolutionv1alpha1.ResolutionRequest
        ExpectedCloudEventCount int
        VerificationPolicies    []*v1alpha1.VerificationPolicy
        Secrets                 []*corev1.Secret
}

// Clients holds references to clients which are useful for reconciler tests.
type Clients struct {
        Pipeline           *fakepipelineclientset.Clientset
        Kube               *fakekubeclientset.Clientset
        CloudEvents        cloudeventclient.CEClient
        ResolutionRequests *fakeresolutionclientset.Clientset
}

// Informers holds references to informers which are useful for reconciler tests.
type Informers struct {
        PipelineRun        informersv1.PipelineRunInformer
        Pipeline           informersv1.PipelineInformer
        TaskRun            informersv1.TaskRunInformer
        Run                informersv1alpha1.RunInformer
        CustomRun          informersv1beta1.CustomRunInformer
        Task               informersv1.TaskInformer
        StepAction         informersv1beta1.StepActionInformer
        Pod                coreinformers.PodInformer
        ConfigMap          coreinformers.ConfigMapInformer
        ServiceAccount     coreinformers.ServiceAccountInformer
        LimitRange         coreinformers.LimitRangeInformer
        ResolutionRequest  resolutioninformersv1alpha1.ResolutionRequestInformer
        VerificationPolicy informersv1alpha1.VerificationPolicyInformer
        Secret             coreinformers.SecretInformer
}

// Assets holds references to the controller, logs, clients, and informers.
type Assets struct {
        Logger     *zap.SugaredLogger
        Controller *controller.Impl
        Clients    Clients
        Informers  Informers
        Recorder   *record.FakeRecorder
        Ctx        context.Context
}

// AddToInformer returns a function to add ktesting.Actions to the cache store
func AddToInformer(t *testing.T, store cache.Store) func(ktesting.Action) (bool, runtime.Object, error) <span class="cov8" title="1">{
        t.Helper()
        return func(action ktesting.Action) (bool, runtime.Object, error) </span><span class="cov8" title="1">{
                switch a := action.(type) </span>{
                case ktesting.CreateActionImpl:<span class="cov8" title="1">
                        if err := store.Add(a.GetObject()); err != nil </span><span class="cov0" title="0">{
                                t.Fatal(err)
                        }</span>

                case ktesting.UpdateActionImpl:<span class="cov8" title="1">
                        objMeta, err := meta.Accessor(a.GetObject())
                        if err != nil </span><span class="cov0" title="0">{
                                return true, nil, err
                        }</span>

                        // Look up the old copy of this resource and perform the optimistic concurrency check.
                        <span class="cov8" title="1">old, exists, err := store.GetByKey(objMeta.GetNamespace() + "/" + objMeta.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return true, nil, err
                        }</span> else<span class="cov8" title="1"> if !exists </span><span class="cov0" title="0">{
                                // Let the client return the error.
                                return false, nil, nil
                        }</span>
                        <span class="cov8" title="1">oldMeta, err := meta.Accessor(old)
                        if err != nil </span><span class="cov0" title="0">{
                                return true, nil, err
                        }</span>
                        // If the resource version is mismatched, then fail with a conflict.
                        <span class="cov8" title="1">if oldMeta.GetResourceVersion() != objMeta.GetResourceVersion() </span><span class="cov8" title="1">{
                                return true, nil, apierrs.NewConflict(
                                        a.Resource.GroupResource(), objMeta.GetName(),
                                        fmt.Errorf("resourceVersion mismatch, got: %v, wanted: %v",
                                                objMeta.GetResourceVersion(), oldMeta.GetResourceVersion()))
                        }</span>

                        // Update the store with the new object when it's fine.
                        <span class="cov8" title="1">if err := store.Update(a.GetObject()); err != nil </span><span class="cov0" title="0">{
                                t.Fatal(err)
                        }</span>
                }
                <span class="cov8" title="1">return false, nil, nil</span>
        }
}

// SeedTestData returns Clients and Informers populated with the
// given Data.
//
//nolint:revive
func SeedTestData(t *testing.T, ctx context.Context, d Data) (Clients, Informers) <span class="cov0" title="0">{
        t.Helper()
        c := Clients{
                Kube:               fakekubeclient.Get(ctx),
                Pipeline:           fakepipelineclient.Get(ctx),
                CloudEvents:        cloudeventclient.Get(ctx),
                ResolutionRequests: fakeresolutionrequestclient.Get(ctx),
        }
        // Every time a resource is modified, change the metadata.resourceVersion.
        PrependResourceVersionReactor(&amp;c.Pipeline.Fake)

        i := Informers{
                PipelineRun:        fakepipelineruninformer.Get(ctx),
                Pipeline:           fakepipelineinformer.Get(ctx),
                TaskRun:            faketaskruninformer.Get(ctx),
                CustomRun:          fakecustomruninformer.Get(ctx),
                Task:               faketaskinformer.Get(ctx),
                StepAction:         fakestepactioninformer.Get(ctx),
                Pod:                fakefilteredpodinformer.Get(ctx, v1.ManagedByLabelKey),
                ConfigMap:          fakeconfigmapinformer.Get(ctx),
                ServiceAccount:     fakeserviceaccountinformer.Get(ctx),
                LimitRange:         fakelimitrangeinformer.Get(ctx),
                ResolutionRequest:  fakeresolutionrequestinformer.Get(ctx),
                VerificationPolicy: fakeverificationpolicyinformer.Get(ctx),
                Secret:             fakesecretinformer.Get(ctx),
        }

        // Attach reactors that add resource mutations to the appropriate
        // informer index, and simulate optimistic concurrency failures when
        // the resource version is mismatched.
        c.Pipeline.PrependReactor("*", "pipelineruns", AddToInformer(t, i.PipelineRun.Informer().GetIndexer()))
        for _, pr := range d.PipelineRuns </span><span class="cov0" title="0">{
                pr := pr.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1().PipelineRuns(pr.Namespace).Create(ctx, pr, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "pipelines", AddToInformer(t, i.Pipeline.Informer().GetIndexer()))
        for _, p := range d.Pipelines </span><span class="cov0" title="0">{
                p := p.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1().Pipelines(p.Namespace).Create(ctx, p, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "taskruns", AddToInformer(t, i.TaskRun.Informer().GetIndexer()))
        for _, tr := range d.TaskRuns </span><span class="cov0" title="0">{
                tr := tr.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1().TaskRuns(tr.Namespace).Create(ctx, tr, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "tasks", AddToInformer(t, i.Task.Informer().GetIndexer()))
        for _, ta := range d.Tasks </span><span class="cov0" title="0">{
                ta := ta.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1().Tasks(ta.Namespace).Create(ctx, ta, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "stepactions", AddToInformer(t, i.StepAction.Informer().GetIndexer()))
        for _, sa := range d.StepActions </span><span class="cov0" title="0">{
                sa := sa.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1beta1().StepActions(sa.Namespace).Create(ctx, sa, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "customruns", AddToInformer(t, i.CustomRun.Informer().GetIndexer()))
        for _, customRun := range d.CustomRuns </span><span class="cov0" title="0">{
                customRun := customRun.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1beta1().CustomRuns(customRun.Namespace).Create(ctx, customRun, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Kube.PrependReactor("*", "pods", AddToInformer(t, i.Pod.Informer().GetIndexer()))
        for _, p := range d.Pods </span><span class="cov0" title="0">{
                p := p.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Kube.CoreV1().Pods(p.Namespace).Create(ctx, p, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">for _, n := range d.Namespaces </span><span class="cov0" title="0">{
                n := n.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Kube.CoreV1().Namespaces().Create(ctx, n, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Kube.PrependReactor("*", "configmaps", AddToInformer(t, i.ConfigMap.Informer().GetIndexer()))
        for _, cm := range d.ConfigMaps </span><span class="cov0" title="0">{
                cm := cm.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Kube.CoreV1().ConfigMaps(cm.Namespace).Create(ctx, cm, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Kube.PrependReactor("*", "serviceaccounts", AddToInformer(t, i.ServiceAccount.Informer().GetIndexer()))
        for _, sa := range d.ServiceAccounts </span><span class="cov0" title="0">{
                sa := sa.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Kube.CoreV1().ServiceAccounts(sa.Namespace).Create(ctx, sa, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.ResolutionRequests.PrependReactor("*", "resolutionrequests", AddToInformer(t, i.ResolutionRequest.Informer().GetIndexer()))
        for _, rr := range d.ResolutionRequests </span><span class="cov0" title="0">{
                rr := rr.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.ResolutionRequests.ResolutionV1beta1().ResolutionRequests(rr.Namespace).Create(ctx, rr, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }

        <span class="cov0" title="0">c.Pipeline.PrependReactor("*", "verificationpolicies", AddToInformer(t, i.VerificationPolicy.Informer().GetIndexer()))
        for _, vp := range d.VerificationPolicies </span><span class="cov0" title="0">{
                vp := vp.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Pipeline.TektonV1alpha1().VerificationPolicies(vp.Namespace).Create(ctx, vp, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }

        <span class="cov0" title="0">c.Kube.PrependReactor("*", "secrets", AddToInformer(t, i.Secret.Informer().GetIndexer()))
        for _, s := range d.Secrets </span><span class="cov0" title="0">{
                s := s.DeepCopy() // Avoid assumptions that the informer's copy is modified.
                if _, err := c.Kube.CoreV1().Secrets(s.Namespace).Create(ctx, s, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        t.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">c.Pipeline.ClearActions()
        c.Kube.ClearActions()
        c.ResolutionRequests.ClearActions()
        return c, i</span>
}

// ResourceVersionReactor is an implementation of Reactor for our tests
type ResourceVersionReactor struct {
        count int64
}

// Handles returns whether our test reactor can handle a given ktesting.Action
func (r *ResourceVersionReactor) Handles(action ktesting.Action) bool <span class="cov8" title="1">{
        body := func(o runtime.Object) bool </span><span class="cov8" title="1">{
                objMeta, err := meta.Accessor(o)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">val := atomic.AddInt64(&amp;r.count, 1)
                objMeta.SetResourceVersion(fmt.Sprintf("%05d", val))
                return false</span>
        }

        <span class="cov8" title="1">switch o := action.(type) </span>{
        case ktesting.CreateActionImpl:<span class="cov8" title="1">
                return body(o.GetObject())</span>
        case ktesting.UpdateActionImpl:<span class="cov8" title="1">
                return body(o.GetObject())</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// React is noop-function
func (r *ResourceVersionReactor) React(action ktesting.Action) (handled bool, ret runtime.Object, err error) <span class="cov0" title="0">{
        return false, nil, nil
}</span>

var _ ktesting.Reactor = (*ResourceVersionReactor)(nil)

// PrependResourceVersionReactor will instrument a client-go testing Fake
// with a reactor that simulates resourceVersion changes on mutations.
// This does not work with patches.
func PrependResourceVersionReactor(f *ktesting.Fake) <span class="cov8" title="1">{
        f.ReactionChain = append([]ktesting.Reactor{&amp;ResourceVersionReactor{}}, f.ReactionChain...)
}</span>

// EnsureConfigurationConfigMapsExist makes sure all the configmaps exists.
func EnsureConfigurationConfigMapsExist(d *Data) <span class="cov8" title="1">{
        var defaultsExists, featureFlagsExists, metricsExists, spireconfigExists, eventsExists, tracingExists, backoffExists bool
        for _, cm := range d.ConfigMaps </span><span class="cov0" title="0">{
                if cm.Name == config.GetDefaultsConfigName() </span><span class="cov0" title="0">{
                        defaultsExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetFeatureFlagsConfigName() </span><span class="cov0" title="0">{
                        featureFlagsExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetMetricsConfigName() </span><span class="cov0" title="0">{
                        metricsExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetSpireConfigName() </span><span class="cov0" title="0">{
                        spireconfigExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetEventsConfigName() </span><span class="cov0" title="0">{
                        eventsExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetTracingConfigName() </span><span class="cov0" title="0">{
                        tracingExists = true
                }</span>
                <span class="cov0" title="0">if cm.Name == config.GetWaitExponentialBackoffConfigName() </span><span class="cov0" title="0">{
                        backoffExists = true
                }</span>
        }
        <span class="cov8" title="1">if !defaultsExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetDefaultsConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !featureFlagsExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetFeatureFlagsConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !metricsExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetMetricsConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !spireconfigExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetSpireConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !eventsExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetEventsConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !tracingExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetTracingConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
        <span class="cov8" title="1">if !backoffExists </span><span class="cov8" title="1">{
                d.ConfigMaps = append(d.ConfigMaps, &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{Name: config.GetWaitExponentialBackoffConfigName(), Namespace: system.Namespace()},
                        Data:       map[string]string{},
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file530" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "testing"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        resolverconfig "github.com/tektoncd/pipeline/pkg/apis/config/resolver"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/system"
)

// requireAnyGate returns a setup func that will skip the current
// test if none of the feature-flags in the given map match
// what's in the feature-flags ConfigMap. It will fatally fail
// the test if it cannot get the feature-flag configmap.
func requireAnyGate(gates map[string]string) func(context.Context, *testing.T, *clients, string) <span class="cov0" title="0">{
        return func(ctx context.Context, t *testing.T, c *clients, namespace string) </span><span class="cov0" title="0">{
                t.Helper()
                featureFlagsCM, err := c.KubeClient.CoreV1().ConfigMaps(system.Namespace()).Get(ctx, config.GetFeatureFlagsConfigName(), metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to get ConfigMap `%s`: %s", config.GetFeatureFlagsConfigName(), err)
                }</span>
                <span class="cov0" title="0">resolverFeatureFlagsCM, err := c.KubeClient.CoreV1().ConfigMaps(resolverconfig.ResolversNamespace(system.Namespace())).
                        Get(ctx, resolverconfig.GetFeatureFlagsConfigName(), metav1.GetOptions{})
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to get ConfigMap `%s`: %s", resolverconfig.GetFeatureFlagsConfigName(), err)
                }</span>
                <span class="cov0" title="0">resolverMap := make(map[string]string)
                if resolverFeatureFlagsCM != nil </span><span class="cov0" title="0">{
                        resolverMap = resolverFeatureFlagsCM.Data
                }</span>
                <span class="cov0" title="0">pairs := []string{}
                for name, value := range gates </span><span class="cov0" title="0">{
                        actual, ok := featureFlagsCM.Data[name]
                        if ok &amp;&amp; value == actual </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">actual, ok = resolverMap[name]
                        if ok &amp;&amp; value == actual </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">pairs = append(pairs, fmt.Sprintf("%q: %q", name, value))</span>
                }
                <span class="cov0" title="0">t.Skipf("No feature flag in namespace %q matching %s\nExisting feature flag: %#v\nExisting resolver feature flag (in namespace %q): %#v",
                        system.Namespace(), strings.Join(pairs, " or "), featureFlagsCM.Data,
                        resolverconfig.ResolversNamespace(system.Namespace()), resolverMap)</span>
        }
}

// requireAllGates returns a setup func that will skip the current
// test if all of the feature-flags in the given map don't match
// what's in the feature-flags ConfigMap. It will fatally fail
// the test if it cannot get the feature-flag configmap.
func requireAllGates(gates map[string]string) func(context.Context, *testing.T, *clients, string) <span class="cov0" title="0">{
        return func(ctx context.Context, t *testing.T, c *clients, namespace string) </span><span class="cov0" title="0">{
                t.Helper()
                featureFlagsCM, err := c.KubeClient.CoreV1().ConfigMaps(system.Namespace()).Get(ctx, config.GetFeatureFlagsConfigName(), metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to get ConfigMap `%s`: %s", config.GetFeatureFlagsConfigName(), err)
                }</span>
                <span class="cov0" title="0">resolverFeatureFlagsCM, err := c.KubeClient.CoreV1().ConfigMaps(resolverconfig.ResolversNamespace(system.Namespace())).
                        Get(ctx, resolverconfig.GetFeatureFlagsConfigName(), metav1.GetOptions{})
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to get ConfigMap `%s`: %s", resolverconfig.GetFeatureFlagsConfigName(), err)
                }</span>
                <span class="cov0" title="0">resolverMap := make(map[string]string)
                if resolverFeatureFlagsCM != nil </span><span class="cov0" title="0">{
                        resolverMap = resolverFeatureFlagsCM.Data
                }</span>
                <span class="cov0" title="0">pairs := []string{}
                for name, value := range gates </span><span class="cov0" title="0">{
                        actual, ok := featureFlagsCM.Data[name]
                        if !ok </span><span class="cov0" title="0">{
                                actual, ok = resolverMap[name]
                                if !ok || value != actual </span><span class="cov0" title="0">{
                                        pairs = append(pairs, fmt.Sprintf("%q is %q, want %s", name, actual, value))
                                }</span>
                        } else<span class="cov0" title="0"> if value != actual </span><span class="cov0" title="0">{
                                pairs = append(pairs, fmt.Sprintf("%q is %q, want %s", name, actual, value))
                        }</span>
                }
                <span class="cov0" title="0">if len(pairs) &gt; 0 </span><span class="cov0" title="0">{
                        t.Skipf("One or more feature flags not matching required: %s", strings.Join(pairs, "; "))
                }</span>
        }
}

func getFeatureFlagsBaseOnAPIFlag(t *testing.T) *config.FeatureFlags <span class="cov0" title="0">{
        t.Helper()
        alphaFeatureFlags, err := config.NewFeatureFlagsFromMap(map[string]string{
                "enable-api-fields":              "alpha",
                "results-from":                   "sidecar-logs",
                "enable-tekton-oci-bundles":      "true",
                "enable-cel-in-whenexpression":   "true",
                "enable-param-enum":              "true",
                "enable-artifacts":               "true",
                "enable-concise-resolver-syntax": "true",
                "enable-kubernetes-sidecar":      "true",
                "keep-pod-on-cancel":             "true",
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error creating alpha feature flags configmap: %v", err)
        }</span>
        <span class="cov0" title="0">betaFeatureFlags, err := config.NewFeatureFlagsFromMap(map[string]string{
                "results-from":       "sidecar-logs",
                "enable-api-fields":  "beta",
                "keep-pod-on-cancel": "true",
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error creating beta feature flags configmap: %v", err)
        }</span>
        <span class="cov0" title="0">stableFeatureFlags, err := config.NewFeatureFlagsFromMap(map[string]string{
                "enable-api-fields": "stable",
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error creating stable feature flags configmap: %v", err)
        }</span>
        <span class="cov0" title="0">enabledFeatureGate, err := getAPIFeatureGate()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error reading enabled feature gate: %v", err)
        }</span>
        <span class="cov0" title="0">switch enabledFeatureGate </span>{
        case "alpha":<span class="cov0" title="0">
                return alphaFeatureFlags</span>
        case "beta":<span class="cov0" title="0">
                return betaFeatureFlags</span>
        default:<span class="cov0" title="0">
                return stableFeatureFlags</span>
        }
}

// getAPIFeatureGate queries the tekton pipelines namespace for the
// current value of the "enable-api-fields" feature gate.
func getAPIFeatureGate() (string, error) <span class="cov0" title="0">{
        ns := os.Getenv("SYSTEM_NAMESPACE")
        if ns == "" </span><span class="cov0" title="0">{
                ns = "tekton-pipelines"
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("kubectl", "get", "configmap", "feature-flags", "-n", ns, "-o", `jsonpath="{.data['enable-api-fields']}"`)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting feature-flags configmap: %w", err)
        }</span>
        <span class="cov0" title="0">output = bytes.TrimSpace(output)
        output = bytes.Trim(output, "\"")
        if len(output) == 0 </span><span class="cov0" title="0">{
                output = []byte("stable")
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}
</pre>
		
		<pre class="file" id="file531" style="display: none">/*
 Copyright 2022 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

*/

package test

import (
        "bytes"
        "os/exec"
        "regexp"
)

var (
        defaultNamespaceRE = regexp.MustCompile("namespace: default")
)

func kubectlCreate(input []byte, namespace string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.Command("kubectl", "create", "-n", namespace, "-f", "-")
        cmd.Stdin = bytes.NewReader(input)
        return cmd.CombinedOutput()
}</span>
</pre>
		
		<pre class="file" id="file532" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "os"
        "runtime"
        "testing"

        "k8s.io/apimachinery/pkg/util/sets"
)

var (
        imageNames    = initImageNames()
        excludedTests = initExcludedTests()
)

const (
        // Busybox image with specific sha
        busyboxImage = iota
        // Registry image
        registryImage
        // kubectl image
        kanikoImage
        // dockerize image
        dockerizeImage
)

// getTestArch returns architecture of the cluster where test suites will be executed.
// default value is similar to build architecture, TEST_RUNTIME_ARCH is used when test target cluster has another architecture
func getTestArch() string <span class="cov8" title="1">{
        val, ok := os.LookupEnv("TEST_RUNTIME_ARCH")
        if ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov8" title="1">return runtime.GOARCH</span>
}

// initImageNames returns the map with arch dependent image names for e2e tests
func initImageNames() map[int]string <span class="cov8" title="1">{
        switch getTestArch() </span>{
        case "s390x":<span class="cov0" title="0">
                return map[int]string{
                        busyboxImage:   "busybox@sha256:4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977",
                        registryImage:  "ibmcom/registry:2.6.2.5",
                        kanikoImage:    "gcr.io/kaniko-project/executor:s390x-9ed158c1f63a059cde4fd5f8b95af51d452d9aa7",
                        dockerizeImage: "ibmcom/dockerize-s390x",
                }</span>
        case "ppc64le":<span class="cov0" title="0">
                return map[int]string{
                        busyboxImage:   "busybox@sha256:4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977",
                        registryImage:  "ppc64le/registry:2",
                        kanikoImage:    "ibmcom/kaniko-project-executor-ppc64le:v0.17.1",
                        dockerizeImage: "ibmcom/dockerize-ppc64le",
                }</span>
        default:<span class="cov8" title="1">
                return map[int]string{
                        busyboxImage:   "busybox@sha256:895ab622e92e18d6b461d671081757af7dbaa3b00e3e28e12505af7817f73649",
                        registryImage:  "registry",
                        kanikoImage:    "gcr.io/kaniko-project/executor:v1.3.0",
                        dockerizeImage: "jwilder/dockerize",
                }</span>
        }
}

// initExcludedTests provides list of excluded tests for e2e and exanples tests
func initExcludedTests() sets.String <span class="cov8" title="1">{
        switch getTestArch() </span>{
        case "s390x":<span class="cov0" title="0">
                return sets.NewString(
                        // Git resolver test using local Gitea instance
                        "TestGitResolver_API",
                        // examples
                        "TestExamples/v1alpha1/taskruns/gcs-resource",
                        "TestExamples/v1beta1/taskruns/gcs-resource",
                        "TestExamples/v1beta1/taskruns/creds-init-only-mounts-provided-credentials",
                )</span>
        case "ppc64le":<span class="cov0" title="0">
                return sets.NewString(
                        // Git resolver test using local Gitea instance
                        "TestGitResolver_API",
                        // examples
                        "TestExamples/v1alpha1/taskruns/gcs-resource",
                        "TestExamples/v1beta1/taskruns/gcs-resource",
                )</span>
        }

        <span class="cov8" title="1">return sets.NewString()</span>
}

// getTestImage gets test image based on unique id
func getTestImage(image int) string <span class="cov0" title="0">{
        return imageNames[image]
}</span>

// skipIfExcluded checks if test name is in the excluded list and skip it
func skipIfExcluded(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        if excludedTests.Has(t.Name()) </span><span class="cov0" title="0">{
                t.Skipf("skip for %s architecture", getTestArch())
        }</span>
}
</pre>
		
		<pre class="file" id="file533" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "archive/tar"
        "bytes"
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/empty"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
        remoteimg "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
        tkremote "github.com/tektoncd/pipeline/pkg/remote/oci"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/yaml"
)

// ObjectAnnotationMapper is a func alias that maps a runtime Object to the Tekton Bundle annotations map.
type ObjectAnnotationMapper func(object runtime.Object) map[string]string

// DefaultObjectAnnotationMapper does the "right" thing by conforming to the Tekton Bundle spec.
var DefaultObjectAnnotationMapper = func(obj runtime.Object) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                tkremote.TitleAnnotation:      GetObjectName(obj),
                tkremote.KindAnnotation:       strings.TrimSuffix(strings.ToLower(obj.GetObjectKind().GroupVersionKind().Kind), "s"),
                tkremote.APIVersionAnnotation: obj.GetObjectKind().GroupVersionKind().Version,
        }
}</span>

// CreateImage will push a new OCI image artifact with the provided raw data object as a layer and return the full image
// reference with a digest to fetch the image. Key must be specified as [lowercase kind]/[object name]. The image ref
// with a digest is returned.
func CreateImage(ref string, objs ...runtime.Object) (string, error) <span class="cov8" title="1">{
        return CreateImageWithAnnotations(ref, DefaultObjectAnnotationMapper, objs...)
}</span>

// CreateImageWithAnnotations is the base form of #CreateImage which accepts an ObjectAnnotationMapper to map an object
// to the annotations for it.
func CreateImageWithAnnotations(ref string, mapper ObjectAnnotationMapper, objs ...runtime.Object) (string, error) <span class="cov8" title="1">{
        imgRef, err := name.ParseReference(ref)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("undexpected error producing image reference %w", err)
        }</span>

        <span class="cov8" title="1">img := empty.Image

        for _, obj := range objs </span><span class="cov8" title="1">{
                data, err := yaml.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("error serializing object: %w", err)
                }</span>

                // Compress the data into a tarball.
                <span class="cov8" title="1">var tarbundle bytes.Buffer
                writer := tar.NewWriter(&amp;tarbundle)
                if err := writer.WriteHeader(&amp;tar.Header{
                        Name:     GetObjectName(obj),
                        Mode:     0o600,
                        Size:     int64(len(data)),
                        Typeflag: tar.TypeReg,
                }); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">if _, err := writer.Write(data); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">layer, err := tarball.LayerFromReader(&amp;tarbundle)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unexpected error adding layer to image %w", err)
                }</span>

                <span class="cov8" title="1">annotations := mapper(obj)
                img, err = mutate.Append(img, mutate.Addendum{
                        Layer:       layer,
                        Annotations: annotations,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("could not add layer to image %w", err)
                }</span>
        }

        <span class="cov8" title="1">if err := remoteimg.Write(imgRef, img); err != nil </span><span class="cov0" title="0">{
                return "", errors.New("could not push example image to registry")
        }</span>

        <span class="cov8" title="1">digest, err := img.Digest()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not read image digest: %w", err)
        }</span>

        <span class="cov8" title="1">return imgRef.Context().Digest(digest.String()).String(), nil</span>
}

// GetObjectName returns the ObjectMetadata.Name field which every resource should have.
func GetObjectName(obj runtime.Object) string <span class="cov8" title="1">{
        return reflect.Indirect(reflect.ValueOf(obj)).FieldByName("ObjectMeta").FieldByName("Name").String()
}</span>
</pre>
		
		<pre class="file" id="file534" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package test

import (
        "bytes"
        "context"
        "crypto"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "os"
        "path/filepath"
        "testing"

        "github.com/sigstore/sigstore/pkg/cryptoutils"
        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/tektoncd/pipeline/pkg/apis/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        fakek8s "k8s.io/client-go/kubernetes/fake"
        "knative.dev/pkg/logging"
)

// TODO(#5820): refactor those into an internal pkg
const (
        namespace = "trusted-resources"
        // signatureAnnotation is the key of signature in annotation map
        signatureAnnotation = "tekton.dev/signature"
)

var read = readPasswordFn

// SetupTrustedResourceConfig configures the trusted-resources-verification-no-match-policy feature flag with the given mode for testing
func SetupTrustedResourceConfig(ctx context.Context, verificationNoMatchPolicy string) context.Context <span class="cov0" title="0">{
        store := config.NewStore(logging.FromContext(ctx).Named("config-store"))
        featureflags := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Namespace: namespace,
                        Name:      "feature-flags",
                },
                Data: map[string]string{
                        "trusted-resources-verification-no-match-policy": verificationNoMatchPolicy,
                },
        }
        store.OnConfigChanged(featureflags)

        return store.ToContext(ctx)
}</span>

// SetupVerificationPolicies set verification policies and secrets to store public keys.
// This function helps to setup 4 kinds of VerificationPolicies:
// 1. One public key in inline data
// 2. One public key in secret
// 3. the policy pattern doesn't match any resources
// 4. warn mode policy without keys
// SignerVerifier is returned to sign resources
// The k8s clientset is returned to fetch secret from it.
// VerificationPolicies are returned to fetch public keys
func SetupVerificationPolicies(t *testing.T) (signature.SignerVerifier, *ecdsa.PrivateKey, *fakek8s.Clientset, []*v1alpha1.VerificationPolicy) <span class="cov0" title="0">{
        t.Helper()
        sv, keys, pub, err := GenerateKeys(elliptic.P256(), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to generate keys %v", err)
        }</span>
        <span class="cov0" title="0">_, _, pub2, err := GenerateKeys(elliptic.P256(), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to generate keys %v", err)
        }</span>

        <span class="cov0" title="0">secret := &amp;corev1.Secret{
                Data: map[string][]byte{"cosign.pub": pub},
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "verification-secrets",
                        Namespace: namespace,
                },
        }

        keyInDataVp := getVerificationPolicy(
                "keyInDataVp",
                namespace,
                []v1alpha1.ResourcePattern{
                        {Pattern: "https://github.com/tektoncd/catalog.git"},
                },
                []v1alpha1.Authority{
                        {
                                Name: "pubkey",
                                Key: &amp;v1alpha1.KeyRef{
                                        Data:          string(pub),
                                        HashAlgorithm: "sha256",
                                },
                        },
                }, v1alpha1.ModeEnforce)

        keyInSecretVp := getVerificationPolicy(
                "keyInSecretVp",
                namespace,
                []v1alpha1.ResourcePattern{
                        {
                                Pattern: "gcr.io/tekton-releases/catalog/upstream/git-clone",
                        },
                },
                []v1alpha1.Authority{
                        {
                                Name: "pubkey",
                                Key: &amp;v1alpha1.KeyRef{
                                        SecretRef: &amp;corev1.SecretReference{
                                                Name:      secret.Name,
                                                Namespace: secret.Namespace,
                                        },
                                        HashAlgorithm: "sha256",
                                },
                        },
                }, v1alpha1.ModeEnforce)

        wrongKeyandPatternVp := getVerificationPolicy(
                "wrongKeyInDataVp",
                namespace,
                []v1alpha1.ResourcePattern{
                        {Pattern: "this should not match any resources"},
                },
                []v1alpha1.Authority{
                        {
                                Name: "pubkey",
                                Key: &amp;v1alpha1.KeyRef{
                                        Data:          string(pub2),
                                        HashAlgorithm: "sha256",
                                },
                        },
                }, v1alpha1.ModeEnforce)

        warnModeVP := getVerificationPolicy(
                "warnModeVP",
                namespace,
                []v1alpha1.ResourcePattern{
                        {
                                Pattern: "warnVP",
                        },
                },
                []v1alpha1.Authority{
                        {
                                Name: "pubkey",
                                Key: &amp;v1alpha1.KeyRef{
                                        SecretRef: &amp;corev1.SecretReference{
                                                Name:      secret.Name,
                                                Namespace: secret.Namespace,
                                        },
                                        HashAlgorithm: "sha256",
                                },
                        },
                }, v1alpha1.ModeWarn)

        k8sclient := fakek8s.NewSimpleClientset(secret)

        return sv, keys, k8sclient, []*v1alpha1.VerificationPolicy{&amp;keyInDataVp, &amp;keyInSecretVp, &amp;wrongKeyandPatternVp, &amp;warnModeVP}</span>
}

// SetupMatchAllVerificationPolicies set verification policies with a Pattern to match all resources
// SignerVerifier is returned to sign resources
// The k8s clientset is returned to fetch secret from it.
// VerificationPolicies are returned to fetch public keys
func SetupMatchAllVerificationPolicies(t *testing.T, namespace string) (signature.SignerVerifier, *fakek8s.Clientset, []*v1alpha1.VerificationPolicy) <span class="cov0" title="0">{
        t.Helper()
        sv, _, pub, err := GenerateKeys(elliptic.P256(), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to generate keys %v", err)
        }</span>

        <span class="cov0" title="0">secret := &amp;corev1.Secret{
                Data: map[string][]byte{"cosign.pub": pub},
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "verification-secrets",
                        Namespace: namespace,
                },
        }

        matchAllVp := getVerificationPolicy(
                "matchAllVp",
                namespace,
                []v1alpha1.ResourcePattern{
                        {Pattern: ".*"},
                },
                []v1alpha1.Authority{
                        {
                                Name: "pubkey",
                                Key: &amp;v1alpha1.KeyRef{
                                        Data:          string(pub),
                                        HashAlgorithm: "sha256",
                                },
                        },
                }, v1alpha1.ModeEnforce)

        k8sclient := fakek8s.NewSimpleClientset(secret)

        return sv, k8sclient, []*v1alpha1.VerificationPolicy{&amp;matchAllVp}</span>
}

// GetSignerFromFile generates key files to tmpdir, return signer and pubkey path
func GetSignerFromFile(ctx context.Context, t *testing.T) (signature.Signer, string) <span class="cov0" title="0">{
        t.Helper()
        sv, _, pub, err := GenerateKeys(elliptic.P256(), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov0" title="0">tmpDir := t.TempDir()
        pubKey := filepath.Join(tmpDir, "ecdsa.pub")
        if err := os.WriteFile(pubKey, pub, 0o600); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">return sv, pubKey</span>
}

// GetKeysFromFile generates key files to tmpdir, return keys and pubkey path
func GetKeysFromFile(ctx context.Context, t *testing.T) (*ecdsa.PrivateKey, string) <span class="cov0" title="0">{
        t.Helper()
        _, keys, pub, err := GenerateKeys(elliptic.P256(), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov0" title="0">tmpDir := t.TempDir()
        pubKey := filepath.Join(tmpDir, "ecdsa.pub")
        if err := os.WriteFile(pubKey, pub, 0o600); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">return keys, pubKey</span>
}

// GenerateKeys creates public key files, return the SignerVerifier
func GenerateKeys(c elliptic.Curve, hashFunc crypto.Hash) (signature.SignerVerifier, *ecdsa.PrivateKey, []byte, error) <span class="cov0" title="0">{
        keys, err := ecdsa.GenerateKey(c, rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Now do the public key
        <span class="cov0" title="0">pubBytes, err := cryptoutils.MarshalPublicKeyToPEM(keys.Public())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">sv, err := signature.LoadSignerVerifier(keys, hashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">return sv, keys, pubBytes, nil</span>
}

// signInterface returns the encoded signature for the given object.
func signInterface(signer signature.Signer, i interface{}) ([]byte, error) <span class="cov8" title="1">{
        if signer == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signer is nil")
        }</span>
        <span class="cov8" title="1">b, err := json.Marshal(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">h := sha256.New()
        h.Write(b)

        sig, err := signer.SignMessage(bytes.NewReader(h.Sum(nil)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return sig, nil</span>
}

// GetSignedV1beta1Pipeline signed the given pipeline and rename it with given name
func GetSignedV1beta1Pipeline(unsigned *v1beta1.Pipeline, signer signature.Signer, name string) (*v1beta1.Pipeline, error) <span class="cov0" title="0">{
        signedPipeline := unsigned.DeepCopy()
        signedPipeline.Name = name
        if signedPipeline.Annotations == nil </span><span class="cov0" title="0">{
                signedPipeline.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">signature, err := signInterface(signer, signedPipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">signedPipeline.Annotations[signatureAnnotation] = base64.StdEncoding.EncodeToString(signature)
        return signedPipeline, nil</span>
}

// GetSignedV1beta1Task signed the given task and rename it with given name
func GetSignedV1beta1Task(unsigned *v1beta1.Task, signer signature.Signer, name string) (*v1beta1.Task, error) <span class="cov0" title="0">{
        signedTask := unsigned.DeepCopy()
        signedTask.Name = name
        if signedTask.Annotations == nil </span><span class="cov0" title="0">{
                signedTask.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">signature, err := signInterface(signer, signedTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">signedTask.Annotations[signatureAnnotation] = base64.StdEncoding.EncodeToString(signature)
        return signedTask, nil</span>
}

// GetSignedV1Pipeline signed the given pipeline and rename it with given name
func GetSignedV1Pipeline(unsigned *v1.Pipeline, signer signature.Signer, name string) (*v1.Pipeline, error) <span class="cov0" title="0">{
        signedPipeline := unsigned.DeepCopy()
        signedPipeline.Name = name
        if signedPipeline.Annotations == nil </span><span class="cov0" title="0">{
                signedPipeline.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">signature, err := signInterface(signer, signedPipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">signedPipeline.Annotations[signatureAnnotation] = base64.StdEncoding.EncodeToString(signature)
        return signedPipeline, nil</span>
}

// GetSignedV1Task signed the given task and rename it with given name
func GetSignedV1Task(unsigned *v1.Task, signer signature.Signer, name string) (*v1.Task, error) <span class="cov0" title="0">{
        signedTask := unsigned.DeepCopy()
        signedTask.Name = name
        if signedTask.Annotations == nil </span><span class="cov0" title="0">{
                signedTask.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">signature, err := signInterface(signer, signedTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">signedTask.Annotations[signatureAnnotation] = base64.StdEncoding.EncodeToString(signature)
        return signedTask, nil</span>
}

func getPass(confirm bool) ([]byte, error) <span class="cov0" title="0">{
        read := read(confirm)
        return read()
}</span>

func readPasswordFn(confirm bool) func() ([]byte, error) <span class="cov0" title="0">{
        pw, ok := os.LookupEnv("PRIVATE_PASSWORD")
        if ok </span><span class="cov0" title="0">{
                return func() ([]byte, error) </span><span class="cov0" title="0">{
                        return []byte(pw), nil
                }</span>
        }
        <span class="cov0" title="0">return func() ([]byte, error) </span><span class="cov0" title="0">{
                return nil, errors.New("fail to get password")
        }</span>
}

func getVerificationPolicy(name, namespace string, patterns []v1alpha1.ResourcePattern, authorities []v1alpha1.Authority, mode v1alpha1.ModeType) v1alpha1.VerificationPolicy <span class="cov0" title="0">{
        return v1alpha1.VerificationPolicy{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "VerificationPolicy",
                        APIVersion: "v1alpha1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: v1alpha1.VerificationPolicySpec{
                        Resources:   patterns,
                        Authorities: authorities,
                        Mode:        mode,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file535" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
Poll Pipeline resources

After creating Pipeline resources or making changes to them, you will need to
wait for the system to realize those changes. You can use polling methods to
check the resources reach the desired state.

The WaitFor* functions use the kubernetes
wait package (https://godoc.org/k8s.io/apimachinery/pkg/util/wait). To poll
they use
PollImmediate (https://godoc.org/k8s.io/apimachinery/pkg/util/wait#PollImmediate)
and the return values of the function you provide behave the same as
ConditionFunc (https://godoc.org/k8s.io/apimachinery/pkg/util/wait#ConditionFunc):
a boolean to indicate if the function should stop or continue polling, and an
error to indicate if there has been an error.


For example, you can poll a TaskRun object to wait for it to have a Status.Condition:

        err = WaitForTaskRunState(c, hwTaskRunName, func(tr *v1alpha1.TaskRun) (bool, error) {
                if len(tr.Status.Conditions) &gt; 0 {
                        return true, nil
                }
                return false, nil
        }, "TaskRunHasCondition")

*/

package test

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "go.opencensus.io/trace"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/wait"
        "knative.dev/pkg/apis"
)

const (
        interval       = 1 * time.Second
        timeout        = 10 * time.Minute
        v1Version      = "v1"
        v1beta1Version = "v1beta1"
)

// ConditionAccessorFn is a condition function used polling functions
type ConditionAccessorFn func(ca apis.ConditionAccessor) (bool, error)

func pollImmediateWithContext(ctx context.Context, fn func() (bool, error)) error <span class="cov0" title="0">{
        return wait.PollImmediate(interval, timeout, func() (bool, error) </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return true, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">return fn()</span>
        })
}

// WaitForTaskRunState polls the status of the TaskRun called name from client every
// interval until inState returns `true` indicating it is done, returns an
// error or timeout. desc will be used to name the metric that is emitted to
// track how long it took for name to get into the state checked by inState.
// version will be used to determine the client to be applied for the wait.
func WaitForTaskRunState(ctx context.Context, c *clients, name string, inState ConditionAccessorFn, desc, version string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForTaskRunState/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                switch version </span>{
                case v1Version:<span class="cov0" title="0">
                        r, err := c.V1TaskRunClient.Get(ctx, name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov0" title="0">return inState(&amp;r.Status)</span>
                default:<span class="cov0" title="0">
                        r, err := c.V1beta1TaskRunClient.Get(ctx, name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov0" title="0">return inState(&amp;r.Status)</span>
                }
        })
}

// WaitForDeploymentState polls the status of the Deployment called name
// from client every interval until inState returns `true` indicating it is done,
// returns an  error or timeout. desc will be used to name the metric that is emitted to
// track how long it took for name to get into the state checked by inState.
func WaitForDeploymentState(ctx context.Context, c *clients, name string, namespace string, inState func(d *appsv1.Deployment) (bool, error), desc string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForDeploymentState/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                d, err := c.KubeClient.AppsV1().Deployments(namespace).Get(ctx, name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>
                <span class="cov0" title="0">return inState(d)</span>
        })
}

// WaitForPodState polls the status of the Pod called name from client every
// interval until inState returns `true` indicating it is done, returns an
// error or timeout. desc will be used to name the metric that is emitted to
// track how long it took for name to get into the state checked by inState.
func WaitForPodState(ctx context.Context, c *clients, name string, namespace string, inState func(r *corev1.Pod) (bool, error), desc string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForPodState/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                r, err := c.KubeClient.CoreV1().Pods(namespace).Get(ctx, name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>
                <span class="cov0" title="0">return inState(r)</span>
        })
}

// WaitForPVCIsDeleted polls the number of the PVC in the namespace from client every
// interval until all the PVCs in the namespace are deleted. It returns an
// error or timeout. desc will be used to name the metric that is emitted to
// track how long it took to delete all the PVCs in the namespace.
func WaitForPVCIsDeleted(ctx context.Context, c *clients, polltimeout time.Duration, name, namespace, desc string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForPVCIsDeleted/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        ctx, cancel := context.WithTimeout(ctx, polltimeout)
        defer cancel()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                pvcList, err := c.KubeClient.CoreV1().PersistentVolumeClaims(namespace).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>
                <span class="cov0" title="0">if len(pvcList.Items) &gt; 0 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        })
}

// WaitForPipelineRunState polls the status of the PipelineRun called name from client every
// interval until inState returns `true` indicating it is done, returns an
// error or timeout. desc will be used to name the metric that is emitted to
// track how long it took for name to get into the state checked by inState.
// version will be used to determine the client to be applied for the wait.
func WaitForPipelineRunState(ctx context.Context, c *clients, name string, polltimeout time.Duration, inState ConditionAccessorFn, desc, version string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForPipelineRunState/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        ctx, cancel := context.WithTimeout(ctx, polltimeout)
        defer cancel()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                switch version </span>{
                case "v1":<span class="cov0" title="0">
                        r, err := c.V1PipelineRunClient.Get(ctx, name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov0" title="0">return inState(&amp;r.Status)</span>
                default:<span class="cov0" title="0">
                        r, err := c.V1beta1PipelineRunClient.Get(ctx, name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov0" title="0">return inState(&amp;r.Status)</span>
                }
        })
}

// WaitForServiceExternalIPState polls the status of the a k8s Service called name from client every
// interval until an external ip is assigned indicating it is done, returns an
// error or timeout. desc will be used to name the metric that is emitted to
// track how long it took for name to get into the state checked by inState.
func WaitForServiceExternalIPState(ctx context.Context, c *clients, namespace, name string, inState func(s *corev1.Service) (bool, error), desc string) error <span class="cov0" title="0">{
        metricName := fmt.Sprintf("WaitForServiceExternalIPState/%s/%s", name, desc)
        _, span := trace.StartSpan(ctx, metricName)
        defer span.End()

        return pollImmediateWithContext(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                r, err := c.KubeClient.CoreV1().Services(namespace).Get(ctx, name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>
                <span class="cov0" title="0">return inState(r)</span>
        })
}

// Succeed provides a poll condition function that checks if the ConditionAccessor
// resource has successfully completed or not.
func Succeed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return true, nil
                        }</span> else<span class="cov0" title="0"> if c.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                return true, fmt.Errorf("%q failed", name)
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
}

// Failed provides a poll condition function that checks if the ConditionAccessor
// resource has failed or not.
func Failed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return true, fmt.Errorf("%q succeeded", name)
                        }</span> else<span class="cov0" title="0"> if c.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
}

// FailedWithReason provides a poll function that checks if the ConditionAccessor
// resource has failed with the TimeoudOut reason
func FailedWithReason(reason, name string) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                if c.Reason == reason </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                                <span class="cov0" title="0">return true, fmt.Errorf("%q completed with the wrong reason: %s (message: %s)", name, c.Reason, c.Message)</span>
                        } else<span class="cov0" title="0"> if c.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return true, fmt.Errorf("%q completed successfully, should have been failed with reason %q", name, reason)
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
}

// FailedWithMessage provides a poll function that checks if the ConditionAccessor
// resource has failed with the TimeoudOut reason
func FailedWithMessage(message, name string) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                if strings.Contains(c.Message, message) </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                                <span class="cov0" title="0">return true, fmt.Errorf("%q completed with the wrong message: %s", name, c.Message)</span>
                        } else<span class="cov0" title="0"> if c.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return true, fmt.Errorf("%q completed successfully, should have been failed with message %q", name, message)
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
}

// Running provides a poll condition function that checks if the ConditionAccessor
// resource is currently running.
func Running(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionTrue || c.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                return true, fmt.Errorf(`%q already finished`, name)
                        }</span> else<span class="cov0" title="0"> if c.Status == corev1.ConditionUnknown &amp;&amp; (c.Reason == "Running" || c.Reason == "Pending") </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
}

// TaskRunSucceed provides a poll condition function that checks if the TaskRun
// has successfully completed.
func TaskRunSucceed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return Succeed(name)
}</span>

// TaskRunFailed provides a poll condition function that checks if the TaskRun
// has failed.
func TaskRunFailed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return Failed(name)
}</span>

// PipelineRunSucceed provides a poll condition function that checks if the PipelineRun
// has successfully completed.
func PipelineRunSucceed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return Succeed(name)
}</span>

// PipelineRunFailed provides a poll condition function that checks if the PipelineRun
// has failed.
func PipelineRunFailed(name string) ConditionAccessorFn <span class="cov0" title="0">{
        return Failed(name)
}</span>

// PipelineRunPending provides a poll condition function that checks if the PipelineRun
// has been marked pending by the Tekton controller.
func PipelineRunPending(name string) ConditionAccessorFn <span class="cov0" title="0">{
        running := Running(name)

        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                c := ca.GetCondition(apis.ConditionSucceeded)
                if c != nil </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionUnknown &amp;&amp; c.Reason == string(v1beta1.PipelineRunReasonPending) </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">status, err := running(ca)
                if status </span><span class="cov0" title="0">{
                        reason := ""
                        // c _should_ never be nil if we get here, but we have this check just in case.
                        if c != nil </span><span class="cov0" title="0">{
                                reason = c.Reason
                        }</span>
                        <span class="cov0" title="0">return false, fmt.Errorf("status should be %s, but it is %s", v1beta1.PipelineRunReasonPending, reason)</span>
                }
                <span class="cov0" title="0">return status, err</span>
        }
}

// Chain allows multiple ConditionAccessorFns to be chained together, checking the condition of each in order.
func Chain(fns ...ConditionAccessorFn) ConditionAccessorFn <span class="cov0" title="0">{
        return func(ca apis.ConditionAccessor) (bool, error) </span><span class="cov0" title="0">{
                for _, fn := range fns </span><span class="cov0" title="0">{
                        status, err := fn(ca)
                        if err != nil || !status </span><span class="cov0" title="0">{
                                return status, err
                        }</span>
                }
                <span class="cov0" title="0">return true, nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
